<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:slash="http://purl.org/rss/1.0/modules/slash/">

    <channel>
        <title>Freewind @ Thoughtworks</title>
        <atom:link href="http://freewind.in/feed.xml" rel="self" type="application/rss+xml" />
        <link>http://freewind.in</link>
        <description>Freewind's programming life</description>
        <lastBuildDate>Sat, 10 Jan 2015 23:20:15 CST</lastBuildDate>
        <language>zh-CN</language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>

        
            <item>
                <title>徐大师关于p2p，产品化交付，BA新要求的session</title>
                <link>http://freewind.in/posts/2826-xuhao-session-about-p2p-production-delivery-ba</link>
                <pubDate>Sat, 10 Jan 2015 22:23:43 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2826</guid>
                <description><![CDATA[&lt;p&gt;昨天中午，徐大师做了一场针对BA（业务分析师）的关于p2p，产品化交付的session。由于徐大师讲的东西都很有营养，所以我得赶紧把听到的东西记下来，早晚能用上。&lt;/p&gt;
&lt;h2&gt;P2P&lt;/h2&gt;
&lt;p&gt;这几年P2P很火，我们公司也有很多新项目是关于P2P的。关于P2P的定义的漏听了，只记得大概，可能不对：大意是说，由于国家对于金融的管制，银行或者支付宝这样帐上有很多钱的公司，为了防止卷款跑路，或者自己用掉，必须要在国家的某个机构存放相应的保证金。在某些时候（好像是银根紧缩），银行的钱就不够放货款了，公司想借钱就非常难，利息也非常高。而民间有些人有钱，有些人缺钱，但他们之间却没法安全的互相借。于是几年前，平安银行就开通了一项服务（名字忘了），在互联网上搭了一个平台，帮助这样的人交易，同时收取一些手续费。这个平台后来被人们认为是国内第一个P2P服务。恰好这个平台是我们公司做的，所以后来我司因此获得了很多P2P的项目。&lt;/p&gt;
&lt;h2&gt;产品化交付&lt;/h2&gt;
&lt;p&gt;我们公司有一些团队正在做这样的项目，在开发过程中，发现了这种类型的项目与我们之前所做的企业定制的项目，有很大的不同。&lt;/p&gt;
&lt;p&gt;对于企业定制，不同的企业拥有非常不同的业务，我们所做的每一个项目几乎都是非常特化的，所以基本上不考虑业务层面的重用性。一个需求来了，对于我们来说就是一张或者几张卡，做完了就算交付成功。我们做的都是“项目”，而不是“产品”。&lt;/p&gt;
&lt;p&gt;但是对于P2P来说，我们是把它当作产品来做的。因为如果我们还是像企业定制那样，每次都新做，进度实在太慢。但如果能把它做成一个足够通用的产品，将会大大减轻后续开发的工作量。&lt;/p&gt;
&lt;p&gt;这就意味着，对于任何一个新来的需求，都将不可避免地被拆分为两部分：“通用”与“特化”&lt;/p&gt;
&lt;p&gt;“通用”的部分，就像一个框架，是对某个领域进行很抽象的建模，而不是针对某家或某几家公司。比如P2P，考虑的就是P2P这种业务，在比较高的层面是，是怎么样的。每一家做P2P的公司，在这方面都是相同或非常相似的。&lt;/p&gt;
&lt;p&gt;而“特化”的部分，则是针对具体的公司。同样的业务在不同的公司里，在细节上都会有很大的不同，甚至是特有的。&lt;/p&gt;
&lt;p&gt;“足够通用”是很难达到的，就算是同一个行业，就算各家公司提供给最终用户的服务看起来是差不多的（比如“存钱”，每家银行都有这样的服务），但是内部的流程就有可能有很大的不同。如果抽象层次不够高，则会发现为某几家公司设计的“通用”部分，完全无法适用于其它公司。&lt;/p&gt;
&lt;p&gt;拿我们熟悉的技术类比，“通用”部分就像是SpringMVC/Rails这些Web框架。对于web开发来说，它们是非常通用的框架，我们却可以用它来开发各种各样不同的网站。&lt;/p&gt;
&lt;p&gt;在“特化”的部分中，我们的原则是“代码改动越少越好”，所以依次是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能否通过“配置项”实现&lt;/li&gt;
&lt;li&gt;如果不行的话，能否通过暴露出来的接口（如JS接口）实现&lt;/li&gt;
&lt;li&gt;还是不行的话，就需要为它提供专门用实现&lt;/li&gt;
&lt;li&gt;&amp;hellip; （少了一个，不记得了）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有经过深思熟虑之后，才能把某些部分放入到“通用”部分。&lt;/p&gt;
&lt;p&gt;（记得“通用”部分是用&lt;code&gt;Core&lt;/code&gt;来表示，“特化”部分是&lt;code&gt;Implementation&lt;/code&gt;, &lt;code&gt;Configuration&lt;/code&gt;，另外两个忘了）&lt;/p&gt;
&lt;p&gt;对于“特化”部分，实现的方式越简单，对于实施团队来说，也就越容易，越难出错。&lt;/p&gt;
&lt;h2&gt;对BA的新要求&lt;/h2&gt;
&lt;p&gt;从上面可以看出，这样的项目对于BA的要求更高了。当用户提出一个需求之后，需要在极短的时间（可能几秒钟），就能清楚地把它拆分并归类于不同的部分，然后才能平等地与客户进行后续的交流。&lt;/p&gt;
&lt;p&gt;（如果判断出错，后期修改的成本会很高，特别是把一个特化的部分放到了通用中，以后又想把它移除）&lt;/p&gt;
&lt;p&gt;所以BA要对业务、行业非常熟悉，拥有较高的业务抽象能力。&lt;/p&gt;
&lt;h2&gt;身边的产品化交付例子&lt;/h2&gt;
&lt;p&gt;在听徐大师讲到产品化交付的方式时，我突然想起了教主，他的做法岂不正是这种“产品化交付”吗？教主开了一家专为中小企业提供OA服务的公司，其中有一个重点功能是报表。由于每家公司都会有各式各样不同的报表，很难做出一个通用的，所以他也是把功能分成了两种，“通用”和“特化”，并且提供了一堆Javascript接口，可以让实施人员去公司现场，当场用JavaScript实现出一个复杂的报表出来。&lt;/p&gt;
&lt;p&gt;由于他设计出来的Js接口很好用，并且提供了非常方便的调试、预览功能，一般一个人到一个公司两天时间，就能帮客户设计出一堆报表，效率非常高。教主曾经给我演示过，的确非常方便。我当时觉得教主太聪明了，居然能想出这么好的办法。&lt;/p&gt;
&lt;p&gt;现在看来，教主的确很牛，一个人就在几年前做出了跟我们现在谈到的“产品化交付”一样的思路。&lt;/p&gt;
&lt;p&gt;会后跟徐大师确认了一下，他说这种开发方式跟他讲的，是一样的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Netty5中线程问题的分析与解决</title>
                <link>http://freewind.in/posts/2825-netty5-thread-problem-analize-fix</link>
                <pubDate>Sat, 10 Jan 2015 18:02:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2825</guid>
                <description><![CDATA[&lt;p&gt;这段时间在开发remote pair工具时，我在server与client端都使用了Netty来接收和发送消息。但由于我对Netty的线程模型不了解，想得比较简单。虽然代码中某些地方做了同步，但并不仔细。&lt;/p&gt;
&lt;p&gt;后来使用的时候，发现在一些简单的情况下没有发现问题，但一旦并发较多时就出了一些奇怪的问题，怎么都无法解决。&lt;/p&gt;
&lt;p&gt;先说一下我的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先有一个server，使用netty作为socket服务器，可接受多个客户端连接&lt;/li&gt;
&lt;li&gt;每个客户端都可以向服务器发送消息，更新服务器上持有的一个文档&lt;/li&gt;
&lt;li&gt;服务器每收到一个信息，都会给它分配一个递增的version数字，同时按顺序把信息发送给所有的客户端，以便大家同步&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我在两台电脑上，使用两个客户端连接到某个server上，同时快速修改文档内容时，发现了一些完全没想到问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端收到的信息顺序乱了&lt;/li&gt;
&lt;li&gt;信息内容有误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个问题让我觉得非常意外，因为我反复检查了代码，感觉这是不可能发生的！然而它就是发生了。&lt;/p&gt;
&lt;p&gt;经常反复检查代码逻辑，我觉得唯一可能的原因就是多线程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果服务器端在发送消息时，是多线程发送的，有可能发生后发先至的情况&lt;/li&gt;
&lt;li&gt;如果线程同步没有做好，服务器端在收到消息时，有可能根据某个中间态数据进行计算，导致信息内容有误&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了确定这两个问题，我没法逃避，只能把Netty的线程模型搞懂。看了很多资料、源代码以及各种尝试，总算确定它们都出现了，并在最后解决了。&lt;/p&gt;
&lt;h2&gt;Netty5的线程模型&lt;/h2&gt;
&lt;p&gt;网上有一些文章讲得比较深入，不过感觉太专业了，不是很容易看懂。我根据我的理解讲一下最重要的几点。&lt;/p&gt;
&lt;p&gt;我们在使用netty创建一个server和client的时候，需要定义两个线程池，一个用来处理客户端连接(bossPool)，一个用来在后续的操作中接收发送消息(workerPool)。&lt;/p&gt;
&lt;p&gt;这两个池子的作用非常不同，我们只要理解了它们的用处，便可以容易给出一些较合理的值。如果用公司来比喻，可以想成：boss是接单的，worker是干活的。&lt;/p&gt;
&lt;p&gt;第一个池子，bossPool，用来处理“客户端连接”。当一个新客户端来连的时候，需要一定的时间建立连接，另外有的可能还设置了一些验证步骤，这都将由第一个池子处理。所以，如果需要支持大量并发连接（比如http server），则需要把这个池子设大一点。但如果客户端比较少，则可直接使用默认值或者设为1（即只使用一个线程处理）。默认值是cpu的核数的2倍。&lt;/p&gt;
&lt;p&gt;第二个池子，workerPool，用来处理所有的后续操作，比如接收消息，发送消息等。如果是长连接，不断有数据交互的那种，这个值就要设得大一些。如果短连接，或者server端不需要做什么复杂的操作，发送给客户端的消息比较小比较少，这个值可以小一点。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，如果server端经常需要做一些耗时的操作，比如操作数据库/访问网络等，这时通常会再创建一个单独的线程池专门异步执行这些任务，而不是占用前面的workerPool。那两个池子都是让netty用来快速处理消息用的。&lt;/p&gt;
&lt;h2&gt;每个连接的后续操作都在同一个线程中执行&lt;/h2&gt;
&lt;p&gt;对于一个多线程程序来说，数据的同步是一件很麻烦的事情。首先需要指出的是，Netty通过一些特别的做法，让这件事变得容易很多，使得我们在某些情况下不需要进行同步。但是如果我们对Netty的线程模型不了解的话，就只能按照普通的多线程情况写法去处理，需要增加一些不必要的&lt;code&gt;synchronized&lt;/code&gt;或者锁。&lt;/p&gt;
&lt;p&gt;Netty的做法是：每一个客户端一旦连接上，就会给它指定一条特定的线程，以后所有与它的交互操作，都将在、必须只在这条线程中进行。但这条线程可以处理多个客户端。&lt;/p&gt;
&lt;p&gt;可以这样理解：某些银行为了给客户提供更好的服务，可以根据客户来电号码，找到上次与他通话的那名客服人员，继续为他服务。在理想的情况下，对于每一位客户来说，为他服务的客服人员都是同一个人，可以省掉很多事。而同一个客服人员，是可以为多位客户服务的。&lt;/p&gt;
&lt;p&gt;正如银行的做法可以让客户少说很多重复的话，Netty的做法也可以让我们少写很多&lt;code&gt;synchronized&lt;/code&gt;关键字。&lt;/p&gt;
&lt;p&gt;如果Netty没有这么做，当某个客户端快速发送两条消息给服务器端，它们可能会转交给两条线程同时处理。这时，如果他们都需要对该连接持有的某个数据进行操作时，就必须小心的进行同步，否则可能出现各种不确定的错误。但如果Netty保证它们只能被同一条线程处理，那么一定是一先一后，顺序执行，并且由于始终在同一个线程中操作，也不会遇到内存栅栏的问题，让事情变得简单。&lt;/p&gt;
&lt;p&gt;那是不是所有的情况都不需要&lt;code&gt;sychronized&lt;/code&gt;了？当然不是。如果需要访问一些共享给所有连接的数据，还是需要进行合适的同步操作。但总比所有操作都要同步好很多。&lt;/p&gt;
&lt;h2&gt;如何让服务器端发送的消息始终保持先后顺序&lt;/h2&gt;
&lt;p&gt;在我前面所说的使用场景中，每当服务器端收到来自某个客户端的消息时，都要把version加1，并把该消息与新version的值一起发送给所有的客户端。我在客户端的代码假设收到的消息的version一定是递增的。&lt;/p&gt;
&lt;p&gt;然而这个假设是很难实现的。按前面所说，两个客户端连接上来，可能恰好由同一个worker线程处理，也可能由不同的worker处理。然后，两个客户端在差不多同时各发送了一个消息过来。如果是前者，由于在同一个线程中执行，顺序是可以保证的；但对于后者，由于线程运行的不确定性，很可能收到晚来的消息线程反而先处理完，这样客户端收到的消息顺序就错了。&lt;/p&gt;
&lt;p&gt;对于这种情况，我知道的有两种做法，分别在服务器端和客户端处理。&lt;/p&gt;
&lt;h3&gt;服务器端workerPool设为1&lt;/h3&gt;
&lt;p&gt;如果把workerPool的线程池大小设为1，即永远只有一条线程在跑，那么消息的顺序就可以简单的保证了。&lt;/p&gt;
&lt;p&gt;但是这么做很可能会影响性能，比如有很多客户端连接的时候，一条线程忙不过来，导致后面所有的消息都不能及时处理。&lt;/p&gt;
&lt;h3&gt;在客户端排序&lt;/h3&gt;
&lt;p&gt;另一种做法是在客户端放一个队列，暂存收到的消息并对其进行排序。然后看看里面有没有顺序正确的消息，有就拿出来处理，否则的话继续等新的消息。&lt;/p&gt;
&lt;p&gt;这样做虽然麻烦了一点，但是对服务器端的workerPool没有任何限制，性能不会受到影响。&lt;/p&gt;
&lt;p&gt;我最终选择了这种方式。&lt;/p&gt;
&lt;h2&gt;bossPool和workerPool的示例代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;private val bossGroup = new NioEventLoopGroup()
private val workerGroup = new NioEventLoopGroup()

private val bootstrap = new ServerBootstrap()
bootstrap.group(bossGroup, workerGroup)
  .channel(classOf[NioServerSocketChannel])
  .childHandler(ChildHandler)
  .option(ChannelOption.SO_BACKLOG.asInstanceOf[ChannelOption[Any]], 128)
  .childOption(ChannelOption.SO_KEEPALIVE.asInstanceOf[ChannelOption[Any]], true)

bootstrap.bind(8080)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;bossGroup&lt;/code&gt;和&lt;code&gt;workerGroup&lt;/code&gt;就是前面所说的&lt;code&gt;bossPool&lt;/code&gt;和&lt;code&gt;workerPool&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果什么参数都没给，则是默认值：&lt;code&gt;Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, Runtime.getRuntime().availableProcessor()*2))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也可以指定值：&lt;code&gt;new NioEventLoopGroup(1)&lt;/code&gt;或者&lt;code&gt;new NioEventLoopGroup(10)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是0，则也是默认值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;同步是一件很痛苦的事&lt;/h2&gt;
&lt;p&gt;在我花了几天的时间终于解决掉这些并发问题之后（希望真的解决了），我深深的觉得，依靠“同步”来进行并发编程是一件非常痛苦的事情。&lt;/p&gt;
&lt;p&gt;以前一直听人说，使用“同步”方式进行并发编程是一件痛苦的事，以及使用&lt;code&gt;actor&lt;/code&gt;这样的模型可以简化并发编程。但对于我来说，并没有太多真实的体会。&lt;/p&gt;
&lt;p&gt;直到这一次，我算是真正深刻的体会到：使用同步方式，不仅仅要知道自己设计的代码的线程模型是什么样的，还需要知道所依赖的框架或者其它库的线程模型是什么样的，这样才能写出（可能）正确高效的代码。加上“可能”二字，是因为这样的多线程与同步问题，基本上是没法通过测试来保证正确性的，上线后出错也是非常难以重现及调试的。&lt;/p&gt;
&lt;p&gt;我这次买了一本《Java虚拟机并发编程》的书，里面讲到如何使用其它的方式（比如&lt;code&gt;STM&lt;/code&gt;, &lt;code&gt;Actor&lt;/code&gt;等）代替“同步”方式。我的这次Netty调错的经验将会对我学习这本书带来非常有效的帮助。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-12 月结</title>
                <link>http://freewind.in/posts/2824-month-2014-12</link>
                <pubDate>Thu, 08 Jan 2015 23:07:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2824</guid>
                <description><![CDATA[&lt;p&gt;这一个月是放松又繁忙的一个月。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做了快一年的项目终于正式发布了&lt;/li&gt;
&lt;li&gt;客户对Scala的使用做了回顾&lt;/li&gt;
&lt;li&gt;用英语给来自外国的同事讲了我们组使用Scala的经验&lt;/li&gt;
&lt;li&gt;客户们放圣诞去了&lt;/li&gt;
&lt;li&gt;项目组解散了，我们分到了不同的组&lt;/li&gt;
&lt;li&gt;Resi组的scala培训再次开始&lt;/li&gt;
&lt;li&gt;我的远程pair插件终于基本实现，有同事很想用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;项目正式发布&lt;/h2&gt;
&lt;p&gt;我在这边大半年的时间，一直在做FAA的项目，Scala+AngularJS，终于在12月份如期发布。成品是这样的：&lt;a href=&quot;https://www.realestate.com.au/agent/29515&quot;&gt;https://www.realestate.com.au/agent/29515&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个项目是我经历过的最好的项目，学到了很多，同事与客户的感情也都非常好。&lt;/p&gt;
&lt;p&gt;一方面因为发布而开心，同时觉得快要解散了而有些遗憾。这里把人名记一下，以作留念。&lt;/p&gt;
&lt;p&gt;我，娟，新宇，婵婵，同同，Greg
&lt;br  /&gt;Fabian, Ben, Mehdi, Alex, Angus, Glen, Bianca, Meedge, Ricky, Dannil&lt;/p&gt;
&lt;h2&gt;客户的Scala回顾&lt;/h2&gt;
&lt;p&gt;在过去的一年半时间里，客户使用Scala大约做了三四个独立项目，共有十几个小服务。在年底，对它们做了一下回顾。&lt;/p&gt;
&lt;p&gt;总体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大多数人认为Scala学习曲线较高&lt;/li&gt;
&lt;li&gt;大多数人认为项目代码的质量很高&lt;/li&gt;
&lt;li&gt;大多数人使用Scala为公司在社区中赢得了声望&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于我们这边来说，有一个突出的问题，就是这边没有得到足够和有效的Scala培训，难以跟上客户的脚步。&lt;/p&gt;
&lt;h2&gt;用英语讲Scala经验&lt;/h2&gt;
&lt;p&gt;有国外的高层来这边，我们组要给他们介绍一下我们这边Scala的项目情况，希望以后能拿到更多的Scala项目。这个任务落在了我身上，而我英语极差。在娟和冯佳的帮助下，弄了一个稿，背了几天，终于在客户来的时候，流利的背了下来。结果背了一半，被一个问题打断后就再也想不起来了。而且对于客户提出来的问题，完全听不懂，幸亏娟在旁边给解了围。胡凯说，说得流利一问问题就蒙了，这一看就是准备过的吧。&lt;/p&gt;
&lt;p&gt;不过不管怎么样，也算是一次小小的进步。&lt;/p&gt;
&lt;h2&gt;客户们放圣诞&lt;/h2&gt;
&lt;p&gt;客户们放圣诞去了，两周时间。所以提前给我们安排了很多卡，并且还找出很多平时想做但又不紧急的东西给我们做。&lt;/p&gt;
&lt;p&gt;我们项目虽然已经完成，但还有一些功能没有做完。曾经在代码里留了不少坑，以前总是说，等圣诞放假时再修正。结果真到了这个时候，大家又觉得产品已经上线，项目组也撤了，客户也放假了，修出问题没人负责，又都不敢修了，所以最终还是留下了很多我觉得不好的代码。&lt;/p&gt;
&lt;p&gt;以后再也不相信“先放着以后再改”这样的话了。&lt;/p&gt;
&lt;h2&gt;项目组解散了&lt;/h2&gt;
&lt;p&gt;项目组解散了，我们被打散分到了不同的组，我进了OPS组，将会做与运维相关的工作。虽然没有Scala项目了，但是运维这块一直是我的弱项，对于我来说，这也是一个机会掌握他们，所以也算愉快的接受了。只是觉得突然解散，心里还是很舍不得，毕竟大家在过去一年感情很好。&lt;/p&gt;
&lt;h2&gt;scala培训再次开始&lt;/h2&gt;
&lt;p&gt;由于客户对于Scala还是比较满意的，所以以后的项目很可能再采用Scala。鉴于这边同事Scala经验还是不够，所以我们又打算开始新的Scala培训。&lt;/p&gt;
&lt;p&gt;这次培训吸取了以前的经验教训，我们不再把它弄成一个讲座，而主要是为了答疑。即平时靠自学，有问题时可以在这里交流，有东西也可以分享给大家。而且也不再依靠少数人讲，大家都参与，并且每周换一个主持人。这样一来，我的压力就小多了。&lt;/p&gt;
&lt;p&gt;希望这次能坚持下去，在我离开的时候，有人能接起Scala项目。&lt;/p&gt;
&lt;h2&gt;Remote pair 插件&lt;/h2&gt;
&lt;p&gt;这个东西做了三个月，中途有一次差不多做完了，结果一用发现有问题，又重新设计了一个类似于git那样的模型，总算达到了基本可用。现在可以安装在IDEA, Rubymine和Webstorm中，一起使用。&lt;/p&gt;
&lt;p&gt;仝老师看到后非常激动，因为他一直在想找一个这样的东西，这样他的培训就可以方便很多。他专门过来跟我一起用了一下，并且表示想抽出人手来一起开发。&lt;/p&gt;
&lt;p&gt;我以前一直担心没人用没需求，现在好了。只是现在还有各种大小问题，一用起来各种不便，我虽然想改，但这段时间实在是太忙了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-11 月结</title>
                <link>http://freewind.in/posts/2823-month-2014-11</link>
                <pubDate>Thu, 08 Jan 2015 22:46:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2823</guid>
                <description><![CDATA[&lt;p&gt;到了2015年，才有机会来补这个月结。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本上是在墨尔本度过的&lt;/li&gt;
&lt;li&gt;回老家休息了一周&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;墨尔本&lt;/h2&gt;
&lt;p&gt;周末基本上都出去玩了，虽然对于我来说，其实是想窝在家里哪儿不去的，但一帮同事都喜欢出去玩。&lt;/p&gt;
&lt;p&gt;一个周末去了大洋路，见到了传说中的十二门徒。在沿海的山路上奔波了几百公里，我晕车晕得快死了，最后吃了一些晕车药才熬过去。不过景色到是挺美的。海滩没有想像中那么好，不过干净美丽的景色，还是很值得的。&lt;/p&gt;
&lt;p&gt;另一个周末飞去了Tosmaniya。在澳洲坐飞机比在国内坐地铁还要方便，让我非常意外。去了一个岛上玩了一天，最后来到了非常有名的灯塔。景色如此美丽，让我彻底的觉得这次真应该来，哪怕晕了两天车。路上一直是智超在开车，他老婆在导航，坐享其成的我只说再次感谢了。&lt;/p&gt;
&lt;p&gt;然后去客户Ben家里做了一次客，见到了他的夫人和两个可爱的孩子，还吃到了烤袋鼠肉。Ben是一个非常好的人，平时工作中的交流非常照顾我们的英语，说得很慢又极有耐心，但我们有需要改进的地方，他又会严历的指出。他说因为我们可能从未到澳洲人家里做过客，所以主动邀请我们，还准备了极为丰富的食物。而我们几个只拎了几个水果，想来真不好意思。&lt;/p&gt;
&lt;p&gt;最后是终于给老婆抢了一个iphone6，给同事和家人带了一堆绵羊油和木瓜，还给老妈带了一双UGG。其他的好像也没什么好买了。&lt;/p&gt;
&lt;h2&gt;回老家一周&lt;/h2&gt;
&lt;p&gt;因为在外国的一个月过得非常辛苦，所以先请了一周年假回家休息了。自从来到这个公司后，比以前有更多的机会回家了，感谢公司。这次回来，儿子居然不怕我，还缠着我玩，让我感觉非常意外。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>选用一个Scala模板引擎</title>
                <link>http://freewind.in/posts/2822-choose-a-scala-template-engine</link>
                <pubDate>Tue, 06 Jan 2015 20:43:23 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2822</guid>
                <description><![CDATA[&lt;p&gt;我的博客生成器是用Scala做的，既然是“生成器”，那就少不了模板，少不了模板引擎。&lt;/p&gt;
&lt;p&gt;我在最开始的时候考虑了两个Scala的模板引擎：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scalate: &lt;a href=&quot;http://scalate.github.io/scalate/&quot;&gt;http://scalate.github.io/scalate/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twirl: &lt;a href=&quot;https://github.com/playframework/twirl&quot;&gt;https://github.com/playframework/twirl&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最开始对Scalate非常看好，因为印象中它是一个比较早也比较出名的Scala模板引擎，提供了多种语法，也有貌似很详细的文档。然而当我想项目中使用它的时候，惊讶地发现，它不知道什么时候变成了一个web framework。虽然提供了详细的语法文档，却找不到任何在普通Scala项目中使用它的办法！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Twirl&lt;/code&gt;是将Playframework2.x内置的scala模板引擎，抽取出来单独发布了。&lt;code&gt;twirl&lt;/code&gt;是&lt;code&gt;@&lt;/code&gt;的一种发音，而该符号在模板中大量使用。它在文档中介绍了如何通过sbt插件来使用它，但是那时候我对SBT还不太熟悉，不知道如何下手，所以也没有采用。&lt;/p&gt;
&lt;p&gt;最后选择的是一个Java版的mustache框架：&lt;a href=&quot;https://github.com/spullara/mustache.java&quot;&gt;mustachejava&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是在后来的使用中发现了一些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无类型。如果需要的数据没有提供，也不会报错，对于一个Scala项目来说，这种无静态类型的模板让人感觉很不适应&lt;/li&gt;
&lt;li&gt;类型需要转换。有些Scala的类型（如集合），需要转成Java的&lt;/li&gt;
&lt;li&gt;不能表达复杂的视图逻辑。比如显示一棵目录树，不太好实现&lt;/li&gt;
&lt;li&gt;如果操作系统的字符集不是&lt;code&gt;utf8&lt;/code&gt;，则读取中文文件会变问号。原因是里面有一些读取文件的代码，没有指定字符集。&lt;a href=&quot;https://github.com/spullara/mustache.java/issues/120&quot;&gt;见我提的Issue&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最近实在无法忍受，决定把它换成&lt;code&gt;Twirl&lt;/code&gt;。现在已经成功了，因为你看到的这稿博客就是它生成的。&lt;/p&gt;
&lt;p&gt;使用方法比较简单，直接照着它的&lt;a href=&quot;https://github.com/playframework/twirl/blob/master/README.md&quot;&gt;readme&lt;/a&gt;来就行了，这里记录一些需要注意的东西。&lt;/p&gt;
&lt;h2&gt;文件后缀&lt;/h2&gt;
&lt;p&gt;注意文件名形如&lt;code&gt;{name}.scala.{ext}&lt;/code&gt;，中间一定要有一个&lt;code&gt;scala&lt;/code&gt;，后缀是&lt;code&gt;html&lt;/code&gt;,&lt;code&gt;js&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt;,或者&lt;code&gt;txt&lt;/code&gt;之一。&lt;/p&gt;
&lt;p&gt;我开始的时候忘了写&lt;code&gt;scala&lt;/code&gt;，结果怎么都出不来，反复检查之后才发现，一定要注意。&lt;/p&gt;
&lt;h2&gt;如何编译成Scala代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Twirl&lt;/code&gt;的模板需要编译成scala源代码，以一个&lt;code&gt;object&lt;/code&gt;的方式供其它Scala代码使用。在Play中，这是自动的，但是对于普通Scala项目，我们必须手动操作。&lt;/p&gt;
&lt;p&gt;在Sbt命令中行执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它就会在&lt;code&gt;target/scala-version/twirl/&lt;/code&gt;下生成相应的Scala源文件，并且以后缀分组。&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;index.scala.html&lt;/code&gt;会变成&lt;code&gt;html/index.scala&lt;/code&gt;，&lt;code&gt;user.scala.js&lt;/code&gt;会变成&lt;code&gt;js/user.scala&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;如何在Scala代码中调用&lt;/h2&gt;
&lt;p&gt;Twirl生成的scala文件形如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package html

import play.twirl.api._
import play.twirl.api.TemplateMagic._


object category extends BaseScalaTemplate[HtmlFormat.Appendable,Format[HtmlFormat.Appendable]](HtmlFormat) with Template1[Category, HtmlFormat.Appendable] {

  def apply(category:Category):HtmlFormat.Appendable = {
    _display_ {
        ...
    }
  }

  def render(category:Category,):HtmlFormat.Appendable = apply(category)

  def f:((Category) =&amp;gt; HtmlFormat.Appendable) = (category) =&amp;gt; apply(category)

  def ref: this.type = this

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们想在普通的Scala代码中调用它，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val someCategory = new Category(&quot;Scala&quot;)
val content = html.category.render(comeCategory).toString()
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是&lt;code&gt;html.category.render(comeCategory)&lt;/code&gt;的返回类型是&lt;code&gt;HtmlFormat.Appendable&lt;/code&gt;，需要调用它的&lt;code&gt;.toString()&lt;/code&gt;方法才能得到一个&lt;code&gt;String&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;与IDEA配合使用&lt;/h2&gt;
&lt;p&gt;如果我们使用Sbt的命令行来编译，不会遇到任何问题，所有的twirl模板会被正确的编译为scala代码，而所有其它的Scala代码也能正确地找到它们。但是在IDEA中，模板并不会自动的转为Scala代码，所以如果我们直接在其它Scala代码中调用它们，将会报编译错误。&lt;/p&gt;
&lt;p&gt;我们需要做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把&lt;code&gt;target/scala-version/twirl&lt;/code&gt;设置为IDEA项目的“源目录”&lt;/li&gt;
&lt;li&gt;同时在命令行上运行&lt;code&gt;sbt ~compile&lt;/code&gt;，当模板文件发生变化时，自动在后台编译&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样IDEA才能及时获取编译后的scala模板文件。需要经常去看看有没有报一些编译错误，及时修正，否则IDEA看到的还是旧代码。稍有不便，但还可以接受。&lt;/p&gt;
&lt;h2&gt;运行时依赖&lt;/h2&gt;
&lt;p&gt;我们还需要在&lt;code&gt;build.sbt&lt;/code&gt;中添加额外的依赖，否则会报某些类找不到：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;libraryDependencies ++= Seq(
  &quot;com.typesafe.play&quot; %% &quot;twirl-api&quot; % &quot;1.0.4&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;使用感受&lt;/h2&gt;
&lt;p&gt;这是一套极为强大的Scala模板引擎，静态类型，与Scala相似的语法，功能很多，可以轻松实现出一些复杂的页面（比如通过在模板内定义一个嵌套的函数，生成树）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;@showCategory(category:Category) = {
    &amp;lt;ol class=&quot;posts&quot;&amp;gt;
        &amp;lt;div class=&quot;category_title&quot;&amp;gt;@category.name&amp;lt;/div&amp;gt;
        @for(post &amp;lt;- category.posts) {
            &amp;lt;li&amp;gt;
                @partials.html.post_title(post)
            &amp;lt;/li&amp;gt;
        }
    &amp;lt;/ol&amp;gt;
    @for(sub &amp;lt;- category.subCategories) {
        @showCategory(sub) // 递归在这里!!!
    }
}

@showCategory(category)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前唯一不方便的是，必须手动把它编译成scala文件才能使用，这样的话，我就没办法只提供一些单独的twirl模板直接使用了（而之前用mustachejava）就可以，用户可以随便改，马上用。&lt;/p&gt;
&lt;p&gt;我想是有办法让它即时编译的，因为Play2自己就实现了。但是我现在对这个需求不强烈，因为只是自动使用，改完编译一下也不嫌麻烦，以后有需求时再考虑。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>2014总结</title>
                <link>http://freewind.in/posts/2820-year-2014</link>
                <pubDate>Fri, 02 Jan 2015 19:30:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2820</guid>
                <description><![CDATA[&lt;p&gt;2014年过去了，一句话总结就是：开心幸福、充满挑战的一年。&lt;/p&gt;
&lt;p&gt;对我来说，感觉如此之好的一年，可能是从毕业至今第一次。今年有很多事都是以前没有经历过的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;真正地在一个相亲相爱，平等互助的团队中工作，每天都朝着同一个目标努力&lt;/li&gt;
&lt;li&gt;如此优秀的客户，不论是技术、工作态度、工作方式、对高效工作的追求都让我们受益匪浅&lt;/li&gt;
&lt;li&gt;有很多的同事在一起玩：乒乓球，羽毛球，篮球，Team building，密室，桌球，保龄球&lt;/li&gt;
&lt;li&gt;第一次出国，在美丽的墨尔本生活了一个月&lt;/li&gt;
&lt;li&gt;第一次和一帮同事一起吃生日蛋糕&lt;/li&gt;
&lt;li&gt;第一次在老外面前用英语给他们讲我们项目中用到的技术&lt;/li&gt;
&lt;li&gt;第一次结识了这么多优秀的同事、朋友&lt;/li&gt;
&lt;li&gt;第一次结识了一些老外朋友&lt;/li&gt;
&lt;li&gt;第一次以Tech Leader的角色参与一个项目&lt;/li&gt;
&lt;li&gt;还有很多很多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一切都来自于朝夕相处的同事，优秀的客户，以及这个充满激情的公司，从内心深处感谢你们。&lt;/p&gt;
&lt;h2&gt;技术&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Scala方面进步较大，因为今年的项目是Scala的。目前处于做项目没什么问题的程度，但对真正理解Scala以及函数式编程，还有着较大的距离。深入学习Scala（及函数式）是明年的重点&lt;/li&gt;
&lt;li&gt;AngularJS也是项目中用得较多的一个技术，不过做完这个项目，对它反而持谨慎态度。因为这个项目的前端有很多比较奇怪的遗留问题和限制，在这种情况下使用Angular实在太过纠结&lt;/li&gt;
&lt;li&gt;对于云部署有一定的了解。这主要得益于客户的选择，平时的开发、产品环境，全部使用了Amazon的云服务&lt;/li&gt;
&lt;li&gt;对于结对、测试、TDD、敏捷、精益这些实践，又积累了更多的疑问和思考&lt;/li&gt;
&lt;li&gt;对于如何提升整个团队、如何与客户合作、如何更有效讨论等，有了更多的经验与教训&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;业余&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;参加了公司的硬件开发大赛，第一次用Arduino做了一个用滚轮控制光标的键盘辅助工具&lt;/li&gt;
&lt;li&gt;自己用Scala写了一个博客生成工具feverblog，把Markdown写的博客转为HTML，自己一直在用，半成品&lt;/li&gt;
&lt;li&gt;基于IDEA的“远程结对”插件，还在开发中&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;英语&lt;/h2&gt;
&lt;p&gt;发音与听力略有进步，但距离独立交流，还有较大的距离，唉。明年努力的重点&lt;/p&gt;
&lt;h2&gt;读书&lt;/h2&gt;
&lt;p&gt;基本没读。每次看到公司的大牛们在总结上写着今年又读了几十本书的时候，感觉非常惭愧。年底买了一堆书，开始读。&lt;/p&gt;
&lt;h2&gt;家庭&lt;/h2&gt;
&lt;p&gt;小家和睦，妻子一个人看孩子很辛苦，儿子又长大一岁很乖很聪明。&lt;/p&gt;
&lt;p&gt;由于年假多了以及贴心的Homefly政策，回家看望父母的时间比去年多，感谢公司。&lt;/p&gt;
&lt;p&gt;希望2015一切更好。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>出差补助计算器</title>
                <link>http://freewind.in/posts/2819-a-travelling-allowance-calculator-for-twer</link>
                <pubDate>Mon, 01 Dec 2014 23:26:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2819</guid>
                <description><![CDATA[&lt;p&gt;作为一个经常出差的TWer，有补助是好的，但填报销单很辛苦，因为工作日和周末的补助是不同的。&lt;/p&gt;
&lt;p&gt;如果遇到懒人，半个月一个月才填一次的，会发现找周末是一件很痛苦的事。&lt;/p&gt;
&lt;p&gt;我用scala写了一个方便计算补助的程序，只需要输入起止日期，就可以算出总金额，并生成一个简单的汇总，可以粘贴到报销表中，方便财务人员查看。&lt;/p&gt;
&lt;p&gt;先看一下运行效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input start date(yyyy-MM-dd, or MM-dd if it&apos;s in current year):
03-09
Input end date(MM-dd or yyyy-MM-dd, use today if empty):

Input allowance for weekday(¥150 if empty):

Input allowance for weekend(¥350 if empty):

########################################
2014-03-09 ~ 2014-12-01

total days: 268
weekday count: 191, weekend day count: 77

allowance for weekday: 150, weekend: 350
Total allowance: 55600

2014-03-09 ~ 2014-12-01, 268 days, 150*191+350*77=55600
########################################
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先你的电脑上要有Java和git&lt;/li&gt;
&lt;li&gt;然后clone一个仓库，把代码弄下来&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/freewind/expense_calc.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cd expense_calc
./sbt run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次运行的时候，它会自动到远程下载一些必要的jar，可能会等时间稍长一些。如果卡住的话，说明有一些jar被墙了，请自行番羽墙或在公司运行。&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/freewind/expense_calc&quot;&gt;https://github.com/freewind/expense_calc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎fork及pull request&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在Future中执行无限循环的任务对吗？</title>
                <link>http://freewind.in/posts/2815-is-it-correct-to-run-infinite-task-in-future</link>
                <pubDate>Mon, 17 Nov 2014 11:35:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2815</guid>
                <description><![CDATA[&lt;p&gt;在项目中看到一段代码，大意如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.concurrent._
import ExecutionContext.Implicits.global

object QueueProcessor {
  def listen() {
    while(true) {
      val msg = queue.next()
      processMessage(msg) match {
        case Success(_) =&amp;gt; 
        case _ =&amp;gt;
      }
    }
  }  
}

object Main extends App {
  Future {
    QueueProcessor.listen()
  }    

  // do other things
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;QueueProcessor.listen()&lt;/code&gt;是一个无限循环的任务，我们在&lt;code&gt;Future {}&lt;/code&gt;调用它，它将会在另一个线程中执行。&lt;/p&gt;
&lt;p&gt;我觉得这种做法不对，原因如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt;通常是用来做延时计算的。当我们使用&lt;code&gt;Future&lt;/code&gt;时，通常会预期该任务将在未来某个时间点返回一个值。把一个无限循环的任务放进去让人感觉有点意外。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ExecutionContext.Implicits.global&lt;/code&gt;默认提供的线程池中的线程是有限的（默认等于cpu核数），长期占用会对其它任务产生影响甚至导致它们无法执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如，我们的程序部署在一个cpu为一个核的虚拟机上，上面的代码将导致Future中其它的任务没有机会执行，所以我在项目中同时发现了以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.setProperty(&quot;scala.concurrent.context.numThreads&quot;, &quot;10&quot;)
System.setProperty(&quot;scala.concurrent.context.maxThreads&quot;, &quot;10&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它用来调整&lt;code&gt;ExecutionContext.Implicits.global&lt;/code&gt;线程值的大小。&lt;/p&gt;
&lt;h2&gt;Future占用的示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import scala.concurrent._
import ExecutionContext.Implicits.global

println(&quot;Your cpu cores: &quot; + Runtime.getRuntime.availableProcessors)

0 to 10 foreach { i =&amp;gt; 
  Future {
    while(true) {
      println(i)
      Thread.sleep(10000);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我的电脑上运行如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;You cpu cores: 8
0
1
2
3
4
5
6
7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可见前8个任务把Future的池全占满了，后面的任务就没有办法执行了。&lt;/p&gt;
&lt;h2&gt;使用Thread&lt;/h2&gt;
&lt;p&gt;最后还是改成java中的传统写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;object Main extends App {
  new Thread(new Runnable() {
    override def run: Unit = QueueProcessor.listen()
  }).start()

  // do other things
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>组内一场关于“测试、TDD、结对、做卡”的讨论会</title>
                <link>http://freewind.in/posts/2806-thoughts-on-the-tdd-testing-discussion-xian-resi</link>
                <pubDate>Sat, 01 Nov 2014 23:28:01 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2806</guid>
                <description><![CDATA[&lt;p&gt;这段时间我有这样的一些感觉和疑惑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我之前在做IdeaRemotePair插件的时候，其中有一些关于交互协议的部分是用TDD的方法来做的，有一些很好的感觉&lt;/li&gt;
&lt;li&gt;我最近在做一些复杂的卡时（多项目，多语言），使用TDD的过程中，遇到了很多麻烦&lt;/li&gt;
&lt;li&gt;我感觉大家在做卡的时候，经常以“项目时间紧”为理由，而采用“先把功能完成再补测试”或者“先做完功能，有空再做重构”的方式，这跟我司倡导的“TDD”等实践是违背的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我在回顾会议上提到了这些，大家让我准备一个session讲讲。但我在准备的过程中，觉得自己在这方面的知识和经验都不够，讲不出来什么，所以把它弄成了一个讨论会。于是预设了以下主题让大家投票：&lt;/p&gt;
&lt;p&gt;主题 票数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何看待“补测试”与&quot;TDD&quot;的关系与区别？  6&lt;/li&gt;
&lt;li&gt;常用测试框架你熟练掌握了吗？  6&lt;/li&gt;
&lt;li&gt;“测试覆盖率”重要，还是“TDD”重要？    5&lt;/li&gt;
&lt;li&gt;测试的取舍：哪些测？哪些不测？ 5&lt;/li&gt;
&lt;li&gt;如何看待“加班”，“课外学习”，是个人私事吗？ 4&lt;/li&gt;
&lt;li&gt;做卡中，时间花在哪里了？有哪些可以改进？    4&lt;/li&gt;
&lt;li&gt;你做过国内项目，在国内出过差吗？跟办公室项目相比有哪些不同的感受？   4&lt;/li&gt;
&lt;li&gt;什么情况下，你认为可以不用，或者不应该使用TDD?   4&lt;/li&gt;
&lt;li&gt;你是否愿意因为一些技术问题与同事争吵？值得吗？如果吵，该怎么吵？    4&lt;/li&gt;
&lt;li&gt;你怎样看待当前的结对？你认为它最重要的地方是什么？是否觉得流于形式，应该取消？ 3&lt;/li&gt;
&lt;li&gt;当你不想TDD时，你会有哪些理由？   3&lt;/li&gt;
&lt;li&gt;你觉得现在的thoughtworks还是你理想中的thoughtworks吗(P2软件卓越)？ 3&lt;/li&gt;
&lt;li&gt;如何维护写完的测试代码，让它们依然容易阅读？  3&lt;/li&gt;
&lt;li&gt;你曾经有没有经历过“没有TDD，甚至没有测试”的开发？有什么感触比较深的？   2&lt;/li&gt;
&lt;li&gt;什么情况下，你认为可以不写，或者不应该写测试？ 2&lt;/li&gt;
&lt;li&gt;TDD让你感受到哪些独特的好处？哪些是你认为最重要的？ 2&lt;/li&gt;
&lt;li&gt;是否会因为做卡时间过长或者客户压力，而放弃TDD或者故意跳过一些测试？ 2&lt;/li&gt;
&lt;li&gt;你对同事提供的session, workshop有什么看法？觉得有帮助吗？有改进吗？想吐槽吗？ 2&lt;/li&gt;
&lt;li&gt;你考虑过讲session，或者举行一些workshop吗？有哪些担心的事情？  2&lt;/li&gt;
&lt;li&gt;结合当前项目情况，你是否经常Spike?如何看待Spike?如何正确的做？   1&lt;/li&gt;
&lt;li&gt;当你不想写测试时，你会有哪些理由？   1&lt;/li&gt;
&lt;li&gt;如何看待小组一起CodeReview？最重要的地方是什么？是否值得？  0&lt;/li&gt;
&lt;li&gt;你觉得TDD有哪些缺点？ 有哪些重要问题它解决不了？  0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按投票人数从上到下讨论，大约进行了2小时。&lt;/p&gt;
&lt;p&gt;讨论很充分也很激烈，但是大家并没有得出很好的结论。大概总结起来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大家对TDD的好处并明确，觉得只要想清楚了，先写还是后写都一样&lt;/li&gt;
&lt;li&gt;大家觉得对常用测试框架的掌握，还不是特别熟练&lt;/li&gt;
&lt;li&gt;如果是强制进行的workshop，应该放在工作时间；而由兴趣形成的，可以放在下班后，号召是你的事，参不参加是别人的事&lt;/li&gt;
&lt;li&gt;下班后不应该加班，因为一你做的事情你的pair不知道，二会给客户错误的进度信息&lt;/li&gt;
&lt;li&gt;下班后自己学习是自己的事，提倡但不强制&lt;/li&gt;
&lt;li&gt;做卡时经常会浪费很多的时间在找人，以及反复确认需求上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后来问了一些同事，得到了一些反馈。比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我感觉大家讨论的时候都在想办法说服别人，没有真正在讨论同一件事。大家都在不同的项目，遇到的情况也不一样，讨论不到一起。如果这个讨论会的主题是，大家结合自己的项目情况介绍一下自己的做法、遇到的问题等，让别人帮忙分析，给出意见，可能更有用一些。在搞讨论会以前，最好多问问大家到底想讨论什么，有什么好建议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我觉得这些主题有点深，而参加讨论的人，很多对一些基本的概念都不清楚，大家都靠着自己想像中的理解在争论。比如关于TDD，大家平时都没有认真系统的看过这方面的书，在实践过程中也没有真正去思考，但现在却坐在一起讨论一些高层的问题，根本没法进行有效讨论。以前我们曾经有过这样的讨论，徐大师在旁边听了，只说“你们真正去做做TDD再过来讨论”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我觉得这种讨论会的形式还是不错的。觉得有些可惜的就是，没有及时要求给出&quot;Action&amp;rdquo;。比如讨论到“测试框架不熟悉”的时候，大家觉得搞个workshop是有益的时候，我们应该提出做一个什么样的workshop，谁愿意来负责等等。不然讨论完了就完了，问题没有解决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-10-月结</title>
                <link>http://freewind.in/posts/2803-month-2014-10</link>
                <pubDate>Fri, 24 Oct 2014 14:39:43 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2803</guid>
                <description><![CDATA[&lt;p&gt;这个月过得很漫长，感觉过了好久。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;十一回家一趟，参加了老婆的弟弟的婚礼，气氛很不错，祝他们永远幸福&lt;/li&gt;
&lt;li&gt;组织了一场“TDD、测试、做卡等”相关的讨论&lt;/li&gt;
&lt;li&gt;第一次出国了，于25号出发，坐了十几个小时的飞机，到了墨尔本&lt;/li&gt;
&lt;li&gt;今天刚得知二姑9号去世了。二姑身体不好，常年生病。不知该说什么，挺难受的&lt;/li&gt;
&lt;li&gt;IdeaRemotePair的插件还在进行中，不过没什么时间做，进展很慢&lt;/li&gt;
&lt;li&gt;篮球俱乐部成立了，去打了三次篮球，感觉身体比以前好多了&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;TDD、测试相关的讨论&lt;/h2&gt;
&lt;p&gt;[link:2806]&lt;/p&gt;
&lt;h2&gt;墨尔本&lt;/h2&gt;
&lt;p&gt;墨尔本很干净，街道漂亮，没有多少高楼。客户的新大楼里面装修的很漂亮。&lt;/p&gt;
&lt;p&gt;相对于当地人的收入，各种东西都比较便宜。相对而言吃东西稍贵一些，每顿饭都在10到15澳元，相当于50到80元人民币。各国的食物都有，份量很足，做的也很好吃，里面的料比如海鲜、肉之类，都超乎预期的多。我觉得同样的饭拿到西安，也至少能卖到30以上。&lt;/p&gt;
&lt;p&gt;相比起来，果汁、牛奶就便宜多了。比如中午一顿饭钱，可以买到6瓶2L装的桔汁。其它的东西相对吃饭也比较便宜，但折合起RMB就不便宜了。&lt;/p&gt;
&lt;p&gt;这边自动化程度很高，可能跟这边人少、人工成本高相关。比如超市都有很先进的自助结帐机，营业员只有几个。住的公寓也只有第一天有人给拿了个钥匙。到处可见的电轨车，车厢里会有十几个刷卡机，上车后自己刷，没人管。&lt;/p&gt;
&lt;p&gt;这边觉得最让人意外的就是，各商场商店，基本上下午五六点就开始关门了，只有周四、五、六会开到晚上9点左右，这让人非常难以接受。有天下午跟几个同事一起去逛商场，感觉刚开始，他们就开始催人了。所以这边晚上到八九点街上便没什么人了，跟国内十一二点的感觉相似。&lt;/p&gt;
&lt;p&gt;这边客户对我们都不错，我的英语不好，他们都会耐心的重复，说得很慢。感觉这边的工作方式跟我们大不一样，他们每天会有很多的时间聊天，各种会议和session，通常会提前下班，但是做卡的时候，速度却很快。可能跟这段时间任务比较少有关，不知道前段时间特别忙的时候是什么样的，总之我感觉代码大部分是国内写的。来这遍呆了一段时间以后，回去就再也不会因为担心客户不满意而加班了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-09-月结</title>
                <link>http://freewind.in/posts/2798-month-2014-09</link>
                <pubDate>Sun, 12 Oct 2014 16:34:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2798</guid>
                <description><![CDATA[&lt;p&gt;这个月也比较平淡：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花了一整个周末，把SBT好好看了一下，弄了一个session：轻快的SBT&lt;/li&gt;
&lt;li&gt;在大组的技术分享大会上，讲了一个session: 如何组织scala代码&lt;/li&gt;
&lt;li&gt;好好打了几场羽毛球，跟高手打了几场，感叹差距之大&lt;/li&gt;
&lt;li&gt;回家了一趟，办了护照，准备出国&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>不同的域名使用不同的ssh key</title>
                <link>http://freewind.in/posts/2797-use-different-ssh-keys-for-different-domains</link>
                <pubDate>Fri, 10 Oct 2014 15:08:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2797</guid>
                <description><![CDATA[&lt;p&gt;在&lt;code&gt;~/.ssh&lt;/code&gt;下有一个&lt;code&gt;config&lt;/code&gt;文件，可以配置不同的域名使用不同的key:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Host github.com
    User git
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/me/id_rsa
Host bitbucket.org
    User git
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/me/id_rsa
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在IdeaPlugin中如何知道当前editor中的内容发生了变化？</title>
                <link>http://freewind.in/posts/2796-how-to-know-the-content-changes-of-editor-in-idea-plugin</link>
                <pubDate>Sat, 27 Sep 2014 20:08:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2796</guid>
                <description><![CDATA[&lt;p&gt;每一个文件打开后，都会有一个对应的&lt;code&gt;com.intellij.openapi.fileEditor.FileEditor&lt;/code&gt;实例。它有一个方法&lt;code&gt;getEditor&lt;/code&gt;可以拿到一个&lt;code&gt;com.intellij.openapi.editor.Editor&lt;/code&gt;实例。&lt;code&gt;Editor&lt;/code&gt;实例中，有一个&lt;code&gt;getDocument&lt;/code&gt;方法，可以拿到一个&lt;code&gt;Document&lt;/code&gt;实例。在这个实例中，我们可以添加一些&lt;code&gt;DocumentListener&lt;/code&gt;，实时监视内容的变化。&lt;/p&gt;
&lt;p&gt;示例代码如下（假设我们有一个editor）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;editor.getDocument.addDocumentListener(new DocumentListener {

  override def beforeDocumentChange(event: DocumentEvent) {
    println(&quot;## beforeDocumentChanged: &quot; + event)
  }

  override def documentChanged(event: DocumentEvent) {
    println(&quot;## documentChanged: &quot; + event)
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，每当文档中有内容发生变化时，这两个回调方法都会被调用，一个在前一个在后。其参数&lt;code&gt;DocumentEvent&lt;/code&gt;会告诉我们，文档发生了什么变化。&lt;/p&gt;
&lt;p&gt;比如，我在文档中输入了一个字母&lt;code&gt;a&lt;/code&gt;后，会打印出两条信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## beforeDocumentChanged: DocumentEventImpl[myOffset=73, myOldLength=0, myNewLength=1, myOldString=&apos;&apos;, myNewString=&apos;a&apos;].
## documentChanged: DocumentEventImpl[myOffset=73, myOldLength=0, myNewLength=1, myOldString=&apos;&apos;, myNewString=&apos;a&apos;].
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会告诉我们哪个位置的内容发生了变化，以及改变的内容是什么样子的。&lt;/p&gt;
&lt;h2&gt;editor从哪里来&lt;/h2&gt;
&lt;h3&gt;直接拿到当前被选中的editor&lt;/h3&gt;
&lt;p&gt;我知道有两种方法，一个是全局的用来拿到“当前被选中的editor”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FileEditorManager.getInstance(project).getSelectedTextEditor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法可以直接拿到当前project中被选中的那个TextEditor，其类型为&lt;code&gt;Editor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;但是对于我想做的事情来说，这个方法用不上。我想给每一个“当前”editor添加一个&lt;code&gt;DocumentListener&lt;/code&gt;。由于每个文件都可以被多次打开、关闭，我必须想办法准确拿到当前操作的editor。&lt;/p&gt;
&lt;h3&gt;通过监听editor切换事件&lt;/h3&gt;
&lt;p&gt;我们可以通过添加一个&lt;code&gt;FileEditorManager&lt;/code&gt;去监听当前项目各editor之间切换、开关的事件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;val connection: MessageBusConnection = project.getMessageBus.connect(project)
connection.subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerAdapter {
  override def fileOpened(@NotNull source: FileEditorManager, @NotNull file: VirtualFile) {}

  override def fileClosed(source: FileEditorManager, file: VirtualFile) {}

  override def selectionChanged(event: FileEditorManagerEvent) {
    val oldEditor = Option(event.getOldEditor)
    val newEditor = Option(event.getNewEditor)

    oldEditor match {
      case Some(x: TextEditor) =&amp;gt; removeDocumentListener(x.getEditor)
      case _ =&amp;gt;
    }
    newEditor match {
      case Some(x: TextEditor) =&amp;gt; addDocumentListener(x.getEditor)
      case _ =&amp;gt;
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们在&lt;code&gt;selectionChanged&lt;/code&gt;回调中，通过事件对象拿到发生切换的两个&lt;code&gt;FileEditor&lt;/code&gt;后，就可以拿到每一个相应的&lt;code&gt;Editor&lt;/code&gt;实例，为其添加或者移除listener.&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在编写Idea Plugin的时候，知道项目中哪些文件被新建、删除、移动等</title>
                <link>http://freewind.in/posts/2795-how-to-know-file-creation-deleteion-when-writing-idea-plugin</link>
                <pubDate>Sat, 27 Sep 2014 17:42:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2795</guid>
                <description><![CDATA[&lt;h2&gt;plugin.xml&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;project-components&amp;gt;
    &amp;lt;component&amp;gt;
        &amp;lt;implementation-class&amp;gt;com.thoughtworks.pli.intellij.remotepair.RemotePairProjectComponent&amp;lt;/implementation-class&amp;gt;
    &amp;lt;/component&amp;gt;
&amp;lt;/project-components&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RemotePairProjectComponent.scala&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.intellij.remotepair

import com.intellij.openapi.fileEditor.{FileEditorManagerEvent, FileEditorManager, FileEditorManagerAdapter, FileEditorManagerListener}
import com.intellij.openapi.vfs._
import org.jetbrains.annotations.NotNull
import com.intellij.util.messages.{Topic, MessageBusConnection}
import com.intellij.openapi.components.ProjectComponent
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.impl.BulkVirtualFileListenerAdapter

class RemotePairProjectComponent(project: Project) extends ProjectComponent {

  override def initComponent() {}

  override def disposeComponent() {}

  override def getComponentName: String = &quot;RemotePairProjectComponent&quot;

  override def projectOpened() {
    val connection: MessageBusConnection = project.getMessageBus.connect(project)
    val fileListener = new VirtualFileAdapter() {
      override def fileDeleted(event: VirtualFileEvent) {
        println(&quot;### file deleted: &quot; + event.getFile)
      }

      override def fileCreated(event: VirtualFileEvent) {
        println(&quot;### file created: &quot; + event.getFile)
      }

      override def fileMoved(event: VirtualFileMoveEvent) {
        println(&quot;### file moved: &quot; + event.getFile)
      }

      override def propertyChanged(event: VirtualFilePropertyEvent) {
        println(&quot;### file property changed: &quot; + event.getFile)
      }

      override def fileCopied(event: VirtualFileCopyEvent) {
        println(&quot;### file copied: &quot; + event.getFile)
      }

      override def contentsChanged(event: VirtualFileEvent) {
        println(&quot;### contents changed: &quot; + event.getFile)
      }
    }

    connection.subscribe(VirtualFileManager.VFS_CHANGES, new BulkVirtualFileListenerAdapter(fileListener))
  }

  override def projectClosed() {}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;### file created: file:///.../test/src/XXX.java
### contents changed: file:///.../test/src/XXX.java
########## file selection changed: null -&amp;gt; file:///.../test/src/XXX.java
########## file opened: file:///.../test/src/XXX.java
### contents changed: file:///.../test/src/XXX.java
### contents changed: file:///.../test/.idea/workspace.xml
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在编写Idea Plugin的时候，知道项目中哪些文件被打开、关闭等</title>
                <link>http://freewind.in/posts/2794-how-to-kown-file-open-close-when-writing-idea-plugin</link>
                <pubDate>Sat, 27 Sep 2014 17:03:24 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2794</guid>
                <description><![CDATA[&lt;h2&gt;plugin.xml&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;project-components&amp;gt;
    &amp;lt;component&amp;gt;
        &amp;lt;implementation-class&amp;gt;com.thoughtworks.pli.intellij.remotepair.RemotePairProjectComponent&amp;lt;/implementation-class&amp;gt;
    &amp;lt;/component&amp;gt;
&amp;lt;/project-components&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RemotePairProjectComponent.scala&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.intellij.remotepair

import com.intellij.openapi.fileEditor.{FileEditorManagerEvent, FileEditorManager, FileEditorManagerAdapter, FileEditorManagerListener}
import com.intellij.openapi.vfs.VirtualFile
import org.jetbrains.annotations.NotNull
import com.intellij.util.messages.MessageBusConnection
import com.intellij.openapi.components.ProjectComponent
import com.intellij.openapi.project.Project

class RemotePairProjectComponent(project: Project) extends ProjectComponent {

  override def initComponent() {}

  override def disposeComponent() {}

  override def getComponentName: String = &quot;RemotePairProjectComponent&quot;

  override def projectOpened() {
    val connection: MessageBusConnection = project.getMessageBus.connect(project)
    connection.subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerAdapter {
      override def fileOpened(@NotNull source: FileEditorManager, @NotNull file: VirtualFile) {
        System.out.println(&quot;########## file opened: &quot; + file)
      }

      override def fileClosed(source: FileEditorManager, file: VirtualFile) {
        System.out.println(&quot;########## file closed: &quot; + file)
      }

      override def selectionChanged(event: FileEditorManagerEvent) {
        val oldFile = event.getOldFile
        val newFile = event.getNewFile
        System.out.println(s&quot;########## file selection changed: $oldFile -&amp;gt; $newFile&quot;)
      }
    })
  }

  override def projectClosed() {}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;p&gt;运行该插件，在新打开的IDEA中打开一个项目，进行一些打开、关闭、切换文件的操作，可以看到原IDEA的console中会输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;########## file selection changed: null -&amp;gt; file:///.../test/src/Aaa.java
########## file opened: file:///.../test/src/Aaa.java
########## file selection changed: file:///.../test/src/Aaa.java -&amp;gt; file:///.../test/src/pubspec.yaml
########## file opened: file:///.../test/src/pubspec.yaml
########## file selection changed: file:///.../test/src/pubspec.yaml -&amp;gt; file:///.../test/src/Aaa.java
########## file selection changed: file:///.../test/src/Aaa.java -&amp;gt; file:///.../test/src/pubspec.yaml
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>写Idea Plugin时，如何让它在某个项目打开的时候做些事？</title>
                <link>http://freewind.in/posts/2793-how-to-do-something-when-a-new-project-is-opened-when-writing-idea-plugin</link>
                <pubDate>Sat, 27 Sep 2014 16:50:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2793</guid>
                <description><![CDATA[&lt;p&gt;比如输出一个&lt;code&gt;Hello world&lt;/code&gt;?&lt;/p&gt;
&lt;h2&gt;plugin.xml&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;project-components&amp;gt;
    &amp;lt;component&amp;gt;
        &amp;lt;implementation-class&amp;gt;com.thoughtworks.pli.intellij.remotepair.RemotePairProjectComponent&amp;lt;/implementation-class&amp;gt;
    &amp;lt;/component&amp;gt;
&amp;lt;/project-components&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;RemotePairProjectComponent.scala&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.intellij.remotepair

import com.intellij.openapi.fileEditor.FileEditorManager
import com.intellij.openapi.fileEditor.FileEditorManagerAdapter
import com.intellij.openapi.vfs.VirtualFile
import org.jetbrains.annotations.NotNull
import com.intellij.util.messages.MessageBusConnection
import com.intellij.openapi.fileEditor.FileEditorManagerListener
import com.intellij.openapi.components.ProjectComponent
import com.intellij.openapi.project.Project

class RemotePairProjectComponent(project: Project) extends ProjectComponent {

  override def initComponent() {
    System.out.println(&quot;##### RemotePairProjectComponent.initComponent&quot;)
    System.out.println(&quot;## project: &quot; + project)
  }

  override def disposeComponent() {
  }

  override def getComponentName: String = &quot;RemotePairProjectComponent&quot;

  override def projectOpened() {
    System.out.println(&quot;########## projectOpened: Hello world!&quot;)
  }

  override def projectClosed() {
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;p&gt;运行该插件，在打开的新idea中，打开一个新项目，则会在console中输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## project: Project &apos;/Users/freewind/IdeaProjects/test&apos; test
########## projectOpened
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在开发Idea Plugin时，为什么修改的代码没有生效？</title>
                <link>http://freewind.in/posts/2791-why-modified-code-is-not-run-when-develop-idea-plugin</link>
                <pubDate>Sat, 27 Sep 2014 15:54:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2791</guid>
                <description><![CDATA[&lt;p&gt;今天打算开发一个新的Idea插件，发现一个奇怪的问题：我在代码中所做的任何修改，运行时都没有生效。&lt;/p&gt;
&lt;p&gt;这个问题浪费了我很多时间，因为我不知道是Idea的问题，还是我的代码写的不对。经过反复排查，终于找到了原因：&lt;/p&gt;
&lt;p&gt;我正在编写的这个插件，是灰色的，而且右边的复选框没有被勾上！也就是说，我的插件没有被启用。&lt;/p&gt;
&lt;p&gt;导致这个原因，是因为中途有一次，修改&lt;code&gt;plugin.xml&lt;/code&gt;文件时写错了，导致插件没法正常启动，Idea便自动把它禁用了。哪怕我后来重新修好了代码，它也不会自动启用。&lt;/p&gt;
&lt;p&gt;所以在开发过程中一定要注意，如果什么时候觉得不对劲，一定要来看看这个插件是否处于启用状态。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何组织你的Scala代码</title>
                <link>http://freewind.in/posts/2788-how-to-organize-your-scala-code</link>
                <pubDate>Sat, 20 Sep 2014 22:09:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2788</guid>
                <description><![CDATA[&lt;h1&gt;如何组织你的Scala代码&lt;/h1&gt;
&lt;p&gt;无关“设计模式”&lt;/p&gt;
&lt;p&gt;核心是能否找到一些方式“优雅的支持依赖注入”，并且“利用Scala的丰富特性”，还“不准用框架”&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;如果&amp;hellip;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果我们的代码不使用依赖注入，直接&lt;code&gt;new&lt;/code&gt;，代码结构就会简单随意到不需要考虑这些问题&lt;/li&gt;
&lt;li&gt;如果scala特性不丰富（如同Java），那我们选择不多，就不用想太多了&lt;/li&gt;
&lt;li&gt;如果使用某些DI框架，可沿用框架制定的规则（如&lt;code&gt;Macwire&lt;/code&gt;, &lt;code&gt;Scaldi&lt;/code&gt;），也不需要考虑太多&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;但是&amp;hellip;&lt;/h2&gt;
&lt;p&gt;Scala中有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;implicit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;函数式&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Monad&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们是否能找到一种只利用语言本身特性，以尽量优雅的方式来实现依赖注入，同时让我们的代码拥有良好的结构。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;取材&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;实际项目&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Constructor parameters&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objects as functions&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;implicit method parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;杨云的Scala培训代码&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(simple cake) &lt;code&gt;trait&lt;/code&gt; and &lt;code&gt;self type annotation&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;考虑过但是未在项目中使用的&lt;ul&gt;
&lt;li&gt;Reader monad&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;用例说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;输入：一个网页的url&lt;/li&gt;
&lt;li&gt;输出：网页上包含的所有图片地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;为了实现该功能，我们将会访问网络，取回页面的html内容，然后对其包含的&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签进行解析，取出图片的地址。&lt;/p&gt;
&lt;p&gt;(将会使用java/scala内置的或者第三方类库，简化实现)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;如果不进行依赖注入&lt;/h2&gt;
&lt;p&gt;根据url取回网页html代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import scala.sys.process._
import scala.util.Try

class PageFetcher {
  def fetch(url: String): Try[String] = Try {
    val output = new ByteArrayOutputStream
    (new URL(url) #&amp;gt; output).!!
    output.toString(&quot;UTF-8&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;从html代码中，找出所有图片地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class ImageExtractor {
  def extractImages(html: String): List[String] = {
    val doc = Jsoup.parse(html)
    val imgs = doc.select(&quot;img&quot;).listIterator()
               .asInstanceOf[JIterator[Element]].toList
    imgs.map(_.attr(&quot;src&quot;))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;组合在一起：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyImageFinder {
  val pageFetcher = new PageFetcher
  val imageExtractor = new ImageExtractor

  def find(url: String): Try[List[String]] = {
    pageFetcher.fetch(url).map(html =&amp;gt; imageExtractor.extractImages(html))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;pageFetcher&lt;/code&gt;和&lt;code&gt;imageExtractor&lt;/code&gt;都是直接&lt;code&gt;new&lt;/code&gt;出来的，而不是注入进来的&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;我们没有办法对&lt;code&gt;MyImageFinder&lt;/code&gt;进行单元测试，只能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供一个真实的url，通过网络取回数据，进行测试&lt;/li&gt;
&lt;li&gt;在本地启动一个http server&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;复杂、不可靠、甚至不可能&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;为了让我们更容易的编写单元测试并且利用Scala的各种豪华特性来体验Scala的强大灵活就让我们想尽各种办法来注入你的依赖吧&lt;/h1&gt;
&lt;hr /&gt;
&lt;h1&gt;使用contructor parameters进行注入&lt;/h1&gt;
&lt;p&gt;这种熟悉的方式，我们在Java里经常这么干&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyImageFinder(pageFetcher: PageFetcher, 
                    imageExtractor: ImageExtractor) {
  def find(url: String): Try[List[String]] = {
    pageFetcher.fetch(url).map(html =&amp;gt; imageExtractor.extractImages(html))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pageFetcher&lt;/code&gt;与&lt;code&gt;imageExtractor&lt;/code&gt;通过构造参数注入进来&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;在入口处组装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Main {
  val pageFetcher = new PageFetcher
  val imageExtractor = new ImageExtractor
  val myImageFinder = new MyImageFinder(pageFetcher, imageExtractor)

  def main(args: Array[String]) {
    val url = args.head
    myImageFinder.find(url)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（这样的入口类不用写单元测试）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;trait Mocking extends Scope {
  val pageFetcher = mock[PageFetcher]
  val imageExtractor = mock[ImageExtractor]
  val imageFinder = new MyImageFinder(pageFetcher, imageExtractor)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用一个&lt;code&gt;trait&lt;/code&gt;，把各mock类圈起来，方便后面使用&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyImageFinderSpec extends Specification with Mockito {

  &quot;MyImageFinder&quot; should {
    &quot;return images successfully if ...&quot; in new Mocking {

      pageFetcher.fetch(&quot;test-url&quot;) returns Success(&quot;some-html&quot;)
      imageExtractor.extractImages(&quot;some-html&quot;) returns List(&quot;a.png&quot;, &quot;b.png&quot;)

      val images = imageFinder.find(&quot;test-url&quot;)

      images must beASuccessfulTry(List(&quot;a.png&quot;, &quot;b.png&quot;))
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;new Mocking&lt;/code&gt;中，可以直接使用前面定义的mock&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单，容易理解&lt;/li&gt;
&lt;li&gt;很成熟&lt;/li&gt;
&lt;li&gt;大多数情况下推荐使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们是在写scala吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;回顾及提问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不使用依赖注入&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;利用构造参数注入依赖&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h1&gt;Objects as Functions&lt;/h1&gt;
&lt;p&gt;如果一个类中只有一个方法，为什么不把它变成一个函数？&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;通常的类定义是这样的（包含有一个或多个方法）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class PageFetcher {
  def fetch(url: String): Try[String] = Try {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这里定义的&lt;code&gt;fetch&lt;/code&gt;，我们要调用它的时候，要写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;pageFetcher.fetch(&quot;some-url&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即：&lt;code&gt;名词.动词(参数)&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;存在的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;表达重复: &lt;code&gt;pageFetcher.fetch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多个职责: &lt;code&gt;obj.method1&lt;/code&gt;, &lt;code&gt;obj.method2&lt;/code&gt;, &lt;code&gt;obj.method3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;无法很好利用scala对函数的支持，因为&lt;code&gt;obj.method&lt;/code&gt;是方法&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;如何解决&lt;/h2&gt;
&lt;p&gt;每个&lt;code&gt;class&lt;/code&gt;或者&lt;code&gt;object&lt;/code&gt;都定义为函数类型&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;定义一个函数类型的FetchPage&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object FetchPage extends (String =&amp;gt; Try[String]) {
  def apply(url: String) = Try {
    val output = new ByteArrayOutputStream
    (new URL(url) #&amp;gt; output).!!
    output.toString(&quot;UTF-8&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（后面详细讲解）&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object FetchPage extends (String =&amp;gt; Try[String]) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Scala中，每一个函数都有类型&lt;/li&gt;
&lt;li&gt;Scala定义了大量trait用来表示函数类型：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Function0[R]&lt;/code&gt;: &lt;code&gt;() =&amp;gt; R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function1[P1,R]&lt;/code&gt;: &lt;code&gt;P1 =&amp;gt; R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function2[P1,P2,R]&lt;/code&gt;: &lt;code&gt;(P1, P2) =&amp;gt; R&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String =&amp;gt; Try[String]&lt;/code&gt;是&lt;code&gt;Function1[String, Try[String]]&lt;/code&gt;的语法糖&lt;/li&gt;
&lt;li&gt;我们可以继承一个函数类型，它本身或者它的实例也将是一个函数&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object FetchPage extends (String =&amp;gt; Try[String]) {
  def apply(url: String) = Try {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;我们可以继承一个函数类型，实现其&lt;code&gt;apply&lt;/code&gt;方法，提供自己的逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FetchPage&lt;/code&gt;是个函数，所以把它命名为一个&lt;strong&gt;动词&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可直接调用&lt;code&gt;FetchPage(&quot;some-url&quot;)&lt;/code&gt;，等价于&lt;code&gt;FetchPage.apply(&quot;some-url&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object FetchPage extends (String =&amp;gt; Try[String]) {
  def apply(url: String) = Try { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;FetchPage&lt;/code&gt;是一个如假包换的函数，意味着：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们可以这样调用: &lt;code&gt;FetchPage(&quot;some-url&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们可以这样组合：&lt;code&gt;FetchPage andThen (s:String)=&amp;gt;s.doSomething&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我们可以依赖&lt;code&gt;String =&amp;gt; Try[String]&lt;/code&gt;这种通用的类型，而不依赖&lt;code&gt;FetchPage&lt;/code&gt;这种具体的类型&lt;/li&gt;
&lt;li&gt;我们可以方便的构造出一些函数帮助测试: &lt;code&gt;_ =&amp;gt; &quot;some-html&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;ExtractImages&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object ExtractImages extends (String =&amp;gt; List[String]) {
  def apply(html: String): List[String] = {
    val doc = Jsoup.parse(html)
    val imgs = doc.select(&quot;img&quot;).listIterator().asInstanceOf[JIterator[Element]].toList
    imgs.map(_.attr(&quot;src&quot;))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ExtractImages&lt;/code&gt;继承自&lt;code&gt;String =&amp;gt; List[String]&lt;/code&gt;，实现了&lt;code&gt;apply&lt;/code&gt;方法，它是一个函数&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;FindMyImages&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class FindMyImages(fetchPage: String =&amp;gt; Try[String], 
    extractImages: String =&amp;gt; List[String]) 
    extends (String =&amp;gt; Try[List[String]]) {
  def apply(url: String): Try[List[String]] = {
    fetchPage(url).map(extractImages)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;FindMyImages&lt;/code&gt;依赖于通用的&lt;code&gt;String =&amp;gt; Try[String]&lt;/code&gt;类型，而不是具体的&lt;code&gt;FetchPage&lt;/code&gt;类型&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;fetchPage: String =&amp;gt; Try[String], extractImages: String =&amp;gt; List[String]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;fetchPage&lt;/code&gt;和&lt;code&gt;extractImages&lt;/code&gt;都是函数，我们在需要时可以调用它们的&lt;code&gt;andThen/compose&lt;/code&gt;等方法，组合多个函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;func1 andThen func2
func2 compose func1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（这里的例子没有体现）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;组装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object MainObjectAsFunctions {

  val findMyImages = new FindMyImages(FetchPage, ExtractImages)

  def main(args: Array[String]) {
    val url = args.head
    findMyImages(url)
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接把&lt;code&gt;FetchPage&lt;/code&gt;和&lt;code&gt;ExtractImage&lt;/code&gt;传进去，因为它们都是&lt;code&gt;object&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class FindMyImagesSpec extends Specification {
  &quot;MyImageFinder&quot; should {
    &quot;return a failure if pageFetcher can&apos;t get the page&quot; in {
      val findMyImages = new FindMyImages(
        _ =&amp;gt; Failure(new Throwable(&quot;test-connection-error&quot;)),
        _ =&amp;gt; ???
      )
      val images = findMyImages(&quot;any-url&quot;)
      images must beAFailedTry.which(_.getMessage === &quot;test-connection-error&quot;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意到那两个mock出来的函数了吗？&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class FindMyImagesSpec extends Specification {

  &quot;MyImageFinder&quot; should {
    &quot;return images successfully if ...&quot; in {
      val findMyImages = new FindMyImages(
        { case &quot;test-url&quot; =&amp;gt; Success(&quot;some-html-code-contains-images&quot;)},
        { case &quot;some-html-code-contains-images&quot; =&amp;gt; List(&quot;a.png&quot;, &quot;b.png&quot;)}
      )

      val images = findMyImages(&quot;test-url&quot;)

      images must beASuccessfulTry(List(&quot;a.png&quot;, &quot;b.png&quot;))
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你要求传入特定的参数，使用&lt;code&gt;{case =&amp;gt;}&lt;/code&gt;声明一个偏函数&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题：缺少线索&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object FetchPage extends (String =&amp;gt; Try[String])

object ExtractImages extends (String =&amp;gt; List[String])

class FindMyImages(fetchPage: String =&amp;gt; Try[String], 
    extractImages: String =&amp;gt; List[String]) 
    extends (String =&amp;gt; Try[List[String]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这么多&lt;code&gt;String =&amp;gt; Try[String]&lt;/code&gt;, &lt;code&gt;String =&amp;gt; List[String]&lt;/code&gt;，我已经晕了&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;type alias 和 package object&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package object some_package {
  type FetchPage = String =&amp;gt; Try[String]
  type ExtractImages = String =&amp;gt; List[String]
  type FindMyImages = String =&amp;gt; Try[List[String]]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里声明了一个&lt;code&gt;package object&lt;/code&gt;，名为&lt;code&gt;some_package&lt;/code&gt;。所有位于&lt;code&gt;some_package&lt;/code&gt;下的类，可以直接访问这里定义的各type alias&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package some_package

object FetchPage extends FetchPage
object ExtractImages extends ExtractImages
class WillFindMyImages(fetchPage: FetchPage, extractImages: ExtractImages)
    extends FindMyImages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们可以引用前面定义的type alias了，看起来是不是清楚了许多？&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大程度利用了scala对函数的支持&lt;/li&gt;
&lt;li&gt;一个类或object只实现一个单一功能，职责明确&lt;/li&gt;
&lt;li&gt;测试时的mock方式非常给力&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当多个函数的类型一致时，容易误传，不会提示编译错误&lt;/li&gt;
&lt;li&gt;IDEA不能显示某个&lt;code&gt;type alias&lt;/code&gt;有哪些子类，跳转不便&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type alias&lt;/code&gt;的声明通常放在&lt;code&gt;package object&lt;/code&gt;中，而不能放在实现类的旁边，不方便查看（Scala不支持在top level声明type alias)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;回顾及提问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不使用依赖注入&lt;/li&gt;
&lt;li&gt;利用构造参数注入依赖&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;定义函数对象，把函数当依赖注入&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h1&gt;你听过说Cake pattern吗&lt;/h1&gt;
&lt;p&gt;利用scala提供的&lt;code&gt;trait&lt;/code&gt;和&lt;code&gt;self type annotation&lt;/code&gt;来注入依赖&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di/&quot;&gt;http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;This pattern is first explained in Martin Oderskys’ paper &lt;a href=&quot;http://lamp.epfl.ch/~odersky/papers/ScalableComponent.pdf&quot;&gt;Scalable Component Abstractions&lt;/a&gt; (which is an excellent paper that is highly recommended) as the way he and his team structured the Scala compiler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Simple Cake&lt;/h2&gt;
&lt;p&gt;但是对于普通的项目来说，Cake Pattern过于复杂，所以出现了很多简化的方案，比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;thin cake: &lt;a href=&quot;http://java.dzone.com/articles/using-scala-traits-modules-or&quot;&gt;http://java.dzone.com/articles/using-scala-traits-modules-or&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;由于我们这里的方案与&lt;strong&gt;thin-cake&lt;/strong&gt;有所不同，所以我使用了一个不同的名字&lt;strong&gt;simple-cake&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;来自“通过构造参数注入”的普通例子&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class PageFetcher { 
    def fetch(url:String):Try[String] = ???
}
class ImageExtractor {
    def extractImages(html:String):List[String] = ???
}
class MyImageFinder(pageFetcher: PageFetcher, imageExtractor: ImageExtractor) {
    def find(url:String):Try[List[String]] = {
        pageFetcher.fetch(url).map(html =&amp;gt; imageExtractor.extractImages(html))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Simple Cake改写后的代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;trait PageFetcher { 
    def fetch(url:String):Try[String] = ???
}
trait ImageExtractor {
    def extractImages(html:String):List[String] = ???
}
trait MyImageFinder {
  self: PageFetcher with ImageExtractor =&amp;gt;
  def find(url: String): Try[List[String]] = {
    fetch(url).map(html =&amp;gt; extractImages(html))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;各小功能都使用&lt;code&gt;trait&lt;/code&gt;定义&lt;/li&gt;
&lt;li&gt;每个&lt;code&gt;trait&lt;/code&gt;中只声明&lt;strong&gt;方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;self type annotation&lt;/code&gt;语法声明依赖：&lt;code&gt;self: PageFetcher with ImageExtractor =&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;直接调用依赖中的方法来实现新的功能&lt;/li&gt;
&lt;li&gt;在入口处混入所有需要的&lt;code&gt;trait&lt;/code&gt;（见下页）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;组装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Main extends MyImageFinder with PageFetcher with ImageExtractor {

  def main(args: Array[String]) {
    val url = args.head
    find(url)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意直接在&lt;code&gt;Main&lt;/code&gt;上混入了所有的&lt;code&gt;trait&lt;/code&gt;，不需要手动注入依赖&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;&quot;MyImageFinder&quot; should {
  &quot;return images successfully if ...&quot; in {
    val imageFinder = new MyImageFinder with PageFetcher with ImageExtractor {
      override def fetch(url: String) = url match {
        case &quot;test-url&quot; =&amp;gt; Success(&quot;some-html&quot;) }
      override def extractImages(html: String) = html match {
        case &quot;some-html&quot; =&amp;gt; List(&quot;a.png&quot;, &quot;b.png&quot;) }
    }
    val images = imageFinder.find(&quot;test-url&quot;)
    images must beASuccessfulTry(List(&quot;a.png&quot;, &quot;b.png&quot;))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;with&lt;/code&gt;和&lt;code&gt;override&lt;/code&gt;，不需要使用&lt;code&gt;mockito&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;易实现、易理解&lt;/li&gt;
&lt;li&gt;巧妙利用了scala的语言特性&lt;/li&gt;
&lt;li&gt;mock方式比较简单&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要注意多个trait中是否同名方法（通过更有描述性的命名和测试来保证正确性）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;回顾及提问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不使用依赖注入&lt;/li&gt;
&lt;li&gt;利用构造参数注入依赖&lt;/li&gt;
&lt;li&gt;定义函数对象，把函数当依赖注入&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;利用&lt;code&gt;trait&lt;/code&gt;和&lt;code&gt;self type annotation&lt;/code&gt;注入依赖&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;通过方法参数注入依赖&lt;/h2&gt;
&lt;p&gt;我不喜欢向类的构造器中注入依赖，因为如果有多个方法，我不知道它们将被哪个方法调用&lt;/p&gt;
&lt;p&gt;我希望依赖出现在方法的参数列表中&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyService(dep1: Dep1, dep2: Dep2, dep3: Dep3) {
  def method1(s:String) = dep1.doIt(s)
  def method2(s:String) = dep2.doIt(dep3.doIt(s))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;method1&lt;/code&gt;只使用了&lt;code&gt;dep1&lt;/code&gt;，&lt;code&gt;method2&lt;/code&gt;只使用了&lt;code&gt;dep2/dep3&lt;/code&gt;，但是我需要同时向&lt;code&gt;MyService&lt;/code&gt;注入所有的依赖。&lt;/p&gt;
&lt;p&gt;如果不看实现，我不知道&lt;code&gt;method1&lt;/code&gt;和&lt;code&gt;method2&lt;/code&gt;有哪些依赖。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;把依赖移到每个方法中&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyService {
  def method1(s:String, dep1: Dep1) = dep1.doIt(s)
  def method2(s:String, dep2: Dep2, dep3: Dep3) = dep2.doIt(dep3.doIt(s))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MyService&lt;/code&gt;没有构造参数了，它们都移到了相应的方法中&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;存在的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;很多方法可能都有长长的参数列表&lt;/li&gt;
&lt;li&gt;如果一个方法调用多个方法，那么它需要提供所有需要的参数（更长了）&lt;/li&gt;
&lt;li&gt;难以分清哪些参数是依赖，哪些是我们真正要处理的&lt;/li&gt;
&lt;li&gt;向一个方法中增删依赖时，会递归影响所有调用它的方法（以及测试），修改量巨大&lt;/li&gt;
&lt;li&gt;在调用一个方法时必须显式传入所有的依赖，影响阅读&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;curry 和 implicit&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyService {
  def method1(s:String)(implicit dep1: Dep1) = dep1.doIt(s)
  def method2(s:String)(implicit dep2: Dep2, dep3: Dep3) = dep2.doIt(dep3.doIt(s))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;第一个括号里是我们要处理的参数，第二个括号里是要注入的依赖&lt;/li&gt;
&lt;li&gt;第二个括号标记为&lt;code&gt;implicit&lt;/code&gt;，意味着我们有办法避免显式传入参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;implicit&lt;/code&gt;作用于所有括号中的全部参数，并不只针对&lt;code&gt;dep1&lt;/code&gt;或&lt;code&gt;dep2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;PageFetcher&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class PageFetcher {
  def fetch(url: String)(implicit dep1: Dep1, dep2: Dep2): Try[String] = Try {
    val output = new ByteArrayOutputStream
    (new URL(url) #&amp;gt; output).!!
    output.toString(&quot;UTF-8&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了突出依赖的个数，我额外定义了几个依赖&lt;code&gt;Dep1&lt;/code&gt;, &lt;code&gt;Dep2&lt;/code&gt;, &lt;code&gt;Dep3&lt;/code&gt;。注意它们被声明为&lt;code&gt;implicit&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;ImageExtractor&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class ImageExtractor {
  def extractImages(html: String)(implicit dep2: Dep2, dep3: Dep3): List[String] = {
    val doc = Jsoup.parse(html)
    val imgs = doc.select(&quot;img&quot;).listIterator().asInstanceOf[JIterator[Element]].toList
    imgs.map(_.attr(&quot;src&quot;))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样将&lt;code&gt;dep2&lt;/code&gt;和&lt;code&gt;dep3&lt;/code&gt;声明为&lt;code&gt;implicit&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;MyImageFinder&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object MyImageFinder {
  def find(url: String)(implicit pageFetcher: PageFetcher, imageExtractor: ImageExtractor, dep1: Dep1, dep2: Dep2, dep3: Dep3): Try[List[String]] = {
    pageFetcher.fetch(url).map(html =&amp;gt; imageExtractor.extractImages(html))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，有一大堆参数都声明为&lt;code&gt;implicit&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;dep1/dep2/dep3&lt;/code&gt;都声明为&lt;code&gt;implicit&lt;/code&gt;了，我们不需要&lt;strong&gt;显式&lt;/strong&gt;把它们传给&lt;code&gt;pageFetcher.fetch(url)&lt;/code&gt;以及&lt;code&gt;imageExtractor.extractImages(html)&lt;/code&gt;，编译器会帮我们。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果没有&lt;code&gt;implicit&lt;/code&gt;，我们必须写成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;pageFetcher.fetch(url)(dep1,dep2)
  .map(html =&amp;gt; imageExtractor.extractImages(html)(dep2,dep3))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意注入的&lt;code&gt;(dep1,dep2)&lt;/code&gt;和&lt;code&gt;(dep2,dep3)&lt;/code&gt;是否影响阅读？&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;组装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Main {
  implicit val pageFetcher = new PageFetcher
  implicit val imageExtractor = new ImageExtractor
  implicit val dep1 = new Dep1
  implicit val dep2 = new Dep2
  implicit val dep3 = new Dep3

  def main(args: Array[String]) {
    var url = args.head
    MyImageFinder.find(url)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;依赖都声明为&lt;code&gt;implicit&lt;/code&gt;，不需要显式传给&lt;code&gt;find&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;trait Mocking extends Scope {
  implicit val pageFetcher: PageFetcher = mock[PageFetcher]
  implicit val imageExtractor: ImageExtractor = mock[ImageExtractor]
  implicit val dep1: Dep1 = mock[Dep1]
  implicit val dep2: Dep2 = mock[Dep2]
  implicit val dep3: Dep3 = mock[Dep3]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：当我们在trait中声明&lt;code&gt;implicit&lt;/code&gt;值时，最好显式给出类型，不然在某些情况下会因为scala的类型推断而报错&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class MyImageFinderSpec extends Specification with Mockito {

  &quot;MyImageFinder&quot; should {
    &quot;return images successfully if ...&quot; in new Mocking {
      pageFetcher.fetch(&quot;test-url&quot;) returns Success(&quot;some-html&quot;)
      imageExtractor.extractImages(&quot;some-html&quot;) returns List(&quot;a.png&quot;, &quot;b.png&quot;)

      val images = MyImageFinder.find(&quot;test-url&quot;)

      images must beASuccessfulTry(List(&quot;a.png&quot;, &quot;b.png&quot;))
    }
  }
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;new Mocking&lt;/code&gt;内部调用&lt;code&gt;fetch&lt;/code&gt;、&lt;code&gt;extractImages&lt;/code&gt;和&lt;code&gt;find&lt;/code&gt;时，不需要显式传入依赖&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;依赖声明在方法的参数列表中，方便查看当前方法的依赖&lt;/li&gt;
&lt;li&gt;测试某方法时只需要给出它所需要的依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;implicit&lt;/code&gt;难以追踪：可以从函数参数中找，也可以从所在的类及&lt;code&gt;import&lt;/code&gt;中找&lt;/li&gt;
&lt;li&gt;因为调用其它方法时不需要显式传入依赖，所以不知道哪个依赖被谁用了&lt;/li&gt;
&lt;li&gt;难以知道某个依赖是否已经没有用，是否可以删掉&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与“通过构造参数注入依赖”的方式相比，这种方式并没有带来更多的好处（不推荐）&lt;/p&gt;
&lt;p&gt;改进方案：&lt;code&gt;Reader monad&lt;/code&gt;?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;回顾及提问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不使用依赖注入&lt;/li&gt;
&lt;li&gt;利用构造参数注入依赖&lt;/li&gt;
&lt;li&gt;定义函数对象，把函数当依赖注入&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;trait&lt;/code&gt;和&lt;code&gt;self type annotation&lt;/code&gt;注入依赖&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;通过方法的implicit参数注入依赖&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h1&gt;我是函数式死忠，我要用Monad&lt;/h1&gt;
&lt;p&gt;试试&lt;code&gt;Reader monad&lt;/code&gt;?&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;随便讲，随便听&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Reader monad&lt;/code&gt;可看作是对“通过implicit注入依赖”的一种改进&lt;/p&gt;
&lt;p&gt;在所有方法拥有一个共同的单一依赖的情况下，使用&lt;code&gt;Reader&lt;/code&gt;看起来是一种很优雅的方案。&lt;/p&gt;
&lt;p&gt;但是，一旦不同的方法有不同的依赖，或者有不同的返回值时，就会遇到各种各样的麻烦。&lt;/p&gt;
&lt;p&gt;而解决方案对于不熟悉函数式及Manod的人（e.g. 我）来说，如同天书一般。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;一个抄来的简单例子&lt;/h2&gt;
&lt;p&gt;来自于下面这篇讲解&lt;code&gt;Reader&lt;/code&gt;的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/&quot;&gt;http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;基础类&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;case class User(email: String, 
                supervisorId: Int, 
                firstName: String, 
                lastName: String)

trait UserRepository {
  def get(id: Int): User
  def find(username: String): User
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;有些方法需要依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import scalaz.Reader
trait Users {
  def getUser(id: Int) = Reader((userRepository: UserRepository) =&amp;gt;
    userRepository.get(id)
  )
  def findUser(username: String) = Reader((userRepository: UserRepository) =&amp;gt;
    userRepository.find(username)
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在需要注入依赖的地方，定义一个新的函数，用&lt;code&gt;Reader(...)&lt;/code&gt;包起来，返回一个&lt;code&gt;Reader monad&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object UserInfo extends Users {
  def userEmail(id: Int) = getUser(id) map (_.email)
  def userInfo(username: String) =
    for {
      user &amp;lt;- findUser(username)
      boss &amp;lt;- getUser(user.supervisorId)
    } yield Map(
      &quot;fullName&quot; -&amp;gt; s&quot;${user.firstName} ${user.lastName}&quot;,
      &quot;email&quot; -&amp;gt; s&quot;${user.email}&quot;,
      &quot;boss&quot; -&amp;gt; s&quot;${boss.firstName} ${boss.lastName}&quot;
    )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用&lt;code&gt;for表达式&lt;/code&gt;的&lt;code&gt;&amp;lt;-&lt;/code&gt;语法对&lt;code&gt;Reader&lt;/code&gt;类型的值进行操作，条理清晰，且不需要传入依赖&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;注入依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;val userRepository = getUserPepositoryFromSomeWhere()

UserInfo.userEmail(123)(userRepository)
UserInfo.userInfo(&quot;Freewind&quot;)(userRepository)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只需在最终使用的地方传入依赖即可。&lt;/p&gt;
&lt;p&gt;避免了“implicit参数注入依赖”方式中的很多问题，但是只在这种极为简单的情况下看起来很简单。&lt;/p&gt;
&lt;p&gt;当情况复杂的时候，会变得很复杂（见下页）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;如果你想了解更多&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/&quot;&gt;介绍Reader的文章，也是前面例子的出处&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://thenewcircle.com/s/post/1108/dependency_injection_in_scala&quot;&gt;Functional programming in scala作者关于Reader的一个演讲视频&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我遇到困难后，在stackoverflow上提的一些问题：&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/25949608/how-to-handle-reader-monad-and-try&quot;&gt;How to handle &lt;code&gt;Reader&lt;/code&gt; monad and &lt;code&gt;Try&lt;/code&gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/25947783/how-to-inject-multi-dependencies-when-i-use-reader-monad-for-dependency-inject&quot;&gt;How to inject multi dependencies when I use “Reader monad” for dependency injection?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;回顾及提问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不使用依赖注入&lt;/li&gt;
&lt;li&gt;利用构造参数注入依赖&lt;/li&gt;
&lt;li&gt;定义函数对象，把函数当依赖注入&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;trait&lt;/code&gt;和&lt;code&gt;self type annotation&lt;/code&gt;注入依赖&lt;/li&gt;
&lt;li&gt;通过方法的implicit参数注入依赖&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot;&gt;Reader Monad&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;示例源代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://github.com/freewind/scala-code-organize&quot;&gt;http://github.com/freewind/scala-code-organize&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;谢谢&lt;/h1&gt;
]]></description>
            </item>
        
            <item>
                <title>Session: 轻快的SBT</title>
                <link>http://freewind.in/posts/2782-session-agile-sbt</link>
                <pubDate>Thu, 18 Sep 2014 12:24:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2782</guid>
                <description><![CDATA[&lt;h1&gt;轻快的SBT&lt;/h1&gt;
&lt;p&gt;Sbt是当前Scala项目的标准构建工具&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Session目的&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;了解sbt中让人感觉轻松愉快的部分&lt;/li&gt;
&lt;li&gt;以最小的学习成本帮助我们处理scala项目&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;http://scala-sbt.org&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt; The interactive build tool &lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Use Scala to define your tasks. Then run them in parallel from the shell.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;Sbt 全称&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Simple Build Tool&lt;/li&gt;
&lt;li&gt;Scala Build Tool&lt;/li&gt;
&lt;li&gt;The interactive build tool&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S(i) B(ian) T(ai)&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Sbt的复杂来源于&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;糟糕的文档: 没有实例，抽象描述，冗长，不准确&lt;/li&gt;
&lt;li&gt;初学者不友好: 无向导工具，无模板项目&lt;/li&gt;
&lt;li&gt;混乱的版本: sbt &amp;amp; scala&lt;/li&gt;
&lt;li&gt;各种奇怪操作符: &lt;code&gt;:=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;++=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;混乱的结构: &lt;code&gt;*.sbt&lt;/code&gt;, &lt;code&gt;project/*.scala&lt;/code&gt;, &lt;code&gt;~/.sbt/0.13/plugins/*&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;以及&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;各种编译错误: Sbt是一套类型安全的scala DSL&lt;/li&gt;
&lt;li&gt;复杂的key机制: &lt;code&gt;settingKey&lt;/code&gt;, &lt;code&gt;taskKey&lt;/code&gt;, &lt;code&gt;inputKey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复杂的scope: &lt;code&gt;project scope&lt;/code&gt;, &lt;code&gt;config scope&lt;/code&gt;, &lt;code&gt;inkey scope&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;Sbt很努力，只是Scala世界很复杂&lt;/h2&gt;
&lt;p&gt;让我们开始SBT轻快之旅吧！&lt;/p&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;一条命令SBT安装&lt;/li&gt;
&lt;li&gt;零配置运行一个Scala程序&lt;/li&gt;
&lt;li&gt;一条命令生成新项目&lt;/li&gt;
&lt;li&gt;快速添加依赖&lt;/li&gt;
&lt;li&gt;快速生成Idea项目&lt;/li&gt;
&lt;li&gt;一条命令让项目内置sbt脚本&lt;/li&gt;
&lt;li&gt;Sbt好插件&lt;/li&gt;
&lt;li&gt;轻松支持多项目&lt;/li&gt;
&lt;li&gt;轻松解读配置文件基本规则&lt;/li&gt;
&lt;li&gt;自定义极简单的任务&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;1. SBT安装&lt;/h2&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;升级：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew update sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;2. 零配置运行一个Scala程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;touch Hello.scala
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Hello extends App {
    println(&quot;Hello, sbt!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt run
Hello, sbt!
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;3. 一条命令生成新项目&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;~/.sbt/0.13/plugins/np.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;resolvers += Resolver.url(&quot;sbt-np&quot;,
  url(&quot;http://scalasbt.artifactoryonline.com/scalasbt/sbt-plugin-releases/&quot;))(
    Resolver.ivyStylePatterns)

addSbtPlugin(&quot;me.lessis&quot; % &quot;np&quot; % &quot;0.2.0&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;~/.sbt/0.13/np.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;seq(npSettings: _*)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;$ sbt np
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── build.sbt
└── src
    ├── main
    │   ├── resources
    │   └── scala
    └── test
        ├── resources
        └── scala
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;organization := &quot;mytest&quot;

name := &quot;default&quot;

version := &quot;0.1-SNAPSHOT&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;4. 快速添加依赖&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;resolvers ++= Seq(
  &quot;ibiblio&quot; at &quot;http://mirrors.ibiblio.org/pub/mirrors/maven2&quot;,
  &quot;Sonatype snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot;,
  &quot;Sonatype releases&quot; at &quot;http://oss.sonatype.org/content/repositories/releases&quot;
)

libraryDependencies ++= Seq(
  &quot;org.scalaz&quot; %% &quot;scalaz-core&quot; % &quot;7.1.0&quot;,
  &quot;org.specs2&quot; %% &quot;specs2&quot; % &quot;2.3.13&quot; % &quot;test&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; update
&amp;gt; gen-idea
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;5. 快速生成Idea项目&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;~/.sbt/0.13/plugins/sbt-idea.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;addSbtPlugin(&quot;com.github.mpeltonen&quot; % &quot;sbt-idea&quot; % &quot;1.6.0&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;不下载源代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt gen-idea
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下载源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt 
&amp;gt; gen-idea sbt-classifiers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用idea打开：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;idea .
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;6. 一条命令让项目内置sbt脚本&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;curl -s https://raw.githubusercontent.com/paulp/sbt-extras/master/sbt &amp;gt; sbt
chmod 0755 sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;$ ./sbt
Downloading sbt launcher for 0.13.6:
  From  http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.13.6/sbt-launch.jar
    To  /Users/freewind/.sbt/launchers/0.13.6/sbt-launch.jar
Getting org.scala-sbt sbt 0.13.6 ...
:: retrieving :: org.scala-sbt#boot-app
    confs: [default]
    44 artifacts copied, 0 already retrieved (13750kB/150ms)
[info] Loading global plugins from /Users/freewind/.sbt/0.13/plugins
[info] Updating {file:/Users/freewind/.sbt/0.13/plugins/}global-plugins...
[info] Resolving org.scala-sbt.ivy#ivy;2.3.0-sbt-14d4d23e25f354cd296c73bfff40554[info] Resolving org.fusesource.jansi#jansi;1.4 ...
[info] Done updating.
[info] Set current project to default (in build file:/private/tmp/mytest/)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;7. Sbt好插件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建新项目: https://github.com/softprops/np&lt;/li&gt;
&lt;li&gt;生成IDEA项目：https://github.com/mpeltonen/sbt-idea&lt;/li&gt;
&lt;li&gt;显示dependency: https://github.com/jrudolph/sbt-dependency-graph&lt;/li&gt;
&lt;li&gt;查看项目文件数量统计：https://github.com/orrsella/sbt-stats&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;Git支持：https://github.com/sbt/sbt-git&lt;/li&gt;
&lt;li&gt;把build.sbt中信息自动生成scala: https://github.com/sbt/sbt-buildinfo&lt;/li&gt;
&lt;li&gt;打包成一个jar: https://github.com/sbt/sbt-assembly&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;更多：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://www.scala-sbt.org/0.13/docs/Community-Plugins.html&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;8. 轻松支持多项目&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; np name:root
&amp;gt; np name:core dir:core
&amp;gt; np name:util dir:util
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;├── build.sbt
├── src
│   ├── main
│   │   ├── resources
│   │   └── scala
│   └── test
│       ├── resources
│       └── scala
├── core
│   ├── build.sbt
│   └── src
└── util
    ├── build.sbt
    └── src
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;添加对子项目的引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val core = project

lazy val util = project
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;9. 轻松解读配置文件基本规则&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;hello&quot;

version := &quot;1.0&quot;

organization := &quot;org.my&quot;

scalaVersion := &quot;2.11.0&quot;

sbtVersion := &quot;0.13.5&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;规则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;以空行分隔两个定义&lt;/li&gt;
&lt;li&gt;可使用预定义的key，也可以自定义key&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;:=&lt;/code&gt;给一个key赋值&lt;/li&gt;
&lt;li&gt;可以将一个key定义成一个task&lt;/li&gt;
&lt;li&gt;会将&lt;code&gt;*.sbt&lt;/code&gt;, &lt;code&gt;*.scala&lt;/code&gt;, &lt;code&gt;project/*.sbt&lt;/code&gt;, &lt;code&gt;project/*.scala&lt;/code&gt;内容合并&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;10. 自定义极简单的任务&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val hello = taskKey[Unit](&quot;An example task&quot;)

hello := { println(&quot;Hello, world&quot;) }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; hello
Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;Task：显示根目录下的文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val showRootFiles = taskKey[Unit](&quot;Show root files&quot;)

showRootFiles := {
  baseDirectory.value.listFiles.foreach(println)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; showRootFiles
/private/tmp/mytest/.idea
/private/tmp/mytest/.idea_modules
/private/tmp/mytest/.sbt
/private/tmp/mytest/build.sbt
/private/tmp/mytest/core
/private/tmp/mytest/project
/private/tmp/mytest/src
/private/tmp/mytest/target
/private/tmp/mytest/util
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;更多文档（后面的简单，从最后一个看起）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/understand-the-output-of-sbt-inspect&quot;&gt;sbt中读懂inspect的输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/understand-sbt-scopes&quot;&gt;理解sbt的scopes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/how-to-create-a-simple-sbt-plugin&quot;&gt;如何创建一个简单的sbt插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/how-to-invoke-objects-defined-in-scala-files-in-build-sbt&quot;&gt;如何在build.sbt中调用其它scala中定义的值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/define-multi-sub-projects-in-build-scala-in-sbt&quot;&gt;在Build.scala中定义多个子项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/build-sbt-in-sub-projects-will-be-combined-to-root-project-in-sbt&quot;&gt;sbt多个子项目的build.sbt是如何处理的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/config-in-build-sbt-for-multi-sub-projects&quot;&gt;使用build.sbt配置多个子项目&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/use-build-sbt-and-build-scala-in-one-sbt-project&quot;&gt;sbt中build.sbt和Build.scala配合使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/create-a-simplest-build-scala-in-sbt&quot;&gt;sbt中如何创建一个最简单的Build.scala&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/download-source-jar-when-declaring-dependency-in-sbt&quot;&gt;在sbt中声明依赖时同时下载源代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/use-a-jar-not-inside-a-maven-repo-as-dependency-in-sbt&quot;&gt;在sbt中使用一个不在maven库中的jar作为依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/run-initailization-code-in-build-sbt&quot;&gt;如何在build.sbt中执行一段初始化代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/the-operators-for-keys-in-build-sbt&quot;&gt;build.sbt中有哪些操作符可用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/the-sbt-shell-for-project&quot;&gt;可放在项目代码中的sbt脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/use-shell-to-create-sbt-dirs-quickly&quot;&gt;用脚本快速初始化一个sbt项目的结构&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/use-simple-sbt-config-to-run-scala-program&quot;&gt;基本的build.sbt配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/use-sbt-to-run-scala-program-directly&quot;&gt;无需任何配置，直接使用sbt运行一个scala文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/how-to-use-value-of-another-key-in-sbt-task&quot;&gt;如何在定义sbt任务时，使用其它key的值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/how-to-define-a-simplest-hello-word-task-in-sbt&quot;&gt;如何在sbt中定义一个最简单的hello world任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freewind.github.io/posts/sbt-keys&quot;&gt;sbt预定义的keys&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>如何查看系统传给某一个进程的环境变量</title>
                <link>http://freewind.in/posts/2781-how-to-see-the-env-vars-system-passed-to-a-process</link>
                <pubDate>Tue, 16 Sep 2014 10:39:13 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2781</guid>
                <description><![CDATA[&lt;p&gt;我们经常需要让系统向某个java程序传入一些环境变量，如何检查它到底向该进程传递了哪些变量呢？&lt;/p&gt;
&lt;h2&gt;找到进程id&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ ps -ef | grep java
12006     1050     1  0 12:25 ?        00:00:04 java ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;在mac上查看&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ ps -wwE -p 1050
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会以一个长长的字符串打印出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1050 ?? 67:40.42 /usr/bin/java -Dcom.sun.management.jmxremote -Xmx2048m -XX:MaxPermSize=512m -jar /Application
/Jenkins/jenkins.war SHELL=/bin/bash TMPDIR=/var/folders/5f/qnywwqmx3h5fxnwlcssp2sr00000gn/T/ USER=jenkins __CF
_USER_TEXT_ENCODING=0x1F5:0:0 JENKINS_HOME=/Users/Shared/Jenkins/Home PATH=/usr/bin:/bin:/usr/sbin:/sbin PWD=/
CATALINA_OPTS= -Dcom.sun.management.jmxremote SHLVL=0 HOME=/Users/jenkins LOGNAME=jenkins SECURITYSESSIONID=1c2
92 com.apple.java.jvmTask=CommandLine JAVA_ARCH=x
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;在linux上查看&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ xargs --null --max-args=1 &amp;lt; /proc/1050/environ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会以列表形式打印出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHELL=/bin/sh
TERM=linux
USER=me
PATH=/sbin:/usr/sbin:/bin:/usr/bin
PWD=/
HOME=/home/me
SHLVL=2
LOGNAME=me
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt中读懂inspect的输出</title>
                <link>http://freewind.in/posts/2780-understand-the-output-of-sbt-inspect</link>
                <pubDate>Mon, 15 Sep 2014 12:50:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2780</guid>
                <description><![CDATA[&lt;p&gt;在sbt中，我们可以使用&lt;code&gt;inspect&lt;/code&gt;命令查看一个key，比如一个任务，一个设置等。&lt;/p&gt;
&lt;p&gt;（如果本文中有一些内容不理解，可以参看我写的关于sbt的其它文章)&lt;/p&gt;
&lt;h2&gt;inspect name&lt;/h2&gt;
&lt;p&gt;先以最常见的&lt;code&gt;name&lt;/code&gt;为例。我们都需要在&lt;code&gt;build.sbt&lt;/code&gt;中定义一个name，表示所在的项目名称：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;my-project&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;inspect&lt;/code&gt;来查看它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; inspect name
[info] Setting: java.lang.String = my-project
[info] Description:
[info]  Project name.
[info] Provided by:
[info]  {file:/Users/freewind/workspace/sbt-scope-test/}sbt-scope-test/*:name
[info] Defined at:
[info]  /Users/freewind/workspace/sbt-scope-test/build.sbt:1
[info] Reverse dependencies:
[info]  *:onLoadMessage
[info]  *:description
[info]  *:normalizedName
[info]  *:projectInfo
[info] Delegates:
[info]  *:name
[info]  {.}/*:name
[info]  */*:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何看懂这些描述呢？&lt;/p&gt;
&lt;h2&gt;Setting&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;[info] Setting: java.lang.String = my-project
[info] Description:
[info]  Project name.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示&lt;code&gt;name&lt;/code&gt;是一个值类型为&lt;code&gt;String&lt;/code&gt;的Setting，其值为&lt;code&gt;my-project&lt;/code&gt;，说明信息是&lt;code&gt;Project name&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从这些内容我们可以反推出它的定义，应该形如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val name = settingKey[String](&quot;Project name.&quot;)

name := &quot;my-project&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Task&lt;/h3&gt;
&lt;p&gt;补充：除了&lt;code&gt;Setting&lt;/code&gt;，还有&lt;code&gt;Task&lt;/code&gt;类型的。比如我这样定义一个&lt;code&gt;hello&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val hello = taskKey[Unit](&quot;hello task&quot;)

hello := println(&quot;hello&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; inspect hello
[info] Task: Unit
[info] Description:
[info]  hello task
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，这里显示的就是&lt;code&gt;Task: Unit&lt;/code&gt;了。&lt;/p&gt;
&lt;h2&gt;Provided by&lt;/h2&gt;
&lt;p&gt;然后是&lt;code&gt;Provided by&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Provided by:
[info]  {file:/Users/freewind/workspace/sbt-scope-test/}sbt-scope-test/*:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句长长的信息是在告诉我们，它在哪里找到了符合我们输入的&lt;code&gt;key&lt;/code&gt;的完整定义。我们输入的命令是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inspect name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;name&lt;/code&gt;只给了key名，没有同时给出project/config/inkey等scope信息。根据sbt的定义，只给出名字时，这个key表示：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;其所在项目的，以global为config，global为inkey的名为&lt;code&gt;name&lt;/code&gt;的key&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中&lt;code&gt;inkey&lt;/code&gt;表示在配置中定义的另一个key，可以是settingKey，taskKey和inputKey.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inspect&lt;/code&gt;会自动帮我们填上缺少的部分，然后寻找与其匹配的scope最接近的key，以&lt;code&gt;Provided by&lt;/code&gt;的形式显示出来。&lt;/p&gt;
&lt;p&gt;在匹配过程中，如果指定的project不存在，则去寻找&lt;code&gt;ThisBuild&lt;/code&gt;，即整个build范围。如果指定的config或者inkey不存在，则去寻找&lt;code&gt;global&lt;/code&gt; scope，直到找到最接近的一个。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{file:/Users/freewind/workspace/sbt-scope-test/}sbt-scope-test/*:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这句话，就是告诉我们，对于我们输入的&lt;code&gt;name&lt;/code&gt;这个key，它找到的最接近的是：位于&lt;code&gt;file:/.../sbt-scope-test/&lt;/code&gt;目录下的&lt;code&gt;sbt-scope-test&lt;/code&gt;项目中的，以&lt;code&gt;global&lt;/code&gt;为config的，名为&lt;code&gt;name&lt;/code&gt;的key&lt;/p&gt;
&lt;h3&gt;输入更完整的key&lt;/h3&gt;
&lt;p&gt;我们还可以通过指定其它scope信息，来输入更完整的key，比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inspect compile:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据前面所说，sbt在找不到精确匹配的情况下，会去寻找&lt;strong&gt;最接近&lt;/strong&gt;的key。所以sbt会先去找有没有这样的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name in compile := ???
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果找不到，再去找:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name in Global := ???
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者它的等价形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name := ???
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; inspect compile:name
[info] Setting: java.lang.String = my-project
[info] Description:
[info]  Project name.
[info] Provided by:
[info]  {file:/Users/freewind/workspace/sbt-scope-test/}sbt-scope-test/*:name
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，它没有找到精确匹配&lt;code&gt;compile:name&lt;/code&gt;的key，最终找到的还是&lt;code&gt;*:name&lt;/code&gt;，跟前面一样。&lt;/p&gt;
&lt;p&gt;但是如果我们在&lt;code&gt;build.sbt&lt;/code&gt;给它添加一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name in Compile := &quot;my-project-for-compile&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，这里写的是&lt;code&gt;Compile&lt;/code&gt;，它对应的是一个&lt;code&gt;config&lt;/code&gt;，而不是&lt;code&gt;compile&lt;/code&gt; task.&lt;/p&gt;
&lt;p&gt;则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; inspect compile:name
[info] Setting: java.lang.String = my-project-for-compile
[info] Description:
[info]  Project name.
[info] Provided by:
[info]  {file:/Users/freewind/workspace/sbt-scope-test/}sbt-scope-test/compile:name
[info] Defined at:
[info]  /Users/freewind/workspace/sbt-scope-test/build.sbt:7
[info] Delegates:
[info]  compile:name
[info]  *:name
[info]  {.}/compile:name
[info]  {.}/*:name
[info]  */compile:name
[info]  */*:name
[info] Related:
[info]  *:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，此时的&lt;code&gt;Provided by&lt;/code&gt;就已经变成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{file:/Users/freewind/workspace/sbt-scope-test/}sbt-scope-test/compile:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而不是&lt;code&gt;*:name&lt;/code&gt;了，说明它找到了更精确的key。&lt;/p&gt;
&lt;h2&gt;Defined at&lt;/h2&gt;
&lt;p&gt;接着是&lt;code&gt;Defined at&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Defined at:
[info]  /Users/freewind/workspace/sbt-scope-test/build.sbt:1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它很有用，直接告诉我们这个key是在哪个文件的哪一行定义的，很酷，方便我们去寻找定义。&lt;/p&gt;
&lt;h2&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;这个&lt;code&gt;Dependencies&lt;/code&gt;是说这个key依赖于别的哪些key。因为我们在例子中使用的&lt;code&gt;name&lt;/code&gt;并不依赖于别的key，所以没有显示该节。在这一节我将换个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val myname = settingKey[String](&quot;a setting of myname&quot;)

myname &amp;lt;&amp;lt;= name { n =&amp;gt; n + &quot;!!!&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们定义了一个&lt;code&gt;myname&lt;/code&gt;的key，它依赖于key &lt;code&gt;name&lt;/code&gt;的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; inspect myname
...
[info] Dependencies:
[info]  *:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会显示&lt;code&gt;Dependencies&lt;/code&gt;项，告诉我们这个key依赖另一个定义config scope为&lt;code&gt;global&lt;/code&gt;的名为&lt;code&gt;name&lt;/code&gt;的key.&lt;/p&gt;
&lt;h2&gt;Reverse dependencies&lt;/h2&gt;
&lt;p&gt;接下来是&lt;code&gt;inspect name&lt;/code&gt;中的&lt;code&gt;Reverse dependencies&lt;/code&gt;了。它表示其它哪些key依赖于本key:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Reverse dependencies:
[info]  *:onLoadMessage
[info]  *:description
[info]  *:normalizedName
[info]  *:projectInfo
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Delegates&lt;/h2&gt;
&lt;p&gt;前面说，当我们输入了一个key后，sbt会自动匹配跟它最接近的key。在匹配的过程中，是有一条由窄到宽的路径的，而&lt;code&gt;Delegates&lt;/code&gt;就是告诉我们这条路径究竟是什么样的。&lt;/p&gt;
&lt;p&gt;对于我们的例子&lt;code&gt;inspect name&lt;/code&gt;来说，它的&lt;code&gt;Delegates&lt;/code&gt;是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Delegates:
[info]  *:name
[info]  {.}/*:name
[info]  */*:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;name&lt;/code&gt;来说，它的&lt;strong&gt;由窄到宽&lt;/strong&gt;的路径是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name -&amp;gt; *:name -&amp;gt; {.}/*:name -&amp;gt; */*:name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;{.}/*:name&lt;/code&gt;中的&lt;code&gt;{.}/&lt;/code&gt;表示整个build(&lt;code&gt;ThisBuild&lt;/code&gt;)，&lt;code&gt;*/*:name&lt;/code&gt;中的&lt;code&gt;*/&lt;/code&gt;表示global project。我觉得它们两者之间很相似，但搜索顺序不同。&lt;/p&gt;
&lt;p&gt;晚点会专门写一篇文章来讲&lt;code&gt;ThisBuild&lt;/code&gt;和global project之间的区别，这里只要先知道它们的顺序就行了。&lt;/p&gt;
&lt;h2&gt;Related&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;inspect&lt;/code&gt;还有一个&lt;code&gt;Related&lt;/code&gt;，在&lt;code&gt;inspect name&lt;/code&gt;的例子中没有体现，这里换成&lt;code&gt;inspect compile:name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;首先是&lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val myname = settingKey[String](&quot;a setting of myname&quot;)

myname in Test := &quot;my-name-in-test&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; inspect compile:myname
[info] No entry for key.
[info] Description:
[info]  a setting of myname
[info] Delegates:
[info]  compile:myname
[info]  *:myname
[info]  {.}/compile:myname
[info]  {.}/*:myname
[info]  */compile:myname
[info]  */*:myname
[info] Related:
[info]  test:myname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，虽然它没有找到&lt;code&gt;compile:myname&lt;/code&gt;的值，但是它发现&lt;code&gt;myname&lt;/code&gt;在其它的scope中有值，便把它们显示在&lt;code&gt;Related&lt;/code&gt;里。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何创建一个简单的sbt插件</title>
                <link>http://freewind.in/posts/2778-how-to-create-a-simple-sbt-plugin</link>
                <pubDate>Sat, 13 Sep 2014 21:59:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2778</guid>
                <description><![CDATA[&lt;p&gt;经过几个小时的吐血，踩了无数的坑以后，终于成功的创建一个简单的sbt插件。其功能异常简单：使用该插件后，可以执行任务&lt;code&gt;hello&lt;/code&gt;，输出一段文字。&lt;/p&gt;
&lt;h2&gt;创建一个普通的sbt项目&lt;/h2&gt;
&lt;p&gt;一个sbt插件项目，首先是一个普通的sbt项目，只是有一些特殊的配置，以及需要继承一些特殊的类。&lt;/p&gt;
&lt;p&gt;可以使用下面的命令创建必要的目录和文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir my-sbt-plugin
cd my-sbt-plugin

touch build.sbt

mkdir project
touch project/build.properties

mkdir -p src/main/scala
touch src/main/scala/MyPlugin.scala
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后向&lt;code&gt;build.sbt&lt;/code&gt;中填入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;my-sbt-plugin&quot;

version := &quot;0.1.0&quot;

organization := &quot;test20140913&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这三个配置非常重要，因为插件发布以后，其它项目使用的时候，需要这样导入它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;addSbtPlugin(&quot;test20140913&quot; %% &quot;myplugin&quot; % &quot;0.1.0&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我使用了一个奇怪的organization名字&lt;code&gt;test20140913&lt;/code&gt;，是为了方便本地测试。因为在测试时，需要把这个包发布到本地，如果起一个正常的如&lt;code&gt;com.xxx&lt;/code&gt;的名字，到时候不好找。可以在调好以后再改名。&lt;/p&gt;
&lt;h2&gt;指定sbt版本&lt;/h2&gt;
&lt;p&gt;在sbt 0.13.5中，sbt提供了一种新的插件机制&lt;code&gt;AutoPlugin&lt;/code&gt;，可以让插件自动被sbt发现并载入，不再像以前那样必须在&lt;code&gt;build.sbt&lt;/code&gt;里添加一些初始化代码。&lt;/p&gt;
&lt;p&gt;我们的插件将使用这种方式，所以我们需要指定sbt版本。&lt;/p&gt;
&lt;p&gt;可以在&lt;code&gt;project/build.properties&lt;/code&gt;中填入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;sbt.version=0.13.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，直接在&lt;code&gt;build.sbt&lt;/code&gt;里添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;sbtVersion := 0.13.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;sbtPlugin := true&lt;/h2&gt;
&lt;p&gt;向&lt;code&gt;build.sbt&lt;/code&gt;中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;sbtPlugin := true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它将自动将sbt作为依赖添加到我们项目中，方便我们在代码中引用sbt中定义的类。&lt;/p&gt;
&lt;h2&gt;定义MySbtPlugin，继承AutoPlugin&lt;/h2&gt;
&lt;p&gt;我们需要创建一个继承自&lt;code&gt;AutoPlugin&lt;/code&gt;的&lt;code&gt;object&lt;/code&gt;，名字可以随便取，这里我使用&lt;code&gt;MySbtPlugin&lt;/code&gt;。它是插件的入口。&lt;/p&gt;
&lt;h3&gt;放在哪里&lt;/h3&gt;
&lt;p&gt;这个&lt;code&gt;MySbtPlugin.scala&lt;/code&gt;应该放在哪里呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以直接放在项目根目录下，如果比较简单的话&lt;/li&gt;
&lt;li&gt;放在&lt;code&gt;src/main/scala/&lt;/code&gt;下&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个位置都是sbt可以自动发现、编译和处理的。&lt;/p&gt;
&lt;p&gt;不能放在&lt;code&gt;project&lt;/code&gt;下，因为这里的scala文件都是为了配置sbt的构建命令而存在的，如果放在这里，它们不会被发布出去。&lt;/p&gt;
&lt;h3&gt;package&lt;/h3&gt;
&lt;p&gt;需要放在一个package下面吗？还是可以直接弄成顶层object?&lt;/p&gt;
&lt;p&gt;这里是一个坑，因为在&lt;code&gt;sbt 0.13.5&lt;/code&gt;中，必须放在某个包下面，否则会报下面的错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Compiling 2 Scala sources to /sbttest/my-sbt-plugin/project/target/scala-2.10/sbt-0.13/classes...
/sbttest/my-sbt-plugin/build.sbt:0: error: &apos;.&apos; expected but eof found.
import _root_.sbt.plugins.IvyPlugin, _root_.sbt.plugins.JvmPlugin, _root_.sbt.plugins.CorePlugin, _root_.sbt.plugins.JUnitXmlReportPlugin, MyPlugin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在&lt;code&gt;sbt 0.13.6&lt;/code&gt;中已经修复了。&lt;/p&gt;
&lt;p&gt;为了能在当前的主流版本&lt;code&gt;sbt 0.13.5&lt;/code&gt;中正常运行，我决定还是把它放在某个包下。&lt;/p&gt;
&lt;h3&gt;包名叫什么&lt;/h3&gt;
&lt;p&gt;随便什么包名都行，也不需要为这个包名专门创建一个目录。我打算使用当前的日期&lt;code&gt;test20140913&lt;/code&gt;作为包名，以后可以改个正常点的。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;最后，我在&lt;code&gt;src/main/scala/MySbtPlugin.scala&lt;/code&gt;中，写入以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package test20140913

import sbt._

object MySbtPlugin extends AutoPlugin {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到现在为止，一个什么也不能做的sbt plugin就完成了。前面提到的&lt;code&gt;hello&lt;/code&gt;的功能呢？我们晚点在后面实现。&lt;/p&gt;
&lt;p&gt;我们可以先把它发布到本地试试，看看效果。&lt;/p&gt;
&lt;h2&gt;发布&lt;/h2&gt;
&lt;p&gt;需要使用&lt;code&gt;sbt&lt;/code&gt;的&lt;code&gt;publicLocal&lt;/code&gt;命令，把它发布到本地。&lt;/p&gt;
&lt;h3&gt;更新sbt到0.13.5或以上&lt;/h3&gt;
&lt;p&gt;因为我们用到的&lt;code&gt;AutoPlugin&lt;/code&gt;功能比较新，所以先升级到最新的版本比较保险。&lt;/p&gt;
&lt;p&gt;首先看一下你本地安装的sbt版本是多少：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt --version
sbt launcher version 0.13.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果低于&lt;code&gt;0.13.5&lt;/code&gt;，需要升级一下。比如在mac下，可以使用&lt;code&gt;brew&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew update
brew upgrade sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当前它支持的最新版本是&lt;code&gt;0.13.5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sbt 0.13.6&lt;/code&gt;也发布了，应该很快能更新。&lt;/p&gt;
&lt;h3&gt;publishLocal&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cd my-sbt-plugin
$ sbt
&amp;gt; publishLocal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; publishLocal
[info] Packaging /sbttest/myplugin/target/scala-2.10/sbt-0.13/my-sbt-plugin-0.1.0-sources.jar ...
[info] Done packaging.
[info] Updating {file:/sbttest/myplugin/}myplugin...
[info] Wrote /sbttest/myplugin/target/scala-2.10/sbt-0.13/my-sbt-plugin-0.1.0.pom
[info] Resolving org.fusesource.jansi#jansi;1.4 ...
[info] Done updating.
[info] :: delivering :: test20140913#my-sbt-plugin;0.1.0 :: 0.1.0 :: release :: Sun Sep 14 12:09:04 CST 2014
[info]  delivering ivy file to /sbttest/myplugin/target/scala-2.10/sbt-0.13/ivy-0.1.0.xml
[info] Main Scala API documentation to /sbttest/myplugin/target/scala-2.10/sbt-0.13/api...
[info] Compiling 1 Scala source to /sbttest/myplugin/target/scala-2.10/sbt-0.13/classes...
model contains 4 documentable templates
[info] Main Scala API documentation successful.
[info] Packaging /sbttest/myplugin/target/scala-2.10/sbt-0.13/my-sbt-plugin-0.1.0-javadoc.jar ...
[info] Packaging /sbttest/myplugin/target/scala-2.10/sbt-0.13/my-sbt-plugin-0.1.0.jar ...
[info] Done packaging.
[info] Done packaging.
[info]  published my-sbt-plugin to /Users/freewind/.ivy2/local/test20140913/my-sbt-plugin/scala_2.10/sbt_0.13/0.1.0/poms/my-sbt-plugin.pom
[info]  published my-sbt-plugin to /Users/freewind/.ivy2/local/test20140913/my-sbt-plugin/scala_2.10/sbt_0.13/0.1.0/jars/my-sbt-plugin.jar
[info]  published my-sbt-plugin to /Users/freewind/.ivy2/local/test20140913/my-sbt-plugin/scala_2.10/sbt_0.13/0.1.0/srcs/my-sbt-plugin-sources.jar
[info]  published my-sbt-plugin to /Users/freewind/.ivy2/local/test20140913/my-sbt-plugin/scala_2.10/sbt_0.13/0.1.0/docs/my-sbt-plugin-javadoc.jar
[info]  published ivy to /Users/freewind/.ivy2/local/test20140913/my-sbt-plugin/scala_2.10/sbt_0.13/0.1.0/ivys/ivy.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，它顺利地把代码编译打包，并发布到了&lt;code&gt;/Users/freewind/.ivy2/local/test20140913&lt;/code&gt;目录下。&lt;/p&gt;
&lt;h3&gt;注意清空&lt;/h3&gt;
&lt;p&gt;如果我们修改了插件代码，最好在每次调用&lt;code&gt;publishLocal&lt;/code&gt;前先把&lt;code&gt;/Users/freewind/.ivy2/local/test20140913&lt;/code&gt;清空一下，不然会有警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[warn] Attempting to overwrite /Users/freewind/.ivy2/local/test20140913/my-sbt-plugin/scala_2.10/sbt_0.13/0.1.0/jars/my-sbt-plugin.jar
[warn]  This usage is deprecated and will be removed in sbt 1.0.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不清空，不知道会不会有奇怪的问题。&lt;/p&gt;
&lt;h2&gt;创建一个新项目使用该plugin&lt;/h2&gt;
&lt;p&gt;为了测试前面创建的plugin，我们新创建一个项目来使用它&lt;/p&gt;
&lt;h3&gt;创建新项目&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;mkdir my-project
cd my-project

touch build.sbt

mkdir project
touch project/plugins.sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;project/plugins.sbt&lt;/h3&gt;
&lt;p&gt;在这个文件中引入我们的插件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;addSbtPlugin(&quot;test20140913&quot; %% &quot;my-sbt-plugin&quot; % &quot;0.1.0&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;build.sbt&lt;/h3&gt;
&lt;p&gt;这里随便填入一些基本内容，比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name := &quot;test-my-sbt-plugin&quot;

version := &quot;0.1.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，由于我们在&lt;code&gt;MySbtPlugin&lt;/code&gt;中，缺少一些必要的设置，没有自动启用插件，所以我们还必须在&lt;code&gt;build.sbt&lt;/code&gt;中手动启用。等我们完善&lt;code&gt;MySbtPlugin&lt;/code&gt;以后，下面这句话就不需要了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val root = (project in file(&quot;.&quot;)).enablePlugins(test20140913.MySbtPlugin)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，我们在这里可以直接调用&lt;code&gt;test20140913.MySbtPlugin&lt;/code&gt;，是因为该插件已经导入，里面定义的对象对于sbt配置文件来说，已经可见。&lt;/p&gt;
&lt;h3&gt;运行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; plugins
In file:/sbttest/my-project/
    sbt.plugins.IvyPlugin: enabled in root
    sbt.plugins.JvmPlugin: enabled in root
    sbt.plugins.CorePlugin: enabled in root
    sbt.plugins.JUnitXmlReportPlugin: root
    test20140913.MySbtPlugin: enabled in root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前面几个是sbt内置的插件。最后一行，显示我们的插件已经启动成功了！&lt;/p&gt;
&lt;p&gt;虽然现在我们什么也做不了。&lt;/p&gt;
&lt;h2&gt;让我们的插件自动启用&lt;/h2&gt;
&lt;p&gt;前面说了，为了使用该插件，我们需要在另一个项目中做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;project/plugins.sbt中通过&lt;code&gt;addSbtPlugin&lt;/code&gt;引用该插件&lt;/li&gt;
&lt;li&gt;build.sbt中通过&lt;code&gt;enablePlugins&lt;/code&gt;启动该插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于一个继承自&lt;code&gt;AutoPlugin&lt;/code&gt;的插件来说，第二步实际上可以避免的。&lt;/p&gt;
&lt;h3&gt;在MySbtPlugin中设置trigger&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;MySbtPlugin.scala&lt;/code&gt;中，添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;override def trigger = allRequirements
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它覆盖了父类&lt;code&gt;AutoPlugin&lt;/code&gt;中的&lt;code&gt;trigger&lt;/code&gt;方法。它有两个值可用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;allRequirements&lt;/code&gt;： 当该插件依赖的其它插件满足之后，会自动启用该插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noTrigger&lt;/code&gt;: 必须在项目中手动启动该插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见第一个值就是我们需要的。（默认是第二个值）&lt;/p&gt;
&lt;h3&gt;重新发布&lt;/h3&gt;
&lt;p&gt;先清空&lt;code&gt;/Users/freewind/.ivy2/local/test20140913&lt;/code&gt;，再重新&lt;code&gt;publishLocal&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;删除my-project中build.sbt中的enablePlugins&lt;/h3&gt;
&lt;p&gt;删除&lt;code&gt;my-project/build.sbt&lt;/code&gt;中的这句代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val root = (project in file(&quot;.&quot;)).enablePlugins(test20140913.MySbtPlugin)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实留着也行，不过没有必要了。&lt;/p&gt;
&lt;h3&gt;重新运行&lt;/h3&gt;
&lt;p&gt;为了保险起见，先删除各&lt;code&gt;target&lt;/code&gt;目录。然后再&lt;code&gt;sbt plugins&lt;/code&gt;，可以看到&lt;code&gt;MySbtPlugin&lt;/code&gt;依然处于启用状态。&lt;/p&gt;
&lt;h2&gt;添加hello任务&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;MySbtPlugin&lt;/code&gt;中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;  lazy val hello = taskKey[Unit](&quot;hello task from my plugin&quot;)
  val helloSetting = hello := println(&quot;Hello from my plugin&quot;)

  override def projectSettings = Seq(
    helloSetting
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里实际上有两块内容，下面依次介绍&lt;/p&gt;
&lt;h3&gt;hello task&lt;/h3&gt;
&lt;p&gt;这两行代码定义了一个简单的&lt;code&gt;hello&lt;/code&gt;任务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val hello = taskKey[Unit](&quot;hello task from my plugin&quot;)
hello := println(&quot;Hello from my plugin&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前者定义了一个task key，第二行给它赋予了行为。只这么做还不够，因为它们对外不可见&lt;/p&gt;
&lt;h3&gt;添加到projectSettings中&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;  override def projectSettings = Seq(
    helloSetting
  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过override &lt;code&gt;projectSettings&lt;/code&gt;，我们把刚定义的&lt;code&gt;hello&lt;/code&gt;任务加了进去，这样引用该插件的项目，会自动把这里定义的&lt;code&gt;projectSettings&lt;/code&gt;信息合并过去，才能使用&lt;code&gt;hello&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;autoImport&lt;/h3&gt;
&lt;p&gt;还有一个名为&lt;code&gt;autoImport&lt;/code&gt;的特性，我们在这里没有用上。因为它很重要，所以一起介绍。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;MySbtPlugin&lt;/code&gt;的内容，我们可以定义一个名为&lt;code&gt;autoImport&lt;/code&gt;的&lt;code&gt;object&lt;/code&gt;（注意一定要是这个名字），它里面的代码将自动合并到目录项目中sbt配置中去。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object MySbtPlugin extends AutoPlugin {
  object autoImport {
    // here is some code will be merged to target project
    // You can consider you are writing something in `build.sbt` here
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;大功告成&lt;/h2&gt;
&lt;p&gt;再将&lt;code&gt;publishLocal&lt;/code&gt;，然后在&lt;code&gt;my-project&lt;/code&gt;中重新执行&lt;code&gt;sbt&lt;/code&gt;。注意各处的清理工作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; plugins
In file:/sbttest/my-project/
    sbt.plugins.IvyPlugin: enabled in my-project
    sbt.plugins.JvmPlugin: enabled in my-project
    sbt.plugins.CorePlugin: enabled in my-project
    sbt.plugins.JUnitXmlReportPlugin: my-project
    test20140913.MySbtPlugin: enabled in my-project
&amp;gt; hello
Hello from my plugin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，我们成功的调用了插件中定义的任务！直至大功告成！&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;可参考我的源代码：https://github.com/freewind/my-sbt-plugin&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt插件的基础知识</title>
                <link>http://freewind.in/posts/2777-basic-knowleage-of-sbt-plugins</link>
                <pubDate>Sat, 13 Sep 2014 21:52:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2777</guid>
                <description><![CDATA[&lt;h2&gt;查看当前启用了哪些plugins&lt;/h2&gt;
&lt;p&gt;在sbt 0.13.5版本，可以调用&lt;code&gt;plugins&lt;/code&gt;任务，查看当前项目启用了哪些插件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; plugins
In file:/private/tmp/sbttest/multi/
    sbt.plugins.IvyPlugin: enabled in multi
    sbt.plugins.JvmPlugin: enabled in multi
    sbt.plugins.CorePlugin: enabled in multi
    sbt.plugins.JUnitXmlReportPlugin: enabled in multi
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;CorePlugin: Provides the core parallelism controls for tasks&lt;/li&gt;
&lt;li&gt;IvyPlugin: Provides the mechanisms to publish/resolve modules.&lt;/li&gt;
&lt;li&gt;JvmPlugin: Provides the mechanisms to compile/test/run/package Java/Scala projects.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;/h2&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在build.sbt中调用其它scala中定义的值</title>
                <link>http://freewind.in/posts/2776-how-to-invoke-objects-defined-in-scala-files-in-build-sbt</link>
                <pubDate>Sat, 13 Sep 2014 17:18:13 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2776</guid>
                <description><![CDATA[&lt;p&gt;我们通常使用&lt;code&gt;build.sbt&lt;/code&gt;来配置一个sbt项目。由于&lt;code&gt;build.sbt&lt;/code&gt;使用了一些简单易读的格式，在带给我们方便的同时，有时候也不太方便定义一些东西。&lt;/p&gt;
&lt;p&gt;这时我们可以将&lt;code&gt;build.sbt&lt;/code&gt;和普通的scala代码结合起来，在scala文件中把东西都定义好，然后在&lt;code&gt;build.sbt&lt;/code&gt;直接调用即可。&lt;/p&gt;
&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;multi
├── build.sbt
└── project
    ├── aaa.scala
    └── bbb.scala
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;aaa.scala&lt;/h3&gt;
&lt;p&gt;这里定义了一个普通的scala文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object aaa {
   val name = &quot;The name from scala file&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;bbb.scala&lt;/h3&gt;
&lt;p&gt;同样普通&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object bbb {
    def hello = { println(&quot;method from scala file&quot;) }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;build.sbt&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := aaa.name

version := &quot;1.0&quot;

lazy val hello = taskKey[Unit](&quot;a hello task&quot;)

hello := bbb.hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到在这里，直接使用了&lt;code&gt;aaa&lt;/code&gt;和&lt;code&gt;bbb&lt;/code&gt;中定义的东西。&lt;/p&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
[info] Loading project definition from  /sbttest/multi/project
[info] Done updating.
[info] Compiling 2 Scala sources to  /sbttest/multi/project/target/scala-2.10/sbt-0.13/classes...
[info] Set current project to The name from scala file (in build file: /sbttest/multi/)
&amp;gt; name
[info] The name from scala file
&amp;gt; hello
method from scala file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，当执行&lt;code&gt;sbt&lt;/code&gt;命令的时候，它会自动编译&lt;code&gt;project&lt;/code&gt;目录下的两个scala文件&lt;code&gt;aaa.scala&lt;/code&gt;和&lt;code&gt;bbb.scala&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当执行&lt;code&gt;name&lt;/code&gt;时，它输出了在&lt;code&gt;aaa&lt;/code&gt;中定义的&lt;code&gt;name&lt;/code&gt;。当执行&lt;code&gt;hello&lt;/code&gt;的时候，它运行的也是&lt;code&gt;bbb&lt;/code&gt;中定义的方法。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在Build.scala中定义多个子项目</title>
                <link>http://freewind.in/posts/2775-define-multi-sub-projects-in-build-scala-in-sbt</link>
                <pubDate>Sat, 13 Sep 2014 17:02:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2775</guid>
                <description><![CDATA[&lt;p&gt;TODO: add link to another article&lt;/p&gt;
&lt;p&gt;在前面的文章里，我们通过&lt;code&gt;build.sbt&lt;/code&gt;定义了多个子项目，那么如何使用&lt;code&gt;Build.scala&lt;/code&gt;来完成同样的事情呢？&lt;/p&gt;
&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;multi
├── project
│   └── Build.scala
├── HelloMulti.scala
├── core
│   └── HelloCore.scala
└── util
    └── HelloUtil.scala
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中各&lt;code&gt;HelloXXX.scala&lt;/code&gt;的内容跟之前一样，这里只看&lt;code&gt;project/Build.scala&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Build.scala&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import sbt._
import sbt.Keys._

object MultiBuild extends Build {
  lazy val root = Project(
    id = &quot;root&quot;,
    base = file(&quot;.&quot;),
    settings = Project.defaultSettings ++ Seq(
      name := &quot;Root&quot;,
      organization := &quot;freewind&quot;,
      version := &quot;0.1.0&quot;,
      scalaVersion := &quot;2.11.0&quot;
      // other settings here
    )
  ).aggregate(util, core)

  lazy val util = project

  lazy val core = project.dependsOn(util)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，我们定义了三个项目，分别是&lt;code&gt;root&lt;/code&gt;, &lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;core&lt;/code&gt;依赖于&lt;code&gt;util&lt;/code&gt;，这意味着在&lt;code&gt;util&lt;/code&gt;中定义的类可以直接在&lt;code&gt;core&lt;/code&gt;项目中使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt;项目将&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;组合起来了，这表示在&lt;code&gt;root&lt;/code&gt;中执行某个任务时，会自动调用&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;中相应的任务。&lt;/p&gt;
&lt;p&gt;可以看到这里的定义跟之前在&lt;code&gt;build.sbt&lt;/code&gt;中的定义基本上是一致的，只是在这里可以完全按照scala的语法来写，来组织代码，更加灵活一些。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt多个子项目的build.sbt是如何处理的</title>
                <link>http://freewind.in/posts/2774-build-sbt-in-sub-projects-will-be-combined-to-root-project-in-sbt</link>
                <pubDate>Sat, 13 Sep 2014 16:50:55 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2774</guid>
                <description><![CDATA[&lt;p&gt;我们可以在一个sbt项目中定义多个子项目，通常每个子项目都有自己独立的目录。如果每个子项目都有自己的&lt;code&gt;build.sbt&lt;/code&gt;，它们是如何处理的呢？&lt;/p&gt;
&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;multi
├── build.sbt
├── core
│   └── build.sbt
└── util
    └── build.sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，我在&lt;code&gt;multi&lt;/code&gt;下，又定义了两个子目录&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;，并且每个下面还有一个&lt;code&gt;build.sbt&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;multi/build.sbt&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;multi&quot;

version := &quot;0.1.0&quot;

lazy val core = project

lazy val util = project
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;multi/core/build.sbt&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;core&quot;

version := &quot;0.2.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;multi/util/build.sbt&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;build&quot;

version := &quot;0.3.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; projects
[info] In file:/sbttest/multi/
[info]     core
[info]   * multi
[info]     util
&amp;gt; version
[info] util/*:version
[info]  0.3.0
[info] core/*:version
[info]  0.2.0
[info] multi/*:version
[info]  0.1.0
&amp;gt; name
[info] util/*:name
[info]  util
[info] core/*:name
[info]  core
[info] multi/*:name
[info]  multi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，两个子项目&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;中的&lt;code&gt;build.sbt&lt;/code&gt;中的内容，被合并到根项目&lt;code&gt;multi&lt;/code&gt;中了，所以在我们显示一个key的时候，它会把每个子项目中相应的key的值都打印出来。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用build.sbt配置多个子项目</title>
                <link>http://freewind.in/posts/2773-config-in-build-sbt-for-multi-sub-projects</link>
                <pubDate>Sat, 13 Sep 2014 15:44:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2773</guid>
                <description><![CDATA[&lt;p&gt;在这里将配置&lt;code&gt;build.sbt&lt;/code&gt;来支持多个项目&lt;/p&gt;
&lt;h2&gt;目录结构&lt;/h2&gt;
&lt;p&gt;我们的项目目录是&lt;code&gt;multi&lt;/code&gt;，然后在里面创建了两个子目录&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;，表示将有两个子项目。&lt;/p&gt;
&lt;p&gt;这样我们的项目中实际上有三个项目：&lt;code&gt;multi&lt;/code&gt;, &lt;code&gt;core&lt;/code&gt;, &lt;code&gt;util&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;为了方便演示，我分别在这三个项目的根目录下，各创建了一个会打出&lt;code&gt;Hello&lt;/code&gt;的scala程序。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;multi
├── build.sbt
├── HelloMulti.scala
├── core
│   └── HelloCore.scala
└── util
    └── HelloUtil.scala
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HelloMulti.scala&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object HelloMulti {
  def main(args: Array[String]) {
    println(&quot;Hello, multi!&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HelloCore.scala&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object HelloCore {
  def main(args: Array[String]) {
    println(&quot;Hello, core!&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HelloUtil.scala&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object HelloUtil {
  def main(args: Array[String]) {
    println(&quot;Hello, util!&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;build.sbt&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;Multi Demo&quot;

version := &quot;1.0&quot;

scalaVersion := &quot;2.11.0&quot;

sbtVersion := &quot;0.13.5&quot;

lazy val util = project

lazy val core = project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;project&lt;/code&gt;就可以声明一个新的子项目。在默认情况下，它会在项目根目录下寻找与变量名同名的目录，比如&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;h3&gt;projects&lt;/h3&gt;
&lt;p&gt;我们可以通过&lt;code&gt;projects&lt;/code&gt;任务，查看该项目有多少个子项目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; projects
[info] In file:/sbttest/multi/
[info]     core
[info]   * multi
[info]     util
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里列出了三个项目，其中有&lt;code&gt;*&lt;/code&gt;的表示“当前项目”。&lt;/p&gt;
&lt;h3&gt;project&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;project&lt;/code&gt;可以查看当前哪个项目被设为“当前项目”。有一些任务默认对当前任务起作用，比如&lt;code&gt;run&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; project
[info] multi (in build file:/sbttest/multi/)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;run&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; run
[info] Running HelloMulti
Hello, multi! 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;project newproject&lt;/h3&gt;
&lt;p&gt;通过给&lt;code&gt;project&lt;/code&gt;任务一个参数，改变“当前项目”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; project
[info] multi (in build file:/sbttest/multi/)
&amp;gt; project core
[info] Set current project to core (in build file:/sbttest/multi/)
&amp;gt; run
[info] Running HelloCore
Hello, core!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到已经更改了当前项目，并且在&lt;code&gt;run&lt;/code&gt;的时候，将会执行另一个scala文件&lt;/p&gt;
&lt;h2&gt;指定目录&lt;/h2&gt;
&lt;p&gt;在前面，如果我们没有指明项目目录，它会默认使用与变量名同名的目录，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val util = project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们想使用另一个目录，如&lt;code&gt;my-powerful-util&lt;/code&gt;来表示项目&lt;code&gt;util&lt;/code&gt;，可以写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val util = project in file(&quot;my-powerful-util&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，&lt;code&gt;util&lt;/code&gt;实际指向的就是&lt;code&gt;my-powerful-util&lt;/code&gt;目录了。&lt;/p&gt;
&lt;h2&gt;组合多个项目&lt;/h2&gt;
&lt;p&gt;上面定义的&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;项目之间，实际上是没有任何关系的。比如我想&lt;code&gt;compile&lt;/code&gt;这两个项目，就必须分别把这两个项目设为当前项目，再依次运行&lt;code&gt;compile&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们可以新建一个项目&lt;code&gt;root&lt;/code&gt;，把它们两个组合起来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val root = (project in  file(&quot;.&quot;)).aggregate(util, core)

lazy val util = project

lazy val core = project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于我们显式地给了根项目一个名字&lt;code&gt;root&lt;/code&gt;，原来以目录名命名的&lt;code&gt;multi&lt;/code&gt;就不见了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; projects
[info] In file:/sbttest/multi/
[info]     core
[info]   * root
[info]     util
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在&lt;code&gt;root&lt;/code&gt;下执行&lt;code&gt;compile&lt;/code&gt;，则会看到&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;也会跟着一起编译：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; clean
[success] Total time: 0 s, completed 2014-9-13 16:24:06
&amp;gt; compile
[info] Updating {file: /sbttest/multi/}root...
[info] Updating {file: /sbttest/multi/}core...
[info] Updating {file: /sbttest/multi/}util...
[info] Resolving jline#jline;2.11 ...
[info] Done updating.
[info] Resolving org.scala-lang#scala-library;2.10.2 ...
[info] Compiling 1 Scala source to  /sbttest/multi/target/scala-2.11/classes...
[info] Resolving org.fusesource.jansi#jansi;1.4 ...
[info] Done updating.
[info] Resolving org.scala-lang#scala-library;2.10.2 ...
[info] Compiling 1 Scala source to  /sbttest/multi/util/target/scala-2.10/classes...
[info] Resolving org.fusesource.jansi#jansi;1.4 ...
[info] Done updating.
[info] Compiling 1 Scala source to  /sbttest/multi/core/target/scala-2.10/classes...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;顺序&lt;/h3&gt;
&lt;p&gt;会在多个子项目中并行执行，并且顺序不确定&lt;/p&gt;
&lt;h3&gt;指定不同时执行的任务&lt;/h3&gt;
&lt;p&gt;在组合项目时，我们还可以指定哪些任务不会被同时执行到子项目中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val root = (project in  file(&quot;.&quot;)).aggregate(util, core)
   .settings(
     aggregate in compile := false
   )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，再执行&lt;code&gt;compile&lt;/code&gt;任务，它就不会被应用到&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; clean
[success] Total time: 0 s, completed 2014-9-13 16:27:29
&amp;gt; compile
[info] Updating {file: /sbttest/multi/}root...
[info] Resolving jline#jline;2.11 ...
[info] Done updating.
[info] Compiling 1 Scala source to  /sbttest/multi/target/scala-2.11/classes...
[success] Total time: 0 s, completed 2014-9-13 16:27:32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，只有&lt;code&gt;root&lt;/code&gt;项目中的scala文件被编译了。&lt;/p&gt;
&lt;h2&gt;依赖于其它项目&lt;/h2&gt;
&lt;p&gt;除了上面的组合，我们还可以让一个项目依赖于另一个项目，这样就可以在这个项目中使用另一个项目中定义的类。&lt;/p&gt;
&lt;p&gt;比如，我们让&lt;code&gt;core&lt;/code&gt;依赖于&lt;code&gt;util&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val util = project

lazy val core = project.dependsOn(util)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;.dependsOn&lt;/code&gt;，我们让&lt;code&gt;core&lt;/code&gt;项目依赖于&lt;code&gt;util&lt;/code&gt;项目，这样我们就可以在&lt;code&gt;core&lt;/code&gt;中使用&lt;code&gt;util&lt;/code&gt;中定义的类了。&lt;/p&gt;
&lt;p&gt;如果我在&lt;code&gt;core&lt;/code&gt;中执行&lt;code&gt;compile&lt;/code&gt;任务，它会自动先到&lt;code&gt;util&lt;/code&gt;中执行&lt;code&gt;compile&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;依赖多个项目&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val mypro = project.dependsOn(core, util)
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Hello world in scala</title>
                <link>http://freewind.in/posts/2772-hello-world-in-scala</link>
                <pubDate>Sat, 13 Sep 2014 15:34:44 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2772</guid>
                <description><![CDATA[&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Hello extends App {
  println(&quot;Hello, world!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Hello {
  def main(args: Array[String]) {
    println(&quot;Hello, world!&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt中build.sbt和Build.scala配合使用</title>
                <link>http://freewind.in/posts/2771-use-build-sbt-and-build-scala-in-one-sbt-project</link>
                <pubDate>Sat, 13 Sep 2014 14:06:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2771</guid>
                <description><![CDATA[&lt;p&gt;在一个sbt项目中，可以同时存在&lt;code&gt;build.sbt&lt;/code&gt;和&lt;code&gt;project/Build.scala&lt;/code&gt;。通常建议尽量使用&lt;code&gt;build.sbt&lt;/code&gt;来定义主要的配置，而在&lt;code&gt;Build.scala&lt;/code&gt;中放置一些供同一个项目中的多个子项目共享的代码。&lt;/p&gt;
&lt;p&gt;另外:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;build.sbt&lt;/code&gt;可以读取&lt;code&gt;Build.scala&lt;/code&gt;中定义的key，反之不可以。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build.sbt&lt;/code&gt;中定义的key优先级高，它会覆盖&lt;code&gt;Build.scala&lt;/code&gt;中定义的同名key&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;project/Build.scala&lt;/h2&gt;
&lt;p&gt;在项目中创建&lt;code&gt;project/Build.scala&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import sbt._
import sbt.Keys._

object DemoBuild extends Build {

  lazy val keyFromScala = settingKey[String](&quot;a key from Build.scala&quot;)

  lazy val demo = Project(
    id = &quot;demo&quot;,
    base = file(&quot;.&quot;),
    settings = Project.defaultSettings ++ Seq(
      name := &quot;Demo&quot;,
      keyFromScala := &quot;Value from Build.scala&quot;
    )
  )
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到它给&lt;code&gt;name&lt;/code&gt;这个预定义的key赋值为&lt;code&gt;Demo&lt;/code&gt;，并且还自定义了一个key &lt;code&gt;keyFromScala&lt;/code&gt;，其值为&lt;code&gt;Value from Build.scala&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;运行&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sbt
&amp;gt; name
[info] Demo
&amp;gt; keyFromScala
[info] Value from Build.scala
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到两者都起作用了&lt;/p&gt;
&lt;h2&gt;build.sbt&lt;/h2&gt;
&lt;p&gt;然后我们在项目下创建一个&lt;code&gt;build.sbt&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;hello&quot;

version := &quot;1.0&quot;

scalaVersion := &quot;2.11.0&quot;

val mykey = settingKey[String](&quot;Key from build.sbt&quot;)

mykey &amp;lt;&amp;lt;= keyFromScala { a =&amp;gt; a + &quot; ==&amp;gt; now in build.sbt&quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运行&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sbt
&amp;gt; name
[info] hello
&amp;gt; mykey
[info] Value from Build.scala ==&amp;gt; now in build.sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;name&lt;/code&gt;的值现在已经变成&lt;code&gt;build.sbt&lt;/code&gt;中定义的&lt;code&gt;hello&lt;/code&gt;了，而&lt;code&gt;mykey&lt;/code&gt;的值，也成功的引用了&lt;code&gt;Build.scala&lt;/code&gt;中定义的&lt;code&gt;keyFromScala&lt;/code&gt;的值。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt中如何创建一个最简单的Build.scala</title>
                <link>http://freewind.in/posts/2770-create-a-simplest-build-scala-in-sbt</link>
                <pubDate>Sat, 13 Sep 2014 13:55:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2770</guid>
                <description><![CDATA[&lt;p&gt;对于简单的sbt项目，我们通常会在项目目录下创建一个&lt;code&gt;build.sbt&lt;/code&gt;，使用简化的格式来配置sbt项目。&lt;/p&gt;
&lt;p&gt;对于复杂一些的项目，我们还可以通过&lt;code&gt;project/Buils.scala&lt;/code&gt;来配置。在这个文件中，我们将使用真正的scala代码。&lt;/p&gt;
&lt;p&gt;这里是一个最简单的&lt;code&gt;Build.scala&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;project/Build.scala&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import sbt._
import sbt.Keys._

object DemoBuild extends Build {
  lazy val demo = Project(
    id = &quot;demo&quot;,
    base = file(&quot;.&quot;),
    settings = Project.defaultSettings ++ Seq(
      name := &quot;Demo&quot;,
      organization := &quot;freewind&quot;,
      version := &quot;0.1-SNAPSHOT&quot;,
      scalaVersion := &quot;2.11.0&quot;
      // other settings here
    )
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;执行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sbt
&amp;gt; name
[info] Demo
&amp;gt; organization
[info] freewind
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;不一定叫&lt;code&gt;Build.scala&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;这个文件名不一定要叫做&lt;code&gt;Build.scala&lt;/code&gt;，也可以改成别的名字，比如&lt;code&gt;bbb.scala&lt;/code&gt;，只要它还位于&lt;code&gt;project&lt;/code&gt;目录下，执行效果是一样的。&lt;/p&gt;
&lt;p&gt;不过人们通常都使用&lt;code&gt;Build.scala&lt;/code&gt;方便交流。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt的resolvers</title>
                <link>http://freewind.in/posts/2769-sbt-resolvers</link>
                <pubDate>Sat, 13 Sep 2014 13:53:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2769</guid>
                <description><![CDATA[&lt;pre&gt;&lt;code&gt;resolvers += &quot;Local Maven Repository&quot; at &quot;file://&quot;+Path.userHome.
   absolutePath+&quot;/.m2/repository&quot;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在sbt中声明依赖时同时下载源代码</title>
                <link>http://freewind.in/posts/2768-download-source-jar-when-declaring-dependency-in-sbt</link>
                <pubDate>Sat, 13 Sep 2014 13:44:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2768</guid>
                <description><![CDATA[&lt;p&gt;在&lt;code&gt;build.sbt&lt;/code&gt;中声明依赖的时候：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;libraryDependencies +=
     &quot;org.apache.felix&quot; % &quot;org.apache.felix.framework&quot; % &quot;1.8.0&quot;
   withSources() withJavadoc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;withSources()&lt;/code&gt;是说要下载源代码jar，&lt;code&gt;withJavadoc()&lt;/code&gt;是说要下载文档jar。&lt;/p&gt;
&lt;p&gt;可根据需要选择。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在sbt中使用一个不在maven库中的jar作为依赖</title>
                <link>http://freewind.in/posts/2779-use-a-jar-not-inside-a-maven-repo-as-dependency-in-sbt</link>
                <pubDate>Sat, 13 Sep 2014 13:40:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2779</guid>
                <description><![CDATA[&lt;p&gt;只上代码不解释：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;libraryDependencies += &quot;slinky&quot; % &quot;slinky&quot; % &quot;2.1&quot; from &quot;http://
   slinky2.googlecode.com/svn/artifacts/2.1/slinky.jar&quot;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>理解sbt的scopes</title>
                <link>http://freewind.in/posts/2767-understand-sbt-scopes</link>
                <pubDate>Sat, 13 Sep 2014 13:11:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2767</guid>
                <description><![CDATA[&lt;p&gt;这是sbt中比较难以理解的一部分，但是很重要，如果不能理解key与scope和value之间的关系，会遇到各种各样的障碍。&lt;/p&gt;
&lt;h2&gt;key与value&lt;/h2&gt;
&lt;p&gt;在sbt中，它已经预定义了各种各样的key，比如:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt; settings &lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name
version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt; tasks &lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile
test
run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们也可以自己定义一些key，比如在&lt;code&gt;build.sbt&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lazy val myname = settingKey[String](&quot;myname setting&quot;)

lazy val hello = taskKey[String](&quot;a hello task&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以给这些key赋值，比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;sbt-scope-test&quot;

version := &quot;1.0.0&quot;

hello := println(&quot;Hello world&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种做法我们经常用到。&lt;/p&gt;
&lt;p&gt;看起来每个key似乎都是和一个值相对应的。其实不是的。&lt;/p&gt;
&lt;h2&gt;scope&lt;/h2&gt;
&lt;p&gt;一个key实际上是可以跟多个value对应的，它们之间是一对多的关系。这是因为每个key的背后，实际上存在着多个不同维度的scope，一个key跟相应的scope一起，才能和一个value一一对应。&lt;/p&gt;
&lt;p&gt;目前有三种scope，分别是&lt;code&gt;project&lt;/code&gt;, &lt;code&gt;config&lt;/code&gt;, &lt;code&gt;task&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设我们有一个名为&lt;code&gt;keys&lt;/code&gt;的map，用来保存key与value的值。当我们给一个key赋值时，它并不是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keys(&quot;mykey&quot;) = &quot;some-value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keys(&quot;mykey&quot;, project, config, task) = &quot;some-value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;key名&lt;/code&gt;与&lt;code&gt;project&lt;/code&gt;、&lt;code&gt;config&lt;/code&gt;和&lt;code&gt;task&lt;/code&gt;这四个列合在一起才能加个“唯一索引”，才能跟某个值一一对应。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;project&lt;/code&gt;、&lt;code&gt;config&lt;/code&gt;和&lt;code&gt;task&lt;/code&gt;都有默认值，所以我们有时候才能简写为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mykey := &quot;some-value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为它实际上对应的是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keys(&quot;mykey&quot;, &quot;self-project&quot;, &quot;global-config&quot;, &quot;global-task&quot;) = &quot;some-value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;self-project&lt;/strong&gt;: 包含这个key定义的&lt;code&gt;build.sbt&lt;/code&gt;或者&lt;code&gt;Build.scala&lt;/code&gt;所在的项目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;global-config&lt;/strong&gt;: 可匹配任意一个config&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;global-task&lt;/strong&gt;: 可匹配任意一个task&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于&lt;code&gt;project&lt;/code&gt;、&lt;code&gt;config&lt;/code&gt;和&lt;code&gt;task&lt;/code&gt;的意思，将在下面说明。&lt;/p&gt;
&lt;h2&gt;project&lt;/h2&gt;
&lt;p&gt;在sbt项目中，我们可以简单的不定义额外项目，也可以定义多个子项目。每个项目都是一个project，可在给key赋值的时候引用。&lt;/p&gt;
&lt;p&gt;按project给同一个key赋不同的值，这种需求是很常见的。比如对于key &lt;code&gt;name&lt;/code&gt;是用来表示项目名的，它在不同的项目中，当然要有不同的值。&lt;/p&gt;
&lt;h3&gt;如果没有定义额外项目&lt;/h3&gt;
&lt;p&gt;如果我们没有定义额外项目，那我们就已经有了一个项目。比如当前项目是&lt;code&gt;sbt-scope-test&lt;/code&gt;，它的&lt;code&gt;build.sbt&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;myproject&quot;

version := &quot;1.0.0&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过&lt;code&gt;projects&lt;/code&gt;命令查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; projects
[info] In file:/Users/freewind/workspace/sbt-scope-test/
[info]   * sbt-scope-test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，它包含了唯一的一个项目，以目录名为项目名。&lt;/p&gt;
&lt;h3&gt;显示定义项目&lt;/h3&gt;
&lt;p&gt;我们可以给这个唯一的项目一个名字，这样可以对它进行一些操作（如&lt;code&gt;enablePlugins&lt;/code&gt;)等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;sbt-scope-test&quot;

version := &quot;1.0.0&quot;

lazy val root = project in file(&quot;.&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再查看一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; projects
[info] In file:/Users/freewind/workspace/sbt-scope-test/
[info]   * root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到还是一个项目，但是名字变了。&lt;/p&gt;
&lt;h3&gt;定义多个项目&lt;/h3&gt;
&lt;p&gt;我们还可以使用同样的语法定义多个项目：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;sbt-scope-test&quot;

version := &quot;1.0.0&quot;

lazy val root = project in file(&quot;.&quot;)

lazy val core = project

lazy val util = project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样又定义了两个额外的项目&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;，它们将以目录&lt;code&gt;myproject/core&lt;/code&gt;和&lt;code&gt;myproject/util&lt;/code&gt;作为它们的主目录。&lt;/p&gt;
&lt;p&gt;查看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;$ sbt
&amp;gt; projects
[info] In file:/Users/freewind/workspace/myproject/
[info]     core
[info]   * root
[info]     util
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到现在有了三个project，当前选定的project是&lt;code&gt;root&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;针对不同project赋值&lt;/h3&gt;
&lt;p&gt;我们可以针对不同的project，给同一个key赋不同的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val myname = settingKey[String](&quot;setting of myname&quot;)

myname in root := &quot;my-root-name&quot;

myname in util := &quot;my-util-name&quot;

myname in core := &quot;my-core-name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，我在不同的project中，给同一个key &lt;code&gt;myname&lt;/code&gt;设置了不同的值。&lt;/p&gt;
&lt;p&gt;查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; project
[info] root (in build file:/Users/freewind/workspace/sbt-scope-test/)
&amp;gt; myname
[info] my-root-name
&amp;gt;
&amp;gt; project core
[info] Set current project to core (in build file:/Users/freewind/workspace/sbt-scope-test/)
&amp;gt; myname
[info] my-core-name
&amp;gt;
&amp;gt; project util
[info] Set current project to util (in build file:/Users/freewind/workspace/sbt-scope-test/)
&amp;gt; myname
[info] my-util-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，当我使用&lt;code&gt;project&lt;/code&gt;命令切换到不同的project后，显示&lt;code&gt;myname&lt;/code&gt;的值会不同。&lt;/p&gt;
&lt;p&gt;再次提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myname in root := &quot;my-root-name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它实际上相当于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keys(&quot;myname&quot;, &quot;root&quot;, global-config, global-task) = &quot;my-root-name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;config&lt;/h2&gt;
&lt;p&gt;config实际上可以看作一些资源的集合。比如sbt提供了&lt;code&gt;compile&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;和&lt;code&gt;runtime&lt;/code&gt;这几个config，它们包含的文件路径是不一样的。&lt;/p&gt;
&lt;h3&gt;如何定义config&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val myconf1 = config(&quot;myconf1&quot;)

lazy val myconf2 = config(&quot;myconf2&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sbt提供的&lt;code&gt;compile&lt;/code&gt;、&lt;code&gt;test&lt;/code&gt;和&lt;code&gt;runtime&lt;/code&gt;等，也是同样的方式定义的，参看sbt的&lt;code&gt;Configuration.scala&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val Default = config(&quot;default&quot;)
lazy val Compile = config(&quot;compile&quot;)
lazy val IntegrationTest = config(&quot;it&quot;) extend(Runtime)
lazy val Provided = config(&quot;provided&quot;) ;
lazy val Docs = config(&quot;docs&quot;)
lazy val Runtime = config(&quot;runtime&quot;) extend(Compile)
lazy val Test = config(&quot;test&quot;) extend(Runtime)
lazy val Sources = config(&quot;sources&quot;)
lazy val System = config(&quot;system&quot;)
lazy val Optional = config(&quot;optional&quot;)
lazy val Pom = config(&quot;pom&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;赋值时指定config&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;myname in myconf1 := &quot;my-conf1-name&quot;

myname in myconf2 := &quot;my-conf2-name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; myconf1:myname
[info] my-conf1-name
&amp;gt; myconf2:mynname
[info] my-conf2-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，需要通过&lt;code&gt;config:key&lt;/code&gt;的方式来指定显示哪个config下的key。&lt;/p&gt;
&lt;p&gt;注意：两者之间是以&lt;code&gt;:&lt;/code&gt;分隔的，这种写法是固定的。也就是说，每当你看到形如&lt;code&gt;a:b&lt;/code&gt;的名称时，你就可以推断&lt;code&gt;a&lt;/code&gt;是一个config，&lt;code&gt;b&lt;/code&gt;是一个key或者task&lt;/p&gt;
&lt;p&gt;(后面还会介绍由&lt;code&gt;::&lt;/code&gt;分隔的写法，代表不同的意思)&lt;/p&gt;
&lt;h2&gt;task&lt;/h2&gt;
&lt;p&gt;task就是我们可以执行的一些操作，比如&lt;code&gt;compile&lt;/code&gt;,&lt;code&gt;test&lt;/code&gt;,&lt;code&gt;run&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;因为同一个key（比如一个设置）在不同的task中，可能有不同的值，所以在给key赋值时，也可以考虑按task来分。&lt;/p&gt;
&lt;h3&gt;定义一个task&lt;/h3&gt;
&lt;p&gt;我们可以通过下面的方式定义一个task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val hello = taskKey[Unit](&quot;a hello task&quot;)

hello := println(&quot;Hello, world&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; hello
Hello, world
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;按task给key赋值&lt;/h3&gt;
&lt;p&gt;假设我定义了两个task和一个key，并且这两个task都依赖于这个key:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val myname = settingKey[String](&quot;my name&quot;)

lazy val upper = taskKey[Unit](&quot;print upper name&quot;)

lazy val lower = taskKey[Unit](&quot;print lower name&quot;)

upper &amp;lt;&amp;lt;= (myname in upper) map { n =&amp;gt; println(&quot;Hello, &quot; + n.toUpperCase) }

lower &amp;lt;&amp;lt;= (myname in lower) map { n =&amp;gt; println(&quot;Hello, &quot; + n.toLowerCase) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;upper&lt;/code&gt;将打印出&lt;code&gt;myname&lt;/code&gt;的大写，而&lt;code&gt;lower&lt;/code&gt;打印出小写。在上面的代码中，我们还没有给&lt;code&gt;myname&lt;/code&gt;赋值，但是&lt;code&gt;myname&lt;/code&gt;作为一个占位符，是可以使用的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;myname in upper := &quot;Jeff&quot;

myname in lower := &quot;Lily&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;运行&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; upper
Hello, JEFF
&amp;gt; lower
Hello, lily
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看myname&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; upper::myname
[info] Jeff
&amp;gt; lower::myname
[info] Lily
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意其格式为&lt;code&gt;task::key&lt;/code&gt;，即两者之间是用&lt;code&gt;::&lt;/code&gt;分隔的。这种格式是固定的，每当我们看到形如&lt;code&gt;a::b&lt;/code&gt;的命名时，我们就可以推断出&lt;code&gt;a&lt;/code&gt;是一个task（或者也是一个key），而&lt;code&gt;b&lt;/code&gt;是另一个key（或者task)&lt;/p&gt;
&lt;p&gt;如果和前面的config结合起来，其格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;config:task::key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意第一个分隔符是&lt;code&gt;:&lt;/code&gt;，第二个是&lt;code&gt;::&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;global是安全网&lt;/h2&gt;
&lt;p&gt;在我们给一个key赋值时，如果我们显式指定了某一个&lt;code&gt;config&lt;/code&gt;或者&lt;code&gt;task&lt;/code&gt;的时候，它会跟相应的config和task绑定起来。如果没有指定，则会采用默认值&lt;code&gt;Global&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然，我们也可以显式指定为&lt;code&gt;Global&lt;/code&gt;，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myname in Global := &quot;Global name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其等价于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myname := &quot;Global name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;如果找到了指定的config&lt;/h3&gt;
&lt;p&gt;假设我指定了某个config:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;myname in myconf1 := &quot;my name in conf1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我查看&lt;code&gt;myconf1:myname&lt;/code&gt;时：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; myconf1:myname
[info] my name in conf1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会显示出正确的值。&lt;/p&gt;
&lt;h3&gt;如果找不到指定的config，会找global&lt;/h3&gt;
&lt;p&gt;但如果我没有上面的&lt;code&gt;myname in myconf1 := ...&lt;/code&gt;的定义，它则会找到&lt;code&gt;global:myname&lt;/code&gt;，打印出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Global name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由此可见，我们可以把Global当作安全网，定义一些比较通用的默认值。这样，当我们执行与某个config特定的任务但又找不到相应的值的时候，还可以用global的值来顶一下。&lt;/p&gt;
&lt;h2&gt;ThisBuild&lt;/h2&gt;
&lt;p&gt;还可以指定一个key的scope是整个build，它不属于某一个特定的project。&lt;/p&gt;
&lt;p&gt;首先看一个普通的&lt;code&gt;build.sbt&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val root = project in file(&quot;.&quot;)

lazy val util = project

lazy val core = project

lazy val myname = settingKey[String](&quot;a setting of myname&quot;)

myname := &quot;Freewind&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;myname&lt;/code&gt;的值&lt;code&gt;Freewind&lt;/code&gt;属于哪个project呢？属于它所在的project，即&lt;code&gt;root&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们在&lt;code&gt;core&lt;/code&gt;和&lt;code&gt;util&lt;/code&gt;这两个project是，是没法使用它的。&lt;/p&gt;
&lt;p&gt;来个&lt;code&gt;ThisBuild&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;myname in ThisBuild := &quot;Freewind&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时&lt;code&gt;myname&lt;/code&gt;的值&lt;code&gt;Freewind&lt;/code&gt;就不再属于某一个project了，我们可以在任何一个project中使用它&lt;/p&gt;
&lt;h4&gt;ThisBuild和global project&lt;/h4&gt;
&lt;p&gt;这两者很相似，会另写一篇文章介绍。&lt;/p&gt;
&lt;h2&gt;key的完整形式&lt;/h2&gt;
&lt;p&gt;根据前面的说明，一个key实际上要跟&lt;code&gt;project&lt;/code&gt;,&lt;code&gt;config&lt;/code&gt;,&lt;code&gt;task&lt;/code&gt;等绑定在一起的。那么我们需要制定一个格式，即可以让我们精确指定，又可以在显示时准确显示。&lt;/p&gt;
&lt;p&gt;它的格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;lt;build-uri&amp;gt;}&amp;lt;project-id&amp;gt;/config:inkey::key
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;举个例子&lt;/h3&gt;
&lt;p&gt;来一个完整的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val root = project in file(&quot;.&quot;)

lazy val myconf = config(&quot;myconf&quot;)

lazy val hello = taskKey[Unit](&quot;hello task&quot;)

lazy val myname = settingKey[String](&quot;a setting of myname&quot;)

myname in(root, myconf, hello) := &quot;my complete name&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于这个&lt;code&gt;myname&lt;/code&gt;，我们要想引用它，必须写成下面的形式，否则找不到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root/myconf:hello::myname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;inspect&lt;/code&gt;一下看看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; inspect root/myconf:hello::myname
[info] Setting: java.lang.String = my complete name
[info] Description:
[info]  a setting of myname
[info] Provided by:
[info]  {file:/Users/freewind/workspace/sbt-scope-test/}root/myconf:hello::myname
[info] Defined at:
[info]  /Users/freewind/workspace/sbt-scope-test/build.sbt:20
[info] Delegates:
[info]  root/myconf:hello::myname
[info]  root/myconf:myname
[info]  root/*:hello::myname
[info]  root/*:myname
[info]  {.}/myconf:hello::myname
[info]  {.}/myconf:myname
[info]  {.}/*:hello::myname
[info]  {.}/*:myname
[info]  */myconf:hello::myname
[info]  */myconf:myname
[info]  */*:hello::myname
[info]  */*:myname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(如果当前正处于&lt;code&gt;root&lt;/code&gt; project，则也可以写成：&lt;code&gt;inspect myconf:hello::myname&lt;/code&gt;，省掉前面的项目名)&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;Provided by:&lt;/code&gt;一节，可以看到它的完整形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{file:/Users/freewind/workspace/sbt-scope-test/}root/myconf:hello::myname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比前面的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;lt;build-uri&amp;gt;}&amp;lt;project-id&amp;gt;/config:inkey::key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;{&amp;lt;build-uri&amp;gt;}&lt;/code&gt;: 项目&lt;code&gt;root&lt;/code&gt;所在的目录&lt;code&gt;{file:/Users/freewind/workspace/sbt-scope-test/}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;project-id&amp;gt;&lt;/code&gt;: 该key所属的项目名&lt;code&gt;root&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config&lt;/code&gt;: 该key所属的config &lt;code&gt;myconf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inkey&lt;/code&gt;: 该key所属的task &lt;code&gt;hello&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt;: 该key的名称&lt;code&gt;myname&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果某一项是&lt;code&gt;global&lt;/code&gt;或者没有指定，则会写成&lt;code&gt;*&lt;/code&gt;，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root/*:myname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是属于整个build，即&lt;code&gt;ThisBuild&lt;/code&gt;，则相应处格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{.}/*:myname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这些表示key和scope的格式在我们&lt;code&gt;inspect&lt;/code&gt;某个key时非常常见，我们一定要记住。&lt;/p&gt;
&lt;p&gt;关于如何读懂&lt;code&gt;inspect&lt;/code&gt;的结果，将会写在另一篇博客里。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在build.sbt中执行一段初始化代码</title>
                <link>http://freewind.in/posts/2766-run-initailization-code-in-build-sbt</link>
                <pubDate>Sat, 13 Sep 2014 12:42:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2766</guid>
                <description><![CDATA[&lt;p&gt;在&lt;code&gt;build.sbt&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;initialize := {
  // your initialization code, e.g.
  System.setProperty(&quot;database.user&quot;, &quot;user1&quot;)
  System.setProperty(&quot;database.schema.name&quot;, &quot;db1&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是追加，则使用&lt;code&gt;~=&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;initialize ~= { _ =&amp;gt;
  // your other initialization code, e.g.
  System.setProperty(&quot;other&quot;, &quot;values&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它不会覆盖前面定义的初始化代码。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>build.sbt中有哪些操作符可用</title>
                <link>http://freewind.in/posts/2765-the-operators-for-keys-in-build-sbt</link>
                <pubDate>Sat, 13 Sep 2014 00:02:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2765</guid>
                <description><![CDATA[&lt;h2&gt;&lt;code&gt;:=&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;给一个Key设置为一个新值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name := &quot;Hello&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;给一个&lt;code&gt;Seq&lt;/code&gt;类型的key追加一个值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;libraryDependencies += &quot;org.apache.commons&quot; % &quot;commons-lang3&quot; % &quot;3.3.2&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;code&gt;++=&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;给一个&lt;code&gt;Seq&lt;/code&gt;类型的key追加多个值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;libraryDependencies += Seq(
    &quot;org.apache.commons&quot; % &quot;commons-lang3&quot; % &quot;3.3.2&quot;,
    &quot;org.scalaz&quot; %% &quot;scalaz-core&quot; % &quot;7.1.0&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;code&gt;~=&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在key已有的值的基础上，修改为一个新值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name ~= { n =&amp;gt; n + &quot;!!!&quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在一个key中使用另一个key的值&lt;/p&gt;
&lt;h3&gt;使用原值&lt;/h3&gt;
&lt;p&gt;假设已经定义了一个key:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;Hello&quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在想在另一个key中直接使用它的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;anotherKey &amp;lt;&amp;lt;= name
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用旧值&lt;/h3&gt;
&lt;p&gt;如果想在另一个值的基础上生成一个新值，可以：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;anotherKey &amp;lt;&amp;lt;= name { n =&amp;gt; n + &quot;!!!&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;同时使用多个值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;anotherKey2 &amp;lt;&amp;lt;= (name, anotherKey) { (n,a) =&amp;gt; n + a }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;？&lt;/h2&gt;
&lt;p&gt;可用来判断一个key是否有值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val unintiedKey = settingKey[String](&quot;Unitialized key&quot;)

lazy val someKey = settingKey[String](&quot;Key to check the value of another&quot;)

someKey := unintiedKey.?.value getOrElse &quot;new value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时&lt;code&gt;someKey&lt;/code&gt;的值是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果已经给&lt;code&gt;unintiedKey&lt;/code&gt;赋了值，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;unintiedKey := &quot;Another value&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么&lt;code&gt;someKey&lt;/code&gt;的值将会是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Another value
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;??&lt;/h2&gt;
&lt;p&gt;跟&lt;code&gt;?&lt;/code&gt;有一点相似：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;lazy val unintiedKey = settingKey[String](&quot;Unitialized key&quot;)

lazy val someKey = settingKey[String](&quot;Key to check the value of another&quot;)

someKey := (unintiedKey ?? &quot;uninitedKey had no value&quot;).value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则&lt;code&gt;someKey&lt;/code&gt;的值是:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;uninitedKey had no value
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;more&lt;/h2&gt;
&lt;p&gt;从文档上看到还有这一些奇怪的操作符，不知道有什么用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;++=
&amp;lt;+=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过万能的stackoverflow告诉我，自从sbt 0.13有了&lt;code&gt;.value&lt;/code&gt;以后，就再也不需要它们了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/25819886/where-are-examples-of-in-build-sbt&quot;&gt;http://stackoverflow.com/questions/25819886/where-are-examples-of-in-build-sbt&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>可放在项目代码中的sbt脚本</title>
                <link>http://freewind.in/posts/2764-the-sbt-shell-for-project</link>
                <pubDate>Fri, 12 Sep 2014 23:54:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2764</guid>
                <description><![CDATA[&lt;p&gt;我们经常需要在项目中放置一个sbt脚本，以执行各种sbt命令，让每个人都使用相同的环境。&lt;/p&gt;
&lt;p&gt;在Linux/Mac下可在项目目录下创建文件sbt，填充为以下内容（这里使用了当前最新的sbt 0.13.5，你可以根据情况调整）。&lt;/p&gt;
&lt;p&gt;项目来源：https://github.com/paulp/sbt-extras&lt;/p&gt;
&lt;h2&gt;一条命令搞定&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;curl -s https://raw.githubusercontent.com/paulp/sbt-extras/master/sbt &amp;gt; sbt &amp;amp;&amp;amp; chmod 0755 sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./sbt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会自动下载所需要的sbt及相关库，非常方便。&lt;/p&gt;
&lt;h2&gt;看一下内容&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;sbt&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;#!/usr/bin/env bash
#
# A more capable sbt runner, coincidentally also called sbt.
# Author: Paul Phillips &amp;lt;paulp@typesafe.com&amp;gt;

# todo - make this dynamic
declare -r sbt_release_version=0.13.5
declare -r sbt_snapshot_version=0.13.5-SNAPSHOT

unset sbt_jar sbt_dir sbt_create sbt_snapshot sbt_launch_dir
unset scala_version java_home sbt_explicit_version
unset verbose debug quiet

for arg in &quot;$@&quot;; do
  case $arg in
    -q|-quiet)  quiet=1 ;;
            *)          ;;
  esac
done

build_props_sbt () {
  if [[ -f project/build.properties ]]; then
    versionLine=$(grep ^sbt.version project/build.properties)
    versionString=${versionLine##sbt.version=}
    echo &quot;$versionString&quot;
  fi
}

update_build_props_sbt () {
  local ver=&quot;$1&quot;
  local old=$(build_props_sbt)

  if [[ $ver == $old ]]; then
    return
  elif [[ -f project/build.properties ]]; then
    perl -pi -e &quot;s/^sbt\.version=.*\$/sbt.version=${ver}/&quot; project/build.properties
    grep -q &apos;^sbt.version=&apos; project/build.properties || echo &quot;sbt.version=${ver}&quot; &amp;gt;&amp;gt; project/build.properties

    echo !!!
    echo !!! Updated file project/build.properties setting sbt.version to: $ver
    echo !!! Previous value was: $old
    echo !!!
  fi
}

sbt_version () {
  if [[ -n $sbt_explicit_version ]]; then
    echo $sbt_explicit_version
  else
    local v=$(build_props_sbt)
    if [[ -n $v ]]; then
      echo $v
    else
      echo $sbt_release_version
    fi
  fi
}

echoerr () {
  [[ -z $quiet ]] &amp;amp;&amp;amp; echo 1&amp;gt;&amp;amp;2 &quot;$@&quot;
}
vlog () {
  [[ $verbose || $debug ]] &amp;amp;&amp;amp; echoerr &quot;$@&quot;
}
dlog () {
  [[ $debug ]] &amp;amp;&amp;amp; echoerr &quot;$@&quot;
}

# this seems to cover the bases on OSX, and someone will
# have to tell me about the others.
get_script_path () {
  local path=&quot;$1&quot;
  [[ -L &quot;$path&quot; ]] || { echo &quot;$path&quot; ; return; }

  local target=$(readlink &quot;$path&quot;)
  if [[ &quot;${target:0:1}&quot; == &quot;/&quot; ]]; then
    echo &quot;$target&quot;
  else
    echo &quot;$(dirname $path)/$target&quot;
  fi
}

# a ham-fisted attempt to move some memory settings in concert
# so they need not be dicked around with individually.
get_mem_opts () {
  local mem=${1:-1024}
  local perm=$(( $mem / 4 ))
  (( $perm &amp;gt; 256 )) || perm=256
  (( $perm &amp;lt; 1024 )) || perm=1024
  local codecache=$(( $perm / 2 ))

  echo &quot;-Xms${mem}m -Xmx${mem}m -XX:MaxPermSize=${perm}m -XX:ReservedCodeCacheSize=${codecache}m&quot;
}

die() {
  echo &quot;Aborting: $@&quot;
  exit 1
}

make_url () {
  groupid=&quot;$1&quot;
  category=&quot;$2&quot;
  version=&quot;$3&quot;

  echo &quot;http://typesafe.artifactoryonline.com/typesafe/ivy-$category/$groupid/sbt-launch/$version/sbt-launch.jar&quot;
}

declare -r default_jvm_opts=&quot;-Dfile.encoding=UTF8&quot;
declare -r default_sbt_opts=&quot;-XX:+CMSClassUnloadingEnabled&quot;
declare -r default_sbt_mem=1024
declare -r noshare_opts=&quot;-Dsbt.global.base=project/.sbtboot -Dsbt.boot.directory=project/.boot -Dsbt.ivy.home=project/.ivy&quot;
declare -r sbt_opts_file=&quot;.sbtopts&quot;
declare -r jvm_opts_file=&quot;.jvmopts&quot;
declare -r latest_28=&quot;2.8.2&quot;
declare -r latest_29=&quot;2.9.2&quot;
declare -r latest_210=&quot;2.10.4-SNAPSHOT&quot;

declare -r script_path=$(get_script_path &quot;$BASH_SOURCE&quot;)
declare -r script_dir=&quot;$(dirname $script_path)&quot;
declare -r script_name=&quot;$(basename $script_path)&quot;

# some non-read-onlies set with defaults
declare java_cmd=java
declare sbt_launch_dir=&quot;$script_dir/.lib&quot;
declare sbt_universal_launcher=&quot;$script_dir/lib/sbt-launch.jar&quot;
declare sbt_mem=$default_sbt_mem
declare sbt_jar=$sbt_universal_launcher

# pull -J and -D options to give to java.
declare -a residual_args
declare -a java_args
declare -a scalac_args
declare -a sbt_commands

build_props_scala () {
  if [[ -f project/build.properties ]]; then
    versionLine=$(grep ^build.scala.versions project/build.properties)
    versionString=${versionLine##build.scala.versions=}
    echo ${versionString%% .*}
  fi
}

execRunner () {
  # print the arguments one to a line, quoting any containing spaces
  [[ $verbose || $debug ]] &amp;amp;&amp;amp; echo &quot;# Executing command line:&quot; &amp;amp;&amp;amp; {
    for arg; do
      if printf &quot;%s\n&quot; &quot;$arg&quot; | grep -q &apos; &apos;; then
        printf &quot;\&quot;%s\&quot;\n&quot; &quot;$arg&quot;
      else
        printf &quot;%s\n&quot; &quot;$arg&quot;
      fi
    done
    echo &quot;&quot;
  }

  exec &quot;$@&quot;
}

sbt_groupid () {
  case $(sbt_version) in
        0.7.*) echo org.scala-tools.sbt ;;
       0.10.*) echo org.scala-tools.sbt ;;
    0.11.[12]) echo org.scala-tools.sbt ;;
            *) echo org.scala-sbt ;;
  esac
}

sbt_artifactory_list () {
  local version0=$(sbt_version)
  local version=${version0%-SNAPSHOT}
  local url=&quot;http://typesafe.artifactoryonline.com/typesafe/ivy-snapshots/$(sbt_groupid)/sbt-launch/&quot;
  dlog &quot;Looking for snapshot list at: $url &quot;

  curl -s --list-only &quot;$url&quot; | \
    grep -F $version | \
    perl -e &apos;print reverse &amp;lt;&amp;gt;&apos; | \
    perl -pe &apos;s#^&amp;lt;a href=&quot;([^&quot;/]+).*#$1#;&apos;
}

make_release_url () {
  make_url $(sbt_groupid) releases $(sbt_version)
}

# argument is e.g. 0.13.5-SNAPSHOT
# finds the actual version (with the build id) at artifactory
make_snapshot_url () {
  for ver in $(sbt_artifactory_list); do
    local url=$(make_url $(sbt_groupid) snapshots $ver)
    dlog &quot;Testing $url&quot;
    curl -s --head &quot;$url&quot; &amp;gt;/dev/null
    dlog &quot;curl returned: $?&quot;
    echo &quot;$url&quot;
    return
  done
}

jar_url () {
  case $(sbt_version) in
             0.7.*) echo &quot;http://simple-build-tool.googlecode.com/files/sbt-launch-0.7.7.jar&quot; ;;
        *-SNAPSHOT) make_snapshot_url ;;
                 *) make_release_url ;;
  esac
}

jar_file () {
  echo &quot;$sbt_launch_dir/$1/sbt-launch.jar&quot;
}

download_url () {
  local url=&quot;$1&quot;
  local jar=&quot;$2&quot;

  echo &quot;Downloading sbt launcher $(sbt_version):&quot;
  echo &quot;  From  $url&quot;
  echo &quot;    To  $jar&quot;

  mkdir -p $(dirname &quot;$jar&quot;) &amp;amp;&amp;amp; {
    if which curl &amp;gt;/dev/null; then
      curl --fail --silent &quot;$url&quot; --output &quot;$jar&quot;
    elif which wget &amp;gt;/dev/null; then
      wget --quiet -O &quot;$jar&quot; &quot;$url&quot;
    fi
  } &amp;amp;&amp;amp; [[ -f &quot;$jar&quot; ]]
}

acquire_sbt_jar () {
  sbt_url=&quot;$(jar_url)&quot;
  sbt_jar=&quot;$(jar_file $(sbt_version))&quot;

  [[ -f &quot;$sbt_jar&quot; ]] || download_url &quot;$sbt_url&quot; &quot;$sbt_jar&quot;
}

usage () {
  cat &amp;lt;&amp;lt;EOM
Usage: $script_name [options]

  -h | -help         print this message
  -v | -verbose      this runner is chattier
  -d | -debug        set sbt log level to Debug
  -q | -quiet        set sbt log level to Error
  -no-colors         disable ANSI color codes
  -sbt-create        start sbt even if current directory contains no sbt project
  -sbt-dir   &amp;lt;path&amp;gt;  path to global settings/plugins directory (default: ~/.sbt/&amp;lt;version&amp;gt;)
  -sbt-boot  &amp;lt;path&amp;gt;  path to shared boot directory (default: ~/.sbt/boot in 0.11+)
  -ivy       &amp;lt;path&amp;gt;  path to local Ivy repository (default: ~/.ivy2)
  -mem    &amp;lt;integer&amp;gt;  set memory options (default: $sbt_mem, which is
                       $(get_mem_opts $sbt_mem) )
  -no-share          use all local caches; no sharing
  -offline           put sbt in offline mode
  -jvm-debug &amp;lt;port&amp;gt;  Turn on JVM debugging, open at the given port.
  -batch             Disable interactive mode

  # sbt version (default: from project/build.properties if present, else latest release)
  !!! The only way to accomplish this pre-0.12.0 if there is a build.properties file which
  !!! contains an sbt.version property is to update the file on disk.  That&apos;s what this does.
  -sbt-version  &amp;lt;version&amp;gt;   use the specified version of sbt
  -sbt-jar      &amp;lt;path&amp;gt;      use the specified jar as the sbt launcher
  -sbt-snapshot             use a snapshot version of sbt
  -sbt-launch-dir &amp;lt;path&amp;gt;    directory to hold sbt launchers (default: $sbt_launch_dir)

  # scala version (default: as chosen by sbt)
  -28                       use $latest_28
  -29                       use $latest_29
  -210                      use $latest_210
  -scala-home &amp;lt;path&amp;gt;        use the scala build at the specified directory
  -scala-version &amp;lt;version&amp;gt;  use the specified version of scala

  # java version (default: java from PATH, currently $(java -version |&amp;amp; grep version))
  -java-home &amp;lt;path&amp;gt;         alternate JAVA_HOME

  # jvm options and output control
  JAVA_OPTS     environment variable holding jvm args, if unset uses &quot;$default_jvm_opts&quot;
  SBT_OPTS      environment variable holding jvm args, if unset uses &quot;$default_sbt_opts&quot;
  .jvmopts      if file is in sbt root, it is prepended to the args given to the jvm
  .sbtopts      if file is in sbt root, it is prepended to the args given to **sbt**
  -Dkey=val     pass -Dkey=val directly to the jvm
  -J-X          pass option -X directly to the jvm (-J is stripped)
  -S-X          add -X to sbt&apos;s scalacOptions (-J is stripped)

In the case of duplicated or conflicting options, the order above
shows precedence: JAVA_OPTS lowest, command line options highest.
EOM
}

addJava () {
  dlog &quot;[addJava] arg = &apos;$1&apos;&quot;
  java_args=( &quot;${java_args[@]}&quot; &quot;$1&quot; )
}
addSbt () {
  dlog &quot;[addSbt] arg = &apos;$1&apos;&quot;
  sbt_commands=( &quot;${sbt_commands[@]}&quot; &quot;$1&quot; )
}
addScalac () {
  dlog &quot;[addScalac] arg = &apos;$1&apos;&quot;
  scalac_args=( &quot;${scalac_args[@]}&quot; &quot;$1&quot; )
}
addResidual () {
  dlog &quot;[residual] arg = &apos;$1&apos;&quot;
  residual_args=( &quot;${residual_args[@]}&quot; &quot;$1&quot; )
}
addResolver () {
  addSbt &quot;set resolvers in ThisBuild += $1&quot;
}
addDebugger () {
  addJava &quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=$1&quot;
}
get_jvm_opts () {
  # echo &quot;${JAVA_OPTS:-$default_jvm_opts}&quot;
  # echo &quot;${SBT_OPTS:-$default_sbt_opts}&quot;

  [[ -f &quot;$jvm_opts_file&quot; ]] &amp;amp;&amp;amp; cat &quot;$jvm_opts_file&quot;
}

process_args ()
{
  require_arg () {
    local type=&quot;$1&quot;
    local opt=&quot;$2&quot;
    local arg=&quot;$3&quot;

    if [[ -z &quot;$arg&quot; ]] || [[ &quot;${arg:0:1}&quot; == &quot;-&quot; ]]; then
      die &quot;$opt requires &amp;lt;$type&amp;gt; argument&quot;
    fi
  }
  while [[ $# -gt 0 ]]; do
    case &quot;$1&quot; in
       -h|-help) usage; exit 1 ;;
    -v|-verbose) verbose=1 &amp;amp;&amp;amp; shift ;;
      -d|-debug) debug=1 &amp;amp;&amp;amp; shift ;;
      -q|-quiet) quiet=1 &amp;amp;&amp;amp; shift ;;

           -ivy) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; addJava &quot;-Dsbt.ivy.home=$2&quot; &amp;amp;&amp;amp; shift 2 ;;
           -mem) require_arg integer &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; sbt_mem=&quot;$2&quot; &amp;amp;&amp;amp; shift 2 ;;
     -no-colors) addJava &quot;-Dsbt.log.noformat=true&quot; &amp;amp;&amp;amp; shift ;;
      -no-share) addJava &quot;$noshare_opts&quot; &amp;amp;&amp;amp; shift ;;
      -sbt-boot) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; addJava &quot;-Dsbt.boot.directory=$2&quot; &amp;amp;&amp;amp; shift 2 ;;
       -sbt-dir) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; sbt_dir=&quot;$2&quot; &amp;amp;&amp;amp; shift 2 ;;
     -debug-inc) addJava &quot;-Dxsbt.inc.debug=true&quot; &amp;amp;&amp;amp; shift ;;
       -offline) addSbt &quot;set offline := true&quot; &amp;amp;&amp;amp; shift ;;
     -jvm-debug) require_arg port &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; addDebugger $2 &amp;amp;&amp;amp; shift 2 ;;
         -batch) exec &amp;lt;/dev/null &amp;amp;&amp;amp; shift ;;

    -sbt-create) sbt_create=true &amp;amp;&amp;amp; shift ;;
  -sbt-snapshot) sbt_explicit_version=$sbt_snapshot_version &amp;amp;&amp;amp; shift ;;
       -sbt-jar) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; sbt_jar=&quot;$2&quot; &amp;amp;&amp;amp; shift 2 ;;
   -sbt-version) require_arg version &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; sbt_explicit_version=&quot;$2&quot; &amp;amp;&amp;amp; shift 2 ;;
-sbt-launch-dir) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; sbt_launch_dir=&quot;$2&quot; &amp;amp;&amp;amp; shift 2 ;;
 -scala-version) require_arg version &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; addSbt &quot;set scalaVersion := \&quot;$2\&quot;&quot; &amp;amp;&amp;amp; shift 2 ;;
    -scala-home) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; addSbt &quot;set scalaHome in ThisBuild := Some(file(\&quot;$2\&quot;))&quot; &amp;amp;&amp;amp; shift 2 ;;
     -java-home) require_arg path &quot;$1&quot; &quot;$2&quot; &amp;amp;&amp;amp; java_cmd=&quot;$2/bin/java&quot; &amp;amp;&amp;amp; shift 2 ;;

            -D*) addJava &quot;$1&quot; &amp;amp;&amp;amp; shift ;;
            -J*) addJava &quot;${1:2}&quot; &amp;amp;&amp;amp; shift ;;
            -S*) addScalac &quot;${1:2}&quot; &amp;amp;&amp;amp; shift ;;
            -28) addSbt &quot;++ $latest_28&quot; &amp;amp;&amp;amp; shift ;;
            -29) addSbt &quot;++ $latest_29&quot; &amp;amp;&amp;amp; shift ;;
           -210) addSbt &quot;++ $latest_210&quot; &amp;amp;&amp;amp; shift ;;

              *) addResidual &quot;$1&quot; &amp;amp;&amp;amp; shift ;;
    esac
  done

  [[ $debug ]] &amp;amp;&amp;amp; {
    case $(sbt_version) in
     0.7.*) addSbt &quot;debug&quot; ;;
         *) addSbt &quot;set logLevel in Global := Level.Debug&quot; ;;
    esac
  }
  [[ $quiet ]] &amp;amp;&amp;amp; {
    case $(sbt_version) in
     0.7.*) ;;
         *) addSbt &quot;set logLevel in Global := Level.Error&quot; ;;
    esac
  }
}

# if .sbtopts exists, prepend its contents to $@ so it can be processed by this runner
[[ -f &quot;$sbt_opts_file&quot; ]] &amp;amp;&amp;amp; {
  sbtargs=()
  while IFS= read -r arg; do
    sbtargs=( &quot;${sbtargs[@]}&quot; &quot;$arg&quot; )
  done &amp;lt;&quot;$sbt_opts_file&quot;

  set -- &quot;${sbtargs[@]}&quot; &quot;$@&quot;
}

# process the combined args, then reset &quot;$@&quot; to the residuals
process_args &quot;$@&quot;
set -- &quot;${residual_args[@]}&quot;
argumentCount=$#

# set scalacOptions if we were given any -S opts
[[ ${#scalac_args[@]} -eq 0 ]] || addSbt &quot;set scalacOptions in ThisBuild += \&quot;${scalac_args[@]}\&quot;&quot;

# Update build.properties no disk to set explicit version - sbt gives us no choice
[[ -n &quot;$sbt_explicit_version&quot; ]] &amp;amp;&amp;amp; update_build_props_sbt &quot;$sbt_explicit_version&quot;
echoerr &quot;Detected sbt version $(sbt_version)&quot;

[[ -n &quot;$scala_version&quot; ]] &amp;amp;&amp;amp; echo &quot;Overriding scala version to $scala_version&quot;

# no args - alert them there&apos;s stuff in here
(( $argumentCount &amp;gt; 0 )) || echo &quot;Starting $script_name: invoke with -help for other options&quot;

# verify this is an sbt dir or -create was given
[[ -f ./build.sbt || -d ./project || -n &quot;$sbt_create&quot; ]] || {
  cat &amp;lt;&amp;lt;EOM
$(pwd) doesn&apos;t appear to be an sbt project.
If you want to start sbt anyway, run:
  $0 -sbt-create

EOM
  exit 1
}

# pick up completion if present; todo
[[ -f .sbt_completion.sh ]] &amp;amp;&amp;amp; source .sbt_completion.sh

# no jar? download it.
[[ -f &quot;$sbt_jar&quot; ]] || acquire_sbt_jar || {
  # still no jar? uh-oh.
  echo &quot;Download failed. Obtain the jar manually and place it at $sbt_jar&quot;
  exit 1
}

[[ -n &quot;$sbt_dir&quot; ]] || {
  sbt_dir=~/.sbt/$(sbt_version)
  addJava &quot;-Dsbt.global.base=$sbt_dir&quot;
  echoerr &quot;Using $sbt_dir as sbt dir, -sbt-dir to override.&quot;
}

# since sbt 0.7 doesn&apos;t understand iflast
(( ${#residual_args[@]} == 0 )) &amp;amp;&amp;amp; residual_args=( &quot;shell&quot; )

# run sbt
echo &quot;running &quot; &quot;$java_cmd&quot; \
                  $(get_mem_opts $sbt_mem) \
                  $(get_jvm_opts) \
                  ${java_args[@]} \
                  -jar &quot;$sbt_jar&quot; \
                  &quot;${sbt_commands[@]}&quot; \
                  &quot;${residual_args[@]}&quot;
execRunner &quot;$java_cmd&quot; \
  $(get_mem_opts $sbt_mem) \
  $(get_jvm_opts) \
  ${java_args[@]} \
  -jar &quot;$sbt_jar&quot; \
  &quot;${sbt_commands[@]}&quot; \
  &quot;${residual_args[@]}&quot;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>用脚本快速初始化一个sbt项目的结构</title>
                <link>http://freewind.in/posts/2763-use-shell-to-create-sbt-dirs-quickly</link>
                <pubDate>Fri, 12 Sep 2014 23:44:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2763</guid>
                <description><![CDATA[&lt;p&gt;sbt没有提供初始化一个项目目录结构的功能，我们有两种办法快速创建&lt;/p&gt;
&lt;h2&gt;纯脚本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;touch build.sbt
mkdir project
touch project/{plugins.sbt,build.properties}
mkdir -p src/{main,test}/{resources,scala}
touch src/main/scala/Hello.scala
echo &quot;target/&quot; &amp;gt; .gitignore
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结构出来了，如果需要一些常用的内容，可以从下面文章中拷贝一些东西过来。&lt;/p&gt;
&lt;p&gt;然后再从下面的文章中，把&lt;code&gt;build.sbt&lt;/code&gt;和&lt;code&gt;plugins.sbt&lt;/code&gt;的基本内容拷贝过来就行了。&lt;/p&gt;
&lt;p&gt;TODO: Add link 2762&lt;/p&gt;
&lt;p&gt;如果需要放置供该项目使用的sbt脚本，可参看：&lt;/p&gt;
&lt;p&gt;TODO: add link 2764&lt;/p&gt;
&lt;h2&gt;插件&lt;/h2&gt;
&lt;p&gt;https://github.com/softprops/np&lt;/p&gt;
&lt;p&gt;一个功能非常简单的插件，可用于创建目录结构，可以设置为全局插件，方便使用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>基本的build.sbt配置</title>
                <link>http://freewind.in/posts/2762-use-simple-sbt-config-to-run-scala-program</link>
                <pubDate>Fri, 12 Sep 2014 23:14:34 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2762</guid>
                <description><![CDATA[&lt;p&gt;有时候我们想快速执行一些scala代码，但是它又依赖第三方的库，这时可以使用下面的sbt配置来快速执行：&lt;/p&gt;
&lt;h2&gt;build.sbt&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;hello&quot;

version := &quot;1.0&quot;

organization := &quot;org.my&quot;

scalaVersion := &quot;2.11.0&quot;

sbtVersion := &quot;0.13.5&quot;

resolvers ++= Seq(
  &quot;ibiblio&quot; at &quot;http://mirrors.ibiblio.org/pub/mirrors/maven2&quot;,
  &quot;Sonatype snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot;,
  &quot;Sonatype releases&quot; at &quot;http://oss.sonatype.org/content/repositories/releases&quot;
)

libraryDependencies ++= Seq(
  &quot;org.apache.commons&quot; % &quot;commons-lang3&quot; % &quot;3.3.2&quot;,
  &quot;commons-io&quot; % &quot;commons-io&quot; % &quot;2.4&quot;,
  &quot;com.google.guava&quot; % &quot;guava&quot; % &quot;18.0&quot;,
  &quot;org.scalaz&quot; %% &quot;scalaz-core&quot; % &quot;7.1.0&quot;,
  &quot;io.argonaut&quot; %% &quot;argonaut&quot; % &quot;6.1-M4&quot;,
  &quot;net.databinder&quot; %% &quot;unfiltered&quot; % &quot;0.8.1&quot;,
  &quot;net.databinder&quot; %% &quot;unfiltered-filter-async&quot; % &quot;0.8.1&quot;,
  &quot;net.databinder&quot; %% &quot;unfiltered-jetty&quot; % &quot;0.8.1&quot;,
  &quot;ch.qos.logback&quot; % &quot;logback-classic&quot; % &quot;1.1.2&quot;,
  &quot;org.slf4j&quot; % &quot;slf4j-api&quot; % &quot;1.7.7&quot;,
  &quot;org.commonjava.googlecode.markdown4j&quot; % &quot;markdown4j&quot; % &quot;2.2-cj-1.0&quot;,
  &quot;com.github.spullara.mustache.java&quot; % &quot;compiler&quot; %    &quot;0.8.16&quot;,
  &quot;org.jsoup&quot; % &quot;jsoup&quot; % &quot;1.7.3&quot;,
  &quot;org.specs2&quot; %% &quot;specs2&quot; % &quot;2.4.2&quot; % &quot;test&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;libraryDependencies&lt;/code&gt;里加的东西比较多，可以自行删减或增加。&lt;/p&gt;
&lt;p&gt;然后运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sbt
&amp;gt; update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会下载各依赖。&lt;/p&gt;
&lt;h2&gt;生成idea项目&lt;/h2&gt;
&lt;p&gt;在项目目录下创建&lt;code&gt;project/plugins.sbt&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;resolvers += &quot;Sonatype snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot;

addSbtPlugin(&quot;com.github.mpeltonen&quot; %% &quot;sbt-idea&quot; % &quot;1.7.0-SNAPSHOT&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ sbt
&amp;gt; gen-idea sbt-classifiers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会生成idea所需的配置文件，可以直接使用idea打开。&lt;/p&gt;
&lt;p&gt;其中参数&lt;code&gt;sbt-classifiers&lt;/code&gt;是指同时下载源代码和文档，如果不需要可以去掉。它还有很多参数可使用。&lt;/p&gt;
&lt;p&gt;如果觉得每次都设置idea插件很麻烦，可以把它设为全局的，参看: TODO Add link&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>无需任何配置，直接使用sbt运行一个scala文件</title>
                <link>http://freewind.in/posts/2761-use-sbt-to-run-scala-program-directly</link>
                <pubDate>Fri, 12 Sep 2014 23:09:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2761</guid>
                <description><![CDATA[&lt;p&gt;简单的说，就是在某个目录中创建一个scala文件，直接用sbt执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mkdir mypro
cd mypro
touch Hello.scala
# edit Hello.scala

sbt run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然前提是你已经安装了sbt。&lt;/p&gt;
&lt;h2&gt;传参数&lt;/h2&gt;
&lt;p&gt;如果&lt;code&gt;Hello.scala&lt;/code&gt;需要传参数，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Hello {

    def main(args:Array[String]) {
       println(&quot;The args is: &quot;)
       println(args.mkString(&quot; + &quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以这样给它传参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sbt run &quot;aaa bbb&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会得到结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The args is:
aaa + bbb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sbt给我的感觉是非常复杂和笨重，没想到还能这么用，感觉还是很方便的。&lt;/p&gt;
&lt;p&gt;不过如果程序依赖别的库，这样就不行了，需要使用&lt;code&gt;build.sbt&lt;/code&gt;来指明依赖，参看：TODO add link&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在定义sbt任务时，使用其它key的值</title>
                <link>http://freewind.in/posts/2760-how-to-use-value-of-another-key-in-sbt-task</link>
                <pubDate>Fri, 12 Sep 2014 23:04:50 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2760</guid>
                <description><![CDATA[&lt;p&gt;TODO: add link [2759]&lt;/p&gt;
&lt;p&gt;如果想使用另一个key的值，可以调用其&lt;code&gt;.value&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;hello&quot;

version := &quot;1.0&quot;

scalaVersion := &quot;2.11.0&quot;

val mykey = settingKey[Int](&quot;demo key&quot;)

mykey := 100

val hello = taskKey[Unit](&quot;demo task&quot;)

hello := {println(&quot;Hello, world: &quot; + mykey.value)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;sbt hello&lt;/code&gt;将输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello, world: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;.value&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;value&lt;/code&gt; - is a macro defined in &lt;a href=&quot;http://www.scala-sbt.org/0.13.5/api/index.html#sbt.std.MacroValue&quot;&gt;sbt.std.MacroValue&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Tasks and Settings both produce values that can be used in other tasks and settings. It’s very rare in sbt that a Task doesn’t return something to be used in other tasks. This design allows great flexibility and power when defining complex builds. It’s also drastically simplifies parallel building.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thanks to: &lt;a href=&quot;http://stackoverflow.com/a/25808809/342235&quot;&gt;http://stackoverflow.com/a/25808809/342235&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在sbt中定义一个最简单的hello world任务</title>
                <link>http://freewind.in/posts/2759-how-to-define-a-simplest-hello-word-task-in-sbt</link>
                <pubDate>Fri, 12 Sep 2014 22:57:23 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2759</guid>
                <description><![CDATA[&lt;p&gt;使用&lt;code&gt;taskKey&lt;/code&gt;函数，定义一个&lt;code&gt;TaskKey&lt;/code&gt;类型的key，然后再给它赋一个函数即可。&lt;/p&gt;
&lt;h2&gt;build.sbt&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;name := &quot;hello&quot;

version := &quot;1.0&quot;

scalaVersion := &quot;2.11.0&quot;

lazy val hello = taskKey[Unit](&quot;An example task&quot;)

hello := { println(&quot;Hello, world&quot;) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt hello
Hello, world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中间的空行不能少&lt;/li&gt;
&lt;li&gt;通常使用&lt;code&gt;lazy&lt;/code&gt;以避免某些初始化顺序问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;show&lt;/h2&gt;
&lt;p&gt;另外，如果想看&lt;code&gt;hello&lt;/code&gt;的返回值，使用&lt;code&gt;show&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sbt
&amp;gt; show hello
[info] ()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;inspect&lt;/h2&gt;
&lt;p&gt;如果想看该任务的详细信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[info] Task: Unit
[info] Description:
[info]  demo task
[info] Provided by:
[info]  {file:/private/tmp/sbttest/}sbttest/*:hello
[info] Defined at:
[info]  /private/tmp/sbttest/build.sbt:9
[info] Delegates:
[info]  *:hello
[info]  {.}/*:hello
[info]  */*:hello
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt预定义的keys</title>
                <link>http://freewind.in/posts/2758-sbt-keys</link>
                <pubDate>Fri, 12 Sep 2014 20:07:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2758</guid>
                <description><![CDATA[&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package sbt
object Keys extends scala.AnyRef {
  val TraceValues : java.lang.String 
  val logLevel : sbt.SettingKey[sbt.Level.Value] 
  val persistLogLevel : sbt.SettingKey[sbt.Level.Value] 
  val traceLevel : sbt.SettingKey[scala.Int] 
  val persistTraceLevel : sbt.SettingKey[scala.Int] 
  val showSuccess : sbt.SettingKey[scala.Boolean] 
  val showTiming : sbt.SettingKey[scala.Boolean] 
  val timingFormat : sbt.SettingKey[java.text.DateFormat] 
  val extraLoggers : sbt.SettingKey[scala.Function1[sbt.Def.ScopedKey[_], scala.Seq[sbt.AbstractLogger]]] 
  val logManager : sbt.SettingKey[sbt.LogManager] 
  val logBuffered : sbt.SettingKey[scala.Boolean] 
  val projectCommand : sbt.AttributeKey[scala.Boolean] 
  val sessionSettings : sbt.AttributeKey[sbt.SessionSettings] 
  val stateBuildStructure : sbt.AttributeKey[sbt.BuildStructure] 
  val buildStructure : sbt.TaskKey[sbt.BuildStructure] 
  val loadedBuild : sbt.SettingKey[sbt.LoadedBuild] 
  val buildDependencies : sbt.SettingKey[sbt.BuildDependencies] 
  val appConfiguration : sbt.SettingKey[xsbti.AppConfiguration] 
  val thisProject : sbt.SettingKey[sbt.ResolvedProject] 
  val thisProjectRef : sbt.SettingKey[sbt.ProjectRef] 
  val configuration : sbt.SettingKey[sbt.Configuration] 
  val commands : sbt.SettingKey[scala.Seq[sbt.Command]] 
  val initialize : sbt.SettingKey[scala.Unit] 
  val onLoad : sbt.SettingKey[scala.Function1[sbt.State, sbt.State]] 
  val onUnload : sbt.SettingKey[scala.Function1[sbt.State, sbt.State]] 
  val onLoadMessage : sbt.SettingKey[scala.Predef.String] 
  val transformState : sbt.AttributeKey[scala.Function1[sbt.State, sbt.State]] 
  val onComplete : sbt.SettingKey[scala.Function0[scala.Unit]] 
  val historyPath : sbt.SettingKey[scala.Option[java.io.File]] 
  val shellPrompt : sbt.SettingKey[scala.Function1[sbt.State, scala.Predef.String]] 
  val analysis : sbt.AttributeKey[sbt.inc.Analysis] 
  val watch : sbt.SettingKey[sbt.Watched] 
  val pollInterval : sbt.SettingKey[scala.Int] 
  val watchSources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val watchTransitiveSources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val watchingMessage : sbt.SettingKey[scala.Function1[sbt.WatchState, scala.Predef.String]] 
  val triggeredMessage : sbt.SettingKey[scala.Function1[sbt.WatchState, scala.Predef.String]] 
  val baseDirectory : sbt.SettingKey[java.io.File] 
  val target : sbt.SettingKey[java.io.File] 
  val crossTarget : sbt.SettingKey[java.io.File] 
  val sourceDirectory : sbt.SettingKey[java.io.File] 
  val sourceManaged : sbt.SettingKey[java.io.File] 
  val scalaSource : sbt.SettingKey[java.io.File] 
  val javaSource : sbt.SettingKey[java.io.File] 
  val sourceDirectories : sbt.SettingKey[scala.Seq[java.io.File]] 
  val unmanagedSourceDirectories : sbt.SettingKey[scala.Seq[java.io.File]] 
  val unmanagedSources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val managedSourceDirectories : sbt.SettingKey[scala.Seq[java.io.File]] 
  val managedSources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val sources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val sourcesInBase : sbt.SettingKey[scala.Boolean] 
  val includeFilter : sbt.SettingKey[sbt.FileFilter] 
  val excludeFilter : sbt.SettingKey[sbt.FileFilter] 
  val resourceDirectory : sbt.SettingKey[java.io.File] 
  val resourceManaged : sbt.SettingKey[java.io.File] 
  val unmanagedResourceDirectories : sbt.SettingKey[scala.Seq[java.io.File]] 
  val unmanagedResources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val managedResourceDirectories : sbt.SettingKey[scala.Seq[java.io.File]] 
  val managedResources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val resourceDirectories : sbt.SettingKey[scala.Seq[java.io.File]] 
  val resources : sbt.TaskKey[scala.Seq[java.io.File]] 
  val classDirectory : sbt.SettingKey[java.io.File] 
  @scala.deprecated(&quot;Use the cacheDirectory provided by streams.&quot;)
  val cacheDirectory : sbt.SettingKey[java.io.File] 
  val cleanFiles : sbt.SettingKey[scala.Seq[java.io.File]] 
  val cleanKeepFiles : sbt.SettingKey[scala.Seq[java.io.File]] 
  val crossPaths : sbt.SettingKey[scala.Boolean] 
  val taskTemporaryDirectory : sbt.SettingKey[java.io.File] 
  val sourceGenerators : sbt.SettingKey[scala.Seq[sbt.Task[scala.Seq[java.io.File]]]] 
  val resourceGenerators : sbt.SettingKey[scala.Seq[sbt.Task[scala.Seq[java.io.File]]]] 
  val autoCompilerPlugins : sbt.SettingKey[scala.Boolean] 
  val maxErrors : sbt.SettingKey[scala.Int] 
  val scalacOptions : sbt.TaskKey[scala.Seq[scala.Predef.String]] 
  val javacOptions : sbt.TaskKey[scala.Seq[scala.Predef.String]] 
  val incOptions : sbt.TaskKey[sbt.inc.IncOptions] 
  val compileOrder : sbt.SettingKey[xsbti.compile.CompileOrder] 
  val initialCommands : sbt.SettingKey[scala.Predef.String] 
  val cleanupCommands : sbt.SettingKey[scala.Predef.String] 
  val compileInputs : sbt.TaskKey[sbt.Compiler.Inputs] 
  val scalaHome : sbt.SettingKey[scala.Option[java.io.File]] 
  val scalaInstance : sbt.TaskKey[sbt.ScalaInstance] 
  val scalaOrganization : sbt.SettingKey[scala.Predef.String] 
  val scalaVersion : sbt.SettingKey[scala.Predef.String] 
  val scalaBinaryVersion : sbt.SettingKey[scala.Predef.String] 
  val crossScalaVersions : sbt.SettingKey[scala.Seq[scala.Predef.String]] 
  val crossVersion : sbt.SettingKey[sbt.CrossVersion] 
  val classpathOptions : sbt.SettingKey[sbt.ClasspathOptions] 
  val definedSbtPlugins : sbt.TaskKey[scala.Predef.Set[scala.Predef.String]] 
  val sbtPlugin : sbt.SettingKey[scala.Boolean] 
  val printWarnings : sbt.TaskKey[scala.Unit] 
  val clean : sbt.TaskKey[scala.Unit] 
  val console : sbt.TaskKey[scala.Unit] 
  val consoleQuick : sbt.TaskKey[scala.Unit] 
  val consoleProject : sbt.TaskKey[scala.Unit] 
  val compile : sbt.TaskKey[sbt.inc.Analysis] 
  val compilers : sbt.TaskKey[sbt.Compiler.Compilers] 
  val compileIncSetup : sbt.TaskKey[sbt.Compiler.IncSetup] 
  val compilerCache : sbt.TaskKey[xsbti.compile.GlobalsCache] 
  val stateCompilerCache : sbt.AttributeKey[xsbti.compile.GlobalsCache] 
  val definesClass : sbt.TaskKey[sbt.inc.Locate.DefinesClass] 
  val doc : sbt.TaskKey[java.io.File] 
  val copyResources : sbt.TaskKey[scala.Seq[scala.Tuple2[java.io.File, java.io.File]]] 
  val aggregate : sbt.SettingKey[scala.Boolean] 
  val sourcePositionMappers : sbt.TaskKey[scala.Seq[scala.Function1[xsbti.Position, scala.Option[xsbti.Position]]]] 
  val packageBin : sbt.TaskKey[java.io.File] 
  val `package` : sbt.TaskKey[java.io.File] 
  val packageDoc : sbt.TaskKey[java.io.File] 
  val packageSrc : sbt.TaskKey[java.io.File] 
  val packageOptions : sbt.TaskKey[scala.Seq[sbt.PackageOption]] 
  val packageConfiguration : sbt.TaskKey[sbt.Package.Configuration] 
  val artifactPath : sbt.SettingKey[java.io.File] 
  val artifact : sbt.SettingKey[sbt.Artifact] 
  val artifactClassifier : sbt.SettingKey[scala.Option[scala.Predef.String]] 
  val artifactName : sbt.SettingKey[scala.Function3[sbt.ScalaVersion, sbt.ModuleID, sbt.Artifact, scala.Predef.String]] 
  val mappings : sbt.TaskKey[scala.Seq[scala.Tuple2[java.io.File, scala.Predef.String]]] 
  val fileMappings : sbt.TaskKey[scala.Seq[scala.Tuple2[java.io.File, java.io.File]]] 
  val selectMainClass : sbt.TaskKey[scala.Option[scala.Predef.String]] 
  val mainClass : sbt.TaskKey[scala.Option[scala.Predef.String]] 
  val run : sbt.InputKey[scala.Unit] 
  val runMain : sbt.InputKey[scala.Unit] 
  val discoveredMainClasses : sbt.TaskKey[scala.Seq[scala.Predef.String]] 
  val runner : sbt.TaskKey[sbt.ScalaRun] 
  val trapExit : sbt.SettingKey[scala.Boolean] 
  val fork : sbt.SettingKey[scala.Boolean] 
  val outputStrategy : sbt.SettingKey[scala.Option[sbt.OutputStrategy]] 
  val connectInput : sbt.SettingKey[scala.Boolean] 
  val javaHome : sbt.SettingKey[scala.Option[java.io.File]] 
  val javaOptions : sbt.TaskKey[scala.Seq[scala.Predef.String]] 
  val envVars : sbt.TaskKey[scala.Predef.Map[scala.Predef.String, scala.Predef.String]] 
  val testLoader : sbt.TaskKey[java.lang.ClassLoader] 
  val loadedTestFrameworks : sbt.TaskKey[scala.Predef.Map[sbt.TestFramework, sbt.testing.Framework]] 
  val definedTests : sbt.TaskKey[scala.Seq[sbt.TestDefinition]] 
  val definedTestNames : sbt.TaskKey[scala.Seq[scala.Predef.String]] 
  val executeTests : sbt.TaskKey[sbt.Tests.Output] 
  val test : sbt.TaskKey[scala.Unit] 
  val testOnly : sbt.InputKey[scala.Unit] 
  val testQuick : sbt.InputKey[scala.Unit] 
  val testOptions : sbt.TaskKey[scala.Seq[sbt.TestOption]] 
  val testFrameworks : sbt.SettingKey[scala.Seq[sbt.TestFramework]] 
  val testListeners : sbt.TaskKey[scala.Seq[sbt.TestReportListener]] 
  val testExecution : sbt.TaskKey[sbt.Tests.Execution] 
  val testFilter : sbt.TaskKey[scala.Function1[scala.Seq[scala.Predef.String], scala.Seq[scala.Function1[scala.Predef.String, scala.Boolean]]]] 
  val testGrouping : sbt.TaskKey[scala.Seq[sbt.Tests.Group]] 
  val isModule : sbt.AttributeKey[scala.Boolean] 
  type Classpath = sbt.Def.Classpath
  val name : sbt.SettingKey[scala.Predef.String] 
  val normalizedName : sbt.SettingKey[scala.Predef.String] 
  val description : sbt.SettingKey[scala.Predef.String] 
  val homepage : sbt.SettingKey[scala.Option[java.net.URL]] 
  val startYear : sbt.SettingKey[scala.Option[scala.Int]] 
  val licenses : sbt.SettingKey[scala.Seq[scala.Tuple2[scala.Predef.String, java.net.URL]]] 
  val organization : sbt.SettingKey[scala.Predef.String] 
  val organizationName : sbt.SettingKey[scala.Predef.String] 
  val organizationHomepage : sbt.SettingKey[scala.Option[java.net.URL]] 
  val apiURL : sbt.SettingKey[scala.Option[java.net.URL]] 
  val entryApiURL : sbt.AttributeKey[java.net.URL] 
  val apiMappings : sbt.TaskKey[scala.Predef.Map[java.io.File, java.net.URL]] 
  val autoAPIMappings : sbt.SettingKey[scala.Boolean] 
  val scmInfo : sbt.SettingKey[scala.Option[sbt.ScmInfo]] 
  val projectInfo : sbt.SettingKey[sbt.ModuleInfo] 
  val defaultConfiguration : sbt.SettingKey[scala.Option[sbt.Configuration]] 
  val products : sbt.TaskKey[scala.Seq[java.io.File]] 
  @scala.deprecated(&quot;This task is unused by the default project and will be removed.&quot;)
  val productDirectories : sbt.TaskKey[scala.Seq[java.io.File]] 
  val exportJars : sbt.SettingKey[scala.Boolean] 
  val exportedProducts : sbt.TaskKey[sbt.Keys.Classpath] 
  val unmanagedClasspath : sbt.TaskKey[sbt.Keys.Classpath] 
  val unmanagedJars : sbt.TaskKey[sbt.Keys.Classpath] 
  val managedClasspath : sbt.TaskKey[sbt.Keys.Classpath] 
  val internalDependencyClasspath : sbt.TaskKey[sbt.Keys.Classpath] 
  val externalDependencyClasspath : sbt.TaskKey[sbt.Keys.Classpath] 
  val dependencyClasspath : sbt.TaskKey[sbt.Keys.Classpath] 
  val fullClasspath : sbt.TaskKey[sbt.Keys.Classpath] 
  val internalConfigurationMap : sbt.SettingKey[scala.Function1[sbt.Configuration, sbt.Configuration]] 
  val classpathConfiguration : sbt.TaskKey[sbt.Configuration] 
  val ivyConfiguration : sbt.TaskKey[sbt.IvyConfiguration] 
  val ivyConfigurations : sbt.SettingKey[scala.Seq[sbt.Configuration]] 
  val moduleSettings : sbt.TaskKey[sbt.ModuleSettings] 
  val unmanagedBase : sbt.SettingKey[java.io.File] 
  val updateConfiguration : sbt.SettingKey[sbt.UpdateConfiguration] 
  val ivySbt : sbt.TaskKey[sbt.IvySbt] 
  val ivyModule : sbt.TaskKey[sbt.IvySbt#Module] 
  val update : sbt.TaskKey[sbt.UpdateReport] 
  val transitiveUpdate : sbt.TaskKey[scala.Seq[sbt.UpdateReport]] 
  val updateClassifiers : sbt.TaskKey[sbt.UpdateReport] 
  val transitiveClassifiers : sbt.SettingKey[scala.Seq[scala.Predef.String]] 
  val updateSbtClassifiers : sbt.TaskKey[sbt.UpdateReport] 
  val publishConfiguration : sbt.TaskKey[sbt.PublishConfiguration] 
  val publishLocalConfiguration : sbt.TaskKey[sbt.PublishConfiguration] 
  val publishM2Configuration : sbt.TaskKey[sbt.PublishConfiguration] 
  val deliverConfiguration : sbt.TaskKey[sbt.DeliverConfiguration] 
  val deliverLocalConfiguration : sbt.TaskKey[sbt.DeliverConfiguration] 
  val makePomConfiguration : sbt.SettingKey[sbt.MakePomConfiguration] 
  val packagedArtifacts : sbt.TaskKey[scala.Predef.Map[sbt.Artifact, java.io.File]] 
  val publishMavenStyle : sbt.SettingKey[scala.Boolean] 
  val credentials : sbt.TaskKey[scala.Seq[sbt.Credentials]] 
  val makePom : sbt.TaskKey[java.io.File] 
  val deliver : sbt.TaskKey[java.io.File] 
  val deliverLocal : sbt.TaskKey[java.io.File] 
  val publish : sbt.TaskKey[scala.Unit] 
  val publishLocal : sbt.TaskKey[scala.Unit] 
  val publishM2 : sbt.TaskKey[scala.Unit] 
  val pomExtra : sbt.SettingKey[scala.xml.NodeSeq] 
  val pomPostProcess : sbt.SettingKey[scala.Function1[scala.xml.Node, scala.xml.Node]] 
  val pomIncludeRepository : sbt.SettingKey[scala.Function1[sbt.MavenRepository, scala.Boolean]] 
  val pomAllRepositories : sbt.SettingKey[scala.Boolean] 
  val moduleName : sbt.SettingKey[scala.Predef.String] 
  val version : sbt.SettingKey[scala.Predef.String] 
  val isSnapshot : sbt.SettingKey[scala.Boolean] 
  val moduleID : sbt.SettingKey[sbt.ModuleID] 
  val projectID : sbt.SettingKey[sbt.ModuleID] 
  val overrideBuildResolvers : sbt.SettingKey[scala.Boolean] 
  val bootResolvers : sbt.TaskKey[scala.Option[scala.Seq[sbt.Resolver]]] 
  val appResolvers : sbt.SettingKey[scala.Option[scala.Seq[sbt.Resolver]]] 
  val externalResolvers : sbt.TaskKey[scala.Seq[sbt.Resolver]] 
  val resolvers : sbt.SettingKey[scala.Seq[sbt.Resolver]] 
  val projectResolver : sbt.TaskKey[sbt.Resolver] 
  val fullResolvers : sbt.TaskKey[scala.Seq[sbt.Resolver]] 
  val otherResolvers : sbt.SettingKey[scala.Seq[sbt.Resolver]] 
  val moduleConfigurations : sbt.SettingKey[scala.Seq[sbt.ModuleConfiguration]] 
  val retrievePattern : sbt.SettingKey[scala.Predef.String] 
  val retrieveConfiguration : sbt.SettingKey[scala.Option[sbt.RetrieveConfiguration]] 
  val offline : sbt.SettingKey[scala.Boolean] 
  val ivyPaths : sbt.SettingKey[sbt.IvyPaths] 
  val libraryDependencies : sbt.SettingKey[scala.Seq[sbt.ModuleID]] 
  val dependencyOverrides : sbt.SettingKey[scala.Predef.Set[sbt.ModuleID]] 
  val allDependencies : sbt.TaskKey[scala.Seq[sbt.ModuleID]] 
  val projectDependencies : sbt.TaskKey[scala.Seq[sbt.ModuleID]] 
  val ivyXML : sbt.SettingKey[scala.xml.NodeSeq] 
  val ivyScala : sbt.SettingKey[scala.Option[sbt.IvyScala]] 
  val ivyValidate : sbt.SettingKey[scala.Boolean] 
  val ivyLoggingLevel : sbt.SettingKey[sbt.UpdateLogging.Value] 
  val publishTo : sbt.SettingKey[scala.Option[sbt.Resolver]] 
  val artifacts : sbt.SettingKey[scala.Seq[sbt.Artifact]] 
  val projectDescriptors : sbt.TaskKey[scala.Predef.Map[org.apache.ivy.core.module.id.ModuleRevisionId, org.apache.ivy.core.module.descriptor.ModuleDescriptor]] 
  val autoUpdate : sbt.SettingKey[scala.Boolean] 
  val retrieveManaged : sbt.SettingKey[scala.Boolean] 
  val managedDirectory : sbt.SettingKey[java.io.File] 
  val classpathTypes : sbt.SettingKey[scala.Predef.Set[scala.Predef.String]] 
  val publishArtifact : sbt.SettingKey[scala.Boolean] 
  val packagedArtifact : sbt.TaskKey[scala.Tuple2[sbt.Artifact, java.io.File]] 
  val checksums : sbt.SettingKey[scala.Seq[scala.Predef.String]] 
  val classifiersModule : sbt.TaskKey[sbt.GetClassifiersModule] 
  val conflictWarning : sbt.SettingKey[sbt.ConflictWarning] 
  val conflictManager : sbt.SettingKey[sbt.ConflictManager] 
  val autoScalaLibrary : sbt.SettingKey[scala.Boolean] 
  val managedScalaInstance : sbt.SettingKey[scala.Boolean] 
  val sbtResolver : sbt.SettingKey[sbt.Resolver] 
  val sbtDependency : sbt.SettingKey[sbt.ModuleID] 
  val sbtVersion : sbt.SettingKey[scala.Predef.String] 
  val sbtBinaryVersion : sbt.SettingKey[scala.Predef.String] 
  val skip : sbt.TaskKey[scala.Boolean] 
  val sessionVars : sbt.AttributeKey[sbt.SessionVar.Map] 
  val parallelExecution : sbt.SettingKey[scala.Boolean] 
  val tags : sbt.SettingKey[scala.Seq[scala.Tuple2[sbt.Tags.Tag, scala.Int]]] 
  val concurrentRestrictions : sbt.SettingKey[scala.Seq[sbt.Tags.Rule]] 
  val cancelable : sbt.SettingKey[scala.Boolean] 
  val settingsData : sbt.TaskKey[sbt.std.FullInstance.SS] 
  val streams : sbt.TaskKey[sbt.Keys.TaskStreams] 
  type TaskStreams = sbt.std.TaskStreams[sbt.Def.ScopedKey[_]]
  val isDummyTask : sbt.AttributeKey[scala.Boolean] 
  val taskDefinitionKey : sbt.AttributeKey[sbt.Def.ScopedKey[_]] 
  val executionRoots : sbt.TaskKey[scala.collection.Seq[sbt.Def.ScopedKey[_]]] 
  val dummyRoots : sbt.Task[scala.collection.Seq[sbt.Def.ScopedKey[_]]] 
  val state : sbt.TaskKey[sbt.State] 
  val dummyState : sbt.Task[sbt.State] 
  type Streams = sbt.std.Streams[sbt.Def.ScopedKey[_]]
  val streamsManager : sbt.TaskKey[sbt.Keys.Streams] 
  val dummyStreamsManager : sbt.Task[sbt.Keys.Streams] 
  val stateStreams : sbt.AttributeKey[sbt.Keys.Streams] 
  val resolvedScoped : sbt.SettingKey[sbt.Def.ScopedKey[_]] 
  val pluginData : sbt.TaskKey[sbt.PluginData] 
  private[sbt] final class TaskProgress(val progress : sbt.ExecuteProgress[sbt.Task]) extends scala.AnyRef {
  }
  private[sbt] val executeProgress : sbt.SettingKey[sbt.Keys.TaskProgress] 
  val triggeredBy : sbt.AttributeKey[scala.collection.Seq[sbt.Task[_]]] 
  val runBefore : sbt.AttributeKey[scala.collection.Seq[sbt.Task[_]]] 
  def dummy[T](name : scala.Predef.String, description : scala.Predef.String)(implicit evidence$1 : scala.Predef.Manifest[T]) : scala.Tuple2[sbt.TaskKey[T], sbt.Task[T]] 
  def dummyTask[T](name : scala.Predef.String) : sbt.Task[T] 
  def isDummy(t : sbt.Task[_]) : scala.Boolean 
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Git使用技巧</title>
                <link>http://freewind.in/posts/2757-git-skills</link>
                <pubDate>Fri, 12 Sep 2014 12:25:34 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2757</guid>
                <description><![CDATA[&lt;h2&gt;让&lt;code&gt;git status&lt;/code&gt;正常显示中文：&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git config --global core.quotepath false
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>让每一个窗口都有自己单独的command history</title>
                <link>http://freewind.in/posts/2756-let-each-window-have-its-own-command-history</link>
                <pubDate>Fri, 12 Sep 2014 12:17:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2756</guid>
                <description><![CDATA[&lt;p&gt;如果用的是&lt;code&gt;zsh&lt;/code&gt;，则在&lt;code&gt;~/.zshrc&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;export HISTCONTROL=ignoredups:erasedups  # no duplicate entries
export HISTSIZE=100000                   # big big history
export HISTFILESIZE=100000               # big big history
setopt extendedhistory                      # append to history, don&apos;t overwrite it

# Save and reload the history after each command finishes
export PROMPT_COMMAND=&quot;history -a; history -c; history -r; $PROMPT_COMMAND&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是&lt;code&gt;bash&lt;/code&gt;，则在&lt;code&gt;~/.bashrc&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;export HISTCONTROL=ignoredups:erasedups  # no duplicate entries
export HISTSIZE=100000                   # big big history
export HISTFILESIZE=100000               # big big history
shopt -s histappend                      # append to history, don&apos;t overwrite it

# Save and reload the history after each command finishes
export PROMPT_COMMAND=&quot;history -a; history -c; history -r; $PROMPT_COMMAND&quot;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Numbers and their stories - Number one</title>
                <link>http://freewind.in/posts/2755-numbers-and-their-stories-number-one</link>
                <pubDate>Mon, 08 Sep 2014 21:21:43 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2755</guid>
                <description><![CDATA[&lt;p&gt;Now, the VOA Special English program WORDS AND THEIR STORIES.&lt;/p&gt;
&lt;p&gt;Today I will tell about expressions using numbers. Let us start with the number one. Numbers can be tricky. &lt;strong&gt;On the one hand&lt;/strong&gt;, they are simply numbers. On the other hand, they have meanings. &lt;strong&gt;I for one&lt;/strong&gt; use these expressions a lot.&lt;/p&gt;
&lt;p&gt;Many people consider themselves &lt;strong&gt;number one&lt;/strong&gt;, the most important person. They are always &lt;strong&gt;looking out for number one&lt;/strong&gt; and &lt;strong&gt;taking care of number one&lt;/strong&gt;. It is as if they are the &lt;strong&gt;one and only&lt;/strong&gt; person on Earth. Some people however, are not so self-centered. My brother is such a person. It is true – no joke. I am not trying to &lt;strong&gt;pull a fast one&lt;/strong&gt; on you.&lt;/p&gt;
&lt;p&gt;First, you have to understand that my brother is &lt;strong&gt;one in a million&lt;/strong&gt;. He is such a nice person. All his friends like him. They consider him &lt;strong&gt;one of the boys&lt;/strong&gt;. Recently, my brother had a bad day at the office. It was just &lt;strong&gt;one of those days&lt;/strong&gt;. Nothing went right. So he stopped at a local bar &amp;ndash; a drinking place &amp;ndash; after leaving work. My brother planned to have a glass of beer with his friends &amp;ndash; a &lt;strong&gt;quick one&lt;/strong&gt; – before he went home. But a quick one turned into &lt;strong&gt;one or two&lt;/strong&gt;, and soon those became &lt;strong&gt;one too many&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;As my brother was leaving, he ordered a last drink &amp;ndash; &lt;strong&gt;one for the road&lt;/strong&gt;. His friends became concerned. &lt;strong&gt;One by one&lt;/strong&gt;, they asked him if he was able to drive home safely.&lt;/p&gt;
&lt;p&gt;Now my brother is a wise and calm person. He is &lt;strong&gt;at one with himself&lt;/strong&gt;. He recognizes when he has had too much alcohol to drink. So he accepted an offer for a ride home from a female friend.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;At one time in the past&lt;/strong&gt;, my brother had been in love with this woman. She is a great person &amp;ndash; kind, thoughtful and intelligent &amp;ndash; all good qualities &lt;strong&gt;rolled up into one&lt;/strong&gt;. But sadly their relationship did not work. He always used to say &amp;ldquo;&lt;strong&gt;One of these days&lt;/strong&gt;, I am going to marry this girl.&amp;rdquo; But that never happened.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For one thing&lt;/strong&gt;, she did not love him as much as he loved her. It was just &lt;strong&gt;one of those things&lt;/strong&gt;. The situation was regrettable and my brother had to accept it. But even now, he considers her &lt;strong&gt;the one that got away&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;However, they are still friends. And because my brother had been kind to her, she felt that &lt;strong&gt;one good turn deserves another&lt;/strong&gt;. He was good to her and she wanted to help him in return. So she drove him home.&lt;/p&gt;
&lt;p&gt;If my brother had driven home from the bar that night, his &lt;strong&gt;number would have been up&lt;/strong&gt;. Something bad would have happened. Thankfully he made it home safely. And, he and the woman are &lt;strong&gt;back to square one&lt;/strong&gt;. They are back to where they started – being friends.&lt;/p&gt;
&lt;p&gt;(MUSIC)&lt;/p&gt;
&lt;p&gt;This VOA Special English program, WORDS AND THEIR STORIES, was written by Jill Moss. I&apos;m Faith Lapidus.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;number would have been up&lt;/h2&gt;
&lt;p&gt;“完蛋”的意思。在本文的语境中，会首先让人想到“死”。如果在其它的语境中，会想到不同的意思。&lt;/p&gt;
&lt;p&gt;http://forum.thefreedictionary.com/postst39005_His-number-would-have-been-up-.aspx&lt;/p&gt;
&lt;h2&gt;back to square one&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;失败了重新回到起点&quot;的意思。没有确定的出处，下面的链接给了三种，并说“人们往往相信他们听到的第一种”。&lt;/p&gt;
&lt;p&gt;http://www.phrases.org.uk/meanings/back%20to%20square%20one.html&lt;/p&gt;
&lt;h2&gt;It&apos;s just one of those things&lt;/h2&gt;
&lt;p&gt;表示一些事件或者情况，是你无法解释、或者不喜欢，但同时也是无法改变的。&lt;/p&gt;
&lt;p&gt;http://dictionary.cambridge.org/dictionary/british/just-one-of-those-things&lt;/p&gt;
&lt;p&gt;没有确定的出处。对于老外来说，如果小孩问父母一些他们不想或者无法解释的问题时，他们可能会用这句话来敷衍。&lt;/p&gt;
&lt;p&gt;http://english.stackexchange.com/questions/195460/the-origin-of-its-just-one-of-those-things&lt;/p&gt;
&lt;p&gt;下面这首以它为标题的老歌，让这句话更加流行。&lt;/p&gt;
&lt;p&gt;Song: One of those things&lt;/p&gt;
&lt;p&gt;http://www.incognito.org.uk/lyrics/eleven/its-just-one-of-those-things&lt;/p&gt;
&lt;h2&gt;the one that got away&lt;/h2&gt;
&lt;p&gt;The mate from a past relationship or friendship who, in the present reality, seems the ideal match, if it weren&apos;t for some force beyond your control, fate or otherwise, keeping you apart.&lt;/p&gt;
&lt;p&gt;http://www.urbandictionary.com/define.php?term=The%20One%20That%20Got%20Away&lt;/p&gt;
&lt;h2&gt;one good turn deserves another&lt;/h2&gt;
&lt;p&gt;said when you do a helpful or kind act for someone who has done something good for you&lt;/p&gt;
&lt;p&gt;http://dictionary.cambridge.org/dictionary/british/one-good-turn-deserves-another&lt;/p&gt;
&lt;p&gt;good turn: A good deed; a thoughtful or selfless act.&lt;/p&gt;
&lt;h2&gt;at one with himself&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;有解释为“头脑冷静下来”，但是没有找到相应出处。下面有比较详细的讨论：&lt;/p&gt;
&lt;p&gt;https://uk.answers.yahoo.com/question/index?qid=20091114082455AA87YBS&lt;/p&gt;
&lt;h2&gt;one of the boys&lt;/h2&gt;
&lt;p&gt;a man who has been socially accepted into a group of other men&lt;/p&gt;
&lt;p&gt;http://www.audioenglish.org/dictionary/one_of_the_boys.htm&lt;/p&gt;
&lt;h2&gt;one of these days&lt;/h2&gt;
&lt;p&gt;One of these days at an uncertain time, usually of the future, rarely of the past; sooner or later&lt;/p&gt;
&lt;p&gt;http://www.finedictionary.com/One%20of%20these%20days.html&lt;/p&gt;
&lt;h2&gt;one of those days&lt;/h2&gt;
&lt;p&gt;a bad day, full of problems&lt;/p&gt;
&lt;h2&gt;look out for number one&lt;/h2&gt;
&lt;p&gt;If you look out for number one, you take care of yourself and your interests, rather than those of other people.&lt;/p&gt;
&lt;p&gt;http://www.usingenglish.com/reference/idioms/look+out+for+number+one.html&lt;/p&gt;
&lt;p&gt;http://en.wiktionary.org/wiki/look_out_for_number_one&lt;/p&gt;
&lt;p&gt;这里对number one的解释比较好： http://en.wiktionary.org/wiki/number_one&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;oneself, being considered foremost, as by an egoist (c.f. look out for number one)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;take care of number one&lt;/h2&gt;
&lt;p&gt;take care of oneself, look out for one&apos;s own interests&lt;/p&gt;
&lt;p&gt;http://idioms.thefreedictionary.com/take+care+of+number+one&lt;/p&gt;
&lt;h2&gt;for one&lt;/h2&gt;
&lt;p&gt;举例来说。一般用于，前面提到了多个原因之后，这里再提出一个原因。&lt;/p&gt;
&lt;p&gt;People often say “for one” when they mean “for one thing”: “I really want to go to the movie. For one, Kevin Spacey is my favorite actor.” (One what?) The only time you should use “for one” by itself to give an example of something is when you have earlier mentioned a class to which the example belongs: “There are a lot of reasons I don’t want your old car. For one, there are squirrels living in the upholstery.” (One reason.)&lt;/p&gt;
&lt;p&gt;http://public.wsu.edu/~brians/errors/forone.html&lt;/p&gt;
&lt;p&gt;还有一个解释：&lt;/p&gt;
&lt;p&gt;used to say that you think your opinion or action is right, even if others do not:
&lt;br  /&gt;The rest of you may disagree, but I, for one, think we should proceed with the plan.&lt;/p&gt;
&lt;h2&gt;pull a fast one&lt;/h2&gt;
&lt;p&gt;忽悠，糊弄，欺骗。大概是说手法很快欺骗了别人&lt;/p&gt;
&lt;p&gt;http://ell.stackexchange.com/questions/20650/what-is-the-origin-of-the-expression-pull-a-fast-one&lt;/p&gt;
&lt;p&gt;take unfair advantage by (rapid) action of some sort&lt;/p&gt;
&lt;p&gt;详细的讨论：http://wordoriginsorg.yuku.com/topic/9638/pull-a-fast-one#.VA3M-GS1apg&lt;/p&gt;
&lt;h2&gt;one for the road&lt;/h2&gt;
&lt;p&gt;上路前的最后一杯&lt;/p&gt;
&lt;p&gt;A final drink taken just before leaving on a journey.&lt;/p&gt;
&lt;p&gt;http://www.phrases.org.uk/meanings/270300.html&lt;/p&gt;
&lt;h2&gt;to have a quick one&lt;/h2&gt;
&lt;p&gt;在前面的链接中解释one for the road的时候提到的：&apos;a quick one&apos; refers to a one taken in haste&lt;/p&gt;
&lt;p&gt;to have a drink, usually an alcoholic drink, just before going somewhere:&lt;/p&gt;
&lt;p&gt;http://dictionary.cambridge.org/dictionary/british/quick-one&lt;/p&gt;
&lt;h2&gt;a quick one&lt;/h2&gt;
&lt;p&gt;似乎不光指喝酒，也指其它的“简短的”表达。&lt;/p&gt;
&lt;p&gt;http://forum.wordreference.com/showthread.php?t=1838615&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;一些不恰当的翻译&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;Now my brother is a wise and calm person. He is at one with himself. He recognizes when he has had too much alcohol to drink. So he accepted an offer for a ride home from a female friend.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这段话，在&lt;a href=&quot;http://www.51voa.com/VOA_Special_English/words-and-their-stories-number-one-44725_1.html&quot;&gt;这里&lt;/a&gt;有一些翻译，但是我觉得不太对：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;我弟弟是个非常聪明冷静的人，他头脑冷静下来，意识到自己喝了太多酒，因此他就接受了一个女性朋友的帮助，让她载他回家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译中用的是过去时态，说的是在那个时刻怎么样，实际上英文中用的都是&lt;code&gt;is&lt;/code&gt;，用来描述人的状态。特别是&lt;code&gt;He is at one with himself&lt;/code&gt;这一句，完全感觉不到有“冷静下来”的意思。&lt;/p&gt;
&lt;p&gt;我觉得应该翻译成这样：&lt;/p&gt;
&lt;p&gt;我弟弟是个非常聪明冷静的人。他是一个跟他自己非常和谐的人（这句话只能意会）。每当他喝多了的时候，他都能自己意识到。因此他就接受了一个女性朋友的帮助，让她载他回家。&lt;/p&gt;
&lt;p&gt;虽然这个翻译不太顺口，但是我觉得这样才是对的。&lt;/p&gt;
&lt;p&gt;http://ell.stackexchange.com/questions/33091/how-to-understand-he-is-at-one-with-himself/33099#33099&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在macbook自带键盘上跳转到IDEA编辑内容的开始和最后</title>
                <link>http://freewind.in/posts/2754-jump-to-idea-document-start-end-on-macbook-keyboard</link>
                <pubDate>Mon, 08 Sep 2014 17:54:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2754</guid>
                <description><![CDATA[&lt;p&gt;这似乎是一个非常简单的问题，但是我一直没有找到相应的快捷键：在macbook上使用IDEA，如何在笔记本自带的键盘上按快捷键，可以让光标跳到文档的最开始和最后？&lt;/p&gt;
&lt;p&gt;终于试出来了：&lt;/p&gt;
&lt;p&gt;最开始：&lt;kbd&gt;fn&lt;/kbd&gt; + &lt;kbd&gt;ctrl&lt;/kbd&gt; + &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;left arrow&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;最后：&lt;kbd&gt;fn&lt;/kbd&gt; + &lt;kbd&gt;ctrl&lt;/kbd&gt; + &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;right arrow&lt;/kbd&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>通过CSS属性解决动态高度的问题</title>
                <link>http://freewind.in/posts/2752-use-css-style-to-update-div-height-dynamic</link>
                <pubDate>Wed, 03 Sep 2014 00:16:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2752</guid>
                <description><![CDATA[&lt;p&gt;http://learnlayout.com/&lt;/p&gt;
&lt;p&gt;http://jsbin.com/pudiwikanoci/3/edit&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-08 月结</title>
                <link>http://freewind.in/posts/2751-month-2014-08</link>
                <pubDate>Sun, 31 Aug 2014 21:08:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2751</guid>
                <description><![CDATA[&lt;p&gt;这个月似乎比较平淡，因为一下子竟想不起来做了什么。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生病了两周，过得很晕乎&lt;/li&gt;
&lt;li&gt;尝试了一周的神仙水(MMS溶液)，没有坚持下去&lt;/li&gt;
&lt;li&gt;激动的away day&lt;/li&gt;
&lt;li&gt;博客搬家&lt;/li&gt;
&lt;li&gt;客户对我提了一个意见&lt;/li&gt;
&lt;li&gt;Greg离开了&lt;/li&gt;
&lt;li&gt;有了一个buddy菜同志&lt;/li&gt;
&lt;li&gt;年度体检&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;生病了两周，过得很晕乎&lt;/h2&gt;
&lt;p&gt;这个月项目压力很大，主要是因为我们主动担负起了向项目中添加前端框架的任务，对我们来说是一个考验。之前我虽然用过一段时间的angularjs，但真正用到项目中，并且要做好单元测试和集成测试，还是第一次。那两周很辛苦，虽然最终解决了所有问题，但可能太累了，感冒发烧了两周，晕晕乎乎的，同组的其他同事也陆续生病了。&lt;/p&gt;
&lt;p&gt;后来我们讨论了一下，感觉可能是我们单方面过于紧张。同事说我太拼了，走得太快，让他们也很累。所以后来我改变了方式，多向大家分享知识，大家一起进步，感觉好一些了。&lt;/p&gt;
&lt;h2&gt;尝试了一周的神仙水(MMS溶液)，没有坚持下去&lt;/h2&gt;
&lt;p&gt;在某一天，突然想起以前看过的一个关于某溶液的文章，又搜了出来，是一个批判MMS溶液的文章。然后我去搜了一下，在某宝上买了两瓶，试了一周，最后实在受不了味道，又没有感觉出什么效果，就放弃了。&lt;/p&gt;
&lt;p&gt;这是一种含氯的消毒液，据说其成分与人体免疫系统分泌出来的灭菌成分一样，在安全剂量中服用不会对身体有影响，但能杀灭体内的病毒。据说有很多人尝试过，治好了自己各种各样的毛病，让我很心动。&lt;/p&gt;
&lt;p&gt;可惜味道实在太重了，每小时喝一次，一天下来感觉喝了一整天的工业原料。一周过后，拉肚子的毛病没有任何变化，坚持不下去了。&lt;/p&gt;
&lt;h2&gt;激动的away day&lt;/h2&gt;
&lt;p&gt;本月最大事件是away day，全国的同事和全球的代表们都来到了西安，包了一个休闲山庄，过了一个周末。在周末里，我见到了很多平时难得一见的朋友，也认识了很多新同事，还听了几个session。其中shadow同学的猎头生活，为聋人提供帮助的心声的演讲，让我印象非常深刻。&lt;/p&gt;
&lt;p&gt;晚上在宾馆里，是我们的scala交流时间。我向两位同事展示了我们项目中的scala代码后，他们纷纷表示严重同情。我们的客户非常追求函数式风格的scala代码，scalaz的大量使用，让我们这边的团队压力很大。唯有努力提高我们的scala能力，才能赶上客户的脚步啊。&lt;/p&gt;
&lt;p&gt;还有一件激动的事情是跟我们公司的精神领袖Roy合了个影:) 坐在Roy身边，就感觉被他强大的气场笼罩着。我的英语水平很弱，连跟Roy打招呼都不会，希望下次再见到他时，能跟他拉几句家常。&lt;/p&gt;
&lt;p&gt;最后不能不提那个晚会。各种卖萌无底线的歌舞表演，实在太开心了。&lt;/p&gt;
&lt;h2&gt;博客搬家&lt;/h2&gt;
&lt;p&gt;这个月陆续收到了域名freewind.me和博客空间的续费通知。我用wordpress写博客很不爽，因为它对markdown支持不好，而我要经常贴代码，特别不方便。所以趁这个机会，把所有的博客转成了markdown，并手写了一些程序处理好了图片引用等，并且可以根据markdown写出的博客生成静态的页面。&lt;/p&gt;
&lt;p&gt;现在的博客已经转到了&lt;code&gt;http://freewind.github.io&lt;/code&gt;，写博客时完全使用markdown，感觉不错。&lt;/p&gt;
&lt;h2&gt;客户对我提了一个意见&lt;/h2&gt;
&lt;p&gt;我们的客户都是非常友好的人，说话特别委婉，对我们也很好。但是前些时间，他们对我提了一个意见，大意是说，他们觉得我对scala编程风格和重构代码的兴趣太大，没有把心思完全放到尽快交付功能上，希望我能先将就一下，先把功能搞定再说。&lt;/p&gt;
&lt;p&gt;故事起源一张卡，要在一个scala项目上添加一些功能。但是那个项目中的scala代码的组织方式以及一些函数实在让人难以理解，我跟pair看得快疯了。我们花了很多时间去理解这种风格和它的逻辑，也向客户那边的同事请教了一些问题，花了两天时间才看懂。&lt;/p&gt;
&lt;p&gt;以后还是要在这方面注意一下跟客户交流的问题。毕竟远程交流，又有语言障碍，有些事情会被放大。&lt;/p&gt;
&lt;h2&gt;Greg离开了&lt;/h2&gt;
&lt;p&gt;我们的组员，来自巴西的小伙子Greg在中国出差的时间满了，离开我们回去了。Greg是一个非常好的人，很喜欢开玩笑。他知道我英语不好，经常跟我聊天，虽然我每次都是结结巴巴的，但他一点也不介意。他也是我们团队跟客户交流的重要桥梁。希望下次还能再见到他，跟他一起挺开心的。&lt;/p&gt;
&lt;h2&gt;有一个buddy菜同志&lt;/h2&gt;
&lt;p&gt;项目来了一位来自上海的刚入职的新同事，我是他的buddy，这也是我第一次当别人的Buddy。希望能成为快乐的伙伴。&lt;/p&gt;
&lt;h2&gt;年度体检&lt;/h2&gt;
&lt;p&gt;又到了年度体检的时候了，去年因为出差错过了。结果还没拿到，但有一些小问题。我觉得还是因为体重和运动导致的，现在已经开始做一些改变了&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在scala中快速下载并保存某url的内容</title>
                <link>http://freewind.in/posts/2750-download-and-save-url-content-to-local</link>
                <pubDate>Sun, 31 Aug 2014 16:20:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2750</guid>
                <description><![CDATA[&lt;p&gt;在Java中获取某个url的内容并把它保存到本地，是一件非常繁琐的事情。&lt;/p&gt;
&lt;p&gt;而在scala的标准库中，它提供了一种很简洁的api：s&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import scala.sys.process._

new URL(&quot;http://google.com&quot;) #&amp;gt; new File(&quot;/tmp/google.html&quot;) !!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在新的scala版本中，上面的代码会有警告，可以写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;(new URL(&quot;http://google.com&quot;) #&amp;gt; new File(&quot;/tmp/google.html&quot;)).!!
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在mac上连接postgresql出现”/tmp/.s.PGSQL.5432″错误，无法连接</title>
                <link>http://freewind.in/posts/2746-cannot-connect-to-postgresql-tmp-s-pgsql-5432</link>
                <pubDate>Sun, 31 Aug 2014 13:59:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2746</guid>
                <description><![CDATA[&lt;p&gt;在mac上使用&lt;code&gt;psql&lt;/code&gt;命令连接postgresql，出现以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$&amp;gt; psql
psql: could not connect to server: Too many levels of symbolic links
Is the server running locally and accepting
connections on Unix domain socket “/tmp/.s.PGSQL.5432″?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反复搜索，卸载了又装，都解决不了问题，但是通过图形工具pgAdmin连接又一切正常。&lt;/p&gt;
&lt;p&gt;最后找到了这个解决办法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export PGHOST=localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就一切正常了。&lt;/p&gt;
&lt;p&gt;可以把它加入到&lt;code&gt;~/.bashrc&lt;/code&gt;中&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>前端培训(1)</title>
                <link>http://freewind.in/posts/2747-front-end-training</link>
                <pubDate>Mon, 18 Aug 2014 07:56:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2747</guid>
                <description><![CDATA[&lt;p&gt;npm + grunt + bower&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;node + npm&lt;/h2&gt;
&lt;h3&gt;install node&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;brew install node
npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;npm init&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;grunt&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm install grunt --save-dev
npm install -g grunt-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;grunt init&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;npm install grunt-init -g
git clone https://github.com/gruntjs/grunt-init-gruntfile.git ~/.grunt-init/gruntfile

grunt-init gruntfile
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-07 月结</title>
                <link>http://freewind.in/posts/2748-month-2014-07</link>
                <pubDate>Wed, 06 Aug 2014 21:00:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2748</guid>
                <description><![CDATA[&lt;p&gt;2014年7月，真是超级繁忙的一个月。这个月主要做了这几件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scala workshop持续进行中&lt;/li&gt;
&lt;li&gt;参加硬件技术大赛，展示了作品&quot;无敌方向键&amp;rdquo;&lt;/li&gt;
&lt;li&gt;对项目的scala代码进行了重构&lt;/li&gt;
&lt;li&gt;把前端框架AngularJs引入到项目中&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Scala workshop&lt;/h2&gt;
&lt;p&gt;Scala workshop参与的人越来越少，现在基本上只剩下几个有scala项目的组的人在参加。想想原因应该有这几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scala的学习门槛太高，如果没有强烈的学习兴趣或项目压力，基本上难以坚持&lt;/li&gt;
&lt;li&gt;组织经验不足，想当然的定出学习计划，到最后无法实施&lt;/li&gt;
&lt;li&gt;备课难度高，常常为了准备一节课，需要一整周的业余时间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过好在坚持下来的，都有强大的动力。所以还是要继续坚持下去&lt;/p&gt;
&lt;h2&gt;硬件技术大赛&lt;/h2&gt;
&lt;p&gt;由西安硬件小组举办的“硬件技术大赛”，终于开始了。我的作品是名为“无敌方向键”，是一个很小的硬件装置，可以放在键盘空格键的旁边，用拇指轻触来向上下左右四个方向移动光标。这里说的“光标”，是编辑文件时一闪一闪的那个竖条，而不是鼠标。&lt;/p&gt;
&lt;p&gt;想做这个东西，是因为平时写代码时，虽然已经做到了大多数时候通过快捷键可以让手指不离字母区，但移动光标时，还是不可避免的要让右手离开，向右移动按方向键。当看到西安硬件小组的session里，介绍可以用arduino这种开源的硬件开发板与电脑交互时，我想利用它来实现这个功能。&lt;/p&gt;
&lt;p&gt;最开始有多种方案，比如触摸屏、触摸条、轻触开关、滚轮、轨迹球等，但实现过程中，多数因为找不到合适的硬件而放弃，最后将黑莓手机的轨迹球改装了一下。当我们用手指轻触上面的小球时，它会在四条不同的线路中发送脉冲，Arduino通过我们编写的程序发送相应的方向键代码给电脑，就能操作光标的移动。&lt;/p&gt;
&lt;h2&gt;对项目的Scala代码进行重构&lt;/h2&gt;
&lt;p&gt;新的项目组中，各项目都是用scala做的，其代码存在一个比较大的问题：在一个共用的项目定义了一个abstract的入口类，定义了程序启动时的各种流程以及需要子类提供的配置，其它的项目都将继承并扩展它。&lt;/p&gt;
&lt;p&gt;这种做法有很大的问题，因为这个基类实际上已经是一个“考虑不周全的框架”了。子类只能在有限的扩展点上添加自己的代码，而无法改变预定义的流程。详细的问题将另写博客说明。&lt;/p&gt;
&lt;p&gt;经过跟客户的沟通，我跟一位有经验的同事一起，对它们进行了构重。我们去掉了共用项目中的子类，把它们分解成一个个独立的组件。在子项目中，程序的流程由子项目决定，只在需要的时候，从共用项目中挑选合适的组件拿过来用。重构之后，代码看起来比以前整洁很多。一位同事说“我看现在的代码，感觉到有一种美感”。&lt;/p&gt;
&lt;p&gt;这是我第一次对Scala项目做重构，收获很大。在这个过程中，深刻体会到了Scala类型系统的优势：项目中几乎所有的类都动了，包括很多测试类，但是当我修复了所有的编译错误后，居然一次性跑过了所有的测试，真有点不可思议。&lt;/p&gt;
&lt;h2&gt;项目中引入前端框架AngularJS&lt;/h2&gt;
&lt;p&gt;项目有越来越多的代码需要由Javascript在前端进行操作了。我们讨论了两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继续使用jQuery、underscore这种工具库操作，不采用框架（如backbone）&lt;/li&gt;
&lt;li&gt;采用AngularJS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后决定使用AngularJS。我和另一位同事有过使用这的经验，倾向于它。&lt;/p&gt;
&lt;p&gt;但引入前端框架，实际上是引入了整个工具链。各种依赖管理、单元测试和集成测试，这一套东西弄下来，是一条相当长的链子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;npm - 各种开发时需要的库的管理&lt;/li&gt;
&lt;li&gt;grunt - 构建工具&lt;/li&gt;
&lt;li&gt;bower - 页面和测试中需要的库的管理&lt;/li&gt;
&lt;li&gt;AnguarJS - 前端框架&lt;/li&gt;
&lt;li&gt;Karma - 主要用来跑单元测试&lt;/li&gt;
&lt;li&gt;Protactor - 主要用来跑e2e测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了把这一套跑通，花了大量的精力。为了不耽误其它同事的工作，我必须冲在最前面，把所有遇到的坑都填平。好消息是，基本上所有的坑都填平了，坏消息是我病了一场。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;繁忙但是非常有收获的一个月&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>快速理解RequireJs</title>
                <link>http://freewind.in/posts/2741-understand-requirejs-quickly</link>
                <pubDate>Tue, 29 Jul 2014 00:49:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2741</guid>
                <description><![CDATA[&lt;p&gt;RequireJs已经流行很久了，我们在项目中也打算使用它。它提供了以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明不同js文件之间的依赖&lt;/li&gt;
&lt;li&gt;可以按需、并行、延时载入js库&lt;/li&gt;
&lt;li&gt;可以让我们的代码以模块化的方式组织&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;初看起来并不复杂。&lt;/p&gt;
&lt;h2&gt;在html中引入requirejs&lt;/h2&gt;
&lt;p&gt;在HTML中，添加这样的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;/path/to/require.js&quot; data-main=&quot;/path/to/app/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常使用requirejs的话，我们只需要导入requirejs即可，不需要显式导入其它的js库，因为这个工作会交给requirejs来做。&lt;/p&gt;
&lt;p&gt;属性&lt;code&gt;data-main&lt;/code&gt;是告诉requirejs：你下载完以后，马上去载入真正的入口文件。它一般用来对requirejs进行配置，并且载入真正的程序模块。&lt;/p&gt;
&lt;h2&gt;在config.js中配置requirejs&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;config.js&lt;/code&gt;中通常用来做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置requirejs 比如项目中用到哪些模块，文件路径是什么&lt;/li&gt;
&lt;li&gt;载入程序主模块&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    app: &apos;app&apos;
  }
});

requirejs([&apos;app&apos;], function(app) {
  app.hello();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;paths&lt;/code&gt;中，我们声明了一个名为&lt;code&gt;app&lt;/code&gt;的模块，以及它对应的js文件地址。在最理想的情况下，&lt;code&gt;app.js&lt;/code&gt;的内容，应该使用requirejs的方式来定义模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([], function() {
  return {
    hello: function() {
      alert(&quot;hello, app~&quot;);
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;define&lt;/code&gt;是requirejs提供的函数。requirejs一共提供了两个全局变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;requirejs/require: 用来配置requirejs及载入入口模块。如果其中一个命名被其它库使用了，我们可以用另一个&lt;/li&gt;
&lt;li&gt;define: 定义一个模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外还可以把&lt;code&gt;require&lt;/code&gt;当作依赖的模块，然后调用它的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([&quot;require&quot;], function(require) {
    var cssUrl = require.toUrl(&quot;./style.css&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;依赖一个不使用requirejs方式的库&lt;/h2&gt;
&lt;p&gt;前面的代码是理想的情况，即依赖的js文件，里面用了&lt;code&gt;define(...)&lt;/code&gt;这样的方式来组织代码的。如果没用这种方式，会出现什么情况？&lt;/p&gt;
&lt;p&gt;比如这个&lt;code&gt;hello.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function hello() {
  alert(&quot;hello, world~&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它就按最普通的方式定义了一个函数，我们能在requirejs里使用它吗？&lt;/p&gt;
&lt;p&gt;先看下面不能正确工作的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    hello: &apos;hello&apos;
  }
});

requirejs([&apos;hello&apos;], function(hello) {
  hello();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码会报错，提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Uncaught TypeError: undefined is not a function 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是最后调用&lt;code&gt;hello()&lt;/code&gt;的时候，这个&lt;code&gt;hello&lt;/code&gt;是个&lt;code&gt;undefined&lt;/code&gt;. 这说明，虽然我们依赖了一个js库（它会被载入），但requirejs无法从中拿到代表它的对象注入进来供我们使用。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们要使用&lt;code&gt;shim&lt;/code&gt;，将某个依赖中的某个全局变量暴露给requirejs，当作这个模块本身的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    hello: &apos;hello&apos;
  },
  shim: {
    hello: { exports: &apos;hello&apos; }
  }
});

requirejs([&apos;hello&apos;], function(hello) {
  hello();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再运行就正常了。&lt;/p&gt;
&lt;p&gt;上面代码&lt;code&gt;exports: &apos;hello&apos;&lt;/code&gt;中的&lt;code&gt;hello&lt;/code&gt;，是我们在&lt;code&gt;hello.js&lt;/code&gt;中定义的&lt;code&gt;hello&lt;/code&gt;函数。当我们使用&lt;code&gt;function hello() {}&lt;/code&gt;的方式定义一个函数的时候，它就是全局可用的。如果我们选择了把它&lt;code&gt;export&lt;/code&gt;给requirejs，那当我们的代码依赖于&lt;code&gt;hello&lt;/code&gt;模块的时候，就可以拿到这个&lt;code&gt;hello&lt;/code&gt;函数的引用了。&lt;/p&gt;
&lt;p&gt;所以：&lt;code&gt;exports&lt;/code&gt;可以把某个非requirejs方式的代码中的某一个全局变量暴露出去，当作该模块以引用。&lt;/p&gt;
&lt;h3&gt;暴露多个变量：init&lt;/h3&gt;
&lt;p&gt;但如果我要同时暴露多个全局变量呢？比如，&lt;code&gt;hello.js&lt;/code&gt;的定义其实是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function hello() {
  alert(&quot;hello, world~&quot;);
}
function hello2() {
  alert(&quot;hello, world, again~&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它定义了两个函数，而我两个都想要。&lt;/p&gt;
&lt;p&gt;这时就不能再用&lt;code&gt;exports&lt;/code&gt;了，必须换成&lt;code&gt;init&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    hello: &apos;hello&apos;
  },
  shim: {
    hello: {
      init: function() {
        return {
          hello: hello,
          hello2: hello2
        }
      }
    }
  }
});

requirejs([&apos;hello&apos;], function(hello) {
  hello.hello1();
  hello.hello2();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;exports&lt;/code&gt;与&lt;code&gt;init&lt;/code&gt;同时存在的时候，&lt;code&gt;exports&lt;/code&gt;将被忽略。&lt;/p&gt;
&lt;h2&gt;无主的与有主的模块&lt;/h2&gt;
&lt;p&gt;我遇到了一个折腾我不少时间的问题：为什么我只能使用&lt;code&gt;jquery&lt;/code&gt;来依赖jquery, 而不能用其它的名字？&lt;/p&gt;
&lt;p&gt;比如下面这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    myjquery: &apos;lib/jquery/jquery&apos;
  }
});

requirejs([&apos;myjquery&apos;], function(jq) {
  alert(jq);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会提示我：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jq is undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但我仅仅改个名字：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    jquery: &apos;lib/jquery/jquery&apos;
  }
});

requirejs([&apos;jquery&apos;], function(jq) {
  alert(jq);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就一切正常了，能打印出&lt;code&gt;jq&lt;/code&gt;相应的对象了。&lt;/p&gt;
&lt;p&gt;为什么？我始终没搞清楚问题在哪儿。&lt;/p&gt;
&lt;h3&gt;有主的模块&lt;/h3&gt;
&lt;p&gt;经常研究，发现原来在jquery中已经定义了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define(&apos;jquery&apos;, [], function() { ... });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它这里的&lt;code&gt;define&lt;/code&gt;跟我们前面看到的&lt;code&gt;app.js&lt;/code&gt;不同，在于它多了第一个参数&lt;code&gt;&apos;jquery&apos;&lt;/code&gt;，表示给当前这个模块起了名字&lt;code&gt;jquery&lt;/code&gt;，它已经是有主的了，只能属于&lt;code&gt;jquery&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;所以当我们使用另一个名字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myjquery: &apos;lib/jquery/jquery&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去引用这个库的时候，它会发现，在&lt;code&gt;jquery.js&lt;/code&gt;里声明的模块名&lt;code&gt;jquery&lt;/code&gt;与我自己使用的模块名&lt;code&gt;myjquery&lt;/code&gt;不能，便不会把它赋给&lt;code&gt;myjquery&lt;/code&gt;，所以&lt;code&gt;myjquery&lt;/code&gt;的值是&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以我们在使用一个第三方的时候，一定要注意它是否声明了一个确定的模块名。&lt;/p&gt;
&lt;h3&gt;无主的模块&lt;/h3&gt;
&lt;p&gt;如果我们不指明模块名，就像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([...], function() {
  ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么它就是无主的模块。我们可以在&lt;code&gt;requirejs.config&lt;/code&gt;里，使用任意一个模块名来引用它。这样的话，就让我们的命名非常自由，大部分的模块就是无主的。&lt;/p&gt;
&lt;h3&gt;为什么有的有主，有的无主&lt;/h3&gt;
&lt;p&gt;可以看到，无主的模块使用起来非常自由，为什么某些库（jquery, underscore）要把自己声明为有主的呢？&lt;/p&gt;
&lt;p&gt;按某些说法，这么做是出于性能的考虑。因为像&lt;code&gt;jquery&lt;/code&gt;, &lt;code&gt;underscore&lt;/code&gt;这样的基础库，经常被其它的库依赖。如果声明为无主的，那么其它的库很可能起不同的模块名，这样当我们使用它们时，就可能会多次载入jquery/underscore。&lt;/p&gt;
&lt;p&gt;而把它们声明为有主的，那么所有的模块只能使用同一个名字引用它们，这样系统就只会载入它们一次。&lt;/p&gt;
&lt;h3&gt;挖墙角&lt;/h3&gt;
&lt;p&gt;对于有主的模块，我们还有一种方式可以挖墙角：不把它们当作满足requirejs规范的模块，而当作普通js库，然后在&lt;code&gt;shim&lt;/code&gt;中导出它们定义的全局变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    myjquery: &apos;lib/jquery/jquery&apos;
  },
  shim: {
    myjquery: { exports: &apos;jQuery&apos; }
  }
});

requirejs([&apos;myjquery&apos;], function(jq) {
  alert(jq);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样通过暴露&lt;code&gt;jQuery&lt;/code&gt;这个全局变量给&lt;code&gt;myjquery&lt;/code&gt;，我们就能正常的使用它了。&lt;/p&gt;
&lt;p&gt;不过我们完全没有必要这么挖墙角，因为对于我们来说，似乎没有任何好处。&lt;/p&gt;
&lt;h2&gt;如何完全不让jquery污染全局的$&lt;/h2&gt;
&lt;p&gt;在前面引用jquery的这几种方式中，我们虽然可以以模块的方式拿到jquery模块的引用，但是还是可以在任何地方使用全局变量&lt;code&gt;jQuery&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;。有没有办法让jquery完全不污染这两个变量？&lt;/p&gt;
&lt;h3&gt;在init中调用noConflict (无效)&lt;/h3&gt;
&lt;p&gt;首先尝试一种最简单但是不工作的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    jquery: &apos;lib/jquery/jquery&apos;
  },
  shim: {
    jquery: {
      init: function() {
        return jQuery.noConflict(true);
      }
    }
  }
});

requirejs([&apos;jquery&apos;], function(jq) {
  alert($);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样是不工作的，还是会弹出来一个非&lt;code&gt;undefined&lt;/code&gt;的值。其原因是，一旦requirejs为模块名&lt;code&gt;jquery&lt;/code&gt;找到了属于它的模块，它就会忽略&lt;code&gt;shim&lt;/code&gt;中相应的内容。也就是说，下面这段代码完全没有执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jquery: {
  init: function() {
    return jQuery.noConflict(true);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用另一个名字&lt;/h3&gt;
&lt;p&gt;如果我们使用挖墙角的方式来使用jquery，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    myjquery: &apos;lib/jquery/jquery&apos;
  },
  shim: {
    myjquery: {
      init: function() {
        return jQuery.noConflict(true);
      }
    }
  }
});

requirejs([&apos;myjquery&apos;], function(jq) {
  alert($);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的确有效，这时弹出来的就是一个&lt;code&gt;undefined&lt;/code&gt;。但是这样做的问题是，如果我们引用的某个第三方库还是使用&lt;code&gt;jquery&lt;/code&gt;来引用jquery，那么就会报“找不到模块”的错了。&lt;/p&gt;
&lt;p&gt;我们要么得手动修改第三方模块的代码，要么再为它们提供一个&lt;code&gt;jquery&lt;/code&gt;模块。但是使用后者的话，全局变量&lt;code&gt;$&lt;/code&gt;可能又重新被污染了。&lt;/p&gt;
&lt;h3&gt;使用map&lt;/h3&gt;
&lt;p&gt;如果我们有办法能让在继续使用&lt;code&gt;jquery&lt;/code&gt;这个模块名的同时，有机会调用&lt;code&gt;jQuery.noConflict(true)&lt;/code&gt;就好了。&lt;/p&gt;
&lt;p&gt;我们可以再定义一个模块，仅仅为了执行这句代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jquery-private.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([&apos;jquery&apos;], function(jq) {
  return jQuery.noConflict(true);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在入口处先调用它:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    jquery: &apos;lib/jquery/jquery&apos;,
    &apos;jquery-private&apos;: &apos;jquery-private&apos;
  }
});

requirejs([&apos;jquery-private&apos;, &apos;jquery&apos;], function() {
  alert($);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的确可行，但是还是会有问题： 我们必须小心的确保&lt;code&gt;jquery-private&lt;/code&gt;永远是第一个被依赖，这样它才有机会尽早调用&lt;code&gt;jQuery.noConflict(true)&lt;/code&gt;清除全局变量&lt;code&gt;$&lt;/code&gt;和&lt;code&gt;jQuery&lt;/code&gt;。这种保证只能靠人，非常不可靠。&lt;/p&gt;
&lt;p&gt;我们这时可以引入&lt;code&gt;map&lt;/code&gt;配置，一劳永逸地解决这样问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    jquery: &apos;lib/jquery/jquery&apos;,
    &apos;jquery-private&apos;: &apos;jquery-private&apos;
  },
  map: {
    &apos;*&apos;: { &apos;jquery&apos;: &apos;jquery-private&apos;},
    &apos;jquery-private&apos;: { &apos;jquery&apos;: &apos;jquery&apos;}
  }
});

requirejs([&apos;jquery&apos;], function(jq) {
  alert($);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做，就解决了前面的问题：在除了jquery-private之外的任何依赖中，还可以直接使用&lt;code&gt;jqurey&lt;/code&gt;这个模块名，并且总是被替换为对&lt;code&gt;jquery-private&lt;/code&gt;的依赖，使得它最先被执行。&lt;/p&gt;
&lt;h2&gt;合并&lt;/h2&gt;
&lt;p&gt;在开发过程中，我们常常会创建很多个小js文件，每个文件一个module。这样在开发时比较方便，但在产品环境中，会导致浏览器下载很多次，性能比较慢。为了解决这个问题，requirejs提供了一个叫r.js的工具，可以把多个文件合并成一个或者少数几个。&lt;/p&gt;
&lt;p&gt;这样自然而然就会有一个疑问：它们是怎么合并的？仅仅是把两个文件的内容原封不动的合并在一起吗？如果是这样的话，会有问题。&lt;/p&gt;
&lt;p&gt;比如，我之前有两个js文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([], function() {
  return &quot;aaa&quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;b.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([], function() {
  return &quot;bbb&quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它们合并以后，如果是这样的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;one.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([], function() {
  return &quot;aaa&quot;;
});
define([], function() {
  return &quot;bbb&quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那我们引用这个文件时，到底用的是哪个模块呢？&lt;/p&gt;
&lt;p&gt;Requirejs聪明的解决了这个问题。它并不是原封不动的合并，而是根据我们在使用每个模块时给的命名，自动加到每个模块的定义处。假设我们分别通过module &lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;去引用这两个文件的话，上面合并后的代码实际是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define(&apos;a&apos;, [], function() {
  return &quot;aaa&quot;;
});
define(&apos;b&apos;, [], function() {
  return &quot;bbb&quot;;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就算有再多的模块放在同一个文件中，我们也能准确的拿到某一个模块。&lt;/p&gt;
&lt;p&gt;TODO: grunt的示例&lt;/p&gt;
&lt;h2&gt;bundles&lt;/h2&gt;
&lt;p&gt;当一个文件中定义了多个模块（或者如前一个例子中所示，多个模块文件合并在同一个文件之后），我们可能不太清楚一个文件中到底有多少个模块，也无法控制哪些模块是我们想用的。&lt;/p&gt;
&lt;p&gt;requirejs又提供了一个叫&lt;code&gt;bundles&lt;/code&gt;的功能。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;require.config({
  paths: {
    mybundleSet: &apos;one&apos;
  },
  bundles: {
    mybundleSet: [&apos;a&apos;, &apos;b&apos;]
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里我们在&lt;code&gt;paths&lt;/code&gt;中，通过&lt;code&gt;mybundleSet&lt;/code&gt;引用了&lt;code&gt;one.js&lt;/code&gt;文件。这个&lt;code&gt;one.js&lt;/code&gt;里包含了多个模块，所以在后面的&lt;code&gt;bundles&lt;/code&gt;配置中，我们又声明将使用其中的&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;两个模块。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;one.js&lt;/code&gt;中缺少&lt;code&gt;a&lt;/code&gt;或&lt;code&gt;b&lt;/code&gt;，代码会出错。如果有其它的模块，但没有在&lt;code&gt;bundles&lt;/code&gt;中声明，也是没有办法使用的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Grunt + Bower + Requirejs + Angular</title>
                <link>http://freewind.in/posts/2739-grunt-bower-requirejs-angular</link>
                <pubDate>Sun, 27 Jul 2014 22:08:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2739</guid>
                <description><![CDATA[&lt;p&gt;现在web开发的趋势是前后端分离。前端采用某些js框架，后端采用某些语言提供restful API，两者以json格式进行数据交互。&lt;/p&gt;
&lt;p&gt;如果后端采用node.js，则前后端可以使用同一种语言，共享某些可重用的Js代码，并共享构建工具。但很多时候我们可能采用别的语言，如ruby/java/scala等，此时前后端代码基本上是完全独立的。虽然大家都在同一个项目中，但可以分成互相独立的两块，并且前后端通常使用不同的构建工具。&lt;/p&gt;
&lt;p&gt;比如当后端使用Scala时，我们会使用sbt进行项目构建，对scala代码进行编译、测试、打包等。它的专长是处理与scala相关的任务，但对于前端的支持比较弱。前端一些常见的任务，如js库的下载和管理、css文件的转换、js文件合并压缩、js测试的执行等，很难在sbt中找到好用的插件，而利用js世界里的工具来做反而更加方便一些。&lt;/p&gt;
&lt;p&gt;我们项目组这几天正在讨论是否在项目中引入一些前端框架，还是直接用原生Javascript写。经过反复讨论和调研，最终决定引入AngularJs。但AngularJs的引入并不是单一的任务，因为我们还需要考虑前端代码的测试、依赖管理等，都需要有相应的工具支持，所以最后引入了这么一整套工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Grunt - Js任务管理工具，通过各种插件对项目进行各种操作，比如文件转换、运行测试、打包部署等。相当于java里的ant/maven/gradle，ruby中的rack，scala中的sbt。&lt;/li&gt;
&lt;li&gt;Bower - Js库依赖管理工具。当你需要jquery时，不需要手动下载，只需要执行&lt;code&gt;bower install jquery&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RequireJs - Js库加载管理，及模块化支持。可以按需及并行加载js库，可以把我们的代码以模块化的方式组织。&lt;/li&gt;
&lt;li&gt;AngularJs - Js前端框架，支持依赖注入，双向绑定等我认为很重要的功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这套东西都是比较基础且使用比较广泛的。一般一旦在项目中引入前端框架，或者需要写比较多的Js代码时，我们都会采用它们，所以很有必要学习并掌握它们。&lt;/p&gt;
&lt;h2&gt;各工具都相当的独立&lt;/h2&gt;
&lt;p&gt;在开始前，需要先提示一下，在javascript的世界里，很多东西都是由社区提供的，所以每一种工具都相当独立。比如，很多工具都有着自己独立的配置文件，自己的命令行参数，有时候还需要有一些额外的插件把两个工具结合起来。&lt;/p&gt;
&lt;p&gt;所以下面将会有很多比较琐碎的命令，我们需要一一了解。不过好在我们一旦了解了，下次就可以使用已经配置好的文件，通过几条命令将把有的东西都准备好，很方便。&lt;/p&gt;
&lt;h2&gt;安装nodejs&lt;/h2&gt;
&lt;p&gt;在Mac中，我们可以使用brew来安装。在其它系统下，请使用相应的工具或直接到官网下载。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nodejs可以让我们在服务器端使用javascript编程，它是很多js工具的基础。如果你已经安装，请确保使用最新版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew upgrade node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我这里显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v0.10.28
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;npm&lt;/h2&gt;
&lt;p&gt;Npm是node官方提供的包依赖管理工具。我们下面使用的grunt等，都是以插件形式下载安装的。&lt;/p&gt;
&lt;p&gt;当我们安装好nodejs后，&lt;code&gt;npm&lt;/code&gt;就自动可用了。&lt;/p&gt;
&lt;p&gt;查看版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我这里显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.0.0-alpha-5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;创建项目目录&lt;/h2&gt;
&lt;p&gt;下面我们从零开始，首先在任意位置新建一个目录作为我们的项目根目录，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir ~/myproject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后进入该目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/myproject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面的命令都将在项目根目录下操作。&lt;/p&gt;
&lt;h2&gt;为npm创建package.json&lt;/h2&gt;
&lt;p&gt;首先我们需要为npm提供一个&lt;code&gt;package.json&lt;/code&gt;，告诉它我们的项目信息，特别是项目中将会使用的插件。我们不需要手动创建，因为可以直接调用以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会问我们一些问题，我们可以按需回答，也可以全部使用默认值，反正以后可以改起来也很容易。&lt;/p&gt;
&lt;p&gt;最后将会产生如下的&lt;code&gt;package.json&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
  &quot;name&quot;: &quot;grunt-bower-angular-demo&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/freewind/grunt-bower-angular-demo.git&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;BSD&quot;,
  &quot;bugs&quot;: {
    &quot;url&quot;: &quot;https://github.com/freewind/grunt-bower-angular-demo/issues&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于像我们这样的非nodejs项目来说，里面的大部分内容都没用，可以删掉大部分，只剩下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
  &quot;name&quot;: &quot;grunt-bower-angular-demo&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装 grunt&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm install grunt --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将使用npm下载grunt插件，它们将保存到项目根目录下的&lt;code&gt;node_components&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;后面的&lt;code&gt;--save-dev&lt;/code&gt;参数是说，把这个插件信息，同时添加到&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;devDependencies&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&quot;devDependencies&quot;: {
  &quot;grunt&quot;: &quot;~0.4.5&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于grunt仅在开发阶段使用，所以使用&lt;code&gt;--save-dev&lt;/code&gt;。如果是运行时使用的，则用&lt;code&gt;--save&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;安装 grunt-cli&lt;/h2&gt;
&lt;p&gt;上面安装的&lt;code&gt;grunt&lt;/code&gt;并不包含命令行工具，我们还需安装相应的&lt;code&gt;grunt-cli&lt;/code&gt;，才能在命令行中调用&lt;code&gt;grunt&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install grunt-cli -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后面的&lt;code&gt;-g&lt;/code&gt;是说，把&lt;code&gt;grunt-cli&lt;/code&gt;安装成全局工具，以便在任意目录下使用。&lt;/p&gt;
&lt;p&gt;安装后，输入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grunt --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我这里显示为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grunt-cli v0.1.13
grunt v0.4.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在比较少的情况下，可能提示找不到grunt，则需要根据安装grunt-cli时的提示信息，把相应的路径添加到&lt;code&gt;PATH&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo PATH=$PATH:/your/path/to/grunt &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;为grunt创建配置文件Gruntfile.js&lt;/h2&gt;
&lt;h3&gt;安装grunt-init&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;npm install grunt-init -g
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;下载grunt模板&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/gruntjs/grunt-init-gruntfile.git ~/.grunt-init/gruntfile
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;生成Gruntfile&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;grunt-init gruntfile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据需要回答问题，或者使用默认值，将得到以下&lt;code&gt;Gruntfile.js&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;/*global module:false*/
module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    // Metadata.
    pkg: grunt.file.readJSON(&apos;package.json&apos;),
    banner: &apos;/*! &amp;lt;%= pkg.title || pkg.name %&amp;gt; - v&amp;lt;%= pkg.version %&amp;gt; - &apos; +
      &apos;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt;\n&apos; +
      &apos;&amp;lt;%= pkg.homepage ? &quot;* &quot; + pkg.homepage + &quot;\\n&quot; : &quot;&quot; %&amp;gt;&apos; +
      &apos;* Copyright (c) &amp;lt;%= grunt.template.today(&quot;yyyy&quot;) %&amp;gt; &amp;lt;%= pkg.author.name %&amp;gt;;&apos; +
      &apos; Licensed &amp;lt;%= _.pluck(pkg.licenses, &quot;type&quot;).join(&quot;, &quot;) %&amp;gt; */\n&apos;,
    // Task configuration.
    concat: {
      options: {
        banner: &apos;&amp;lt;%= banner %&amp;gt;&apos;,
        stripBanners: true
      },
      dist: {
        src: [&apos;lib/&amp;lt;%= pkg.name %&amp;gt;.js&apos;],
        dest: &apos;dist/&amp;lt;%= pkg.name %&amp;gt;.js&apos;
      }
    },
    uglify: {
      options: {
        banner: &apos;&amp;lt;%= banner %&amp;gt;&apos;
      },
      dist: {
        src: &apos;&amp;lt;%= concat.dist.dest %&amp;gt;&apos;,
        dest: &apos;dist/&amp;lt;%= pkg.name %&amp;gt;.min.js&apos;
      }
    },
    jshint: {
      options: {
        curly: true,
        eqeqeq: true,
        immed: true,
        latedef: true,
        newcap: true,
        noarg: true,
        sub: true,
        undef: true,
        unused: true,
        boss: true,
        eqnull: true,
        browser: true,
        globals: {
          jQuery: true
        }
      },
      gruntfile: {
        src: &apos;Gruntfile.js&apos;
      },
      lib_test: {
        src: [&apos;lib/**/*.js&apos;, &apos;test/**/*.js&apos;]
      }
    },
    qunit: {
      files: [&apos;test/**/*.html&apos;]
    },
    watch: {
      gruntfile: {
        files: &apos;&amp;lt;%= jshint.gruntfile.src %&amp;gt;&apos;,
        tasks: [&apos;jshint:gruntfile&apos;]
      },
      lib_test: {
        files: &apos;&amp;lt;%= jshint.lib_test.src %&amp;gt;&apos;,
        tasks: [&apos;jshint:lib_test&apos;, &apos;qunit&apos;]
      }
    }
  });

  // These plugins provide necessary tasks.
  grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-qunit&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);

  // Default task.
  grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;qunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]);

};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它里面已经包含了一些常用的插件，比如&lt;code&gt;grunt-contrib-jshint&lt;/code&gt;等，我们可根据需要删减一些用不上的。&lt;/p&gt;
&lt;p&gt;它同时还会在&lt;code&gt;package.json&lt;/code&gt;里添加上这些插件的依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&quot;grunt-contrib-concat&quot;: &quot;~0.4.0&quot;,
&quot;grunt-contrib-jshint&quot;: &quot;~0.10.0&quot;,
&quot;grunt-contrib-qunit&quot;: &quot;~0.5.2&quot;,
&quot;grunt-contrib-uglify&quot;: &quot;~0.5.0&quot;,
&quot;grunt-contrib-watch&quot;: &quot;~0.6.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些插件还未下载，如果需要，可以运行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把它们下载到本地&lt;/p&gt;
&lt;h2&gt;bower&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;npm install bower -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
  &quot;engines&quot;: {
    &quot;node&quot;: &quot;&amp;gt;= 0.10.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.5&quot;,
    &quot;grunt-contrib-jshint&quot;: &quot;~0.10.0&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.6.1&quot;,
    &quot;grunt-contrib-qunit&quot;: &quot;~0.5.2&quot;,
    &quot;grunt-contrib-concat&quot;: &quot;~0.4.0&quot;,
    &quot;grunt-contrib-uglify&quot;: &quot;~0.5.0&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装bower&lt;/h2&gt;
&lt;p&gt;bower跟npm在某种意义上相似，它是用来管理常用的js库的依赖的，比如jquery, underscore, angularjs等。&lt;/p&gt;
&lt;p&gt;我们可以通过npm安装它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install bower -g
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把它装为全局工具&lt;/p&gt;
&lt;h2&gt;为bower生成配置文件bower.json&lt;/h2&gt;
&lt;p&gt;bower也有它自己的配置文件&lt;code&gt;bower.json&lt;/code&gt;，我们不需要手动创建。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bower init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会生成如下的&lt;code&gt;bower.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
  &quot;name&quot;: &quot;grunt-bower-angular-demo&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;homepage&quot;: &quot;https://github.com/freewind/grunt-bower-angular-demo&quot;,
  &quot;authors&quot;: [
    &quot;Peng Li &amp;lt;nowind_lee@qq.com&amp;gt;&quot;
  ],
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;ignore&quot;: [
    &quot;**/.*&quot;,
    &quot;node_modules&quot;,
    &quot;bower_components&quot;,
    &quot;test&quot;,
    &quot;tests&quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于我们的项目来说，里面的东西基本上都没用。有用的是后面将会出现的&lt;code&gt;dependencies&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;下载requirejs、jquery、angularjs&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;bower insall requirejs --save
bower insall jquery --save
bower install angularjs --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将会自动下载jquery到angularjs相应的文件，到项目根目录下的&lt;code&gt;bower_components&lt;/code&gt;目录。并在&lt;code&gt;bower.json&lt;/code&gt;中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&quot;dependencies&quot;: {
  &quot;angularjs&quot;: &quot;~1.2.20&quot;,
  &quot;jquery&quot;: &quot;~2.1.1&quot;,
  &quot;requirejs&quot;: &quot;~2.1.14&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;安装grunt-bower-task&lt;/h2&gt;
&lt;p&gt;bower只负责把依赖下载到本地的&lt;code&gt;bower_components&lt;/code&gt;目录，并不负责把它们拷贝到我们项目中实际使用的地方，比如&lt;code&gt;public/js/lib&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;为了实现这样的功能，我们还需要另一个插件的帮助：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install grunt-bower-task --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后打开其文档：https://www.npmjs.org/package/grunt-bower-task ，按照上面的提示进行配置。&lt;/p&gt;
&lt;p&gt;首先在&lt;code&gt;Gruntfile&lt;/code&gt;中合适位置添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grunt.loadNpmTasks(&apos;grunt-bower-task&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;grunt.initConfig({...})&lt;/code&gt;参数中，添加相应的配置项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;bower: {
    install: {
      options: {
        targetDir: &apos;./public/js/lib&apos;,
        layout: &apos;byComponent&apos;,
        install: true,
        verbose: false,
        cleanTargetDir: false,
        cleanBowerDir: false,
        bowerOptions: {}
      }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里指定拷贝的目标目录为&lt;code&gt;public/js/lib&lt;/code&gt;，且文件按照模块分成单个目录(byComponent)。如果想把所有的js放在同一个目录，所有的css文件放在同一个目录，则使用&lt;code&gt;byType&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;关于RequireJs&lt;/h2&gt;
&lt;p&gt;在前面我们已经使用bower安装了requirejs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bower install requirejs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RequireJs可用来管理页面中使用的js库之间的依赖关系，可以按需、并行、延迟加载js库。同时它可以让我们以模块化的形式组织js代码。&lt;/p&gt;
&lt;p&gt;强烈建议先了解RequireJs的运行原理再动手写代码，不然肯定会遇到各种坑。RequireJs的文档写得有点绕，可参考我的另一篇文章：TODO&lt;/p&gt;
&lt;h2&gt;配置RequireJs&lt;/h2&gt;
&lt;p&gt;前面我们第三方的依赖，通过grunt-bower-task拷贝到了&lt;code&gt;public/js/lib&lt;/code&gt;目录下。我们自己写的js，将会放置在&lt;code&gt;public/js&lt;/code&gt;目录下。&lt;/p&gt;
&lt;p&gt;我们需要手动创建一个&lt;code&gt;config.js&lt;/code&gt;文件，用来配置和初始化requirejs。&lt;/p&gt;
&lt;h3&gt;在HTML中引入requirejs&lt;/h3&gt;
&lt;p&gt;如果我们使用了requirejs，则在HTML中，我们通常只需要一个&lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;标签引入requirejs并指定入口文件即可，而不需要写多个&lt;code&gt;script&lt;/code&gt;标签手动加载其它js文件。&lt;/p&gt;
&lt;p&gt;在HTML中合适位置加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;/public/js/lib/requirejs/require.js&quot; data-main=&quot;/public/js/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里首先加载了require.js，并通过&lt;code&gt;data-main&lt;/code&gt;属性告诉requirejs：当你加载完以后，请加载config.js文件进行初始化。&lt;/p&gt;
&lt;h3&gt;config.js&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;config.js&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;requirejs.config({
  baseUrl: &apos;/public/js&apos;,
  paths: {
    app: &apos;app&apos;,
    jquery: &apos;lib/jquery/jquery&apos;,
    angular: &apos;lib/angularjs/angular&apos;
  },
  shim: {
  }
});

requirejs([&apos;app&apos;], function(app) {
  app.hello();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;paths&lt;/code&gt;中声明了几个模块，其中的&lt;code&gt;app&lt;/code&gt;是我们自己创建的js文件，用于放我们自己的业务代码，它对应于&lt;code&gt;/public/js/app.js&lt;/code&gt;. &lt;code&gt;jquery&lt;/code&gt;与&lt;code&gt;angular&lt;/code&gt;对应的文件是我们使用grunt-bower-task拷贝过来的第三方js库。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shim&lt;/code&gt;中用来处理一些没有遵守requirejs规范的js库，比如&lt;code&gt;underscore&lt;/code&gt;之类。可在里面对它们进行一些依赖声明、初始化操作等。这里暂时用不上。&lt;/p&gt;
&lt;p&gt;最后用&lt;code&gt;requirejs&lt;/code&gt;来导入我们自己的模块，可在后面的callback中拿到对应模块的实例，并对它进行一些操作，比如我们调用了&lt;code&gt;app.hello()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3&gt;app.js&lt;/h3&gt;
&lt;p&gt;为了让这个例子完整，我们可以定义相应的&lt;code&gt;app.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([], function() {
  return {
    hello: function() {
      alert(&quot;hello, requirejs&quot;);
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;index.html&lt;/h3&gt;
&lt;p&gt;为了能让例子跑起来，我们还需要创建一个&lt;code&gt;public/index.html&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;script src=&quot;/public/js/lib/requirejs/require.js&quot; 
          data-main=&quot;/public/js/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;Hello, world!&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;启动 web server&lt;/h3&gt;
&lt;p&gt;进入项目根目录，运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grunt bower
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把bower下载的js库拷贝到&lt;code&gt;public/js/lib&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;然后启动web server:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后打开浏览器，访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://localhost:8000/public/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一切正常的话，会看到弹出一个提示框，上面内容为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hello, requirejs
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Angularjs&lt;/h2&gt;
&lt;p&gt;然后我们做一个简单的angular的例子。&lt;/p&gt;
&lt;p&gt;由于angularjs并不是按requirejs的模块方式组织代码的，我们需要在&lt;code&gt;config.js&lt;/code&gt;中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;shim: {
    angular : { exports : &apos;angular&apos;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Angularjs会在全局域中添加一个名为&lt;code&gt;angular&lt;/code&gt;的变量。我们必须在&lt;code&gt;shim&lt;/code&gt;中显式把它暴露出来，才能通过模块注入的方式使用它，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([&apos;angular&apos;], function(ng) {
  // we can use argument `ng` instead of gloabl `angular` now
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;在index.html中添加angular代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;div ng-controller=&quot;MyController&quot;&amp;gt;
  &amp;lt;input type=&quot;text&quot; ng-model=&quot;name&quot; /&amp;gt;
  &amp;lt;span&amp;gt;{{name}}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;准备相应的controller&lt;/h3&gt;
&lt;p&gt;把&lt;code&gt;app.js&lt;/code&gt;的内容改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;define([&apos;angular&apos;], function(angular) {
  angular.module(&apos;myApp&apos;, [])
      .controller(&apos;MyController&apos;, [&apos;$scope&apos;, function ($scope) {
        $scope.name = &apos;Change the name&apos;;
      }]);

    angular.element(document).ready(function() {
      angular.bootstrap(document, [&apos;myApp&apos;]);
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段代码里，我定义了一个angularjs自己的模块&lt;code&gt;myApp&lt;/code&gt;，以及相应的&lt;code&gt;MyController&lt;/code&gt;。在后面，通过&lt;code&gt;angular.bootstrap&lt;/code&gt;方法，把该模块与&lt;code&gt;document&lt;/code&gt;结合在了一起。&lt;/p&gt;
&lt;p&gt;启动web server，就可以看到效果了。当我们修改了页面上输入框里的内容，它旁边的文字也会跟着改变。&lt;/p&gt;
&lt;h2&gt;修改angularjs的占位符&lt;/h2&gt;
&lt;p&gt;在html中显示angularjs里的一个字段时，我们使用&lt;code&gt;{{}}&lt;/code&gt;来占位，比如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{{name}}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我们同时使用了mustcahe模板，就会有冲突。我们可以更改angularjs的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;angular.module(&apos;myApp&apos;, []).config(function($interpolateProvider){
        $interpolateProvider.startSymbol(&apos;[[&apos;).endSymbol(&apos;]]&apos;);
    }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们就可以写成：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[[name]]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;了.&lt;/p&gt;
&lt;h2&gt;项目代码&lt;/h2&gt;
&lt;p&gt;上面的操作，都在这个项目中： &lt;a href=&quot;https://github.com/freewind/grunt-bower-angular-demo&quot;&gt;https://github.com/freewind/grunt-bower-angular-demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外，关于requirejs/angularjs的结合使用，可以参看这个比较好的样板项目： &lt;a href=&quot;https://github.com/tnajdek/angular-requirejs-seed&quot;&gt;https://github.com/tnajdek/angular-requirejs-seed&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;guxiangguo&lt;/h3&gt;
&lt;p&gt;可以使用sbt-web，提供了很多支持前端处理的plugin。&lt;/p&gt;
&lt;h3&gt;laoweiyeah&lt;/h3&gt;
&lt;p&gt;why not yeoman?&lt;/p&gt;
&lt;h4&gt;我&lt;/h4&gt;
&lt;p&gt;刚看了一下yeoman，似乎它的最大特色是模板功能吧？我们是在一个已有的后端项目中添加前端框架，需要小心的控制每一步，以保证不破坏已有功能。&lt;/p&gt;
&lt;h3&gt;zackyang&lt;/h3&gt;
&lt;p&gt;一直不知道, 相对于uglify把js打包成一个文件而言, RequireJs在加载时到底是提升了性能还是降低了性能. 如果不使用uglify压缩, 我们有非常多的module, 分散的js文件可能超过100个.&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>为什么Nil的类型是List[Nothing]，而不是List[Any]</title>
                <link>http://freewind.in/posts/2737-why-type-of-nil-is-list-nothing-not-list-any</link>
                <pubDate>Wed, 23 Jul 2014 21:50:24 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2737</guid>
                <description><![CDATA[&lt;p&gt;今天在做scala workshop讲到Nil的类型时，杜娟提了一个很好的问题：为什么Nil的类型是List[Nothing]，而不是List[Any]&lt;/p&gt;
&lt;p&gt;首先看Nil的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case object Nil extends List[Nothing] {
  ..
}


对于Scala的List来说，它是不可变的，不会往里面添加东西。这样的话，它的类型是List[Nothing]还是List[Any]似乎都没什么区别才对。

让我们从类型系统方面考虑一下，很快就能知道原因。

我们定义一个List的时候，可以使用这样的方式：

val list = 1 :: 2 :: Nil


它实际上等于：

val list = Nil.::(2).::(1)


让我们看一下`::`的定义（简化了）：

class List[+A] {
  def ::[B &amp;gt;: A] (x: B): List[B] =
    new scala.collection.immutable.::(x, this)
}


再看一下`immutable.::`的定义：

case class ::[B](hd: B, tl: List[B])


可见`::[B]`中B的类型，将由传入的两个参数`hd`和`tl`的公共父类决定。如果Nil继承自List[Any]，那么：

Nil.::(1)


即：

::(1, Nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的类型，将是&lt;code&gt;Int&lt;/code&gt;和&lt;code&gt;Any&lt;/code&gt;的父类，即&lt;code&gt;Any&lt;/code&gt;。这样的话，我们不论怎么写，都只能得到List[Any]类型的List，显然是没有意义的。&lt;/p&gt;
&lt;p&gt;但反过来，如果Nil继承自List[Nothing]，由于Nothing是任意类型的子类，所以它与另一个类型的公共父类型总是另一个类型，所以我们就可以轻易由另一个类型来确定List的类型了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala workshop – Collections(1) – List</title>
                <link>http://freewind.in/posts/2735-scala-workshop-collections-1-list</link>
                <pubDate>Wed, 23 Jul 2014 17:45:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2735</guid>
                <description><![CDATA[&lt;hr /&gt;
&lt;p&gt;layout: reveal&lt;/p&gt;
&lt;h2&gt;title: Scala Workshop &amp;#8212; Collections(1)&lt;/h2&gt;
&lt;h1&gt;Collection&lt;/h1&gt;
&lt;p&gt;List&lt;/p&gt;
&lt;p&gt;// Set/Map &amp;amp; Tuple/Option &amp;amp; Array&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Scala为什么重写集合库&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Java中已经提供了一套强大的集合库，比如List/Set/Map等等&lt;/li&gt;
&lt;li&gt;JVM上一些其它的面向对象语言，如Groovy/Xtend/Kotlin等等，都是直接或间接使用Java的集合类库&lt;/li&gt;
&lt;li&gt;但Scala不但不用，还自己重写了两套：一套&quot;不可变&quot;的，一套&quot;可变的&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3&gt;Scala为什么要&quot;重新造轮子&amp;rdquo;？&lt;/h3&gt;
&lt;hr /&gt;
&lt;h2&gt;三个原因&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Scala最初希望同时运行于Java和.net平台，所以需要尽量保持独立，不要与Java的类库产生太多交集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scala是一门面向对象+函数式的语言，而函数式语言追求&quot;不可变的数据类型&amp;rdquo;，而Java的类库都是可变的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scala的类型系统与Java不同&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中的集合类不支持协变/逆变&lt;/li&gt;
&lt;li&gt;Scala早期甚至不支持Java的泛型（后来加入&quot;存在类型&amp;rdquo;）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;引申小知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Scala.net 被官方废弃 &lt;a href=&quot;https://github.com/magarciaEPFL/scaladotnet&quot;&gt;https://github.com/magarciaEPFL/scaladotnet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但IKVM (&lt;a href=&quot;http://ikvm.net&quot;&gt;http://ikvm.net&lt;/a&gt;) 在.net上实现了一套JVM，可以运行Java程序&lt;/li&gt;
&lt;li&gt;scala.js 正在蓬勃发展中 &lt;a href=&quot;http://lihaoyi.github.io/roll/&quot;&gt;http://lihaoyi.github.io/roll/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3&gt;Scala同时提供了两套集合库:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不可变：&lt;code&gt;scala.collection.immutable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可变： &lt;code&gt;scala.collection.mutable&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;我们通常都应该使用&amp;rdquo;&lt;strong&gt;不可变&lt;/strong&gt;&amp;#8220;的&lt;/h2&gt;
&lt;hr /&gt;
&lt;h2&gt;scala._&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package object scala {
  type List[+A] = scala.collection.immutable.List[A]
  val List = scala.collection.immutable.List

  val Nil = scala.collection.immutable.Nil

  type ::[A] = scala.collection.immutable.::[A]
  val :: = scala.collection.immutable.::
}


* * *

## List api快速浏览

* * *

## 创建普通List：

val list = List(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)
val list2 = List(1,2,3,4,5,6,7)


* * *

其它方式：

List.range(1, 5)  // List(1,2,3,4,5)
(1 to 5).toList   //  List(1,2,3,4,5)
List.fill(5)(&apos;a&apos;)  // List(&apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;, &apos;a&apos;)


* * *

## 创建空List:

val list = List()
val list = List[String]()
val list2 = List.empty[String]
Nil


* * *

## 基本操作

val list = List(1,2,3,4)

list.head // 1
list.headOption // Some(1)
list.tail // List(2,3,4)
list.init // List(1,2,3)
list.last // 4
list.lastOption // Some(4)

list(0) // 1
list.apply(0) // 1
list.length // 4
list.size // 4
list.isEmpty // false
list.reverse // List(4,3,2,1)


* * *

## 更多操作

val list = List(5,6,7,8)

list.drop(2)      // List(7,8)
list.take(3)       // List(5,6,7)
list.splitAt(2)   // (List(5,6),List(7,8))
list.indices      // Range(0, 1, 2, 3)
list.takeWhile (_ &amp;lt; 7)    // List(5,6)
list.dropWhile (_%2==1)   // List(6, 7,8)


* * *

&amp;amp;nbsp;

1 :: List(2,3,4)
1 :: 2 :: 3 :: 4 :: Nil

List(1,2,3) :+ 4 
List(1,2) ::: List(3,4)

List(1,2,3).mkString(&quot;,&quot;) // 1,2,3
List(1,2,3).mkString(&quot;[&quot;,&quot;,&quot;,&quot;]&quot;) // [1,2,3]


* * *

&amp;amp;nbsp;

List(5,6,7).zip(List(0,1,2))   // List((5,0), (6,1), (7,2))
List((5,0), (6,1), (7,2)).unzip   // (List(5, 6, 7),List(0, 1, 2))
List(5,6,7).zipWithIndex    // List((5,0), (6,1), (7,2))


* * *

&amp;amp;nbsp;

List(1, 2, 3) map (_ + 1)
List(1, 2, 3) map (x =&amp;gt; x + 1)
List(1,2,3).map(x =&amp;gt; List(x,x))   // List(List(1,1), List(2,2), List(3,3))
List(List(5,6), List(7,8)).flatten() // List(5,6,7,8)
List(1,2,3).map(x =&amp;gt; List(x,x)).flatten   // List(1,1,2,2,3,3)
List(1,2,3).flatMap(x =&amp;gt; List(x,x))    // List(1,1,2,2,3,3)


* * *

&amp;amp;nbsp;

List(1,2,3) foreach { num =&amp;gt; println(&quot;Num is: &quot; + num) }
List(1, 2, 3, 4, 5) filter (_ % 2 == 0)          // List(2, 4)
List(1, 2, 3, 4, 5) partition (_ % 2 == 0)    // (List(2, 4),List(1, 3, 5))
List(1,2,3,4,5) find (_%2==0)             // Some(2)
List(1, 2, 3, 4, 5) find (_ &amp;lt;= 0)             // None
List(1, 2, 3, -4, 5) span (_ &amp;gt; 0)  // (List(1, 2, 3),List(-4, 5))
List(1,2,3,4,5,6).groupBy(_ % 3) // Map(2 -&amp;gt; List(2, 5), 1 -&amp;gt; List(1, 4), 0 -&amp;gt; List(3, 6))
List(1,2,3,4,5).grouped(2).toList // List(List(1, 2), List(3, 4), List(5))


* * *

&amp;amp;nbsp;

List(1,2,3).forall(_&amp;gt;0)  // true
List(1,2,3).exists(_&amp;lt;0)  // false
List(1,2,3).foldLeft(10)(_+_) // 16
(10 /: List(1,2,3))(_+_) // 16
List(1,2,3).foldRight(10)(_+_) // 16
(List(1,2,3) :\ 10)(_+_) // 16
&quot;abcde&quot; sortWith (_ &amp;gt; _) // edcba


* * *

## 问题1: 看懂创建List

* * *

### val list = List(&amp;amp;#8220;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)

* * *

等价于

val list = List.apply(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)


所以`List`是一个`object`

* * *

### List可能是一个单独的`object`：

object List {
    def apply[T](items: T*) = ???
}


* * *

### 或者是一个`case class`

（编译器将会生成一个`object`）

case class List[T](items: T*)


* * *

&amp;amp;nbsp;

case class List[T](items: T*)


等价于：

class List[T](items: T*)
object List {
    def apply[T](items: T*) = ???
}


* * *

## Scala用的是哪一种？

object List {
    def apply[T](items: T*) = ???
}


因为它需要定义很多帮助方法，并且还有一个对应的`trait List`

* * *

## 问题2: 关于List类型的推断

* * *

## List[String]

val list = List(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)


* * *

## List[Int]

val list2 = List(111,222,333)


* * *

## List[Any]

val list3 = List(111,&quot;bbb&quot;)


* * *

## 指定类型

val list = List.empty[String]
// List[String]


* * *

## 它的类型呢？

val list4 = List()


* * *

## List[Nothing]

val list1 = List.empty
val list2 = List()


* * *

## `Nil`，等价于`List()`

其定义为：

object Nil extends List[Nothing]


* * *

### 它们可以赋给任意类型的List:

val list:List[String]  = List.empty

val list2:List[Int] = Nil


* * *

## 为什么可以赋值?
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Nothing&lt;/code&gt;是任意类型的子类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;List[T]&lt;/code&gt;是协变的 (&lt;code&gt;List[+T]&lt;/code&gt;)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题3: 理解List的协变&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;协变记法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;List[+T]&lt;/code&gt;，其中的&lt;code&gt;+&lt;/code&gt;表示&lt;code&gt;List&lt;/code&gt;相对于&lt;code&gt;T&lt;/code&gt;是协变的&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;协变的性质&lt;/h3&gt;
&lt;p&gt;对于协变的&lt;code&gt;List[+T]&lt;/code&gt;，当&lt;code&gt;C&lt;/code&gt;是&lt;code&gt;P&lt;/code&gt;的子类型时，则&lt;code&gt;List[C]&lt;/code&gt;是&lt;code&gt;List[P]&lt;/code&gt;的子类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;子类型定义&lt;/h3&gt;
&lt;p&gt;由子类型定义（是什么？）得知：需要&lt;code&gt;List[P]&lt;/code&gt;的地方，我们总是可以用&lt;code&gt;List[C]&lt;/code&gt;的实例代替&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;所以，我们总是能把:&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;List[String]&lt;/code&gt;的实例赋给&lt;code&gt;List[Any]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;List[Nothing]&lt;/code&gt;的实例赋给任意的&lt;code&gt;List[T]&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;通常&lt;strong&gt;不可变&lt;/strong&gt;的泛型，都可以声明为协变的（这里不讲）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题4: 向&quot;大List&quot;尾巴多次添加数据效率很低&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;val bigList = (1 to 1000000).toList&lt;/p&gt;
&lt;p&gt;向尾巴依次添加从1到1000这些数&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;直接在尾巴添加：&lt;/p&gt;
&lt;p&gt;(1 to 1000).foldLeft(bigList) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case (list, item) =&amp;gt; list :+ item
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;共用时&lt;strong&gt;15349ms&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;先反转、在前面添加、再反转&lt;/h3&gt;
&lt;p&gt;(1 to 1000).foldLeft(bigList.reverse) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case (list, item) =&amp;gt; item :: list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}.reverse&lt;/p&gt;
&lt;p&gt;共用时&lt;strong&gt;47ms&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;换个思路（从前面加）&lt;/h2&gt;
&lt;p&gt;bigList.foldRight(List.range(1,1001)) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case (item, list) =&amp;gt; item :: list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;共用时&lt;strong&gt;89ms&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;留个问题，请认领&lt;/h2&gt;
&lt;p&gt;为什么从前面加效率很高，从后面加效率很低？&lt;/p&gt;
&lt;p&gt;(请下节课用代码、图解等方式，为大家讲解这个问题)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;提示：List是不可变的链表结构&lt;/h3&gt;
&lt;p&gt;class List[T](head:T, tail: List[T])&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题5: 列表的匹配&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;List&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;val list = List(1,2,3)&lt;/p&gt;
&lt;p&gt;list match {
&lt;br  /&gt;case List(a,b,c) =&gt; println(s&amp;rdquo;${a} ~ ${b} ~ ${c}&amp;ldquo;)
&lt;br  /&gt;}
&lt;br  /&gt;//{1} ~ {2} ~ {3}&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;使用&lt;code&gt;::&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;val list = List(1,2,3)&lt;/p&gt;
&lt;p&gt;list match {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;case head :: tail =&amp;gt; println(s&quot;${head} ~ ${tail}&quot;)
case _ =&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;// 1 ~ List(2, 3)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;赋值时匹配&lt;/h3&gt;
&lt;p&gt;val List(a, b, c) = List(1,2,3)
&lt;br  /&gt;// a==1, b==2, c==3&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;两种方式使用&lt;code&gt;::&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;val ::(a, tail) = List(1,2,3)
&lt;br  /&gt;// a==1, tail==List(2,3)&lt;/p&gt;
&lt;p&gt;val a :: tail = List(1,2,3)
&lt;br  /&gt;// a==1, tail==List(2,3)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;如何理解&lt;code&gt;::&lt;/code&gt;?&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;举个例子&lt;/h3&gt;
&lt;p&gt;case class Hello(a:String, b:String)&lt;/p&gt;
&lt;p&gt;Hello(&amp;ldquo;aaa&amp;rdquo;, &amp;ldquo;bbb&amp;rdquo;) match {
&lt;br  /&gt;case Hello(a,b) =&gt; println(a + &amp;ldquo;: &quot; + b)
&lt;br  /&gt;}
&lt;br  /&gt;// aaa: bbb&lt;/p&gt;
&lt;p&gt;Hello(&amp;ldquo;aaa&amp;rdquo;, &amp;ldquo;bbb&amp;rdquo;) match {
&lt;br  /&gt;case a Hello b =&gt; println(a + &amp;ldquo;: &quot; + b)
&lt;br  /&gt;}
&lt;br  /&gt;// aaa: bbb&lt;/p&gt;
&lt;p&gt;(把这里的&lt;code&gt;Hello&lt;/code&gt;替换为&lt;code&gt;::&lt;/code&gt;即可)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;中缀类型&lt;/h3&gt;
&lt;p&gt;trait Hello[A,B]&lt;/p&gt;
&lt;p&gt;def world: Hello[String, Int] = ???
&lt;br  /&gt;// world: Hello[String,Int]&lt;/p&gt;
&lt;p&gt;def anotherWorld: String Hello Int  = ???
&lt;br  /&gt;// anotherWorld: Hello[String,Int]&lt;/p&gt;
&lt;p&gt;（跟pattern matching无关）&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;pattern matching时的中缀表达&lt;/h3&gt;
&lt;p&gt;object Hello {
&lt;br  /&gt;def unapply(s:String):Option[(String, String)] = ???
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&amp;ldquo;hello&amp;rdquo; match {
&lt;br  /&gt;case a Hello b =&gt; println(a + &amp;ldquo;: &quot; + b)
&lt;br  /&gt;}&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;如果参数&gt;2&lt;/h3&gt;
&lt;p&gt;object Hello {
&lt;br  /&gt;def unapply(s:String):Option[(String, String, String)] = ???
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&amp;ldquo;hello&amp;rdquo; match {
&lt;br  /&gt;case a Hello (b,c) =&gt; println(a + &amp;ldquo;: &quot; + b + &amp;ldquo;: &quot; + c)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;通常用作中缀的objec名称，都是操作符，比如&lt;code&gt;::&lt;/code&gt;, &lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;再看一遍&lt;code&gt;::&lt;/code&gt;&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;创建List&lt;/h3&gt;
&lt;p&gt;val list = 1 :: 2 :: 3 :: Nil&lt;/p&gt;
&lt;h3&gt;模式匹配：&lt;/h3&gt;
&lt;p&gt;list match {
&lt;br  /&gt;case a :: b :: Nil =&gt;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;list match {
&lt;br  /&gt;case ::(a, b) =&gt;
&lt;br  /&gt;}&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;这三个&lt;code&gt;::&lt;/code&gt;是不是同一个&lt;code&gt;::&lt;/code&gt;?&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3&gt;方法List.::&lt;/h3&gt;
&lt;p&gt;1 :: 2 :: 3 :: Nil&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;abstract class List[+A] {
&lt;br  /&gt;def ::[B &gt;: A] (x: B): List[B] =&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new scala.collection.immutable.::(x, this)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;右结合&lt;/h2&gt;
&lt;p&gt;1 :: (2 :: (3 :: Nil))&lt;/p&gt;
&lt;p&gt;Nil.::(3).::(2).::(1)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;case class ::&lt;/h3&gt;
&lt;p&gt;case a :: b :: Nil =&gt;
&lt;br  /&gt;case ::(a, b) =&gt;&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;final case class ::[B](private var hd: B, private[scala] var tl: List[B]) extends List[B] {    … }&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题6： 哪个能匹配上？&lt;/h2&gt;
&lt;p&gt;List(1,2) match {
&lt;br  /&gt;case a :: b :: Nil =&gt;
&lt;br  /&gt;case a :: b =&gt;
&lt;br  /&gt;case ::(a, b) =&gt;
&lt;br  /&gt;}&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;这个呢&lt;/h3&gt;
&lt;p&gt;List(1,2,3) match {
&lt;br  /&gt;case a :: b :: Nil =&gt;
&lt;br  /&gt;case a :: b =&gt;
&lt;br  /&gt;case ::(a, b) =&gt;
&lt;br  /&gt;}&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;等价&lt;/h2&gt;
&lt;p&gt;a :: b == :: (a, b)
&lt;br  /&gt;a :: b :: Nil == :: (a, ::(b, Nil))&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题7：无法匹配, why?&lt;/h2&gt;
&lt;p&gt;val List(a, tail) = List(1,2,3)&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;如何找线索&lt;/h2&gt;
&lt;p&gt;case class User(name:String, friends: Seq[String])&lt;/p&gt;
&lt;p&gt;user match {
&lt;br  /&gt;case User(n, fs) =&gt;
&lt;br  /&gt;}
&lt;br  /&gt;// 这里fs一定是Seq[String]类型&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;通过unapply的返回值&lt;/h2&gt;
&lt;p&gt;object Hello {
&lt;br  /&gt;def unapply(s:String): Option[(String, List[String])] = ???
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&amp;ldquo;some-words&amp;rdquo; match {
&lt;br  /&gt;case Hello(a,b) =&gt;
&lt;br  /&gt;}
&lt;br  /&gt;// b 一定是 List[String]&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;List的线索在哪里？&lt;/h2&gt;
&lt;p&gt;val List(a, tail) = List(1,2,3)&lt;/p&gt;
&lt;p&gt;// 将会调用
&lt;br  /&gt;List.unapplySeq(List(1,2,3))&lt;/p&gt;
&lt;p&gt;// 并根据其返回值类型与List(a,tail)匹配&lt;/p&gt;
&lt;p&gt;// unapplySeq定义
&lt;br  /&gt;def unapplySeq[A](x: Seq[A]): Option[Seq[A]] = Some(x)&lt;/p&gt;
&lt;p&gt;// 其返回值中包含的还是Seq[A]&lt;/p&gt;
&lt;p&gt;线索似乎断了~&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;线索就是unapplySeq&lt;/h2&gt;
&lt;p&gt;scala规范中规定了，对于&lt;/p&gt;
&lt;p&gt;def unapplySeq(…):Option[Seq[A]]&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;匹配有两种规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;List(a,b) 表示匹配一个长度为2的List，a为第一个元素，b为第二个&lt;/li&gt;
&lt;li&gt;List(a,b@_*) 表示匹配一个长度&gt;1的list，a为第一个元素，b为后面全部&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;更多问题，欢迎大家领取：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;Map&lt;/li&gt;
&lt;li&gt;Tuple&lt;/li&gt;
&lt;li&gt;Option&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;li&gt;前面的为什么List右边插数据比左边慢？&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala热情workshop: 结对实践课马上要开始了，你来吗？</title>
                <link>http://freewind.in/posts/2732-scala-workshop-pair-practise</link>
                <pubDate>Mon, 07 Jul 2014 20:28:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2732</guid>
                <description><![CDATA[&lt;p&gt;西安办公室的&amp;laquo;Scala热情workshop&amp;raquo;已经开始三周了，经历了感性介绍、基础概念串讲、在线习题讲解之后，将于本周正式进入结对实践。有些同学可能对scala也感兴趣，但由于种种原因没有参加完前面的课，现在想参加的话还来得及吗？&lt;/p&gt;
&lt;p&gt;答案是没问题！&lt;/p&gt;
&lt;p&gt;因为前几节实践课，要实现的功能都是极简单的。我们把功能分解成了一个个极小的任务，并且会结对编程，还有现场指导，都可以帮助你尽快上手。当然，如果真的有兴趣，还是希望能先看一下Scala方面的书籍，比如《快学Scala》，《Scala编程》等书。&lt;/p&gt;
&lt;h2&gt;前三课节的回顾&lt;/h2&gt;
&lt;p&gt;Scala热情workshop已经开了三周，每周一节课。我们先回顾一下这几节课做了什么，让没有完全参加的同学知道自己错过了什么。&lt;/p&gt;
&lt;p&gt;第一节课是“感性认识”。任小君同学以简单的代码，展示了scala中一些与众不同、独具魅力的特性；张锦文同学以生动的图片展示了一下scala类型系统中的协变、逆变；李鹏同学讲述了Scala初学者对它的一些认识上的误区。&lt;/p&gt;
&lt;p&gt;第二节课是“基础概念”的串讲。Scala相对于Java等语言，更加偏学术一些，里面有很多基础的概念，如果没有理解清楚（或者不知道它们的存在），在后面的学习中很容易卡住。所以李鹏同学在一开始，就把这些概念（如class, type, subtype）等串讲了一遍，让大家先对它们有一些印象，然后在以后的实践中有获得更深刻的认识。&lt;/p&gt;
&lt;p&gt;第三节课是“习题讲解”课。在前两节课的课余，我们实现了一个简陋的scala在线做题网站（shuzu.org)，里面布置了几道题目，绝大部分同学在这节课前都完成了。这节课里，我们对大家的答案进行了讲解，找出其中的优缺点。最后，我们讨论了如何开始真正的实践课。&lt;/p&gt;
&lt;h2&gt;实践课的内容、计划&lt;/h2&gt;
&lt;h3&gt;实践课的内容&lt;/h3&gt;
&lt;p&gt;以shuzu.org的功能为蓝本，通过“分story”，“结对开发”，“代码Review”，“CI构建部署”，这些与我们日常工作相似的方式，让大家在尽量真实的环境中学习和使用scala，从中找到一些好的scala实践，可以直接应用到未来的项目开发中。&lt;/p&gt;
&lt;h3&gt;模块划分&lt;/h3&gt;
&lt;p&gt;我们把整体功能划分为五个单独的模块，其中有四个以micro service的方式提供服务，另一个通过对它们的调用组装成最终的网站。&lt;/p&gt;
&lt;p&gt;五个模块的描述如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;题库管理： 对题库进行管理，可添加、修改、删除、查看题目。该模块独立部署，以restful api的方式向外提供接口。&lt;/li&gt;
&lt;li&gt;用户管理： 可对用户进行增删改查，可登录、退出，权限管理（普通用户、管理员）。该模块独立部署，以restful api的方式向外提供接口。&lt;/li&gt;
&lt;li&gt;Scala代码在线验证：可执行一段scala代码，并通过相应的输入、输出数据，检查该代码的正确性。该模块独立部署，以restful api的方式向外提供接口。&lt;/li&gt;
&lt;li&gt;做题管理：可记录用户每次做题时的答案和最终结果。该模块独立部署，以restful api的方式向外提供接口。&lt;/li&gt;
&lt;li&gt;最终网站：通过调用前四个模块的功能组装成一个真正可用的网站。用户可通过网站界面进行注册、登录、做题、查看结果等功能。该模块独立部署，以网站界面的方式供用户使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;技术选型及环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Scala&lt;/li&gt;
&lt;li&gt;Playframework: 所有模块均采用playframework，原因是它提供了最好的文档和产品化支持&lt;/li&gt;
&lt;li&gt;CI: 自建Jenkins, 地址：http://jenkins.shuzu.org&lt;/li&gt;
&lt;li&gt;发布：5个模块都将发布到heroku上&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;时间计划&lt;/h3&gt;
&lt;p&gt;这将会是一个较长期（三个月左右）的workshop，主要是因为scala本身的特性很多，需要较长时间的练习才能掌握。我希望能在这个workshop结束后，参与的同学都能达到独立开发Scala项目的要求。&lt;/p&gt;
&lt;p&gt;如果你中途出差或者很忙，也可自己领卡做，但一定要找人帮你review一下。&lt;/p&gt;
&lt;h3&gt;代码Review和重构&lt;/h3&gt;
&lt;p&gt;我们做卡的最主要的目的是为了让大家能更好的学习和思考Scala，所以代码Review是重要的一环。我们将在每次workshop中Review大家的代码，每张卡做完后，都必须找人review才能进入Done。鼓励大家对代码进行重构，追求更好的代码。&lt;/p&gt;
&lt;h3&gt;一张卡的完整流程&lt;/h3&gt;
&lt;p&gt;找Pair -&gt; 拿卡（或自建卡） -&gt; 讨论清楚需求 -&gt; 开发(TDD) -&gt; 找人Review(改进) -&gt; Git Push -&gt; CI过 -&gt; Heroku可正常访问 -&gt; Ready for Check -&gt; Done&lt;/p&gt;
&lt;h2&gt;项目地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tw-scala-workshop&quot;&gt;https://github.com/tw-scala-workshop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个项目的README中都写了CI和Demo的地址，可自行查看。Jenkins帐号找我要。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala热情workshop 2. Scala学习路线(3) scala资源</title>
                <link>http://freewind.in/posts/2721-scala-workshop-2-scala-resources</link>
                <pubDate>Sat, 14 Jun 2014 23:38:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2721</guid>
                <description><![CDATA[&lt;p&gt;参看以前搜集的：http://freewind.me/blog/20130101/1343.html&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala热情workshop 2. Scala学习路线(2) 为什么学以及难度分块</title>
                <link>http://freewind.in/posts/2717-scala-workshop-2-why-learn-scala-and-difficulties</link>
                <pubDate>Sat, 14 Jun 2014 23:34:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2717</guid>
                <description><![CDATA[&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;为什么要学Scala&lt;/h2&gt;
&lt;p&gt;有不少人问过我这个问题：你为什么要学习Scala?&lt;/p&gt;
&lt;p&gt;在最开始，我也是被各种宣传忽悠了，以为Scala是一门简单的，对Java有很多改进的，甚至可能很快就成为下一代Java的语言。当时正打算做一个网站，于是就用它边学边做。几个月后，实在无法忍受它的编译速度、各种类库的缺失、以及各种各样的编译错误，放弃了它。&lt;/p&gt;
&lt;p&gt;但是当时创建的那个Scala群里，却有非常好的交流氛围。很多人由于对Scala很有兴趣，在群里讨论各种新鲜好玩的技术，让我大开眼界，发现Java原来只是一个小世界。另外在群里认识了杨云，也因此加入了TW，现在他是我的sponsor。&lt;/p&gt;
&lt;p&gt;来到我们公司之后，居然有两次参与Scala项目的机会。发现我们的客户居然都喜欢用Scala，西安办公室里也有越来越多的人主动或者被迫学习Scala。由于现在有了更多学习的时间，所以我又把它捡了起来，同时惊喜地发现之前一直没搞懂的问题，现在竟然差不多理解了。&lt;/p&gt;
&lt;p&gt;我认为我现在学习Scala的原因是：它为我打开了编程世界的一扇门，让我看到了与之前完全不同的世界。通过对它的学习，我可以强迫自己学习更多编程知识，提高自己的能力，从而有机会跟更多牛人交流。另外，我个人也看好Scala的未来，所以认为越早掌握它对自己越有利。&lt;/p&gt;
&lt;h2&gt;Scala学习路线&lt;/h2&gt;
&lt;p&gt;结合我自己的学习经历，我把Scala的学习按难度分成了几块。每一块的难度侧重点相对独立，需要一段时间的专门学习。&lt;/p&gt;
&lt;h3&gt;第一块：语法糖&lt;/h3&gt;
&lt;p&gt;第一块是学习Scala的各种基本特性，比如object, trait, pattern matching等，这些知识对于一个熟练的Java程序员来说，没有太大难度。看完一本Scala书，或者参与一个不太复杂的Scala项目，基本上就可以到达。&lt;/p&gt;
&lt;p&gt;推荐书籍： &amp;laquo; Scala编程&amp;raquo; 或者 &amp;laquo;快学Scala&amp;raquo;&lt;/p&gt;
&lt;p&gt;文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Daily Scala: &lt;a href=&quot;http://daily-scala.blogspot.com/&quot;&gt;http://daily-scala.blogspot.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Neophyte&apos;s Guide to Scala: &lt;a href=&quot;http://danielwestheide.com/scala/neophytes.html&quot;&gt;http://danielwestheide.com/scala/neophytes.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开源项目：&lt;a href=&quot;https://github.com/inca/circumflex/tree/master/web&quot;&gt;https://github.com/inca/circumflex/tree/master/web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Circum-web是一个比较简单的scala mvc框架，代码简单、注释丰富。由于它没有用到多少函数式风格的代码，对于初学者来说，还是比较容易上手的。虽然现在用它的人不多，但不失为一个很好的学习资源。同时它还有circum-orm等项目，也可以用来学习。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h3&gt;第二块：类型系统&lt;/h3&gt;
&lt;p&gt;此时最困扰我们的，应该就是各种各样类型相关的编译错误，以及一些复杂难懂的类型声明。&lt;/p&gt;
&lt;p&gt;特别是这几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路径依赖类型&lt;/li&gt;
&lt;li&gt;非变，协变，逆变&lt;/li&gt;
&lt;li&gt;Type class&lt;/li&gt;
&lt;li&gt;高阶类型等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐书籍：&lt;code&gt;&amp;lt;&amp;lt;Scala in Depth&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;博客文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://hongjiang.info/scala/&quot;&gt;http://hongjiang.info/scala/&lt;/a&gt; 中有关类型系统的文章&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/&quot;&gt;http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考语言：Haskell中的类型系统&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h3&gt;第三块：函数式&lt;/h3&gt;
&lt;p&gt;这一块的目标就是搞懂monad，以及各种函数式编程中提到的概念。这里可能要结合其它函数式语言学习。&lt;/p&gt;
&lt;p&gt;推荐书籍：&lt;code&gt;&amp;lt;&amp;lt;Scala in Depth&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;functional programming in scala&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;推荐博客：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://hongjiang.info/scala/&quot;&gt;http://hongjiang.info/scala/&lt;/a&gt; 中关于monad的文章&lt;/li&gt;
&lt;li&gt;Manods are elephants系列: ​&lt;a href=&quot;http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html&quot;&gt;http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;论面向组合子程序设计方法: &lt;a href=&quot;http://www.blogjava.net/ajoo/category/6968.html&quot;&gt;http://www.blogjava.net/ajoo/category/6968.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Learning scalaz: &lt;a href=&quot;http://eed3si9n.com/learning-scalaz/&quot;&gt;http://eed3si9n.com/learning-scalaz/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐库：scalaz&lt;/p&gt;
&lt;p&gt;推荐语言：Haskell&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h3&gt;第四块：生态&lt;/h3&gt;
&lt;p&gt;前三块基本上都是语言层面，这一块是库，比如一些我们经常用到的，或者scala中一些很有名的库：&lt;/p&gt;
&lt;p&gt;构建工具: sbt&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;scalatest/specs2&lt;/li&gt;
&lt;li&gt;scalaz&lt;/li&gt;
&lt;li&gt;akka&lt;/li&gt;
&lt;li&gt;spark&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里要根据项目和兴趣进行选择。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h3&gt;第五块：其它&lt;/h3&gt;
&lt;p&gt;Scala中的一些其它特性，比如:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dynamic: &lt;a href=&quot;http://stackoverflow.com/questions/15799811/how-does-type-dynamic-work-and-how-to-use-it&quot;&gt;http://stackoverflow.com/questions/15799811/how-does-type-dynamic-work-and-how-to-use-it&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;macro&lt;/li&gt;
&lt;li&gt;​scala.js, jsscala&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala热情workshop: 2. Scala学习路线(1)  初学者的观点</title>
                <link>http://freewind.in/posts/2704-scala-workshop-2-opinions-from-beginners</link>
                <pubDate>Sat, 14 Jun 2014 20:54:27 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2704</guid>
                <description><![CDATA[&lt;p&gt;这是一篇为公司内部”scala热情workshop”活动准备的文章，面向Scala初学者，目的在于帮助大家能尽早就建立起对Scala的整体认识，少走弯路。当然由于水平有限，有些地方可能不准确，不过如果能促进大家多思考多求证，也算达到了目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我最开始接触Scala是2010年初，到现在竟然已经过了4年半了。想到自己现在的scala水平，还处于入门后刚有点感觉的状态，感觉十分的惭愧。这四年多，一直断断续续的学习，中间多次放弃又多次拿起，就像是一本厚书，每次都是从头看了几十页便放下，多次之后，看到的还是前几十页。&lt;/p&gt;
&lt;p&gt;我之前的学习完全是自学，靠自己摸索，在没有人指导的情况下，走了很多弯路。其中最大的阻碍，有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己在编程方面的知识储备不够，太多的东西需要现学，有时候甚至意识不到自己该学&lt;/li&gt;
&lt;li&gt;对scala的定位和认识不清楚，常常在错误的方向上努力直到最后撞墙，而一些重要的知识却总在回避，导致学习过程特别的痛苦&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我想把其中一些重要的东西记录下来，让和我一样正在学习scala的同学能多一些思考，少走一些弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;刚接触Scala的同学，看到的基本上都是一些宣传性的文章，也因此对它有一些不太正确的观点。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Scala很简单，Scala=Java+语法糖&lt;/h2&gt;
&lt;p&gt;在Scala群里，经常看到一些初学者在聊天的时候，说Scala不过是给Java增加了一些语法糖，让我们写代码的时候可以方便一些而已。他们很喜欢这些语法糖，因为写出来的代码看起来不像Java那么繁琐。在经过一两周的学习以后，他们认为自己已经掌握了Scala，觉得它很简单，于是跑到别的群里吹嘘，忽悠更多的人来学Scala。&lt;/p&gt;
&lt;p&gt;的确，Scala中有一些东西看起来的确很简单，只需要把&amp;lt;&amp;lt;scala编程&amp;gt;&amp;gt;或者&amp;lt;&amp;lt;快学Scala&amp;gt;&amp;gt;这样的书大概翻过一遍，就差不多能用了。比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分号可选&lt;/li&gt;
&lt;li&gt;多行字符串&lt;/li&gt;
&lt;li&gt;val&lt;/li&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;trait&lt;/li&gt;
&lt;li&gt;pattern matching&lt;/li&gt;
&lt;li&gt;类型推断&lt;/li&gt;
&lt;li&gt;map/filter/flatMap&lt;/li&gt;
&lt;li&gt;for表达式&lt;/li&gt;
&lt;li&gt;implicit&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看起来，学习Scala就像爬楼梯一样，哪有什么学习曲线？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-2.png&quot; alt=&quot;&quot; /&gt;&lt;img src=&quot;undefined&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当我们基本掌握上面那些知识点之后，也许一些基本的Scala开发还能勉强胜任，但是我们很快就会发现很多别人写的Scala代码我们看不懂，别人讨论的Scala知识我们也看不懂，我们只是在把Scala当Java用。为什么？&lt;/p&gt;
&lt;p&gt;因为那些真正让Scala具有吸引力、有难度的地方不在上面。比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类型系统&lt;/li&gt;
&lt;li&gt;函数式编程&lt;/li&gt;
&lt;li&gt;Monad&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也许是因为那些书面向的都是初学者，在这些方面都讲得比较简略，点到即止。此时如果看&amp;lt;&amp;lt;Scala in Depth&amp;gt;&amp;gt;这本书，基本上很难看得下去。&lt;/p&gt;
&lt;p&gt;当我们决定把这些都学会的时候，会惊讶的发现，难度变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为我们会发现，自己缺少了太多的背景知识，需要先补很多东西，甚至学一门别的函数式语言之后，才能回来学Scala。&lt;/p&gt;
&lt;h2&gt;Groovy创始人曾经说过：如果Scala早点出来，我就不会搞groovy了&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不太清楚Groovy的创始人在什么场合说了这句开玩笑的话，但有些人就信以为真，经常在群里喊：都来学Scala吧，还学什么groovy啊，你没听说那谁都这么说了。&lt;/p&gt;
&lt;p&gt;然而对这两种语言有所了解的人都知道，这两门语言就没什么可比性。&lt;/p&gt;
&lt;p&gt;Scala是一门静态类型，结合了面向对象和函数式的，拥有强大的类型系统的语言。而Groovy是一门同时提供了动态类型和静态类型，基本兼容Java语法的语言。&lt;/p&gt;
&lt;p&gt;这两者的特性、适合场景都不一样。&lt;/p&gt;
&lt;h2&gt;Java中能做到的事，Scala都能做并且做的更好&lt;/h2&gt;
&lt;p&gt;通过各种资料介绍，我们感觉scala比Java要强大的多，有时候会认为，只要Java中能做到的事，在Scala中都能做并且做的更好。&lt;/p&gt;
&lt;p&gt;也许很多情况下是这样，但是有时候不是，比如类似ORM这样的库。&lt;/p&gt;
&lt;p&gt;在Java中，有hibernate或者跟它类似的，比如我最喜欢的&lt;a href=&quot;http://www.avaje.org/&quot;&gt;Ebean&lt;/a&gt;。它们利用字节码操作，在背后为我们提供了很多增强的功能，让我们建好model再CRUD非常轻松。虽然它们在后面有一些看不到的魔术操作，但是可以让我们写出很干净简洁的代码。&lt;/p&gt;
&lt;p&gt;然而这些库在scala中，要么用起来非常别扭，要么有一些奇怪的问题。而Scala原生的库，比如squeryl，slick等，都有“多利用类型系统，少做魔术”的追求，所以用起来总是不那么好用。&lt;/p&gt;
&lt;p&gt;再举一个playframework的例子。曾经的playframework1是java版的，现在的playframework2用scala重写了，虽然名字相同，但是两者的风格有很大不同。play1有很多魔术，但是代码简洁、开发效率极高；而play2 typesafe了，对于普通网站的开发，它的开发效率大大降低了。&lt;/p&gt;
&lt;h2&gt;Scala和Java互操作很简单&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Scala运行于JVM上，可以与Java互操作。我们甚至在同一个项目中，可以既有Java代码，又有scala代码。这是不是意味着，我们可以让项目中的一部分代码使用Java实现，另一部分使用Scala？&lt;/p&gt;
&lt;p&gt;在理论上是可以的，并且在实际中，有的时候我们不得不这样。但是混用的过程还是比较痛苦的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;很多类，特别是集合类，Java与Scala各有一套，我们需要不停转换&lt;/li&gt;
&lt;li&gt;Java与Scala类型系统不完全相同，有时候会遇到奇怪的编译错误&lt;/li&gt;
&lt;li&gt;有些java库会对javabean的getter/setter进行字节码增强，而scala对这种风格支持不好&lt;/li&gt;
&lt;li&gt;Scala的类名方法名，有可能在java中看起来很奇怪&lt;/li&gt;
&lt;li&gt;过程式与函数式之间的风格冲突&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我通常会采用纯java或者纯scala方案，除非很有必要，并且两者可以分离得很清楚，并且之间只用很少的接口进行交互。&lt;/p&gt;
&lt;p&gt;Java里有一些很好的库想在scala使用，人们通常都会先写一个wrapper，在外面包上一层scala接口。但是如果包的不好，用起来也是非常麻烦，不如不用，比如: &lt;a href=&quot;http://scalafx.io&quot;&gt;http://scalafx.io&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Java程序员学习Scala最容易&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;初看起来Scala的语法跟Java比较像，对于Java程序员比较友好，所以很多人认为Java程序员学习Scala最容易。然而对于Java程序员来说，如果以前没有接触过函数式编程，对于类型系统了解不多的话，到后期会面临巨大的压力，因为有太多与函数式及类型系统相关的概念需要学习，而这往往不是短期内就能掌握的。甚至有可能为了学习scala而中途专门去学习另一门函数式语言（如haskell, lisp等），掌握了那些概念后，再回来看scala。&lt;/p&gt;
&lt;p&gt;Scala是一门过程式与函数式结合的语言，Scala代码中，过程式的代码经常与函数式代码混在一起，所以利用它来学习，常常会让人迷惑。而且在scala资料中，专门讲函数式知识的并不多。而像Haskell这样的纯函数式语言，几乎所有的资料都会讲到函数式编程里的各种概念，更加利于学习。&lt;/p&gt;
&lt;p&gt;所以Scala对于从函数式语言的程序员来说，可能学习曲线更小一些。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;函数式很简单&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对于像我这样的Java程序员来说，函数式编程是一个很神秘的话题。从前以为，像Java/C这样的过程式语言的编程方式，就是全部，想不出除此之外还能有什么编程方式。所以对于“函数式”，我们往往通过一两个简单的定义会想像，然后得到“函数式编程”很简单的结论。&lt;/p&gt;
&lt;p&gt;比如，关于函数式编程，有人说它有两个重要的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;追求不变性和无副作用&lt;/li&gt;
&lt;li&gt;函数作为一等公民，它可以当作值一样定义、传递&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后我们想，我已经做到了尽量用val不用var，也不在方法里中做一些有副作用的操作，比如打印输出。然后，我还喜欢用那些好用的map之类的函数，直接写一个匿名函数给它，这不是符合了第二条吗？这样看来，函数式编程好像很简单啊。&lt;/p&gt;
&lt;p&gt;这种想法，就跟我们会用class定义类了，然后就说自己会“面向对象”了一样。&lt;/p&gt;
&lt;p&gt;由于我也刚刚开始学习函数式编程，没法给出准确的描述，只能大概说一些：在纯函数式编程中不能使用像&lt;code&gt;for&lt;/code&gt;循环这样的语法，也不能给一个变量重新赋值，所以它解决问题的思路跟我们在过程式语言中做的，有很大不同。比如递归的大量使用，比如函数的组合，比如monad的概念，很多都是我之前从来没有见过的。在学习一门纯函数式语言的过程中，我们会发现以前的编程经验用不上了，经常有种寸步难行、有力无处使的感觉。而且会经常遇到各种数学相关的概念，还得不断补数学知识。&lt;/p&gt;
&lt;p&gt;从一门过程式语言转向另一门过程式语言很快，可能要熟悉的就是语法、类库、一些最佳实践等，一两周可能就差不多了。但是从一门过程式语言转向一门函数式语言，可能要花几个月的时间。前者像是搬到了新城市，后者像是移民到了新国家。&lt;/p&gt;
&lt;p&gt;（这一块要等我掌握了一门函数式语言之后再来补充）&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Scala的DSL很强大&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2704-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由于Scala强大的类型系统和它的语法支持，我们可以设计出强大的类型安全的DSL。&lt;/p&gt;
&lt;p&gt;比如像scalatest这样的库，可以让我们这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;list should have length 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样看起来像是一句普通英语。&lt;/p&gt;
&lt;p&gt;但Scala的DSL有两点需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的特点是类型安全。如果以表达能力看，它比动态语言要弱要难看。可以通过查看sbt和gradle的构建文件来获取直观感受&lt;/li&gt;
&lt;li&gt;对类型系统方面的能力要求高。以scalatest为例，如果没有熟悉、深刻地掌握scala类型系统，很难设计出来这样的DSL。而在动态语言中就没有这个门槛&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以个人感觉，scala中DSL的“强大”主要体现在类型方面，而在表达能力和易读性方面，可能要弱于其它一些语言。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;类型系统我们不用学&lt;/h2&gt;
&lt;p&gt;Scala中的类型系统很强大，也很复杂，对于初学者来说是一个难点。记得以前看到有人说，普通的程序员不需要掌握它们，只有类库的设计者需要掌握。&lt;/p&gt;
&lt;p&gt;但是实际情况是，如果不能尽早的掌握足够的类型系统知识，在使用Scala时我们几乎寸步难行。我们在编译Scala代码时，遇到的最多错误就是各种类型不匹配，如果不熟悉的话，可能要卡几个小时都解决不了。&lt;/p&gt;
&lt;p&gt;所以在最开始学习的时候，就不能回避它。也许我们的目的不是设计出一个类型很复杂的类库，我们也要能做到看得懂复杂一点的方法签名，解决常见的类型编译错误。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;我公司有个新项目，我想用Scala，边学边用&lt;/h2&gt;
&lt;p&gt;很多人低估了Scala的学习难度，甚至刚开始学习时，便打算在公司的新项目上使用。或者在自己也没有熟练掌握的情况下，便向团队中强推Scala，这种做法是十分危险的。&lt;/p&gt;
&lt;p&gt;Scala中关于函数式与类型系统方面的知识，对团队成员的要求比较高。如果是一个在这些方面不熟悉的团队，想在短期内掌握并且用好它们，基本上是一件不可能的任务。&lt;/p&gt;
&lt;p&gt;另外，Scala的IDE支持、资料文档、生态圈等，相对于Java这种成熟的语言还比较弱，这对于新人也是一个比较大的障碍。&lt;/p&gt;
&lt;p&gt;我觉得，只有当团队中已经有对Scala熟练的人，团队成员学习能力较强，并预留了大量学习时间的情况下，才可以尝试使用Scala来做项目。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala热情workshop(1). 安装快速尝试scala代码的工具: scalaconsole</title>
                <link>http://freewind.in/posts/2689-scala-workshop-1-try-scala-code-with-scalaconsole</link>
                <pubDate>Sat, 14 Jun 2014 11:32:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2689</guid>
                <description><![CDATA[&lt;h2&gt;Scala Console&lt;/h2&gt;
&lt;p&gt;为了快速尝试一段代码，我们有scala repl, eclipse, idea可用，但是在某些情况下，它们都不够好用。&lt;/p&gt;
&lt;p&gt;而scala console这个工具，为scala-repl提供了图形界面，代码高亮等支持，十分方便，实乃居家必备。&lt;/p&gt;
&lt;h3&gt;快速运行代码&lt;/h3&gt;
&lt;p&gt;上个主界面图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2689-1.png&quot;&gt;&lt;img src=&quot;/user_images/2689-1.png&quot; alt=&quot;2638699&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;左边是编辑区，可以贴scala代码，它提供了高亮、行号等。按”Cmd+R”后，将会在右边内嵌的一个scala-repl中显示结果。&lt;/p&gt;
&lt;h3&gt;快速添加依赖&lt;/h3&gt;
&lt;p&gt;这是一个非常有用的功能。有时候我们尝试一些库的功能，那会相当麻烦，通常我会这么做：&lt;/p&gt;
&lt;p&gt;写一个build.sbt文件，在里面写上所有的依赖，然后&lt;code&gt;sbt idea&lt;/code&gt;生成，再打开idea写代码。&lt;/p&gt;
&lt;p&gt;但是有了scalaconsole，就很简单了：点击菜单中的Dependencies选项，将会出现如下界面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2689-3.png&quot;&gt;&lt;img src=&quot;/user_images/2689-3.png&quot; alt=&quot;487403&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们输入关键字，双击右边列表中某个版本，它就会加到下面的列表中。点击OK后，它就会开始下载&lt;img src=&quot;/user_images/2689-4.png&quot; alt=&quot;9596797&quot; /&gt;&lt;/p&gt;
&lt;p&gt;期间有半分钟左右没有输出变化，需要耐心等一下。完成后我们就可以直接用了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2689-6.png&quot;&gt;&lt;img src=&quot;/user_images/2689-6.png&quot; alt=&quot;1042034&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;发布到gist&lt;/h3&gt;
&lt;p&gt;如果想与其它人讨论或者分享你的代码，可以点击菜单中的Post Anonymous Gist或者Post Gist with Account，快速发布。&lt;/p&gt;
&lt;h2&gt;项目信息&lt;/h2&gt;
&lt;p&gt;项目作者：老猪，”无水scala群（231809997）“的群主，是一件严肃而热情的技术高手。公司网站 &lt;a href=&quot;http://gtan.com&quot;&gt;http://gtan.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;http://git.oschina.net/43284683/scalaconsole&quot;&gt;http://git.oschina.net/43284683/scalaconsole&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;下载安装&lt;/h3&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://git.oschina.net/43284683/scalaconsole/attach_files&quot;&gt;http://git.oschina.net/43284683/scalaconsole/attach_files&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ScalaConsole-assembly-2.0.0-M5.jar，大约25M左右&lt;/p&gt;
&lt;p&gt;这个文件已经打包了所有需要的文件，你只需要运行：&lt;code&gt;java -jar ScalaConsole-assembly-$VERSION.jar&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;注意：由于scalaconsole使用了最新版的JavaFX，你需要安装jdk1.8才能正常运行。&lt;/p&gt;
&lt;h3&gt;启动脚本&lt;/h3&gt;
&lt;p&gt;你可以手动建立一个scalaconsole.sh，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/path/to/jdk1.8/java -jar ~/dev/scala/ScalaConsole-assembly-2.0.0-M2.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后把它加入到path中，就可以快速启动scalconsole了&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 3-3 如何反馈 – 游戏</title>
                <link>http://freewind.in/posts/2686-twi18-how-to-feedback</link>
                <pubDate>Sat, 14 Jun 2014 10:51:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2686</guid>
                <description><![CDATA[&lt;h2&gt;需不需要反馈&lt;/h2&gt;
&lt;p&gt;（大家的回答）没有反馈就不知道自己做的是对还是错，别人怎么看待自己的做法，没有安全感等等。不能及时改正。&lt;/p&gt;
&lt;h2&gt;如何反馈&lt;/h2&gt;
&lt;p&gt;第一场：&lt;/p&gt;
&lt;p&gt;张一坐在椅子上，向后丢笔，希望能砸中椅子。每丢一次，郑大大就给出反馈，但反馈都是”你怎么这么笨“”只知道乱丢“这样的话，最后赵一只好听声辨位，把笔丢向郑大大&lt;/p&gt;
&lt;p&gt;第二场：&lt;/p&gt;
&lt;p&gt;其它一样，只是郑大大给反馈时，会说”你的力气正好，只是方向向左偏了一点点，你再向右偏一点就好了“。经过这样多次反馈，张一成功把笔扔到了椅子腿上。&lt;/p&gt;
&lt;p&gt;说明：反馈的方式，提供的信息很重要。反馈不是为了宣泄，而是帮助对方如何改进。&lt;/p&gt;
&lt;h2&gt;要验证猜测&lt;/h2&gt;
&lt;p&gt;D.I.E&lt;/p&gt;
&lt;p&gt;Description - 你看到的事实&lt;/p&gt;
&lt;p&gt;Interpretation- 你的解读&lt;/p&gt;
&lt;p&gt;Evaluation - 你的想法与反应&lt;/p&gt;
&lt;p&gt;比如，&lt;/p&gt;
&lt;p&gt;Description： 上班时间，我看到某人趴在桌子上&lt;/p&gt;
&lt;p&gt;Interpretation1： 他在睡觉&lt;/p&gt;
&lt;p&gt;Evaluation1： 我觉得他这样做不好&lt;/p&gt;
&lt;p&gt;Interpretation2： 他生病了，没有力气&lt;/p&gt;
&lt;p&gt;Evaluation1： 我觉得他应该回家休息，不要强撑&lt;/p&gt;
&lt;p&gt;当我们给反馈时，我们不能仅根据自己的解读武断地下结论，要去求证一下真实情况。否则会让人误会。&lt;/p&gt;
&lt;h2&gt;语气、态度&lt;/h2&gt;
&lt;p&gt;IIU&lt;/p&gt;
&lt;p&gt;句式：&lt;/p&gt;
&lt;p&gt;我看到/听说了什么，&lt;/p&gt;
&lt;p&gt;我觉得怎么怎么样，&lt;/p&gt;
&lt;p&gt;你认为呢？&lt;/p&gt;
&lt;p&gt;先说事实，再说对自己的影响，再留给对方解释的空间。&lt;/p&gt;
&lt;h2&gt;被反馈者&lt;/h2&gt;
&lt;p&gt;有的人收到不好的反馈时，第一时间就是辩解，这样会让人以后不敢给反馈。&lt;/p&gt;
&lt;p&gt;另外，如果觉得某个反馈自己不在意，也可以不接受&lt;/p&gt;
&lt;h2&gt;反馈者&lt;/h2&gt;
&lt;p&gt;可以主动给人反馈，但通常可以先问对方：我想给你一些反馈，不知道什么时候方便我们聊一聊？&lt;/p&gt;
&lt;h2&gt;需求反馈&lt;/h2&gt;
&lt;p&gt;可以主动邀请别人给自己反馈。也可以先给别人反馈，再要求对方给反馈&lt;/p&gt;
&lt;h2&gt;实名&lt;/h2&gt;
&lt;p&gt;反馈要实名，这样可以就某个问题深入聊。否则被反馈者自己看不明白某个反馈又不知道是谁提的，就没法继续了&lt;/p&gt;
&lt;h2&gt;反馈最关键的是给方案，帮助对方如何解决&lt;/h2&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 3-2 如何引导客户找到解决方案 – 游戏</title>
                <link>http://freewind.in/posts/2684-twi18-3-2-how-to-help-client-to-find-the-solution</link>
                <pubDate>Sat, 14 Jun 2014 10:50:55 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2684</guid>
                <description><![CDATA[&lt;p&gt;分成两个组，每个组8个人，配一个客户。&lt;/p&gt;
&lt;p&gt;在第一场中，客户由郑大大扮演。是A公司某项目经理，因为领导觉得团队的交付速度不理想，又听说我们公司推的持续交付很有意思，所以过来咨询。&lt;/p&gt;
&lt;p&gt;我们想了一大堆问题问客户，第一个问题是：您认为你们现在的项目出了什么问题。后面都是更深入一些的问题。&lt;/p&gt;
&lt;p&gt;但是没想到客户第一个回答就把我们搞晕了，因为他说：我觉得我们项目挺好的，没什么问题啊。大家干得挺开心的。。。。&lt;/p&gt;
&lt;p&gt;然后我们就乱套了，不知道该问什么了，大家乱七八糟的问，总是找不到问题在哪儿，又觉得用户说的有点不对劲。因为他说，他们一个需求来了，快的时候一两天就上次了，平时可能要四五天。&lt;/p&gt;
&lt;p&gt;但是我们始终没有察觉，一直在问别的，直到结束后讨论时才发现：但是根据更细致一些的问题，发现根据客户说明的一些情况，很难在几天的时间内交付，客户一定说谎了。然后我们准备在第二场时，让用户详细列出开发一个需求到上线过程中，所有经过的步骤与每个步骤的时间，来找到真实的时间。&lt;/p&gt;
&lt;p&gt;结果第二场，两个组交换客户。。。&lt;/p&gt;
&lt;p&gt;第二场中，我们的客户由凯锋扮演，他是B公司的项目经理，目前遇到了严重的交付问题。他直接坦承说，现在一个迭代是两周，但一次上线要8个月。&lt;/p&gt;
&lt;p&gt;这两个客户态度差别之大，让我们在讨论时的方案又完全落空，又是一阵不知所措。再次上演上一场七嘴八舌的问题，最后勉强问出了一点东西，但好像方向错了。因为我们是dev，对CI比较熟悉，所以我们问客户都是CI上的问题。而客户真正的问题是在部署，而我们都不太熟悉，所以都避开这个问题。&lt;/p&gt;
&lt;p&gt;这次游戏，让我们知道”自己有干货“的重要性。否则，根本不知道如何判断用户是否说了实情，关键的问题在哪里，在提问的过程中，也会不自觉地绕开自己不熟悉的地方，也许那些正是问题所在。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 3-1 咨询入门</title>
                <link>http://freewind.in/posts/2682-twi18-3-1-how-to-be-a-consultant</link>
                <pubDate>Sat, 14 Jun 2014 10:50:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2682</guid>
                <description><![CDATA[&lt;p&gt;做“咨询”只有一个目的：驱动变化&lt;/p&gt;
&lt;p&gt;客户找到我们，让我们去做咨询，一定是客户那边有什么问题让他们不满意。如果咨询师不能够驱动变化，改变不了他们，就没有任何意义。&lt;/p&gt;
&lt;p&gt;作为一个咨询师，如果我们说“用户很难搞定”“用户不听我们的”这样的话，只能说明自己是个失败者。&lt;/p&gt;
&lt;h2&gt;变化的两个问题&lt;/h2&gt;
&lt;p&gt;如果要驱动变化，一定要想好这两个问题：&lt;/p&gt;
&lt;p&gt;我们为什么要变&lt;/p&gt;
&lt;p&gt;我们为什么要现在变&lt;/p&gt;
&lt;p&gt;如果自己都回答不了这两个问题，那么根本没法说服客户。&lt;/p&gt;
&lt;p&gt;变化的起点是”紧迫感“，变化的终点是”融入企业文化“&lt;/p&gt;
&lt;p&gt;紧迫感，可以通过跟客户的交流，引导客户自己意识到问题所在，提出解决方案。&lt;/p&gt;
&lt;p&gt;问问题的时候，要注意开放型问题和封闭型问题结合。开放型问题一般是”为什么“，封闭型一般是”是“或者”否“，或者从几个选项中选择一个。我们通过开放型问题进行发散，再通过封闭型问题收敛。如果用户老是回避问题，则需要用一些只能回答”是或者否“的问题，要求客户给出确定答案。&lt;/p&gt;
&lt;p&gt;就像是”盗梦空间“，要通过造梦让用户认为我们的方案其实是他自己想出来的，自己要去推行的。这样他才有动力。&lt;/p&gt;
&lt;p&gt;否则，他会认为这是咨询师的方案，成功了是咨询师得了好，失败了也是咨询师的错。&lt;/p&gt;
&lt;p&gt;但问问题只是一种技巧，如果自己没有干货，根本把握不了客户，问来问去只能让用户烦。&lt;/p&gt;
&lt;p&gt;（后来做了一个游戏，我们去问客户问题，自己对于一些基本概念都不太理解，怎么都问不到点子上）&lt;/p&gt;
&lt;p&gt;这时徐大师举了一个例子，他说他有次在机场看到一本书，上面列举了各种公司组织结构，有一百多个。他发现每一个他都知道，并且在三本以上的书里看到过。而一般的企业管理者可能只熟悉五六种，他跟他们聊天的时候，很容易让别人产生信任感。因为自己有大量干货在脑袋里。&lt;/p&gt;
&lt;p&gt;变化如果不能融入企业文化，则没有生命力，用不了多久就会消失。所谓”企业文化“，就是指：&lt;/p&gt;
&lt;p&gt;你做什么事情会得到企业/同事的认同&lt;/p&gt;
&lt;p&gt;在某公司，实行的是“谁的代码谁负责”的制度，这些都是跟KPI挂钩，是企业鼓励的。所以在这个企业去强调团队合作，代码是大家的，一定会受到很多人的反对。去做敏捷推广，由于很多实践都是跟公司文化冲突的，很难开展。后来跟领导商量，把“敏捷”写到了KPI中，才使得工作顺利开展下去。KPI不是敌人，在某些时候，它是朋友。&lt;/p&gt;
&lt;p&gt;只在当某个变化最后成为企业文化，才可以算作终点，因为它才能生存下去。&lt;/p&gt;
&lt;h2&gt;对公司的分析&lt;/h2&gt;
&lt;p&gt;用到了四象限的图：&lt;/p&gt;
&lt;p&gt;4   |   1&lt;/p&gt;
&lt;p&gt;&amp;#8212;&amp;#8212;&amp;#8212;-&lt;/p&gt;
&lt;p&gt;3   |   2&lt;/p&gt;
&lt;p&gt;第一象限：control类型的公司，command chain&lt;/p&gt;
&lt;p&gt;这样的公司有很多，像军队，像华x，中x等。特点就是，上级向下级发命令，下级执行，然后向上次报告。所以每个人都有一个直接报告的上级。重要的是下级的执行力。&lt;/p&gt;
&lt;p&gt;第二象限：竞争类型的公司&lt;/p&gt;
&lt;p&gt;专业服务类公司，比如会计事务所，律师事务所，或者我们公司。&lt;/p&gt;
&lt;p&gt;每个人的专业要求都很高。这样的公司一般都有多个层级，像金字塔。有要求，当几年之内，不能从某个级别升到上面一个级别，则自动离职，哪怕你在公司已经工作了很多年，哪怕你业绩很好。&lt;/p&gt;
&lt;p&gt;因为在这样的公司里，最宝贵的是机会。如果你在某个位置呆得太久不能上次，那么你就占据了下级人员向上流动的机会，那么就只有走人。&lt;/p&gt;
&lt;p&gt;我们公司目前还没有这样的规定，允许一个人在某个级别呆很久，只是因为我们现在正在扩张，新增了很多机会。等到以后不再扩张的时候，也许就会有类似的规定了。&lt;/p&gt;
&lt;p&gt;在这样的公司里，竞争非常激烈，哪怕表面一团和气，实际上每个人都在努力。每次新招一个人，都要比同级别的平均水平要高，若干年以后，对于新员工的要求就会越来越高，每一级别的门槛也会越来越高。老人如果不努力，很可能会被淘汰。据说国外某公司很长时间都没有招到人，就是因为对新人的要求已经高到在市场上找不到合适的人了。&lt;/p&gt;
&lt;p&gt;第三象限： 培养型公司&lt;/p&gt;
&lt;p&gt;像教会等。这样的公司一般有伟大的理想，每个人是不可替代的，会很注重对新人的培养。&lt;/p&gt;
&lt;p&gt;我们公司在这块也做的比较好，比如我们的一些实践（结对、code-review）等，可以帮助新人快速成长。&lt;/p&gt;
&lt;p&gt;这里谈到了结对。结对编程，一定会比两个人分开干自己的活要慢。但是它可以培养新人，传递知识。&lt;/p&gt;
&lt;p&gt;两个人结对时，老人只写测试，新人只写业务代码。这样新人可以快速了解项目，培养独立开发的能力。&lt;/p&gt;
&lt;p&gt;（更多的忘了）&lt;/p&gt;
&lt;p&gt;第四象限： 合作型公司&lt;/p&gt;
&lt;p&gt;我们公司也属于这样。强调团队，不强调各人。如果成功，是团队的成功。如果失败，是团队的失败。&lt;/p&gt;
&lt;p&gt;第一、二象限，涵盖了中国99%的公司。&lt;/p&gt;
&lt;h2&gt;咨询&lt;/h2&gt;
&lt;p&gt;给公司做咨询时，要先搞清楚它的类型。如果是control类型的，则可以引入一些团队合作。如果是竞争型公司，则可以引入一些培养方面的实践。&lt;/p&gt;
&lt;p&gt;咨询方面的东西太深了，这些东西只能算个大纳，让我们知道自己去找哪些方面的资料补充。不可能通过一个session就让大家掌握。&lt;/p&gt;
&lt;p&gt;最重要的是要比客户知道得更多。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 2-3 精益创业游戏 – 乐高</title>
                <link>http://freewind.in/posts/2680-twi18-2-3-lean-startup-a-game-with-lego</link>
                <pubDate>Sat, 14 Jun 2014 10:50:20 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2680</guid>
                <description><![CDATA[&lt;p&gt;使用乐高积木来玩一个精益创业的游戏。&lt;/p&gt;
&lt;p&gt;分成两组，每组8个人。再配一个CEO和一个用户。这个CEO谈他的想法，投钱。用户可以扮演不同的角色，提出不同的需求。只有当我们开发出来的产品满足用户的需求时，他才会付费。&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;p&gt;跟CEO聊天，了解他的想法和要求&lt;/p&gt;
&lt;p&gt;回来考虑怎么跟不同的客户了解他们的喜好&lt;/p&gt;
&lt;p&gt;使用精益分析的方式，做一个表，确定方案&lt;/p&gt;
&lt;p&gt;向CEO汇报想法，得到第一笔投资&lt;/p&gt;
&lt;p&gt;第一次开工，做出第一批产品。其间有两次机会向用户卖出产品&lt;/p&gt;
&lt;p&gt;向CEO汇报市场情况，一起做回顾。CEO决定是否追加投资&lt;/p&gt;
&lt;p&gt;第二次开工，做出第二批产品，期间有两次机会向用户卖出产品&lt;/p&gt;
&lt;p&gt;再次向CEO汇报，报告最终收益。与CEO、用户一起做回顾&lt;/p&gt;
&lt;p&gt;这个游戏我们组输了，有两个原因：&lt;/p&gt;
&lt;p&gt;第一次开工，我们的产品满足了用户的需求，卖了不少钱。在第二次开工时，我们根据用户的喜爱，全力生产相似的产品。但是实际上用户不再为同样功能再次付费。我们没有跟用户确认这一点，而是团队自己决定了第二次开工时的重要的方向。&lt;/p&gt;
&lt;p&gt;我跟一位同事，没有紧扣用户需求，做了两个产品都没有卖出去，浪费了时间和材料&lt;/p&gt;
&lt;p&gt;我们分析的结果是：&lt;/p&gt;
&lt;p&gt;我们应该有一个专职的BA，专门负责跟用户交流，他想要什么样的，会为什么样的功能付费。&lt;/p&gt;
&lt;p&gt;我们还应该有一个专职的QA，去检查大家做出来的东西，是否真正满足了客户的需求&lt;/p&gt;
&lt;p&gt;实际上我们8个人都成了DEV，都争分夺秒忙着做产品，把用户晾在了一边，卖东西的时候才发现没有满足客户要求。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 2-2 精益分析</title>
                <link>http://freewind.in/posts/2678-twi18-2-2-lean-analysis</link>
                <pubDate>Sat, 14 Jun 2014 10:50:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2678</guid>
                <description><![CDATA[&lt;p&gt;听客户话的BA不是好BA&lt;/p&gt;
&lt;p&gt;BA分三种：&lt;/p&gt;
&lt;p&gt;客户说什么就是什么&lt;/p&gt;
&lt;p&gt;问客户为什么，找到真正的需求，帮助客户找到更好的方案&lt;/p&gt;
&lt;p&gt;（有点记不太清了）好像是，验证客户的问题是不是真正的问题？&lt;/p&gt;
&lt;p&gt;客户有问题的时候，不会直接把问题告诉我们，而是把他想好的一个方案当作需求告诉我们。&lt;/p&gt;
&lt;p&gt;好的BA会根据客户的方案，跟客户交流，还原出他真正的需求。&lt;/p&gt;
&lt;p&gt;然后再找到他认为“这个是需求”时背后的一些假设条件，验证这些假设是否正确。&lt;/p&gt;
&lt;p&gt;精益分析&lt;/p&gt;
&lt;p&gt;举了一个例子，在非洲有一个客户，是一家电力公司。他告诉我们有一些需求：&lt;/p&gt;
&lt;p&gt;想让用户电表上的数据，实时发送到电力公司&lt;/p&gt;
&lt;p&gt;当电力公司可以远程切断某用户的电&lt;/p&gt;
&lt;p&gt;客户的需求是什么？&lt;/p&gt;
&lt;p&gt;预付费&lt;/p&gt;
&lt;p&gt;按需付费&lt;/p&gt;
&lt;p&gt;我们需要验证它们的假设条件。&lt;/p&gt;
&lt;p&gt;有一个表如下：&lt;/p&gt;
&lt;p&gt;=================================&lt;/p&gt;
&lt;p&gt;假设1  证据1 证据2 证据3&lt;/p&gt;
&lt;p&gt;假设2  证据1 证据2 证据3&lt;/p&gt;
&lt;p&gt;假设3  证据1 证据2 证据3&lt;/p&gt;
&lt;p&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-&lt;/p&gt;
&lt;p&gt;Core Assumptions |   Ways of validation&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                          |       Risk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;================================&lt;/p&gt;
&lt;p&gt;我们分成了几个组，填这个表，只有我们组搭上了一点边，但实际上我还是没搞明白怎么填写，怎么分析，基本上是乱猜的。&lt;/p&gt;
&lt;p&gt;徐大师解答时说了一点：预付费这一点，是不需要验证的，它可以当作一个核心假设。&lt;/p&gt;
&lt;p&gt;因为像这种，一边都是公司层面上的大事，选择某种商业模式是公司做出来的决定，我们没必要去验证它。&lt;/p&gt;
&lt;p&gt;所以假设应该基于”按需付费“，想找到哪些假设可以支持它，然后再找到办法去验证这些假设是否成立。&lt;/p&gt;
&lt;p&gt;后面的RISK之类都没时间做，我也不清楚该写些什么。&lt;/p&gt;
&lt;p&gt;徐大师说，我们只要搞清楚‘精益分析”的思路，就可以把它用在别处，比如搞过一次“精益招聘”&lt;/p&gt;
&lt;p&gt;对于求职者，我们说他通过还是不通过时，是有一些假设条件的。&lt;/p&gt;
&lt;p&gt;比如，“我觉得这个人编程能力不错”，也许基于一个假设：“如果他只有一年工作经验”&lt;/p&gt;
&lt;p&gt;或者，“我觉得他可以通过试用期”，也许基于“在试用期间有老员工带他的话”&lt;/p&gt;
&lt;p&gt;如果这些假设实际上无法成立或者满足的时候，我们就不能聘用他们。&lt;/p&gt;
&lt;p&gt;在精益招聘中，我们要记录假设，验证他们，追踪下去。&lt;/p&gt;
&lt;p&gt;另外还举了一个例子，好像是关于真正需求的：&lt;/p&gt;
&lt;p&gt;我们要招一个合格的人。实际上是：&lt;/p&gt;
&lt;p&gt;我们要招一个在6个月试用期之后，能通过的人。实际上是：&lt;/p&gt;
&lt;p&gt;我们要招一个满足XXX客户项目需求的，在6个月试用期之后，能通过的人。&lt;/p&gt;
&lt;p&gt;所以在招人时，我们只有根据真正的需求来招人，才能招到真正合适的人&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 2-1 敏捷与精益</title>
                <link>http://freewind.in/posts/2676-twi18-2-1-agile-and-lean</link>
                <pubDate>Sat, 14 Jun 2014 10:49:45 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2676</guid>
                <description><![CDATA[&lt;p&gt;一个很好的例子：买房&lt;/p&gt;
&lt;p&gt;在北京买房，肯定会涨（确定有价值），这时你不会考虑它有多贵（成本），因为肯定能赚钱。会选择更好的小区，升值空间更大（最大价值），只要有办法能低成本的获得大量资金即可（不计成本）。&lt;/p&gt;
&lt;p&gt;但是如果在一个偏远的三四线城市买房，会不会涨不确定，人们就会倾向于买便宜的房子。因为就算亏，也要少亏点。这时候最重要的是减少成本。&lt;/p&gt;
&lt;p&gt;敏捷：追求最大价值&lt;/p&gt;
&lt;p&gt;适合企业软件开发&lt;/p&gt;
&lt;p&gt;有价值或者很容易确定有价值&lt;/p&gt;
&lt;p&gt;企业软件所有的功能都是有价值的，软件可与行政互换&lt;/p&gt;
&lt;p&gt;用户都在企业中，容易得到反馈&lt;/p&gt;
&lt;p&gt;当软件不满足时，可以通过行政命令去适应软件，所以企业软件的功能都是有价值的&lt;/p&gt;
&lt;p&gt;所以我们要考虑的就是“优先级”&lt;/p&gt;
&lt;p&gt;敏捷是风险管理 Risk&lt;/p&gt;
&lt;p&gt;在开发时会追求开发速度，在估点时会下意识做最乐观估计。“这个功能我已经做过类似的，比较熟悉”，“已经有相关代码可以重用”，但大多数情况下，实际情况总会超过预期，成为常态。&lt;/p&gt;
&lt;p&gt;最后会拆卡，会说“超出scope”，但是人们都会接受这些理由。&lt;/p&gt;
&lt;p&gt;问进度时会问：这张卡你还要多久可以完成，人们通常会乐观估计，告诉一个理想化的最短时间&lt;/p&gt;
&lt;p&gt;看板上有很多queue，一般以&quot;ready for XXX&quot;为标题。这些queue会把看板分成独立的几个部分，每个角色只会关注其中的一块。&lt;/p&gt;
&lt;p&gt;比如dev会关注：Ready for dev -&gt; in dev -&gt; ready for QA&lt;/p&gt;
&lt;p&gt;QA会关注：Ready for QA -&gt; in QA -&gt; ready for Prod&lt;/p&gt;
&lt;p&gt;当dev完成后，就会把卡移到ready for QA，而不管里面积了多少张卡，因为不是自己的事。可能dev会很快，但是QA不够，积了很多卡，最后还是无法交付，有大量的WIP(work in progress)&lt;/p&gt;
&lt;p&gt;那么什么是推式系统呢？它是依赖批量计划来执行，成批送到下游工序或仓库排队。集中控制，不考虑下一个工序的实际节拍，独立的工序控制，关注资源能力。没有形成连续流。&lt;/p&gt;
&lt;p&gt;容易库存，容易浪费&lt;/p&gt;
&lt;p&gt;（感觉就像是发邮件：完成任务后，给下一个人发件邮件，告诉他该他了。然后自己再接着做下一个任务）&lt;/p&gt;
&lt;p&gt;在度量时，不是整体时间：backlog -&gt; production，而是部分时间，比如dev只关注dev那几列的最时间。&lt;/p&gt;
&lt;p&gt;精益：追求最小成本&lt;/p&gt;
&lt;p&gt;适合互联网软件开发&lt;/p&gt;
&lt;p&gt;做出来的东西，有没有价值不容易确定。很可能做出一个东西后，发现用户不用，只能砍掉。&lt;/p&gt;
&lt;p&gt;在东西做出来以前，没有用户。&lt;/p&gt;
&lt;p&gt;在这种情况下，关注的是一个需求从提出到上线的时间，叫做cycle time。对于单个需求，叫singleton cycletime，单件时间&lt;/p&gt;
&lt;p&gt;在最短的时间内上线，如果没用，损失也会少一些（浪费的时间和dev少）&lt;/p&gt;
&lt;p&gt;事故管理 Accident&lt;/p&gt;
&lt;p&gt;问进度时会问：在这个cycletime期限，这个功能你能不能完成。只回答能或者不能，而不关心几天&lt;/p&gt;
&lt;p&gt;如果没有完成，则是一个“事故”。人们通常会悲观估计。&lt;/p&gt;
&lt;p&gt;人们关心的是一个需求从提出（答应客户要做），直到上线的总体时间。&lt;/p&gt;
&lt;p&gt;看板上没有Queue，每个列上有一个&quot;MAX&quot;值，说这一列最多有几个。超过数量后，人们就要尽快解决。&lt;/p&gt;
&lt;p&gt;那么什么是拉式系统呢？它是实时响应实际需求或消耗来执行，一种由下游向上游提出实际生产需求的生产控制方法。分散控制，灵活和容易的适应性，关注物料的流动。&lt;/p&gt;
&lt;p&gt;市场要多少，生产多少，没有库存（WIP），没有浪费&lt;/p&gt;
&lt;p&gt;当某列阻塞时，两种做法：&lt;/p&gt;
&lt;p&gt;临时加个Q，做为临时解决方法，多一些缓冲&lt;/p&gt;
&lt;p&gt;某些人解决问题，其它人去做“过程改进”。“改进”是要花时间和成本的。在另一个“改进”看板&lt;/p&gt;
&lt;p&gt;人们会关心从dev到qa到deployment的整个过程，而不像以前只专注某几列。&lt;/p&gt;
&lt;p&gt;&amp;#8212;&amp;#8212;&amp;#8212;-&lt;/p&gt;
&lt;p&gt;敏捷和精简中的很多实践是一样的，但是由于动机不同，关注点不同，所以在做法上会有很多不同。&lt;/p&gt;
&lt;p&gt;我们的REA-RESI项目的确是“精益式开发”。徐大师说我们公司至少有一半的项目应该使用精益。&lt;/p&gt;
&lt;p&gt;另外选择哪一种做法，要看项目类型，客户关注点等，知道什么时候用，什么时候不用&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 1-6 开发者之间如何协作 – 画图游戏</title>
                <link>http://freewind.in/posts/2674-twi-18-1-6-how-to-collaborate-for-developers</link>
                <pubDate>Sat, 14 Jun 2014 10:49:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2674</guid>
                <description><![CDATA[&lt;h2&gt;第一次&lt;/h2&gt;
&lt;p&gt;每人拿一张纸条，上面写要画个什么，大家互相不能看&lt;/p&gt;
&lt;p&gt;然后把大家画的拼在一起，发现很多东西不能拼成功&lt;/p&gt;
&lt;h2&gt;第二次&lt;/h2&gt;
&lt;p&gt;大家先互相看，知道整体是什么样的&lt;/p&gt;
&lt;p&gt;然后定好接口，比如画车的两个人，要定好相同的高度，画房子和树的部分的，也要定好连接处的宽度&lt;/p&gt;
&lt;p&gt;第二次拼在一起好多了&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 1-5 如何向客户交付更多功能 – 折纸游戏</title>
                <link>http://freewind.in/posts/2672-twi-18-1-5-how-to-contribute-more-to-client</link>
                <pubDate>Sat, 14 Jun 2014 10:49:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2672</guid>
                <description><![CDATA[&lt;p&gt;用纸折帽子，要通过用户验收&lt;/p&gt;
&lt;h2&gt;第一轮&lt;/h2&gt;
&lt;p&gt;大家低头使劲折，但用户一个都没满意，交付为0&lt;/p&gt;
&lt;p&gt;这个时候大家才去问客户有什么要求&lt;/p&gt;
&lt;h2&gt;第二轮&lt;/h2&gt;
&lt;p&gt;大家折的少了，每一个都仔细按要求，虽然折的少了，但是客户满意的多了。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;要尽早跟客户确认需求，并严格按照需求做。少做多交付 &gt; 多做都没完成&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 1-4 如何分配项目与人员 – 游戏</title>
                <link>http://freewind.in/posts/2670-twi-18-1-4-how-to-assign-projects-and-people</link>
                <pubDate>Sat, 14 Jun 2014 10:48:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2670</guid>
                <description><![CDATA[&lt;h2&gt;如何分配&lt;/h2&gt;
&lt;p&gt;手上有几个项目，每个项目有对人员的要求、什么语言，什么时候到&lt;/p&gt;
&lt;p&gt;还有一些人的列表：什么技能、什么时候能到、近期有什么事、对项目有什么要求，是BA/DEV/UX&lt;/p&gt;
&lt;p&gt;如何分配最好&lt;/p&gt;
&lt;h2&gt;突然发生了变化：&lt;/h2&gt;
&lt;p&gt;有些人离职了，有些人生病了，有些人请假了，怎么办&lt;/p&gt;
&lt;p&gt;项目那边突然要加人了，对人员要求改变了，怎么办&lt;/p&gt;
&lt;h2&gt;分配者与开发者之间&lt;/h2&gt;
&lt;p&gt;分配者希望开发者：告诉自己对项目有什么希望，请假等要提前告知，不断更新自己简历和技能&lt;/p&gt;
&lt;p&gt;开发者希望分配者：有项目时提前告诉大家，把每个项目的要求列出来&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 1-3 如何演讲</title>
                <link>http://freewind.in/posts/2668-twi-18-1-3-how-to-make-a-speech</link>
                <pubDate>Sat, 14 Jun 2014 10:48:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2668</guid>
                <description><![CDATA[&lt;p&gt;大家总结了一堆，忘了。&lt;/p&gt;
&lt;p&gt;每天中午都有几个人，每人5分钟做个session。&lt;/p&gt;
&lt;p&gt;有人介绍自己，有人宠物保护，有人吉它，有人潜水员，有人讲编程，有人讲彩票，有人讲育儿&lt;/p&gt;
&lt;p&gt;我的是“和stackoverflow做朋友”&lt;/p&gt;
&lt;p&gt;feedback:&lt;/p&gt;
&lt;p&gt;比较紧张，似乎沉浸在自己的回忆中&lt;/p&gt;
&lt;p&gt;眼睛看着脚下， 要多看观众&lt;/p&gt;
&lt;p&gt;缺少激情&lt;/p&gt;
&lt;p&gt;声音不大&lt;/p&gt;
&lt;p&gt;改进：&lt;/p&gt;
&lt;p&gt;要经常环视观众，从每个人的头上方过去&lt;/p&gt;
&lt;p&gt;站稳，不要乱晃&lt;/p&gt;
&lt;p&gt;与听众互动&lt;/p&gt;
&lt;p&gt;声音不能一个调，要有快慢和起伏&lt;/p&gt;
&lt;p&gt;某些时候要有动作&lt;/p&gt;
&lt;p&gt;准备要充分&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 1-2. 什么是敏捷</title>
                <link>http://freewind.in/posts/2666-twi-18-1-2-agile</link>
                <pubDate>Sat, 14 Jun 2014 10:47:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2666</guid>
                <description><![CDATA[&lt;p&gt;敏捷宣言&lt;/p&gt;
&lt;p&gt;虽然我们更认同左右的价值，但我们也承认右边的价值&lt;/p&gt;
&lt;p&gt;我们会问：你是选金钱，还是美女？&lt;/p&gt;
&lt;p&gt;但不会问：你是选金钱，还是大粪？&lt;/p&gt;
&lt;p&gt;瀑布是一个反模型：从上到下，不能回头&lt;/p&gt;
&lt;p&gt;在需求分析阶段，会对所有功能进行分析&lt;/p&gt;
&lt;p&gt;无法应对变化，反馈慢。&lt;/p&gt;
&lt;p&gt;对日外包：文档超详细，甚至连每个方法和变量名都定好了&lt;/p&gt;
&lt;p&gt;但是，它有很多改良版。敏捷中的一个迭代，也可看作是一个非常小型的瀑布&lt;/p&gt;
&lt;p&gt;（我认为，topcoder中的模型，也是一种改良的瀑布）&lt;/p&gt;
&lt;h2&gt;轻量级方法&lt;/h2&gt;
&lt;p&gt;XP： 极限编程， Kent, Martin flower等。极限的意思是：既然我们承认开发中有一些很好的实践，那么我们便把它们发挥到极限。TDD，跟客户一起工作，showcase，每日code review。small release。&lt;/p&gt;
&lt;p&gt;水晶：根据项目大小和人员多少，分成多个格。不同的格采用不同的开发方式&lt;/p&gt;
&lt;p&gt;scrum: 迭代，站会，kickoff, code review, retro&lt;/p&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;我们公司采用的是scrum +  xp。&lt;/p&gt;
&lt;h2&gt;敏捷&lt;/h2&gt;
&lt;p&gt;这些轻量级方法有很多共同点，所以它们的创建者们在一起开了个会，总结出一套价值观，叫敏捷宣言。17个人开了个会，签了字，定了下来。&lt;/p&gt;
&lt;p&gt;怎么感觉这个session很长，但是却回忆不出多少内容了？是不是漏了什么？&lt;/p&gt;
&lt;p&gt;另外凯锋提到说，敏捷方法也许不太适合互联网公司。我会后问了一下，他的大意是说，互联网公司要求很快的推出某个功能，甚于不会像我们这样写测试，因为按我们的方法，开发一个功能时大部分的时间都花在测试上了。而互联网用户对网站出错的容忍程度比较大，只要发现错误后及时改正就可以。另外，我们前同事去了某家公司后，发现那边有很强的出错切换机制，当新功能出现问题时，能快速切换到备用的旧版本机器。&lt;/p&gt;
&lt;p&gt;可能我对凯锋的回答理解得不太清楚，加上我对这些也没什么想法，后来就这个问题问徐大师时，感觉自己讲不清楚，只记得徐大师强烈质疑我的问题：不写测试就能让交付更快？&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>TWI 1-1 – 公司历史、文化、三个支柱</title>
                <link>http://freewind.in/posts/2663-twi18-1-1-tw-history-culture-p3</link>
                <pubDate>Sat, 14 Jun 2014 10:47:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2663</guid>
                <description><![CDATA[&lt;p&gt;公司由Roy创建于1993年。&lt;/p&gt;
&lt;p&gt;当时在校园里招聘时的口号是：University by paid&lt;/p&gt;
&lt;p&gt;公司文化可信度：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有历史事件支撑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每一个口号都有产生的原因&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以人为本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;曾经某ceo无理解雇了两个员工，第二天自己被解雇&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Roy想解雇某员工，没有成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;扁平结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在中国有400人左右，但是管理人员只有十来个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三个支柱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;持续经营&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件卓越和IT革命&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;社会与经济公正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;持续经营&lt;/h2&gt;
&lt;p&gt;赚不了大钱，不倒闭就行&lt;/p&gt;
&lt;p&gt;曾经有人投资500万，后来索要4300万。北美最高法院审理，公司不必破产，但有钱时需要还。快解决了，解决以后所有人去加勒比海、豪华游轮&lt;/p&gt;
&lt;p&gt;公司除了人以外，没有其它任何资产&lt;/p&gt;
&lt;p&gt;twer的生产力是行业平均水平的8到10倍，以此吸引更多类似的人加入&lt;/p&gt;
&lt;p&gt;Roy不靠公司挣钱，只希望它能生存。&lt;/p&gt;
&lt;p&gt;一个社会实验。&lt;/p&gt;
&lt;p&gt;先干活，后付费。通常70天后才能拿到客户的付款&lt;/p&gt;
&lt;p&gt;Roy在公司初期的三五年内，靠各种信用卡套现发工资。&lt;/p&gt;
&lt;p&gt;公司每月扣除所有开支后，只剩1.5万美金&lt;/p&gt;
&lt;p&gt;所以我们要求每周五尽快填写timesheet，就是为了早点拿到回款&lt;/p&gt;
&lt;h2&gt;软件卓越和IT革命&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;公司不会发明下一代的编程语言、数据库，在技术上并不是最好的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是几乎每一个新技术的最佳实践，都是最先由我们公司推出(ruby?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;立足根本：新技术，更好的实践？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;个人生产力是行业平均的8到10倍（曾经）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;交付项目的报价是同类公司的2到4倍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;领导IT行业的革命：敏捷的普及&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们公司，如果你只需要钻研新技术，希望开发出下一代的编程语言、数据库什么的人，不适合我们公司。&lt;/p&gt;
&lt;p&gt;你必须要不断追求，如何让新技术与实践结合，让它比现在的实践更好。只有做到这些，才能在公司里活得开心。&lt;/p&gt;
&lt;h2&gt;社会与经济公正&lt;/h2&gt;
&lt;p&gt;在非洲很多偏远地区，有人会给村民量体温等数据，记在纸上，通过步行走很远交给一些部门，再通过人眼分析统计，预测疫情。&lt;/p&gt;
&lt;p&gt;我们公司曾经帮助他们开发了一个通过短信发送报告的程序，虽然很小，但是对千万人的健康带来很大的帮助。&lt;/p&gt;
&lt;p&gt;程序员有着远大于自己想像的能力。&lt;/p&gt;
&lt;p&gt;做公益有多种方式，直接给钱是最容易的一种。我们通过自己的参与去帮助他们。&lt;/p&gt;
&lt;p&gt;公司有专门的公益事业负责人，帮助国内公益组织。&lt;/p&gt;
&lt;p&gt;心声，阳光书屋等&lt;/p&gt;
&lt;h2&gt;公司什么流&lt;/h2&gt;
&lt;p&gt;marketing -&gt; sale -&gt; ba -&gt; dev -&gt; qa -&gt; &amp;hellip;. -&gt; finace ???&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>第18期TWI记录 – 大纲</title>
                <link>http://freewind.in/posts/2658-twi18-outline</link>
                <pubDate>Fri, 06 Jun 2014 21:31:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2658</guid>
                <description><![CDATA[&lt;p&gt;在加入公司一年以后，我终于有机会参加公司针对新人举办的TWI。一共三天时间，16名学员，6名培训师。每天上午主要由徐大师、张凯锋等讲session，下午是各种游戏。&lt;/p&gt;
&lt;p&gt;这三天的培训，让我觉得自己的收获非常大，很多困惑多时的疑问，终于得到了解答，有种豁然开朗的感觉。真希望自己能早点参加。&lt;/p&gt;
&lt;p&gt;首先要对各位培训师、组织者以及公司、表示深深的谢意。同时感谢一起参加的各位同学，我们在一起度过了愉快的三天。&lt;/p&gt;
&lt;p&gt;第一天：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;公司历史、文化、三个支柱 (徐大师)&lt;/li&gt;
&lt;li&gt;什么是敏捷 (张凯锋)&lt;/li&gt;
&lt;li&gt;如何演讲&lt;/li&gt;
&lt;li&gt;如何分配项目与人员 - 游戏&lt;/li&gt;
&lt;li&gt;如何向客户交付更多功能 - 折纸游戏&lt;/li&gt;
&lt;li&gt;开发者之间如何协作 - 画图游戏&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二天：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从敏捷到精益 (徐大师)&lt;/li&gt;
&lt;li&gt;精益分析&lt;/li&gt;
&lt;li&gt;精益创业游戏 - 乐高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第三天：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;咨询入门 (徐大师)&lt;/li&gt;
&lt;li&gt;如何引导客户找到解决方案 - 游戏&lt;/li&gt;
&lt;li&gt;如何反馈 - 游戏&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些内容非常重要，对于每一个thoughtworker而言，每一个都是必须了解和掌握的技能。&lt;/p&gt;
&lt;p&gt;下面将分篇记录每一个主题。有些地方可能记的不太准确了，只能凭印象尽力而为。我们可以把这些当作入门索引，通过了解这些知识，去读更多的书深入。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>2014-05 月结</title>
                <link>http://freewind.in/posts/2656-month-2014-05</link>
                <pubDate>Fri, 06 Jun 2014 20:57:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2656</guid>
                <description><![CDATA[&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尝试做一个好用的博客编辑器供自己使用，采用JavaFX，最后因JavaFX对中文支持太差中止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以“无敌方向键”为名参加公司举办的技术大赛，在张新宇的帮助下尝试多种方案，进行中。深刻体会到“硬件是一个不断妥协放弃、寻找替代方案的过程”，因为理想中的配件都买不到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继续深入scala，为了掌握高阶类型等知识，开始看haskell和sicp&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>iterm2中使用home/end跳到行首/行尾</title>
                <link>http://freewind.in/posts/2649-use-home-end-in-iterm2</link>
                <pubDate>Sat, 31 May 2014 21:08:44 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2649</guid>
                <description><![CDATA[&lt;p&gt;在mac上使用windows键盘，在iterm2中，按下Home/End键时，默认会切换到上/下一个tab，十分不方便。我想修改它们，让Home跳到行首，End跳到行尾。&lt;/p&gt;
&lt;p&gt;在Preferences中，设置keys:&lt;/p&gt;
&lt;p&gt;Home: send Hex code: 001&lt;/p&gt;
&lt;p&gt;End: send Hex code: 005&lt;/p&gt;
&lt;p&gt;即可。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt设置全局idea插件</title>
                <link>http://freewind.in/posts/2647-sbt-setup-global-idea-plugin</link>
                <pubDate>Wed, 28 May 2014 23:41:14 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2647</guid>
                <description><![CDATA[&lt;p&gt;sbt本身不支持生成IDEA项目，但是对于我们来说，几乎每一个sbt项目，都需要生成相应的IDEA项目。&lt;/p&gt;
&lt;p&gt;我们可以在项目中的plugins文件中添加，更方便的做法是在全局添加，这样拿到一个sbt项目，什么都不用动就能生成IDEA项目了。&lt;/p&gt;
&lt;p&gt;在用户目录下的全局插件文件&lt;code&gt;~/.sbt/0.13/plugins/build.sbt&lt;/code&gt;中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;resolvers ++= Seq(
    &quot;Sonatype snapshots&quot; at &quot;http://oss.sonatype.org/content/repositories/snapshots/&quot;
)

addSbtPlugin(&quot;com.github.mpeltonen&quot; % &quot;sbt-idea&quot; % &quot;1.7.0-SNAPSHOT&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样在任意一个sbt项目中，我们都可以运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sbt gen-idea
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成相应的IDEA文件。&lt;/p&gt;
&lt;p&gt;如果想同时下载源代码，可运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sbt &quot;gen-idea sbt-classifiers&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后可以用idea直接打开，里面的各项依赖都可以直接使用了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>技术创新大赛西安赛区硬件培训 (1)</title>
                <link>http://freewind.in/posts/2643-xian-hardware-training-1</link>
                <pubDate>Wed, 28 May 2014 22:09:01 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2643</guid>
                <description><![CDATA[&lt;p&gt;课程1. 让脑袋硬一点，从Arduino开始&lt;/p&gt;
&lt;p&gt;内容：Arduino介绍&lt;/p&gt;
&lt;p&gt;Arduino软硬件开发环境介绍&lt;/p&gt;
&lt;p&gt;搭建并使用开发环境，驱动各种硬件接口（ C &amp;#038; C++语言 ）&lt;/p&gt;
&lt;p&gt;做个无级调光遥控灯玩玩&lt;/p&gt;
&lt;p&gt;目标：让硬件开发在你的脑子里面更具象化一些；时间半个到一个小时。&lt;/p&gt;
&lt;p&gt;1 . Download and Install&lt;/p&gt;
&lt;p&gt;Arduino IDE : http://arduino.googlecode.com/files/arduino-1.0.5-macosx.zip&lt;/p&gt;
&lt;p&gt;FTDI USB Serial Driver : http://www.ftdichip.com/Drivers/VCP/MacOSX/FTDIUSBSerialDriver_v2_2_18.dmg&lt;/p&gt;
&lt;p&gt;2 . Have a look at this document&lt;/p&gt;
&lt;p&gt;Getting Started with Arduino on Mac OS X : http://arduino.cc/en/Guide/MacOSX&lt;/p&gt;
&lt;p&gt;3 . Bookmark following links:&lt;/p&gt;
&lt;p&gt;http://arduino.cc/en/Main/ArduinoBoardNano&lt;/p&gt;
&lt;p&gt;http://arduino.cc/en/Main/ArduinoBoardUno&lt;/p&gt;
&lt;p&gt;http://arduino.cc/en/Main/ArduinoBoardMega2560&lt;/p&gt;
&lt;p&gt;http://arduino.cc/en/Reference/HomePage&lt;/p&gt;
&lt;p&gt;Agenda&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Arduino介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Go through &amp;#8220;Getting Started&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Digital I/O, Analog I/O介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Practice: &amp;#8220;Digital I/O&quot;控制，通过按钮控制LED灯的亮和灭&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Practice: &amp;#8220;Analog I/O&quot;控制，通过电位器控制LED灯的亮度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;串口通讯UART&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;程序调试&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>技术创新大赛西安赛区硬件培训 (2)</title>
                <link>http://freewind.in/posts/2645-xian-hardware-training-2</link>
                <pubDate>Wed, 28 May 2014 22:03:39 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2645</guid>
                <description><![CDATA[&lt;p&gt;课程 2 Agenda&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;课程1内容回顾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;串口通讯UART&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小练习：使用模拟输入口读取电位器数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通讯接口原理：SPI, I2C&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分组实验&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数字i/o类：按键，LED灯，1/4位数码管，继电器，有源嗡鸣器，RGB三色灯，矩形键盘，红外遥控&lt;/p&gt;
&lt;p&gt;模拟i/o类：可调电阻／光敏电阻，无源嗡鸣器(pwm)，LED调光(pwm)&lt;/p&gt;
&lt;p&gt;通讯类：串行通讯(uart)，LCD显示屏（i2c)，以太网通讯(spi-&gt;ethernet)，近场通讯RFID &amp;amp; NFC，SD卡读写&lt;/p&gt;
&lt;p&gt;其它：Arduino内部Flash使用，iBeacon&lt;/p&gt;
&lt;p&gt;课前准备：&lt;/p&gt;
&lt;p&gt;请大家提前下载Mac 上的串口驱动 http://wch.cn/downloads.php?name=pro&amp;amp;proid=178&lt;/p&gt;
&lt;p&gt;读串口：brew install minicom&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用brew安装scala 2.8.x</title>
                <link>http://freewind.in/posts/2641-brew-install-scala-2-8-x</link>
                <pubDate>Wed, 28 May 2014 21:41:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2641</guid>
                <description><![CDATA[&lt;p&gt;有时候我们需要使用旧版本的scala，比如2.8.x，但是brew只支持2.9.x以后的。&lt;/p&gt;
&lt;p&gt;我们可以自己动手创建一个&lt;code&gt;scala.rb&lt;/code&gt;，来支持brew:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require &apos;formula&apos;

class Scala &amp;lt; Formula
  homepage &apos;http://www.scala-lang.org/&apos;
  url &apos;http://www.scala-lang.org/files/archive/scala-2.8.2.final.tgz&apos;
  # 如果已经下载到本地，则
  # url &apos;file:/Users/freewind/Downloads/scala-2.8.2.final.tgz&apos;
  version &apos;2.8.2&apos;

  def install
    rm_f Dir[&quot;bin/*.bat&quot;]
    doc.install Dir[&apos;doc/*&apos;]
    man1.install Dir[&apos;man/man1/*&apos;]
    libexec.install Dir[&apos;*&apos;]
    bin.install_symlink Dir[&quot;#{libexec}/bin/*&quot;]
  end
end


然后：

brew install scala.rb --with-docs


查看本地通过brew安装了的scala版本：

brew info scala


切换到某个特定版本：

brew switch scala 2.8.2
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>JavaFX试用</title>
                <link>http://freewind.in/posts/2629-try-javafx</link>
                <pubDate>Sat, 17 May 2014 15:51:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2629</guid>
                <description><![CDATA[&lt;p&gt;我这些天尝试使用JavaFX做一个本地的Markdown编辑器，支持预览等功能，以方便写博客。最后因为JavaFX的TextArea中的一些问题导致无法继续，转而寻找其它的方案。&lt;/p&gt;
&lt;p&gt;总结一下这段时间使用JavaFX的感受。&lt;/p&gt;
&lt;h2&gt;选用JavaFX的原因&lt;/h2&gt;
&lt;p&gt;之所以选用JavaFX，主要是因为现在JavaFX已经支持Mac了，在主流的操作系统上都可以运行。同时官方提供的示例中，有一个Ensemble.jar，演示了各种各样很漂亮的JavaFX控件和特色，感觉很好：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2629-1.png&quot;&gt;&lt;img src=&quot;/user_images/2629-1.png&quot; alt=&quot;QQ20140517-3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时它还提供了一个界面设计器Scene builder，也很精致：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2629-3.png&quot;&gt;&lt;img src=&quot;/user_images/2629-3.png&quot; alt=&quot;QQ20140517-5&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一个可帮助调试Scenic View ，可以监控另一个运行中的JavaFX程序，实时查看各个控件的属性：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2629-5.png&quot;&gt;&lt;img src=&quot;/user_images/2629-5.png&quot; alt=&quot;QQ20140517-6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;我所感受到的优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;支持多种操作系统，比如windowx, mac, linux, Solaris，另外似乎&lt;span style=&quot;font-size: 14px; line-height: 1.5em;&quot;&gt;Raspberry Pi也支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可使用fxml/css/java来分离界面、样式和逻辑，如同html/css/javascript&lt;/li&gt;
&lt;li&gt;fxml与相应的controller之间结合得比较好，可以方便地互相引用&lt;/li&gt;
&lt;li&gt;支持binding，可以在fxml中方便地引用controller中的属性或者事件处理方法&lt;/li&gt;
&lt;li&gt;几乎所有的属性都可以添加listener，以监控其值的变化&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;我所遇到的问题&lt;/h2&gt;
&lt;p&gt;JavaFX现在还在紧张开发中，不成熟。虽然大体功能看起来都不错，但是一旦用得细了，经常会遇到各种各样的问题。&lt;/p&gt;
&lt;h3&gt;TextArea问题很多&lt;/h3&gt;
&lt;p&gt;由于我想做的是一个markdown编辑器，在TextArea方面用得比较细，也因此发现了很多的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我想按下&lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;=&lt;/kbd&gt;的时候放大字体，但是发现它会多触发两个按键事件。所以我需要额外添加按键间隔时间的检查，以绕过这个问题&lt;/li&gt;
&lt;li&gt;当我选择了一些比较好看的字体后，发现按向下方向键时，光标有时候无法跳到下一行&lt;/li&gt;
&lt;li&gt;当我按&lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;up&lt;/kbd&gt;来选择文字的时候，它无法选中第一行&lt;/li&gt;
&lt;li&gt;当我在一行长中文前添加空格时，中文整行会向下跳一行，但是行首并没有显示出空格&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没想到TextArea的这些基本功能居然有这么多问题。虽然我在官网上提了几个issue，但是不知道什么时候才能修复。我试着自己来处理它们以绕过这些问题，但是发现这些基本功能之间联系太紧密了，我几乎需要把所有的基本功能实现一遍，工作量太大了。&lt;/p&gt;
&lt;h3&gt;2. 文字显示效果不太好&lt;/h3&gt;
&lt;p&gt;一段文字，使用同样的字体和字号，在JavaFX与浏览器中对比，发现JavaFX的显示没有浏览器中好看。主要问题是文字有点虚，不太清晰。所以我只好设置成比较大的字号，看起来会好一点。&lt;/p&gt;
&lt;h3&gt;3. CSS支持不完善&lt;/h3&gt;
&lt;p&gt;JavaFX支持CSS样式，但是所有的属性都要以&lt;code&gt;-fx-&lt;/code&gt;开头。它实现了部分CSS属性，有一些常用的，比如&lt;code&gt;line-height&lt;/code&gt;它都没有提供。另外某些功能还不完善，比如&lt;code&gt;-fx-font-family&lt;/code&gt;，它只能设一个值。&lt;/p&gt;
&lt;p&gt;这里是JavaFX所支持的CSS属性，需要时可过来查一下：&lt;a href=&quot;http://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html&quot;&gt;http://docs.oracle.com/javafx/2/api/javafx/scene/doc-files/cssref.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4. 布局略显繁琐&lt;/h3&gt;
&lt;p&gt;虽然我们可以在fxml文件来布局，但是还是不够方便。比如我想让各组件在resize时，能自动按一定规则缩放，就无法在fxml中设置，只能在对应的controller中，依次调用如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HBox.setHgrow(editorPane, Priority.ALWAYS);
HBox.setHgrow(previewPane, Priority.ALWAYS);
HBox.setHgrow(preview, Priority.ALWAYS);


这样的方式给它们每个都设上这样的一个属性。有时候我们其实用不上某个控件，但仅仅因为布局，就需要在controller里声明对它的引用：

@FXML private BorderPane previewPane;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果能在布局方面做得更好一些，比如可以直接在fxml文件中实现， 或者在CSS中定义就更好了。&lt;/p&gt;
&lt;h3&gt;5. 调试不方便&lt;/h3&gt;
&lt;p&gt;主要是布局和样式方面，因为不能实时真实的看到样式的变化，所以只能修改后重启程序，非常低效。也许对于定义在css中的样式可以做到监控文件并重新加载，解决部分问题，但是我还没有来得及尝试。&lt;/p&gt;
&lt;p&gt;我感觉自己的大部分时间是浪费在这上面了。&lt;/p&gt;
&lt;h3&gt;6. API变化快&lt;/h3&gt;
&lt;p&gt;在JavaFX正在紧张开发的时候，API变化快出现不兼容是无法避免的。我在开发的过程中，必须使用&lt;code&gt;jdk1.8_05&lt;/code&gt;的版本，才能正确地使用某些第三方库。换一个小版本，都会出现编译错误。&lt;/p&gt;
&lt;h3&gt;7. 某些常用组件缺失&lt;/h3&gt;
&lt;p&gt;比如用于显示提示信息的各种对话框，javaFx都没有内置，我们必须自己找第三方库解决。由于这些库没有进maven仓库，必须下载成jar包放在项目里，感觉很不方便。&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;https://github.com/freewind/ColaBlog&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;JavaFX是一个功能强大的Java GUI框架，相比swing等要好用很多。特别是binding的功能，可以让我们的代码简洁很多。&lt;/p&gt;
&lt;p&gt;对于编辑器这样的功能，它还存在各种各样的问题；但对于通常的应用，我觉得应该没太大问题了，毕竟有SenceBuilder这样的案例可证明。&lt;/p&gt;
&lt;p&gt;我想给它更多的时间，也许JavaFX就会担负起振兴Java GUI功能的重任了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Gradle设置全局仓库</title>
                <link>http://freewind.in/posts/2627-gradle-global-repo</link>
                <pubDate>Thu, 15 May 2014 18:40:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2627</guid>
                <description><![CDATA[&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 14px; line-height: 1.5em;&quot;&gt;在用户目录下创建&lt;/span&gt;&lt;code&gt;~/.gradle/init.gradle&lt;/code&gt;&lt;span style=&quot;font-size: 14px; line-height: 1.5em;&quot;&gt;，内容如下:&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;allprojects {
    repositories {
        mavenLocal()
        maven {
          name &apos;oschina&apos;
          url &quot;http://maven.oschina.net/content/groups/public/&quot;
        }
        maven {
          url &quot;http://localhost:8081/nexus/content/groups/public/&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把想要先访问的库放在前面。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>问候sbt一千遍之：添加全局镜像库</title>
                <link>http://freewind.in/posts/2619-sbt-global-repo</link>
                <pubDate>Fri, 09 May 2014 23:15:22 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2619</guid>
                <description><![CDATA[&lt;p&gt;sbt运行时经常需要下载大量的jar包，默认连接到maven官网，速度通常比较慢。我想把国内的一些maven库添加到sbt的全局设置里，并且先尝试它们，这样就不必修改每个sbt项目。&lt;/p&gt;
&lt;p&gt;在老猪的帮助下，最终无比郁闷的知道了解决方法：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;~/.sbt/&lt;/code&gt;下添加一个&lt;code&gt;repositories&lt;/code&gt;文件，里面内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[repositories]
local
osc: http://maven.oschina.net/content/groups/public/
typesafe: http://repo.typesafe.com/typesafe/ivy-releases/, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext], bootOnly
sonatype-oss-releases
maven-central
sonatype-oss-snapshots
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;要放在&lt;code&gt;~/.sbt&lt;/code&gt;目录下，而不是&lt;code&gt;~/.sbt/0.13.x&lt;/code&gt;这样的子目录下&lt;/p&gt;
&lt;p&gt;如果你想看官方文档，请打开：&lt;a href=&quot;http://www.scala-sbt.org/0.13.2/docs/Detailed-Topics/Library-Management.html#override-all-resolvers-for-all-builds&quot;&gt;http://www.scala-sbt.org/0.13.2/docs/Detailed-Topics/Library-Management.html#override-all-resolvers-for-all-builds&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，再次问候sbt一千遍！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala类型系统之：来自星星的猫</title>
                <link>http://freewind.in/posts/2613-scala-type-systems-the-cat-from-stars</link>
                <pubDate>Fri, 02 May 2014 20:18:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2613</guid>
                <description><![CDATA[&lt;blockquote&gt;&lt;p&gt;注：本文是我这段时间学习Scala类型系统时的一些所得，可能有很多地方不严谨或者不正确，欢迎指出。在些期间，得到了老猪、大魔头、教主等多位群友，以及无敌的stackoverflow的帮助，特此感谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Scala in programming上，关于协变、逆变这一章，藏着一只非常奇特的猫，我叫它“来自星星的猫”。&lt;/p&gt;
&lt;p&gt;下面是原书内容，见“Scala编程”第19章“参数类型化”第258页：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;下面是个显得有点生编硬造的例子，我们考虑如下的类型定义，其中若干位置的变化型被标了&lt;sup&gt;+&lt;/sup&gt;（正的）或&lt;sup&gt;-&lt;/sup&gt;（负的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class Cat[-T, +U] {

  def meow[W&amp;lt;sup&amp;gt;-&amp;lt;/sup&amp;gt;](volue: T&amp;lt;sup&amp;gt;-&amp;lt;/sup&amp;gt;, listener: Cat[U&amp;lt;sup&amp;gt;+&amp;lt;/sup&amp;gt;, T&amp;lt;sup&amp;gt;-&amp;lt;/sup&amp;gt;]&amp;lt;sup&amp;gt;-&amp;lt;/sup&amp;gt;) :Cat[Cat[U&amp;lt;sup&amp;gt;+&amp;lt;/sup&amp;gt;,T&amp;lt;sup&amp;gt;-&amp;lt;/sup&amp;gt;]&amp;lt;sup&amp;gt;-&amp;lt;/sup&amp;gt;, U&amp;lt;sup&amp;gt;+&amp;lt;/sup&amp;gt;]&amp;lt;sup&amp;gt;+&amp;lt;/sup&amp;gt;

}



类型参数W，以及两个值参数，volume和listener的位置都是负的。注意meow的结果类型，第一个Cat[U,T]参数的位置是负的，因为Cat的第一个类型参数T被标了-号。这个参数中的类型U重新转为正的位置（两次翻转），而参数中的类型T仍然是负的位置。

从讨论中你可以发现想要跟上变化型位置的变化是非常困难的。因此Scala编译器自动帮你完成这项工作，从而减轻了你的负担。

计算变化型的过程中，编译器检查每个类型参数是否仅用于分类正确的位置。这个例子中，T仅用在负的位置上，而U仅用于正的位置上。因此Cat类是类型正确的。

​本文的目的，就是要看懂这只猫。

&amp;lt;div class=&quot;se-section-delimiter&quot;&amp;gt;&amp;lt;/div&amp;gt;

## 类型位置

在一个类(class/triat)及方法中，有一些位置可以声明或使用类型，比如，以这只简单的猫为例：

trait Cat[A] {
  def meow[B](volume: C): D
}


如上所示，共有4个位置是跟类型相关。其中A、B处可以声明类型，C、D处可以使用类型。

有一些位置有正负之分，比如B、C处是负的，D是正的。还有一些是中立的，在这里没有体现出来。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里需要强调一下：如果下文里提到“A位置”、“B位置”、“C位置”、“D位置”，如果上下文不顺畅，那么就是指这里的这四个位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;se-section-delimiter&quot;&amp;gt;&amp;lt;/div&amp;gt;

## 正负是什么意思

书上提到了类型位置的正负，但是没有给它一个准确的定义，只是大概说了一下：“负”的位置只能用逆变，“正”的位置只能用“协变”。我查阅了很多资料，也问了很多人，都没有得到满意的答案。

以下是我自己的理解，可能对也可能不对，请小心阅读：

“类型”是我们的程序与编译器交流沟通的工具，它就像一些神秘的指令，我们利用它向编译器告诉我们的意图，编译器会试着理解它，生成更高效的代码，同时找出可能存在错误或矛盾的地方。

我们的“与类型相关的意图”反映在代码层面（类、方法），可以分为这三种：
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个方法可以向外界提供什么类型的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个方法可以处理什么类型的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个泛型类的多个类型参数之间有什么关系&lt;/p&gt;
&lt;p&gt;这三种意图互相独立，并且当类型不是“无变”时，对类型的变化型还有不同的要求。我认为，如果一个位置是为了“对外提供”而声明和使用类型的，则是“正”的；如果是为了“处理”而声明或使用的，则为“负”的。“正”与“负”只是为了对两种意图进行区分和表达的。&lt;/p&gt;
&lt;p&gt;这样D处就是正的，C处就是负的。而B处声明的类型通常用于C处，所以它也是负的。而A处声明的参数，并不确定是用在哪个地方，所以它的正负需要看具体情况而定。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;变化型&lt;/h2&gt;
&lt;p&gt;我们知道，在scala中有三种变化型，分别是无变(invariant)，协变(covariant)，和逆变(contravariant)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无变：定义泛型Cat[T]，尽管String &amp;lt;: Any，但Cat[String]与Cat[Any]之间没有任何关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协变：定义泛型Cat[+T]，如果String &amp;lt;: Any，则Cat[String] &amp;lt;: Cat[Any]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逆变：定义泛型Cat[-T]，如果String &amp;lt;: Any，则Cat[Any] &amp;lt;: Cat[String]&lt;/p&gt;
&lt;p&gt;其中无变的情况比较特殊。如果一个参数被声明为无变，则它可以无视类型位置的正负，出现在任何地方。&lt;/p&gt;
&lt;p&gt;而“协变”和“逆变”的目的在于，用于让编译检查：当泛型对象被看作它原本类型的父类型时，它的原有功能（“向外提供”或“处理外界传入数据”）的类型要求是否被破坏。&lt;/p&gt;
&lt;h3&gt;上下界&lt;/h3&gt;
&lt;p&gt;当以一个协变或逆变的类型作为上下界来声明一个新类型时，需要注意，新类型本身是“无变”的。比如：&lt;/p&gt;
&lt;p&gt;trait Cat[+A] {
&lt;br  /&gt;def meow[B &gt;: A](x: B): B
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;trait Cat[-A] {
&lt;br  /&gt;def meow[B &lt;: A](x: B): B
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;上面的代码是可以通过编译的。这里的定义出来的&lt;code&gt;B&lt;/code&gt;类型本身并不是逆变的，它实际上是“无变”的，只是它依赖于另一个协变或者逆变的&lt;code&gt;A&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而无变的类型可以出现在任何位置，所以它可以放在参数和返回值位置。&lt;/p&gt;
&lt;p&gt;再来个例子：&lt;/p&gt;
&lt;p&gt;trait Cat[-A, T&gt;:A] {
&lt;br  /&gt;def meow(x: T): T
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;这里通过下界声明了一个类型&lt;code&gt;T&lt;/code&gt;，它可以同时用于方法参数和返回值处，说明它也是无变的。&lt;/p&gt;
&lt;p&gt;如果我们给它加上变化型：&lt;/p&gt;
&lt;p&gt;trait Cat[-A, +T&gt;:A] {
&lt;br  /&gt;def meow(x: T): T  // !!! can&apos;t compile
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;它会报错说&lt;code&gt;T&lt;/code&gt;是协变的，不能出现在参数位置那里（因为那里是负位置）&lt;/p&gt;
&lt;h2&gt;参数与返回值&lt;/h2&gt;
&lt;p&gt;上面那只奇特的猫，实际上是很复杂的。它成功的把很多问题和难点，以夸张的形式组合在了一起，让人很难一下子看懂。所以我们要减化问题，从易到难，一点点剖析它。&lt;/p&gt;
&lt;p&gt;先以这只简化的猫为例：&lt;/p&gt;
&lt;p&gt;trait Cat[-C, +D] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(volume: C): D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;我们要回答两个问题：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么meow方法的返回值D处（正的），只能用协变？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为什么meow方法的参数C处（负的），只能用逆变？&lt;/p&gt;
&lt;p&gt;再次强调，本文的讨论都是基于各类型是协变或者逆变的前提，不考虑“无变”的情况。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;返回值必须是协变的&lt;/h2&gt;
&lt;p&gt;在下面更加简化的代码里，我们定义了一个协变的类型&lt;code&gt;T&lt;/code&gt;，它被用于返回值。&lt;/p&gt;
&lt;p&gt;trait Cat[+T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def meow: T
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;它是可以通过编译的。但是如果&lt;code&gt;T&lt;/code&gt;是逆变的，就无法通过编译：&lt;/p&gt;
&lt;p&gt;trait Cat[-T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def meow:T   // !! can&apos;t be compiled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;会提示错误：&lt;/p&gt;
&lt;p&gt;error: contravariant type T occurs in covariant position in type =&gt; T of method meow&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       def meow:T
           ^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是为什么呢？&lt;/p&gt;
&lt;h3&gt;如果返回值是协变的&lt;/h3&gt;
&lt;p&gt;首先看这只协变猫&lt;code&gt;Cat[+T]&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;trait Cat[+T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def meow: T
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;val child = new Cat[String] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow:String = &quot;miaomiao~~&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;val parent: Cat[Any] = child&lt;/p&gt;
&lt;p&gt;由于T是协变的，所以Cat[String]是Cat[Any]的子类型，所以上面的赋值是成立的。&lt;/p&gt;
&lt;p&gt;然后取返回值：&lt;/p&gt;
&lt;p&gt;val voice:Any = parent.meow&lt;/p&gt;
&lt;p&gt;由于parent的类型是&lt;code&gt;Cat[Any]&lt;/code&gt;，所以在编译器看来，&lt;code&gt;parent.meow&lt;/code&gt;返回值是&lt;code&gt;Any&lt;/code&gt;。同时不要忘了，&lt;code&gt;parent&lt;/code&gt;指向的是&lt;code&gt;child&lt;/code&gt;实例，所以&lt;code&gt;voice&lt;/code&gt;的值实际上是&lt;code&gt;child.meow&lt;/code&gt;返回的&lt;code&gt;miaomiao~~&lt;/code&gt;这个String。&lt;/p&gt;
&lt;p&gt;由于String实例总是Any类型的，所以不会有任何编译错误。&lt;/p&gt;
&lt;h3&gt;如果返回值是逆变的&lt;/h3&gt;
&lt;p&gt;那么是只逆变猫&lt;code&gt;Cat[-T]&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;trait Cat[-T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def meow: T
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;根据逆变的定义，我们可以写出下面的赋值：&lt;/p&gt;
&lt;p&gt;val child = new Cat[Any] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow:Any = 123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;val parent: Cat[String] = child&lt;/p&gt;
&lt;p&gt;然后对返回值赋值：&lt;/p&gt;
&lt;p&gt;val voice:String = parent.meow  // error !!!&lt;/p&gt;
&lt;p&gt;问题出来了。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;Cat[String]&lt;/code&gt;类型，所以我们可以期望&lt;code&gt;parent.meow&lt;/code&gt;的返回值也是String类型。但是不要忘了，&lt;code&gt;parent&lt;/code&gt;指向的是&lt;code&gt;child&lt;/code&gt;这个实例，而它的&lt;code&gt;meow&lt;/code&gt;返回值是123这个Integer，显然不能赋给String。&lt;/p&gt;
&lt;p&gt;编译器帮我们检查到了错误，所以这段代码不能通过编译。&lt;/p&gt;
&lt;p&gt;综合起来就是，方法的返回值必须是协变的，其位置是正的。&lt;/p&gt;
&lt;h2&gt;参数必须是逆变的&lt;/h2&gt;
&lt;p&gt;再来定义两只带参数的猫。&lt;/p&gt;
&lt;p&gt;trait Cat[+T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(voice: T) // !!! can&apos;t compile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;trait Cat[-T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(voice: T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;第一只是协变的，第二只是逆变的，为了简单，只定义了参数部分。其中前者是无法通过编译的，后者没有问题。&lt;/p&gt;
&lt;h3&gt;如果参数是协变的&lt;/h3&gt;
&lt;p&gt;如果这是一只协变猫，让我们跟前面一样，来个转型赋值：&lt;/p&gt;
&lt;p&gt;trait Cat[+T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(voice: T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;val child = new Cat[String] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(voice: String) { println(voice.toLowerCase) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;val parent: Cat[Any] = child&lt;/p&gt;
&lt;p&gt;根据协变的定义，上面的赋值是正确的。&lt;/p&gt;
&lt;p&gt;然后传参数：&lt;/p&gt;
&lt;p&gt;parent.meow(123)  // error !!!&lt;/p&gt;
&lt;p&gt;由于parent的类型是&lt;code&gt;Cat[Any]&lt;/code&gt;，所以它的&lt;code&gt;meow&lt;/code&gt;方法的类型是这样的：&lt;/p&gt;
&lt;p&gt;def meow(voice: Any)&lt;/p&gt;
&lt;p&gt;因为参数类型是Any，所以我们可以向它传入一个Integer。但是不要忘了，parent引用的实际上是child，而child的&lt;code&gt;meow&lt;/code&gt;只能接受&lt;code&gt;String&lt;/code&gt;类型，所以这个调用会报错。&lt;/p&gt;
&lt;p&gt;编译器帮我们检查到了这个错误，所以这段代码不能编译。&lt;/p&gt;
&lt;h3&gt;如果参数是逆变的&lt;/h3&gt;
&lt;p&gt;如果这是一只逆变猫，根据逆变的定义，我们可以写出下面的赋值：&lt;/p&gt;
&lt;p&gt;trait Cat[-T] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(voice: T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;val child = new Cat[Any] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow(voice: Any) { println(voice) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;val parent: Cat[String] = child&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;parent&lt;/code&gt;的类型是&lt;code&gt;Cat[String]&lt;/code&gt;，所以它对应的&lt;code&gt;meow&lt;/code&gt;方法的类型是这样的：&lt;/p&gt;
&lt;p&gt;def meow(voice: String)&lt;/p&gt;
&lt;p&gt;所以我们可以传个String进去：&lt;/p&gt;
&lt;p&gt;parent.meow(&amp;ldquo;miaomiao~~&amp;ldquo;)&lt;/p&gt;
&lt;p&gt;会不会出问题呢？由于parent引用的实际上是child对象，而&lt;code&gt;child.meow&lt;/code&gt;方法可以授受一个&lt;code&gt;Any&lt;/code&gt;类型的参数，所以这个调用是没有任何问题的。&lt;/p&gt;
&lt;p&gt;综上所述，参数类型必须是逆变的，参数类型位置是负的。&lt;/p&gt;
&lt;h2&gt;方法中声明的参数类型&lt;/h2&gt;
&lt;p&gt;这里要说的是：&lt;/p&gt;
&lt;p&gt;trait Cat[A] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow[B](volume: C): D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;中的B位置，即我们在一个单独的方法上声明的类型。由于在这里定义的类型通常是给参数使用的，所以这个位置是负的。&lt;/p&gt;
&lt;p&gt;一个负位置，可以接受“逆变”和“无变”的类型。在这里，我们没有办法声明一个“逆变”的类型，下面的代码是不能通过编译的：&lt;/p&gt;
&lt;p&gt;trait Cat[A] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow[-B]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;会报语法错误。那么我们只能声明“无变”类型的。&lt;/p&gt;
&lt;p&gt;最简单的方式是声明一个简单类型，比如&lt;/p&gt;
&lt;p&gt;trait Cat[+A] {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def meow[B](x:B)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;B&lt;/code&gt;跟协变参数&lt;code&gt;A&lt;/code&gt;之间没有任何关系，不管Cat对象如何向上转型，&lt;code&gt;meow&lt;/code&gt;都可以接受任意类型的参数。&lt;/p&gt;
&lt;p&gt;实际上这种定义没多少用，因为B可以是任意类型，所以我们在&lt;code&gt;meow&lt;/code&gt;里，只能把它当作&lt;code&gt;Any&lt;/code&gt;来看待。所以更多的情况是以A作为上界或下界，对新类型进行限定。&lt;/p&gt;
&lt;p&gt;由于A可能是协变、也可能是逆变，而B可能以A为上界、也可能以A为下界，所以就会有下面四种情况：&lt;/p&gt;
&lt;p&gt;trait Cat1[+A] {
&lt;br  /&gt;def meow[B &gt;: A](x: B)
&lt;br  /&gt;}
&lt;br  /&gt;trait Cat2[+A] {
&lt;br  /&gt;def meow[B &lt;: A](x: B)   // can&apos;t compile
&lt;br /&gt;}
&lt;br  /&gt;trait Cat3[-A] {
&lt;br  /&gt;def meow[B &gt;: A](x: B)  // can&apos;t compile
&lt;br  /&gt;}
&lt;br  /&gt;trait Cat4[-A] {
&lt;br  /&gt;def meow[B &lt;: A](x: B)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;上面这四种情况，只有Cat1和Cat4是可以通过编译的，而Cat2和Cat3不能。为了解释这一点，我们需要知道三点：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B位置是负的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当使用下界符号&gt;:时，会翻转右边类型位置的正负&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当使用上界符号&amp;lt;:时，不会翻转右边类型位置的正负&lt;/p&gt;
&lt;p&gt;后面两点后面会讨论，这里先知道这个结果就可以了。&lt;/p&gt;
&lt;p&gt;结合这三点，我们就可以得出结论，只有Cat1与Cat4是符合要求的。&lt;/p&gt;
&lt;p&gt;我们以Cat3为例，看看违反以后，会出现什么问题。&lt;/p&gt;
&lt;p&gt;trait Cat3[-A] {
&lt;br  /&gt;def meow[B &gt;: A](x: B)  // can&apos;t compile
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;val child:Cat3[Any] = new Cat3[Any] {
&lt;br  /&gt;def meow[B &gt;: Any](x: B) = x
&lt;br  /&gt;}
&lt;br  /&gt;val parent: Cat3[String] = child&lt;/p&gt;
&lt;p&gt;然后我们调用：&lt;/p&gt;
&lt;p&gt;parent.meow(&amp;ldquo;miaomiao~~&amp;ldquo;)&lt;/p&gt;
&lt;p&gt;这时会出现错误，因为&lt;code&gt;parent&lt;/code&gt;实际上指向的是&lt;code&gt;child&lt;/code&gt;，所以我们向&lt;code&gt;child.meow()&lt;/code&gt;传入了一个String类型的参数。而child的meow的类型是：&lt;/p&gt;
&lt;p&gt;def meow[B &gt;: Any](x: B) = x&lt;/p&gt;
&lt;p&gt;意思是说，“我只能处理Any类型的父类”，但是传过来的String是Any的子类，无法处理。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h3&gt;为什么下界会翻转正负&lt;/h3&gt;
&lt;p&gt;先看这只逆变猫：&lt;/p&gt;
&lt;p&gt;trait Cat[-A] {
&lt;br  /&gt;def meow(a: A)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;当我们把参数类型指明为&lt;code&gt;A&lt;/code&gt;时，我们隐藏的意思是说：&lt;code&gt;meow&lt;/code&gt;可以接受A的任意子类型。&lt;/p&gt;
&lt;p&gt;与下面代码等价：&lt;/p&gt;
&lt;p&gt;trait Cat[-A] {
&lt;br  /&gt;def meow[B &lt;: A](a: B)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;这段代码可以这么理解：如果我有一个对象是&lt;code&gt;Cat[Any]&lt;/code&gt;，那么它的&lt;code&gt;meow&lt;/code&gt;实际处理能力是&lt;code&gt;所有Any的子类&lt;/code&gt;。同时因为&lt;code&gt;A&lt;/code&gt;是逆变的，所以它可以看作是&lt;code&gt;Cat[String]&lt;/code&gt;的子类，那么展示出来的&lt;code&gt;meow&lt;/code&gt;就变成了&lt;code&gt;meow[B:&amp;lt;String]&lt;/code&gt;，宣称自己只能够处理&lt;code&gt;所有String的子类&lt;/code&gt;。由于宣称的处理能力比实际处理能力弱，所以可以轻松处理传入的各String子类对象，不会有任何问题。&lt;/p&gt;
&lt;p&gt;如果A是协变的，即：&lt;/p&gt;
&lt;p&gt;trait Cat[+A] {
&lt;br  /&gt;def meow[B &gt;: A](a: B)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;此时对于给定的类型&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;meow&lt;/code&gt;只能处理它的父类型。如果我有一个对象是&lt;code&gt;Cat[String]&lt;/code&gt;，那么&lt;code&gt;meow&lt;/code&gt;的实际处理能力就是“所有String的父类型”。同时因为A是协变的，所以它可以看作是&lt;code&gt;Cat[Any]&lt;/code&gt;的子类，所以宣称的处理能力就变成了“所有Any的父类型”。由于宣称的处理能力比实际处理能力弱，所以也不会有问题。&lt;/p&gt;
&lt;p&gt;对于负位置来说，它定义的类型是用于参数，让方法“处理输入”的。而下界符号&lt;code&gt;&amp;gt;:&lt;/code&gt;会把类型的处理能力由默认的“处理子类”变成“处理父类”，这两个正好是相反的，所以会翻转位置的正负。&lt;/p&gt;
&lt;p&gt;所以，如果某个位置[X &gt;: Y]是“正”的，那么&lt;code&gt;Y&lt;/code&gt;所在的位置就是“负”的，需要传入一个逆变的Y。如果某个位置[X &gt;: Y]是“负”的，那么Y所在位置就是正的，需要传入一个协变的Y。&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;泛型参数&lt;/h2&gt;
&lt;p&gt;如果我们的猫的meow参数或者返回值，是一个拥有协变或逆变参数的泛型呢？&lt;/p&gt;
&lt;p&gt;定义一只老鼠先：&lt;/p&gt;
&lt;p&gt;trait Mouse[+T]&lt;/p&gt;
&lt;p&gt;再来一只吃老鼠的猫：&lt;/p&gt;
&lt;p&gt;trait Cat[-A] {
&lt;br  /&gt;def eat(mouse: Mouse[A])
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;这段代码是可以通过编译的。需要注意的是，&lt;code&gt;Mouse[+T]&lt;/code&gt;中的&lt;code&gt;T&lt;/code&gt;是协变的，其位置为正，但是在&lt;code&gt;eat&lt;/code&gt;里，它却可以接受一个逆变类型A。&lt;/p&gt;
&lt;p&gt;让我们试一下：&lt;/p&gt;
&lt;p&gt;val child: Cat[Any] = new Cat[Any] {
&lt;br  /&gt;def eat(mouse: Mouse[Any]) = mouse
&lt;br  /&gt;}
&lt;br  /&gt;val parent: Cat[String] = child&lt;/p&gt;
&lt;p&gt;然后传一只老鼠进去：&lt;/p&gt;
&lt;p&gt;parent.eat(new Mouse[String])&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;Mouse[+T]&lt;/code&gt;是协变的，所以我们传入的&lt;code&gt;Mouse[String]&lt;/code&gt;是&lt;code&gt;Mouse[Any]&lt;/code&gt;的子类，满足了&lt;code&gt;child.eat(Mouse[Any])&lt;/code&gt;的类型要求。&lt;/p&gt;
&lt;p&gt;但是如果我们的猫是协变的：&lt;/p&gt;
&lt;p&gt;trait Cat[+A] {
&lt;br  /&gt;def eat(mouse: Mouse[A])
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;val child: Cat[String] = new Cat[String] {
&lt;br  /&gt;def eat(mouse: Mouse[String]) = mouse
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;val parent: Cat[Any] = child&lt;/p&gt;
&lt;p&gt;由于parent的eat是：&lt;/p&gt;
&lt;p&gt;def eat(mouse: Mouse[Any])&lt;/p&gt;
&lt;p&gt;且Mouse是协变的，那么我们可以传一只&lt;code&gt;Mouse[Int]&lt;/code&gt;进去：&lt;/p&gt;
&lt;p&gt;parent.eat(new Mouse[Int])&lt;/p&gt;
&lt;p&gt;消化不良。。。&lt;/p&gt;
&lt;p&gt;同样的道理，我们还可以验证当Mouse是逆变，以及放在返回值位置的情况。&lt;/p&gt;
&lt;p&gt;我们可以从这个例子中感受一下，但是很难证明对于更复杂的情况（如嵌套类型&lt;code&gt;Mouse[Mouse[Mouse[T]]]&lt;/code&gt;）也一样，但是好在scala规范中已经明确告诉了我们结论：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The variance position of a method parameter is the opposite of the variance position of the enclosing parameter clause.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The variance position of a type parameter is the opposite of the variance position of the enclosing type parameter clause.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The variance position of the lower bound of a type declaration or type parameter is the opposite of the variance position of the type declaration or parameter.&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;（第一句看不懂，不过不影响）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个泛型拥有的变化型位置的正负，跟它所在的变化型位置正好相反&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个类型声明或类型参数的变化型位置的正负，跟它里面声明的类型的下界类型所在的变化型位置正好相反&lt;/p&gt;
&lt;div class=&quot;se-section-delimiter&quot;&gt;&lt;/div&gt;
&lt;h2&gt;来自星星的猫&lt;/h2&gt;
&lt;p&gt;最后再来看这只猫：&lt;/p&gt;
&lt;p&gt;abstract class Cat[-T, +U] {
&lt;br  /&gt;def meow[W&lt;sup&gt;-&lt;/sup&gt;](volue: T&lt;sup&gt;-&lt;/sup&gt;, listener: Cat[U&lt;sup&gt;+&lt;/sup&gt;, T&lt;sup&gt;-&lt;/sup&gt;]&lt;sup&gt;-&lt;/sup&gt;) :Cat[Cat[U&lt;sup&gt;+&lt;/sup&gt;,T&lt;sup&gt;-&lt;/sup&gt;]&lt;sup&gt;-&lt;/sup&gt;, U&lt;sup&gt;+&lt;/sup&gt;]&lt;sup&gt;+&lt;/sup&gt;
&lt;br  /&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，是否可以看懂了？&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;Lambda47&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;一个泛型拥有的变化型位置的正负，跟它所在的变化型位置正好相反&quot;这是怎么理解的？&lt;/p&gt;
&lt;h4&gt;我&lt;/h4&gt;
&lt;p&gt;这句话是翻译的，我觉得这样写可能更准确（如果没有理解错误的话）：一个泛型如果处于一个负的位置，那么它拥有的变化型位置要反转（即正变负，或负变正）；如果处于一个正的位置，则不变。可参考文章开始引用的那个Cat的例子理解&lt;/p&gt;
&lt;h3&gt;杨博&lt;/h3&gt;
&lt;p&gt;我处理逆变逆变一般是先用+A，如果编译器报错就改成-A，如果再报错就改成_ : A，再报错就用普通的A。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>不要删你mac上的jdk1.6</title>
                <link>http://freewind.in/posts/2605-dont-delete-your-jdk1.6-of-mac</link>
                <pubDate>Sat, 26 Apr 2014 11:50:39 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2605</guid>
                <description><![CDATA[&lt;p&gt;今天早上打开电脑，发现Idea启动不了了！Eclipse也启动不了！&lt;/p&gt;
&lt;p&gt;经过两个多小时的修复，终于找到了原因：我昨天升级jdk后，把Mac自带的jdk1.6删了，而Idea它们就找不到了。&lt;/p&gt;
&lt;p&gt;虽然我已经把&lt;code&gt;/usr/bin/java&lt;/code&gt;设成了最新的java路径，后来还在&lt;code&gt;~/.profile&lt;/code&gt;和&lt;code&gt;~/.zshrc&lt;/code&gt;里都设置了:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
export JDK_HOME=`/usr/libexec/java_home -v 1.7`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是不行。&lt;/p&gt;
&lt;p&gt;经过搜索，在&lt;a href=&quot;https://intellij-support.jetbrains.com/entries/23455956-Selecting-the-JDK-version-the-IDE-will-run-under&quot;&gt;https://intellij-support.jetbrains.com/entries/23455956-Selecting-the-JDK-version-the-IDE-will-run-under&lt;/a&gt;里找到了一段话：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Mac OS X&lt;/p&gt;
&lt;p&gt;At the moment all our products require Apple JDK 1.6 to be installed in order to run on Mac. JDK 1.7 from Oracle is not officially supported yet and has known problems that stop us from using it by default. Oracle JDK 1.7.0_40 has added support for Retina and works much better than previous versions on Mac. You are welcome to give it a try in case you have any problems with Apple JDK.&lt;/p&gt;
&lt;p&gt;To force running under JDK 1.7 edit /Applications/&lt;Product&gt;.app/Contents/Info.plist file, change JVMVersion from 1.6&lt;em&gt; to 1.7&lt;/em&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;key&amp;gt;JVMVersion&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;1.7*&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;似乎IDEA在mac上，默认情况只支持jdk1.6，除非把&lt;code&gt;JVMVersion&lt;/code&gt;的值改成&lt;code&gt;1.7*&lt;/code&gt;。我改了以后，的确可以启动了，但是也不能每个程序都这么改吧。&lt;/p&gt;
&lt;p&gt;于是只好重装jdk1.6。在java的官网上，还找不到mac里1.6的安装包，最后在这里找到了：&lt;/p&gt;
&lt;p&gt;http://support.apple.com/kb/DL1573&lt;/p&gt;
&lt;p&gt;安装好以后，idea/eclipse就可以正常启动了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt; jdk路径 &lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Mac里jdk安装的路径还会变，比如曾经jdk1.6，会安装在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/System/Library/Java/JavaVirtualMachines/1.6.0.jdk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而jdk1.7和1.8，就会安装在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/Library/Java/JavaVirtualMachines/jdk1.7.0_55.jdk
/Library/Java/JavaVirtualMachines/jdk1.8.0_20.jdk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而且好像一般的java程序还只认第一个。所以为了减少麻烦，最好不要删除你mac上的jdk1.6&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (8) 暂时中止</title>
                <link>http://freewind.in/posts/2601-write-idea-plugin-yourself-pubeditor-8-pause-dev</link>
                <pubDate>Fri, 25 Apr 2014 23:13:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2601</guid>
                <description><![CDATA[&lt;p&gt;这个系列到这里就暂时中止了。&lt;/p&gt;
&lt;p&gt;因为我发现，想要实现更多的功能，比如代码提示、格式化这些看起来似乎不太复杂的，都需要我们在Lexer的基础上提供一个Parser，以及相应的PsiElement等，在它们的基础上继续开发。&lt;/p&gt;
&lt;p&gt;但IDEA中相关的API很庞大，类很多、代码很多，因为它们需要为编辑器提供强大的编辑、查找、重构、定制等功能，而文档和资料又比较少，只能从代码去猜，不是短时间内能掌握的。&lt;/p&gt;
&lt;p&gt;所以我打算暂时中止，转而以研究IDEA代码为主，然后再回过头来继续实现该插件。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (7) 高亮</title>
                <link>http://freewind.in/posts/2597-write-idea-plugin-yourself-pubeditor-7-highlight</link>
                <pubDate>Wed, 23 Apr 2014 14:19:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2597</guid>
                <description><![CDATA[&lt;p&gt;做了这么多准备工作，激动人心的时候终于要一个个到来了。首先上场的是语法高亮，这个是比较简单的。&lt;/p&gt;
&lt;h2&gt;效果图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2597-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Highlighter&lt;/h2&gt;
&lt;p&gt;我们在Idea编辑器中看到的每一个单词或者token，并不是一个简单的字符串，实际上是一个对象，定义了文本内容，前景色后景色，各种文字效果（加粗、斜体、下划线），以及不同状态下的效果（悬停、出错、选中）。&lt;/p&gt;
&lt;p&gt;我们要定义一个Highlighter，它将使用前面定义的Lexer对代码进行解析，然后根据不同的token类型，提供一些颜色定义。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.pub_editor.highlight

import com.intellij.lexer.Lexer
import com.intellij.openapi.editor.colors.TextAttributesKey
import com.intellij.openapi.fileTypes.SyntaxHighlighterBase
import com.intellij.psi.tree.IElementType
import com.thoughtworks.pli.pub_editor.parser.PubSpecLexer
import com.thoughtworks.pli.pub_editor.parser.PubTokenTypes
import com.intellij.openapi.editor.DefaultLanguageHighlighterColors

class PubHighlighter extends SyntaxHighlighterBase {

  object keys {
    val Comment = newKey(&quot;Pub.Comment&quot;, DefaultLanguageHighlighterColors.LINE_COMMENT)
    val KnownKey = newKey(&quot;Pub.KnownKey&quot;, DefaultLanguageHighlighterColors.KEYWORD)
    val UnknownKey = newKey(&quot;Pub.UnknownKey&quot;, DefaultLanguageHighlighterColors.INSTANCE_FIELD)
    val Value = newKey(&quot;Pub.Value&quot;, DefaultLanguageHighlighterColors.MARKUP_ENTITY)
    val String = newKey(&quot;Pub.String&quot;, DefaultLanguageHighlighterColors.STRING)
    val Unknown = newKey(&quot;Pub.Unknown&quot;, DefaultLanguageHighlighterColors.BLOCK_COMMENT)

    def newKey(keyId: String, color: TextAttributesKey): TextAttributesKey = {
      TextAttributesKey.createTextAttributesKey(keyId, color)
    }
  }

  def getHighlightingLexer: Lexer = new PubSpecLexer

  def getTokenHighlights(tokenType: IElementType): Array[TextAttributesKey] = {
    import PubTokenTypes._
    tokenType match {
      case Comment =&amp;gt; Array(keys.Comment)
      case OneLineOfMultiLineString =&amp;gt; Array(keys.String)
      case BadCharacter =&amp;gt; Array(keys.Unknown)
      case KnownKey =&amp;gt; Array(keys.KnownKey)
      case MultiLineStringKey | ParentKey | InlineKey =&amp;gt; Array(keys.UnknownKey)
      case _ =&amp;gt; Array()
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码比较直白，不多讲&lt;/p&gt;
&lt;h2&gt;HighlighterFactory&lt;/h2&gt;
&lt;p&gt;然后我还要建立一个HighlighterFactory，注册到Idea，告诉它当编辑pubspec.yaml文件时，使用我们提供的Highlighter。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class PubHighlighterFactory extends SyntaxHighlighterFactory {

  def getSyntaxHighlighter(project: Project, virtualFile: VirtualFile): SyntaxHighlighter = {
    new PubHighlighter
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在plugin.xml中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;lang.syntaxHighlighterFactory key=&quot;pub&quot; implementationClass=&quot;com.thoughtworks.pli.pub_editor.highlight.PubHighlighterFactory&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;key&lt;/code&gt;的值很重要，一定是我们定义的language名称，否则Idea没法匹配。其值跟这里定义的Language相同：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;class PubLanguage extends Language(&quot;pub&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;对认识的key特殊对待&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.dartlang.org/tools/pub/pubspec.html&quot;&gt;Pub的文档&lt;/a&gt;中定义了哪些key是它所识别的，对于这个key我们可以以特殊的颜色显示，跟其它的key区分开。&lt;/p&gt;
&lt;p&gt;以下key是可识别的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;name&quot;, &quot;version&quot;, &quot;description&quot;, &quot;author&quot;,
&quot;homepage&quot;, &quot;documentation&quot;, &quot;dependencies&quot;, 
&quot;dev_dependencies&quot;, &quot;dependency_overrides&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了跟其它key分开，我们必须定义一种新的token类型&lt;code&gt;KnownKey&lt;/code&gt;，同时把由Lexer解析出来的&lt;code&gt;InlineKey&lt;/code&gt;, &lt;code&gt;ParentKey&lt;/code&gt;和&lt;code&gt;MultiLineStringKey&lt;/code&gt;根据其值转换为&lt;code&gt;KnownKey&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;首先定义一个&lt;code&gt;PubWithKnownKeyLexer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class PubWithKnownKeyLexer extends PubSpecLexer {

  val KeyTypes = List(InlineKey, ParentKey, MultiLineStringKey)
  val KnownKeys = List(
    &quot;name&quot;, &quot;version&quot;, &quot;description&quot;, &quot;author&quot;,
    &quot;homepage&quot;, &quot;documentation&quot;, &quot;dependencies&quot;, &quot;dev_dependencies&quot;, &quot;dependency_overrides&quot;
  )

  override def getTokenType: IElementType = {
    val tokenType = super.getTokenType
    if (KeyTypes.contains(tokenType) &amp;amp;&amp;amp; KnownKeys.contains(getKey(getTokenText)))
      PubTokenTypes.KnownKey
    else tokenType
  }

  private def getKey(token: String) = StringUtils.substringBefore(token, &quot;:&quot;).trim.toLowerCase
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后修改&lt;code&gt;PubHighlighter&lt;/code&gt;，让它返回新的Lexer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def getHighlightingLexer: Lexer = new PubWithKnownKeyLexer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就大功告成了。&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;上传至&lt;a href=&quot;http://github.com/freewind/PubEditor&quot;&gt;http://github.com/freewind/PubEditor&lt;/a&gt;, 本篇标签为&lt;code&gt;7_highlight&lt;/code&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (6) 实现简化的yaml语法规则</title>
                <link>http://freewind.in/posts/2595-write-idea-plugin-yourself-pubeditor-6-simplify-yaml-syntax</link>
                <pubDate>Tue, 22 Apr 2014 22:05:27 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2595</guid>
                <description><![CDATA[&lt;p&gt;YAML是一种看起来很易读、格式简单的语法格式，但实际上，它的&lt;a href=&quot;www.yaml.org/spec/1.2/spec.html&quot;&gt;语言规范&lt;/a&gt;相当复杂，甚至连读一遍文档都是非常痛苦的事情。同时在IDEA上也没有找到可用的YAML插件，这让我很头痛，看起来一个很简单的任务突然变得复杂到无法实现。&lt;/p&gt;
&lt;h2&gt;简化的文法&lt;/h2&gt;
&lt;p&gt;经过短暂的纠结，我决定按照pubspec.yaml上给出的例子，实现一个简化的YAML语法规则，只支持以下几种格式：&lt;/p&gt;
&lt;h3&gt;注释&lt;/h3&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# this is comment
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;单行key value&lt;/h3&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key: value
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;嵌套key value, 如&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;key:
  key1: value1
  key2:
    key3: value3
    key4: value4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;多行文本，如&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;key: &amp;gt;
  this is
  multiline
  string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于其它格式的内容，直接当作不识别的文本处理，这样简化后，词法规则的规模小了很多。&lt;/p&gt;
&lt;h2&gt;缩进处理&lt;/h2&gt;
&lt;p&gt;但是马上又遇到另一个头疼的问题：YAML的文法实际上并不完全是“上下文无关”的，因为它的很多词法成分实际上跟它前面的缩进数量是相关的。而我使用的词法生成器工具JFlex只支持“上下文无关”文法，必须对缩进进行一些额外的处理才行。&lt;/p&gt;
&lt;p&gt;好在看到了一篇文章，讲如何在JFlex中处理缩进，对于我要实现的简化的缩进来说，还是可行的: &lt;a href=&quot;http://matt.might.net/articles/standalone-lexers-with-lex/&quot;&gt;http://matt.might.net/articles/standalone-lexers-with-lex/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;JFlex规则&lt;/h2&gt;
&lt;p&gt;经过两天的努力和反复的尝试，终于实现了以下规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thoughtworks.pli.pub_editor.parser;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;
import java.util.*;

%%

%class _PubSpecLexer
%implements FlexLexer
%unicode
%type IElementType
%function advance
//%debug
%{
IndentationStack indentationStack = new IndentationStack();
public int currentIndentation() { return indentationStack.current(); }
public List&amp;lt;Integer&amp;gt; allIndentations() { return indentationStack.all(); }
%}

Comment = &quot;#&quot; .*
LineSeparator = \r\n | \r | \n
Indentation = {WhiteSpace}+
WhiteSpace = [\ ]
NonWhiteSpace = [^\ ]
BlankChar = [\ \t\f]
NonBlankChar = [^\ \r\n\t\f]
ParentKey = {NonBlankChar}+ &quot;:&quot; {BlankChar}* {LineSeparator}
InlineKey = {NonBlankChar}+ &quot;:&quot; {BlankChar}+
InlineValue = .+
MultiLineStringKey = {NonBlankChar}+ &quot;:&quot; {BlankChar}* &quot;&amp;gt;&quot; {LineSeparator}

%state $newLine
%state $value
%state $multiLineString
%state $multiLineStringAfterIndentation
%state $inlineValue
%state $multiChildren

%%
&amp;lt;YYINITIAL&amp;gt; {
    {Indentation}    { indentationStack.push(yytext().length()); return PubTokenTypes.Indentation(); }
    {Comment}        { return PubTokenTypes.Comment(); }
    {ParentKey}      { yybegin(YYINITIAL);return PubTokenTypes.ParentKey(); }
    {InlineKey}      { yybegin($inlineValue); return PubTokenTypes.InlineKey(); }
    {MultiLineStringKey} { yybegin($multiLineString); return PubTokenTypes.MultiLineStringKey(); }
    {LineSeparator}  { return PubTokenTypes.LineSeparator(); }
}
&amp;lt;$inlineValue&amp;gt; {
    {InlineValue}    { yybegin(YYINITIAL); return PubTokenTypes.InlineValue(); }
}
&amp;lt;$multiLineString&amp;gt; {
    {Indentation}    {
                         int currentIndent = yytext().length();
                         if(currentIndent &amp;gt;= indentationStack.current()) {
                         yybegin($multiLineStringAfterIndentation);
                             return PubTokenTypes.Indentation();
                         } else {
                             yypushback(currentIndent);
                             yybegin(YYINITIAL);
                         }
                     }
    {NonWhiteSpace}+ { yypushback(yytext().length()); yybegin(YYINITIAL); }
    &amp;lt;$multiLineStringAfterIndentation&amp;gt; {
        {NonBlankChar}+ {  return PubTokenTypes.OneLineOfMultiLineString(); }
        {LineSeparator} {  yybegin($multiLineString); return PubTokenTypes.LineSeparator(); }
    }
}
.                    { return PubTokenTypes.BadCharacter(); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到对于这小小的文法，居然需要这么多定义和代码。除去文法相关的定义，有不少代码是关于处理缩进的。不过由于上面的代码比较直白，所以就不多解释，如果看起来有不明白的地方，最好再看一遍JFlex的文档：&lt;a href=&quot;http://jflex.de/manual.html&quot;&gt;http://jflex.de/manual.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;最后上一个测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String input = &quot;#!!!!!\n&quot; +
        &quot;#????\n&quot; +
        &quot;abc: \&quot;sss\&quot;\n&quot; +
        &quot;xxx:\n&quot; +
        &quot;  aaa: 111\n&quot; +
        &quot;  bbb: 222\n&quot; +
        &quot;yyy: &amp;gt;\n&quot; +
        &quot;  1111111111111\n&quot; +
        &quot;    2222222222222\n&quot; +
        &quot;  3333333333333\n&quot; +
        &quot;zzz: ZZZ\n&quot; +
        &quot;  ccc: This line actually is invalid\n&quot; +
        &quot;???&quot;;
PubSpecLexer lexer = new PubSpecLexer();
lexer.start(input);
while (true) {
    IElementType tokenType = lexer.getTokenType();
    if (tokenType == null) {
        System.out.println(&quot;--- end ---&quot;);
        return;
    }

    System.out.println(tokenType + &quot;(&quot; + lexer.getTokenText() + &quot;)&quot;);
    lexer.advance();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Comment(#!!!!!)
LineSeparator(
)
Comment(#????)
LineSeparator(
)
InlineKey(abc: )
InlineValue(&quot;sss&quot;)
LineSeparator(
)
ParentKey(xxx:
)
Indentation(  )
InlineKey(aaa: )
InlineValue(111)
LineSeparator(
)
Indentation(  )
InlineKey(bbb: )
InlineValue(222)
LineSeparator(
)
MultiLineStartFlag(yyy: &amp;gt;
)
Indentation(  )
OneLineOfMultiLineString(1111111111111)
LineSeparator(
)
Indentation(    )
OneLineOfMultiLineString(2222222222222)
LineSeparator(
)
Indentation(  )
OneLineOfMultiLineString(3333333333333)
LineSeparator(
)
InlineKey(zzz: )
InlineValue(ZZZ)
LineSeparator(
)
Indentation(  )
InlineKey(ccc: )
InlineValue(This line actually is invalid)
LineSeparator(
)
BadCharacter(?)
BadCharacter(?)
BadCharacter(?)
--- end ---
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;代码在&lt;a href=&quot;http://github.com/freewind/PubEditor&quot;&gt;http://github.com/freewind/PubEditor&lt;/a&gt;，标签为&lt;code&gt;6_other_basic_rules&lt;/code&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (5) 搭起JFlex的架子</title>
                <link>http://freewind.in/posts/2584-write-idea-plugin-yourself-pubeditor-5-jflex</link>
                <pubDate>Mon, 14 Apr 2014 22:55:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2584</guid>
                <description><![CDATA[&lt;p&gt;在IDEA中，使用JFlex来写词法分析器最方便，因为IDEA提供了一个修改后的jflex，内置了对它的支持。&lt;/p&gt;
&lt;p&gt;需要注意的是，由于IDEA提供的&lt;code&gt;idea-flex.skeleton&lt;/code&gt;的实现内容跟原始的模板有一些区别，用法也不一样，我在这里花费了不少时间才搞清楚。具体参看：&lt;a href=&quot;http://stackoverflow.com/questions/23031925/whats-wrong-with-this-simplest-jflex-code&quot;&gt;http://stackoverflow.com/questions/23031925/whats-wrong-with-this-simplest-jflex-code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于JFlex的内容，可以看官方文档：&lt;a href=&quot;http://jflex.de/manual.html&quot;&gt;http://jflex.de/manual.html&lt;/a&gt;，非常详细，看一遍下来就差不多了，然后再注意一下我上面提的那个问题，就差不多可以搭架子了。&lt;/p&gt;
&lt;p&gt;不过JFlex相关的内容还是比较复杂的，特别JFlex生成的Java代码很难读，一些复杂的逻辑基本上没法看懂，我花了一天的时间也没弄懂，只好点到为止了。&lt;/p&gt;
&lt;p&gt;等这个PubEditor完成后，将会好好研究一下，到时候再写一些东西。&lt;/p&gt;
&lt;h2&gt;IDEA插件支持&lt;/h2&gt;
&lt;p&gt;IDEA中有插件支持jflex，可以语法高亮，查错，自动下载idea修改的jflex.jar，以及一键生成java代码，非常有用，必备插件。&lt;/p&gt;
&lt;p&gt;安装以下两个插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JFlex support&lt;/li&gt;
&lt;li&gt;Grammar Kit&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;创建pubspec.flex语法文件&lt;/h2&gt;
&lt;p&gt;下面在项目中创建一个&lt;code&gt;pubspec.flex&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;flex&quot;&gt;package com.thoughtworks.pli.pub_editor.parser;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;
import scala.Some;

%%

%class _PubSpecLexer
%implements FlexLexer
%unicode
%type IElementType
%function advance
%{
private String matchedText() {
    return yytext().toString();
}
private Some&amp;lt;String&amp;gt; someText() {
    return new Some&amp;lt;String&amp;gt;(yytext().toString());
}
%}

Comment = &quot;#&quot; .*
NewLine = \r\n | \r | \n

%%

{Comment} { return PubTokenTypes.comment(matchedText()); }
{NewLine} { return PubTokenTypes.newLine(); }
.         { return PubTokenTypes.badCharacter(matchedText()); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个jflex定义文件，都分成三部分，以&lt;code&gt;%%&lt;/code&gt;隔开。&lt;/p&gt;
&lt;h3&gt;User code&lt;/h3&gt;
&lt;p&gt;第一部分是&lt;code&gt;user code&lt;/code&gt;，我们可以添加自己的java代码，将原样写到最终生成的java文件中，一般用来放&lt;code&gt;package&lt;/code&gt;,&lt;code&gt;import&lt;/code&gt;之类的语句。&lt;/p&gt;
&lt;p&gt;在我们的例子中，声明了所在的package和引入的类，这些类将会在下面的代码里用到。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;scala.Some&lt;/code&gt;是因为我其它的代码是用scala写的，需要这个类。而｀FlexLexer｀和&lt;code&gt;IElementType&lt;/code&gt;是IDEA提供的公共类，我们必须使用它们才能让IDEA识别生成的类。&lt;/p&gt;
&lt;h3&gt;Options and declarations&lt;/h3&gt;
&lt;p&gt;第二部分是&lt;code&gt;options and declarations&lt;/code&gt;，我们可以提供一些代码生成的设置，使用类似于正则表达式的方式定义一些字符类，还可以定义一些state，以及一些将嵌入到生成文件中的java方法。&lt;/p&gt;
&lt;p&gt;生成的类名为&lt;code&gt;_PubSpecLexer&lt;/code&gt;，使用这个名字是因为还会生成一个供外部使用的包装类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%class _PubSpecLexer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将实现&lt;code&gt;FlexLexer&lt;/code&gt;，这是IDEA要求的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%implements FlexLexer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;unicode&lt;/code&gt;来解析目标文件，这基本上是必须的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%unicode
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配到token时，返回哪种类型的对象。&lt;code&gt;IElementType&lt;/code&gt;是IDEA提供的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%type IElementType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义用于获取下一个token的方法名，默认是&lt;code&gt;yylex&lt;/code&gt;，但为了配合&lt;code&gt;FlexLexer&lt;/code&gt;接口的定义，需要改成&lt;code&gt;advance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%function advance
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们还可以定义一些变量或者方法供文件中的其它代码使用，它们将会成为生成的类的实例变量或方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%{
private String matchedText() {
    return yytext().toString();
}
private Some&amp;lt;String&amp;gt; someText() {
    return new Some&amp;lt;String&amp;gt;(yytext().toString());
}
%}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后定义了两个字符类，使用了类似正则的表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Comment = &quot;#&quot; .*
NewLine = \r\n | \r | \n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Comment&lt;/code&gt;将匹配所有以&lt;code&gt;#&lt;/code&gt;开头的单行内容，&lt;code&gt;NewLine&lt;/code&gt;匹配了三种换行符。&lt;/p&gt;
&lt;h3&gt;Lexcial rules&lt;/h3&gt;
&lt;p&gt;第三部分将针对某一种词法定义，提供相应的java代码返回某个特点的token对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{Comment} { return PubTokenTypes.comment(matchedText()); }
{NewLine} { return PubTokenTypes.newLine(); }
.         { return PubTokenTypes.badCharacter(matchedText()); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它们使用了自定义的&lt;code&gt;PubTokenTypes&lt;/code&gt;类，其内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thoughtworks.pli.pub_editor.parser

import com.intellij.psi.tree.IElementType
import com.thoughtworks.pli.pub_editor.PubLanguage
import scala.util.Try

class PubTokenTypes

object PubTokenTypes {
  def badCharacter(value: String) = new PubElementType(&quot;BadCharacter&quot;, Some(value))
  def comment(value: String) = new PubElementType(&quot;Comment&quot;, Some(value))
  def newLine = new PubElementType(&quot;NewLine&quot;)
}

class PubElementType[T](elementType: String, value: Option[T] = None) extends IElementType(elementType, PubLanguage) {
  override def toString = elementType + value.map(v =&amp;gt; s&quot; ($v)&quot;).getOrElse(&quot;&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到内容比较简单，只是定义了一些方法生成特定的token对象。&lt;/p&gt;
&lt;p&gt;匹配的时候，定义在前面的规则将会先使用，所以当匹配到最后一行，即:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.         { return PubTokenTypes.badCharacter(matchedText()); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;时，说明它不是我们认识的，直接生成一个相应的&lt;code&gt;badCharacter&lt;/code&gt;类型的对象。&lt;/p&gt;
&lt;h2&gt;生成Java类&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;pubspec.flex&lt;/code&gt;文件上点右键，选中&lt;code&gt;Run JFlex Generator&lt;/code&gt;，插件会自动下载所需要的&lt;code&gt;jflex.jar&lt;/code&gt;和&lt;code&gt;idea-flex.skeleton&lt;/code&gt;文件，放在我们指定的位置，然后生成两个Java文件。&lt;/p&gt;
&lt;p&gt;一个是&lt;code&gt;_PubSpecLexer&lt;/code&gt;，主要的逻辑都在里面，代码很长，是典型的C风格代码（为了性能）。&lt;/p&gt;
&lt;p&gt;另一个是&lt;code&gt;PubSpecLexer&lt;/code&gt;，这是一个包装类，继承了IDEA提供的&lt;code&gt;FlexAdapter&lt;/code&gt;类，供我们使用，其内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thoughtworks.pli.pub_editor.parser;

import com.intellij.lexer.FlexAdapter;

import java.io.Reader;

public class PubSpecLexer extends FlexAdapter {
    public PubSpecLexer() {
        super(new _PubSpecLexer((Reader) null));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这个类可能有编译错误，改成上面的就行了。下次再生成时，这个类不会重新生成。&lt;/p&gt;
&lt;h2&gt;如何使用&lt;/h2&gt;
&lt;p&gt;生成的代码如何使用呢？这里先不考虑插件如何使用，而是从普通调用的方式考虑。&lt;/p&gt;
&lt;p&gt;这里给出示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package com.thoughtworks.pli.pub_editor.parser;

public class TryLexer {

    public static void main(String[] args) {
        String input = &quot;#!!!!!\n#????\nabc&quot;;
        PubSpecLexer lexer = new PubSpecLexer();
        lexer.start(input);
        for (int i = 0; i &amp;lt; 10; i++) {
            System.out.println(lexer.getTokenType());
            lexer.advance();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，这种用法是IDEA修改后的JFlex代码的使用方法，而不是原始方法，这一点在本文最前面的那个问题里，已经说明了。&lt;/p&gt;
&lt;p&gt;它会打印出以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Comment (#!!!!!)
NewLine
Comment (#????)
NewLine
BadCharacter (a)
BadCharacter (b)
BadCharacter (c)
null
null
null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，的确可以正确匹配上各Token.&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;源代码地址：&lt;/p&gt;
&lt;p&gt;https://github.com/freewind/PubEditor&lt;/p&gt;
&lt;p&gt;可以checkout出这个标签：&lt;code&gt;5_jflex_skeleton&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下一篇将会完善我们的词法定义。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (4) pubspec.yaml文件语法</title>
                <link>http://freewind.in/posts/2580-write-idea-plugin-yourself-pubeditor-4-pubspec-syntax</link>
                <pubDate>Thu, 10 Apr 2014 22:55:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2580</guid>
                <description><![CDATA[&lt;p&gt;pubspec.yaml在本质上是一个YAML文件，所以它的语法遵守YAML的规定。但同时它的内容又比较简单，因为它规定了哪些配置项是有效的，其它的都会被自动忽略。&lt;/p&gt;
&lt;p&gt;全部有效选项如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;name: newtify
version: 1.2.3
description: &amp;gt;
  Have you been turned into a newt?  Would you like to be?
  This package can help: it has all of the
  newt-transmogrification functionality you&apos;ve been looking
  for.
author: Nathan Weizenbaum &amp;lt;nweiz@google.com&amp;gt;
homepage: http://newtify.dartlang.org
documentation: http://docs.newtify.com
dependencies:
  efts: &apos;&amp;gt;=2.0.4 &amp;lt;3.0.0&apos;
  transmogrify: &apos;&amp;gt;=0.4.0 &amp;lt;1.0.0&apos;
dev_dependencies:
  unittest: &apos;&amp;gt;=0.6.0&apos;
dependency_overrides:
  transmogrify:
    path: ../transmogrify_patch/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中只有&lt;code&gt;name&lt;/code&gt;项是在所有情况下都必须的，&lt;code&gt;version&lt;/code&gt;和&lt;code&gt;description&lt;/code&gt;只有当要发布时才是必须的，其它的都是可选的。除它们以外的内容都会被忽略。&lt;/p&gt;
&lt;p&gt;上面是一个简化的模板，实际上很多选项还有更复杂的用法。更详细的内容，请参考官方文档：&lt;a href=&quot;https://www.dartlang.org/tools/pub/pubspec.html&quot;&gt;https://www.dartlang.org/tools/pub/pubspec.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我原以为IDEA中有可直接使用的YAML插件，但是发现竟然没有！而YAML语法实际上还有比较复杂的，对于我这次的任务来说，提供完整的YAML支持有点不太现实，所以我打算仅仅按pubspec.yaml的定义来实现部分YAML功能。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (3) 将pub文件与PubEditor关联起来</title>
                <link>http://freewind.in/posts/2509-write-idea-plugin-yourself-pubeditor-3-bind-pub-files-with-pubeditor</link>
                <pubDate>Mon, 07 Apr 2014 18:31:13 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2509</guid>
                <description><![CDATA[&lt;p&gt;Dart使用Pub进行依赖管理。我们需要在项目目录下创建一个名为&lt;code&gt;pubspec.yaml&lt;/code&gt;的文件，供Pub使用。&lt;/p&gt;
&lt;h2&gt;本篇目标&lt;/h2&gt;
&lt;p&gt;我们的PubEditor要能够识别&lt;code&gt;pubspec.yaml&lt;/code&gt;文件。当打开该文件时，会调用PubEditor进行编辑。&lt;/p&gt;
&lt;p&gt;注：我们暂不考虑&lt;code&gt;pubspec.yaml&lt;/code&gt;的内容，仅关注文件名即可。&lt;/p&gt;
&lt;h2&gt;必读资料&lt;/h2&gt;
&lt;p&gt;下面两篇文章非常重要，基本上提供了我们目前所需要的所有功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://confluence.jetbrains.com/display/IDEADEV/Developing+Custom+Language+Plugins+for+IntelliJ+IDEA&quot;&gt;Developing Custom Language Plugins for IntelliJ IDEA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://confluence.jetbrains.com/display/IntelliJIDEA/Language+and+File+Type&quot;&gt;Language and File Type&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文件图标&lt;/h2&gt;
&lt;p&gt;当我们将某种类型的文件识别为一种语言时，Idea可以让我们为它提供一个自定义的图标。这个图标将会显示在文件树中文件名节点的左边，以及编辑器标题的左边。&lt;/p&gt;
&lt;p&gt;文件大小为16x16，格式为png。&lt;/p&gt;
&lt;p&gt;我使用一个&lt;a href=&quot;http://www.uupoop.com/&quot;&gt;在线版photoshop&lt;/a&gt;，生成了下面这个图标:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2509-0.png&quot; alt=&quot;pub&quot; /&gt;&lt;/p&gt;
&lt;p&gt;取名为&lt;code&gt;pub_file.png&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;自定义Language&lt;/h2&gt;
&lt;p&gt;这个PubEditor实际上就是一个小型的自定义语言插件。对于这类插件，我们需要定义一个Language子类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.pub_editor

import com.intellij.lang.Language

class PubLanguage extends Language(&quot;pub&quot;)

object PubLanguage extends PubLanguage
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码很简单，只需要继承&lt;code&gt;Language&lt;/code&gt;即可。其中的&quot;pub&quot;参数是照着教程来的，不太清楚到底有什么用（Idea源代码还没下完，看不了），不过写成&quot;pub&quot;应该没什么问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;object PubLanguage&lt;/code&gt;是一个单例，方便在其它类中直接引用。&lt;/p&gt;
&lt;h2&gt;自定义FileType&lt;/h2&gt;
&lt;p&gt;我们还需要自定义一个LanguageFileType，提供名称、描述和图标：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.pub_editor

import com.intellij.openapi.fileTypes.LanguageFileType
import org.jetbrains.annotations.NotNull
import org.jetbrains.annotations.Nullable
import javax.swing.Icon
import com.intellij.openapi.util.IconLoader

class PubFileType extends LanguageFileType(PubLanguage) {

  @NotNull
  override def getName = &quot;Pub&quot;

  @NotNull
  override def getDescription = &quot;Dart&apos;s Pub File&quot;

  @NotNull
  override def getDefaultExtension = &quot;&quot;

  @Nullable
  override def getIcon: Icon = IconLoader.getIcon(&quot;/com/thoughtworks/pli/pub_editor/pub_file.png&quot;)

}

object PubFileType extends PubFileType
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;getDescription&lt;/code&gt;，会在关联某种文件时，显示在列表中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2509-1.png&quot; alt=&quot;QQ20140407-27&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;getDefaultExtension&lt;/code&gt;是说默认把哪种后缀名的文件与该插件关联起来。由于我们需要对&lt;code&gt;pubspec.yaml&lt;/code&gt;这个完整的文件名，而不是某个后缀名进行关联，所以我只好把它留空。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getIcon&lt;/code&gt;会让我们提供一个自定义的图标供使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2509-2.png&quot; alt=&quot;QQ20140407-28&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;getName&lt;/code&gt;我也不知道有什么用，可能是用来标识这种类型的文件，就叫&lt;code&gt;Pub&lt;/code&gt;吧。&lt;/p&gt;
&lt;h2&gt;自定义FileTypeFactory&lt;/h2&gt;
&lt;p&gt;我们还需要提供一个&lt;code&gt;FileTypeFactory&lt;/code&gt;子类，用来把我们的定义的&lt;code&gt;FileType&lt;/code&gt;与某种类型的文件关联起来。同时还要把它注册到插件配置文件里。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.pub_editor

import com.intellij.openapi.fileTypes.{FileNameMatcher, FileTypeConsumer, FileTypeFactory}
import org.jetbrains.annotations.NotNull

class PubFileTypeFactory extends FileTypeFactory {

  val PubFileName = &quot;pubspec.yaml&quot;

  @Override
  override def createFileTypes(@NotNull fileTypeConsumer: FileTypeConsumer) = {
    fileTypeConsumer.consume(PubFileType, new FileNameMatcher {
      override def accept(fileName: String) = fileName == PubFileName
      override def getPresentableString: String = PubFileName
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到只有当文件名为&lt;code&gt;pubspec.yaml&lt;/code&gt;时，才会把它与PubEditor关联起来。&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;plugin.xml&lt;/code&gt;中注册：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;extensions defaultExtensionNs=&quot;com.intellij&quot;&amp;gt;
    &amp;lt;fileTypeFactory implementation=&quot;com.thoughtworks.pli.pub_editor.PubFileTypeFactory&quot;/&amp;gt;
&amp;lt;/extensions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;p&gt;运行效果如下图。当我创建了一个&lt;code&gt;pubspec.yaml&lt;/code&gt;文件时，IDEA立刻识别出来，并显示了我们自定义的图标。而创建了其它的文件，如&lt;code&gt;abc.yaml&lt;/code&gt;，则关联上了其它的编辑器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2509-3.png&quot; alt=&quot;QQ20140407-29&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;http://github.com/freewind/PubEditor&lt;/p&gt;
&lt;p&gt;切换到&lt;code&gt;3_associate_pubspec_yaml&lt;/code&gt;标签即可。&lt;/p&gt;
&lt;p&gt;本篇关联的编辑器是默认的文本编辑器，功能有限。而&lt;code&gt;pubspec.yaml&lt;/code&gt;使用了&lt;code&gt;yaml&lt;/code&gt;格式，下一篇将让我们的编辑器基于yaml插件。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (2) Scala改写Hello world</title>
                <link>http://freewind.in/posts/2554-write-idea-plugin-yourself-pubeditor-2-use-scala-to-write-hello-world</link>
                <pubDate>Sun, 06 Apr 2014 23:34:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2554</guid>
                <description><![CDATA[&lt;h2&gt;本篇目标&lt;/h2&gt;
&lt;p&gt;使用Scala改写上次的&lt;code&gt;HelloWorldAction&lt;/code&gt;，以确认用Scala写插件会不会有什么问题。&lt;/p&gt;
&lt;h2&gt;安装Scala插件&lt;/h2&gt;
&lt;p&gt;首先需要到&lt;a href=&quot;http://www.scala-lang.org&quot;&gt;http://www.scala-lang.org&lt;/a&gt;上下载最新的scala安装包，并在IDEA中安装好Scala插件&lt;/p&gt;
&lt;h2&gt;在项目中添加Scala支持&lt;/h2&gt;
&lt;p&gt;首先打开项目属性，在&quot;Facets&quot;中添加Scala：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2554-0.png&quot; alt=&quot;QQ20140406-25&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后在Modules中选择PubEditor的module，添加上scala-library相应的依赖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2554-1.png&quot; alt=&quot;QQ20140406-26&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果你对Idea下的scala配置不熟悉，需要多一些时间摸索，我也是连蒙带猜弄好的。&lt;/p&gt;
&lt;h2&gt;用Scala重写&lt;/h2&gt;
&lt;p&gt;删除原来的&lt;code&gt;HelloWorldAction.java&lt;/code&gt;，新建一个&lt;code&gt;HelloWorldAction.scala&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;package com.thoughtworks.pli.pub_editor

import com.intellij.openapi.actionSystem.{CommonDataKeys, AnAction, AnActionEvent}
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.Messages

class HelloWorldAction extends AnAction {

  def actionPerformed(event: AnActionEvent) {
    val project = event.getData(CommonDataKeys.PROJECT)
    val userName = askForName(project)
    sayHello(project, userName)
  }

  private def askForName(project: Project) = {
    Messages.showInputDialog(project, &quot;What is your name?&quot;, &quot;Input Your Name&quot;, Messages.getQuestionIcon)
  }

  private def sayHello(project: Project, userName: String) {
    Messages.showMessageDialog(project,
      s&quot;Hello, $userName!\n Welcome to PubEditor.&quot;, &quot;Information&quot;,
      Messages.getInformationIcon)
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到代码跟以前很相似，有一个重要的不同是这一行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val project = event.getData(CommonDataKeys.PROJECT)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以前的Java版是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Project project = event.getData(PlatformDataKeys.PROJECT);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;PROJECT&lt;/code&gt;的确是在&lt;code&gt;CommonDataKeys&lt;/code&gt;类中声明的，而&lt;code&gt;PlatformDataKeys&lt;/code&gt;继承了&lt;code&gt;CommonDataKeys&lt;/code&gt;。在Java中可以在子类中访问父类中的&lt;code&gt;static&lt;/code&gt;属性，而Scala中就不行。&lt;/p&gt;
&lt;h2&gt;运行&lt;/h2&gt;
&lt;p&gt;运行方式跟上一篇一样，一切正常。通过这个尝试，发现的确可以用scala代替Java来写Idea插件。&lt;/p&gt;
&lt;p&gt;本文所对应的tag为&lt;code&gt;2_hello_world_scala&lt;/code&gt;，源代码地址在：&lt;/p&gt;
&lt;p&gt;https://github.com/freewind/PubEditor&lt;/p&gt;
&lt;p&gt;下一篇我们将把&apos;.pub&apos;文件与我们的插件关联起来。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写IDEA plugin – PubEditor (1) Hello, world</title>
                <link>http://freewind.in/posts/2503-write-idea-plugin-yourself-pubeditor-1-hello-world</link>
                <pubDate>Sun, 06 Apr 2014 23:06:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2503</guid>
                <description><![CDATA[&lt;p&gt;我发现在实现编辑器功能时，比较容易用到编译原理方面的东西，比如高亮、格式化、代码提示、重构等，所以我打算通过开发一些编辑器插件来锻练。而IDEA是我们用的最多，也是我很喜欢的一个编辑器，所以就有了“自己动手写IDEA plugin”系列。&lt;/p&gt;
&lt;h2&gt;任务目标&lt;/h2&gt;
&lt;p&gt;这个任务的目标有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实现一个功能完善的IDEA plugin。包括格式化，高亮，代码提示等功能&lt;/li&gt;
&lt;li&gt;全面支持dart的pub。&lt;a href=&quot;http://pub.dartlang.org&quot;&gt;pub&lt;/a&gt;是dart的依赖管理工具，可定义、下载、管理dart包依赖&lt;/li&gt;
&lt;li&gt;使用scala来实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本上把我目前关注的几个方面都包括了。&lt;/p&gt;
&lt;h2&gt;本篇目标&lt;/h2&gt;
&lt;p&gt;作为开篇，我们将实现最基本的功能：创建一个最最基本的idea plugin，可以弹出一个Hello World的提示。&lt;/p&gt;
&lt;p&gt;为了方便，这里只使用Java实现，下一篇会改成scala的&lt;/p&gt;
&lt;h2&gt;准备工作&lt;/h2&gt;
&lt;h3&gt;入门教程&lt;/h3&gt;
&lt;p&gt;首先是IDEA plugin开发入门，非常值得一看，了解一下背景知识。&lt;/p&gt;
&lt;p&gt;http://confluence.jetbrains.com/display/IDEADEV/PluginDevelopment&lt;/p&gt;
&lt;p&gt;但是其中关于&lt;a href=&quot;http://confluence.jetbrains.com/display/IDEADEV/Getting+Started+with+Plugin+Development#GettingStartedwithPluginDevelopment-anchor2&quot;&gt;如何建立项目&lt;/a&gt;的一节讲得太繁琐，根本看不懂。不过好在不是很复杂，跟着本文走就行了。&lt;/p&gt;
&lt;p&gt;另外，上面列出的内容比较多，我没有全部看完，只看了前几篇，足够把本篇的任务完成。&lt;/p&gt;
&lt;h3&gt;下载IDEA&lt;/h3&gt;
&lt;p&gt;如果临时试一下，下载IDEA的社区版或企业版都行，也不需要下载源代码。但如果深入开发，就只能使用社区版，因为它可以跟源代码结合起来，方便调试。&lt;/p&gt;
&lt;p&gt;下载IDEA: &lt;a href=&quot;http://www.jetbrains.com/idea/download/&quot;&gt;http://www.jetbrains.com/idea/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随便下一个就行，不过为了方便，推荐社区版。&lt;/p&gt;
&lt;h3&gt;下载source&lt;/h3&gt;
&lt;p&gt;不论是社区版还是企业版，里面都自带插件开发工具，可以直接用。但是为了以后调试的方便，还需要下载idea的源代码，将它们关联起来，就可以单步了。&lt;/p&gt;
&lt;p&gt;使用git下载社区版对应的源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://git.jetbrains.org/idea/community.git idea --depth 1    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个非常大的库，就算添加了&lt;code&gt;--depth 1&lt;/code&gt;的参数，下载的源代码打成.tar.gz包后也超过了1G。由于代码库在国外，对于我们大部分人来说，这不是一天两天能完成的任务。&lt;/p&gt;
&lt;p&gt;这几天访问国外网络非常不稳定，所以我只好在一个国外的vpn上下载完代码，然后打包传过来。gz包的大小为1.18G，还要传19个小时。。。&lt;/p&gt;
&lt;h3&gt;启用Plugin DevKit插件&lt;/h3&gt;
&lt;p&gt;Idea中默认自带了&lt;code&gt;Plugin DevKit&lt;/code&gt;插件，但是没有开启。首先我们需要将它开启:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2503-1.png&quot;&gt;&lt;img src=&quot;/user_images/2503-1.png&quot; alt=&quot;QQ20140406-16&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后激动人心的时刻就要开始了！&lt;/p&gt;
&lt;h2&gt;创建项目&lt;/h2&gt;
&lt;p&gt;打开Idea，创建一个新项目，记得要选左右要选&quot;Intellij Plugin Platform&quot;类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-2.png&quot; alt=&quot;QQ20140406-4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后输入项目名，我选的是&lt;code&gt;PubEditor&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-3.png&quot; alt=&quot;QQ20140406-5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;创建完成后，就自动打开项目，注意在&lt;code&gt;META-INF&lt;/code&gt;下有一个&lt;code&gt;plugin.xml&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-4.png&quot; alt=&quot;QQ20140406-6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这个plugin.xml文件是一个重要的配置文件，用于向IDEA平台注册我们的提供的功能。如果你开发过eclipse插件，会知道那边也有一个类似的文件。&lt;/p&gt;
&lt;h2&gt;添加Action&lt;/h2&gt;
&lt;p&gt;我打算实现一个功能：在菜单最后添加一项&quot;Pub Editor&amp;rdquo;，里面有一个&quot;Hello world&quot;的子菜单。当点击它以后，会提示一个对话框，让我们输入自己的名字，然后弹出欢迎的信息。&lt;/p&gt;
&lt;p&gt;首先我们需要实现一个&lt;code&gt;AnAction&lt;/code&gt;的子类，用于实现触发之后的功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.thoughtworks.pli.pub_editor;

import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;

public class HelloWorldAction extends AnAction {

    @Override
    public void actionPerformed(AnActionEvent event) {
        Project project = event.getData(PlatformDataKeys.PROJECT);
        String userName = askForName(project);
        sayHello(project, userName);
    }

    private String askForName(Project project) {
        return Messages.showInputDialog(project,
                &quot;What is your name?&quot;, &quot;Input Your Name&quot;,
                Messages.getQuestionIcon());
    }

    private void sayHello(Project project, String userName) {
        Messages.showMessageDialog(project,
                String.format(&quot;Hello, %s!\n Welcome to PubEditor.&quot;, userName), &quot;Information&quot;,
                Messages.getInformationIcon());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，它实现了父类&lt;code&gt;AnAction&lt;/code&gt;中的&lt;code&gt;actionPerformed&lt;/code&gt;方法，提供了自己的逻辑。一个是弹出一个&lt;code&gt;inputDialog&lt;/code&gt;让用户输入自己的名字，另一个是弹出一个&lt;code&gt;messageDialog&lt;/code&gt;显示欢迎信息。&lt;/p&gt;
&lt;h2&gt;在plugin.xml中注册&lt;/h2&gt;
&lt;p&gt;只提供上面的类还不够，还需要在plugin.xml中添加一些注册信息。&lt;/p&gt;
&lt;p&gt;打开plugin.xml，找到其中的&lt;code&gt;&amp;lt;actions&amp;gt;&lt;/code&gt;一节，添加：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;group id=&quot;PubEditorPlugin.Menu&quot; text=&quot;_Pub Editor&quot; description=&quot;Pub Editor Menu&quot;&amp;gt;
    &amp;lt;add-to-group group-id=&quot;MainMenu&quot; anchor=&quot;last&quot;/&amp;gt;
    &amp;lt;action id=&quot;PubEditorPlugin.HelloWorldAction&quot; 
            class=&quot;com.thoughtworks.pli.pub_editor.HelloWorldAction&quot;
            text=&quot;_Hello world&quot; description=&quot;Hello world from PubEditor&quot;/&amp;gt;
&amp;lt;/group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一段信息量很大的配置代码。外面的&lt;code&gt;group&lt;/code&gt;指定了菜单组的位置&lt;code&gt;last&lt;/code&gt;，显示的内容为&lt;code&gt;Pub Editor&lt;/code&gt;，它前面的&lt;code&gt;_&lt;/code&gt;表示可用快捷键&lt;code&gt;p&lt;/code&gt;访问。里面的&lt;code&gt;action&lt;/code&gt;指定了菜单项显示的内容为&lt;code&gt;Hello world&lt;/code&gt;，对应的类为我们刚创建的&lt;code&gt;HelloWorldAction&lt;/code&gt;类。&lt;/p&gt;
&lt;h2&gt;代码部分结束&lt;/h2&gt;
&lt;p&gt;代码部分就结束了，东西不多，过程还是很轻松的。我的项目文件是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-5.png&quot; alt=&quot;QQ20140406-17&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面是运行效果了。&lt;/p&gt;
&lt;h2&gt;运行插件&lt;/h2&gt;
&lt;p&gt;不能直接运行，而要先建立一个配置。打开菜单&quot;Run&amp;rdquo;-&gt;&amp;ldquo;Configuration&amp;rdquo;，点击左上角的&amp;rdquo;+&amp;ldquo;新建，选择&quot;Plugin&amp;rdquo;，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-6.png&quot; alt=&quot;QQ20140406-18&quot; /&gt;&lt;/p&gt;
&lt;p&gt;基本上不用改什么，我就只把名字设成了&quot;Pub Editor&amp;rdquo;，然后点击&quot;OK&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;这时右上角运行栏处会变成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-7.png&quot; alt=&quot;QQ20140406-19&quot; /&gt;&lt;/p&gt;
&lt;p&gt;点击绿色小三角即可。&lt;/p&gt;
&lt;p&gt;它会打开一个新的IDEA。如果你运行的是企业版，可能会提示你输入license等信息，可以选择“继续试用”，进入开始界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-8.png&quot; alt=&quot;QQ20140406-20&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由于我们添加的菜单只能在进入项目后才能看到，所以我们需要随便创建一个项目。我建的是&quot;TestPlugin&amp;rdquo;，进去后可以看到上面的菜单最右边多了一项&quot;Pub Editor&amp;rdquo;，以及&quot;Hello world&amp;rdquo;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-9.png&quot; alt=&quot;QQ20140406-22&quot; /&gt;&lt;/p&gt;
&lt;p&gt;点击&quot;Hello world&quot;后，会弹出对话框，提示我们输入名称：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-10.png&quot; alt=&quot;QQ20140406-23&quot; /&gt;&lt;/p&gt;
&lt;p&gt;输入名字后，会弹出一个新的信息框：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2503-11.png&quot; alt=&quot;QQ20140406-24&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;作为Hello world，本文到此就结束了。源代码已经上传至:&lt;/p&gt;
&lt;p&gt;http://github.com/freewind/PubEditor&lt;/p&gt;
&lt;p&gt;本文所对应的tag为&quot;1_hello_world&amp;rdquo;，你可以checkout它运行一下看结果。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Access-Control-Allow-Origin与跨域</title>
                <link>http://freewind.in/posts/2456-access-control-allow-origin-and-cross-domain</link>
                <pubDate>Thu, 27 Mar 2014 20:24:31 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2456</guid>
                <description><![CDATA[&lt;p&gt;今天与萌萌一起修bug，遇到一个跨域的问题。我们两个都对它有一些不太清楚，一起搞清楚后记录下来。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;在某域名下使用Ajax向另一个域名下的页面请求数据，会遇到跨域问题。另一个域名必须在response中添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;的header，才能让前者成功拿到数据。&lt;/p&gt;
&lt;p&gt;这句话对吗？如果对，那么流程是什么样的？&lt;/p&gt;
&lt;h2&gt;跨域&lt;/h2&gt;
&lt;p&gt;怎样才能算跨域？协议，域名，端口都必须相同，才算在同一个域。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1077218/are-different-ports-on-the-same-server-considered-cross-domain-ajax-wise&quot;&gt;Are different ports on the same server considered cross-domain? (Ajax-wise)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://twlidong.github.io/blog/2013/12/22/kua-yuan-zi-yuan-gong-xiang-cross-origin-resource-sharing-cors/&quot;&gt;同事李栋的博客：跨源资源共享&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;当跨域访问时，浏览器会发请求吗&lt;/h2&gt;
&lt;p&gt;这是真正困扰我们的问题，因为我们不清楚浏览器会怎么做。它会不会检查到你要请求的地址不是同一个域的，直接就禁止了呢？&lt;/p&gt;
&lt;p&gt;我在jsbin上&lt;a href=&quot;http://jsbin.com/fusaweqe/1/edit&quot;&gt;做了一个试验&lt;/a&gt;，使用Chrome打开。当点击“Run with Js”时，控制台上会打出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://google.com/. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://run.jsbin.io&apos; is therefore not allowed access. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但开发者工具的&quot;Network&quot;栏并没有任何记录。它到底发请求了没？&lt;/p&gt;
&lt;p&gt;我又使用&lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt;在本地创建了一个小服务器，然后把地址改成它，结果发现在python这边的确打印出请求来了，可见浏览器的确发出了请求。&lt;/p&gt;
&lt;h2&gt;Access-Control-Allow-Origin&lt;/h2&gt;
&lt;p&gt;现在该&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;出场了。只有当目标页面的response中，包含了&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;这个header，并且它的值里有我们自己的域名时，浏览器才允许我们拿到它页面的数据进行下一步处理。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: http://run.jsbin.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果它的值设为&lt;code&gt;*&lt;/code&gt;，则表示谁都可以用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没错，在产品环境中，没人会用&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外注意，它不支持部分通配符，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://*.jsbin.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要么是&lt;code&gt;*&lt;/code&gt;，要么是一个确定的地址&lt;/p&gt;
&lt;p&gt;你可以阅读下面这篇文章了解更多，并可找到其中的&quot;Run Sample&quot;链接，实际体验一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/cors/&quot;&gt;http://www.html5rocks.com/en/tutorials/cors/&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Atom vs Spark：用Node/Dart+css+html打造编辑器</title>
                <link>http://freewind.in/posts/2461-atom-spark</link>
                <pubDate>Thu, 27 Mar 2014 19:57:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2461</guid>
                <description><![CDATA[&lt;h2&gt;Atom&lt;/h2&gt;
&lt;p&gt;感谢好友子叶发过的Atom邀请，我体验了一下可用Javascript/css/html写插件的编辑器。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://atom.io/&quot;&gt;http://atom.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网现在还处于非公开状态，需要有邀请才能下载。它是一个核心部分还未开源的编辑器，最大特点是内置了node.js，可以让人们使用Javascript/css/html写插件，即可以利用node.js的功能，又可以利用上成千上万的js库，相当强大。&lt;/p&gt;
&lt;p&gt;运行起来很流畅，有点sublime的感觉，所以我怀疑它自己并不是用nodejs写的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2461-1.png&quot;&gt;&lt;img src=&quot;/user_images/2461-1.png&quot; alt=&quot;QQ20140327-2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从官方文档上可以看到其功能已经相当完善，插件生态圈也差不多建起来了，目前已经有600多插件。我挑了一个插件看了一下，里面用到了coffeescript/less等，功能还比较复杂，但结构很清晰。也许因为Javascript给人的轻量感觉，让我觉得写一个插件出来似乎不是一件很困难的事情，不像给Eclipse/Idea写插件那样压力巨大。&lt;/p&gt;
&lt;p&gt;Atom目前只支持Mac平台，不久会推出Windows/Linux。另外它是一个商业软件，并不是免费的，但是“会提供与类似编辑器相比很有竞争力的价格”。&lt;/p&gt;
&lt;h2&gt;Spark&lt;/h2&gt;
&lt;p&gt;Node.js平台都有编辑器了，Dart呢？&lt;/p&gt;
&lt;p&gt;Dart有一个叫Spark的项目，利用Dart + Polymer在chrome上创建一个编辑器。这个项目还相当早期，只有不多的文档和源代码，需要开发者自己准备好环境、编译、执行才能看到结果。&lt;/p&gt;
&lt;p&gt;我经过一翻折腾，终于在今天把它跑起来了，果然是相当的早期！与前面的Atom大哥相比，实在不好意思露脸。。。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2461-3.png&quot;&gt;&lt;img src=&quot;/user_images/2461-3.png&quot; alt=&quot;QQ20140327-1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不论是界面还是功能都非常的简陋，我感觉和一个“记事本”差不多，后台还经常报错。只能说Dart很新，Polymer也很新，一切都还在探索之中。&lt;/p&gt;
&lt;p&gt;不过我个人对它还是很有兴趣的，至少可以拿来学习。而且，我对Dart还是很有信心的，相信Spark也会越来越好的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Varnish重写url与backend的关系</title>
                <link>http://freewind.in/posts/2439-relationship-between-rewrite-url-and-backend-of-varnish</link>
                <pubDate>Sun, 23 Mar 2014 20:29:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2439</guid>
                <description><![CDATA[&lt;p&gt;Varnish是一个开源的反向代理服务器，具有页面缓存功能，也可以用来做负载均衡，据说它的性能比较好。我们的项目中也使用了它。&lt;/p&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;我们有几台不同的服务器，分别运行不同的网站，每个服务器有自己的域名。为了能让用户得到更好的体验，不需要在不同的域名中跳转，我们使用了一台服务器运行Varnish来进行反向代理，根据用户请求的路径分别到不同的服务器上取内容展示给用户。&lt;/p&gt;
&lt;p&gt;假设Varnish服务器对应域名为&lt;code&gt;abc.com&lt;/code&gt;，后端几个网站分别为&lt;code&gt;x1.com&lt;/code&gt;, &lt;code&gt;x2.com&lt;/code&gt;, &lt;code&gt;x3.com&lt;/code&gt;，我们在Varnish中定义了以下映射规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abc.com/products   -&amp;gt;   x1.com/products
abc.com/admin      -&amp;gt;   x2.com/admin
abc.com/help       -&amp;gt;   x3.com/help


对于用户来说，他看到的网站都在`abc.com`下，完全不需要知道后台有多少服务器多少独立系统。由于这些系统的页面风格都非常一致，从用户角度上看，似乎就是在访问一个网站。

## 新需求

现在有一个新的需求：

我们有一个网站部署在另一家服务商，并且可以通过网址：`https://some.server.com/myserver/user/login.html`访问到。为了让用户有一致的体验，要添加一个映射：

abc.com/login -&amp;gt; https://some.server.com/myserver/user/login.html


## 分析

最开始我们觉得这是一个很简单的任务，虽然对Varnish不太了解，但是因为有类似的功能可参考，以为直接复制下代码就能完成。但随着多次尝试失败，发现问题似乎不是这么简单。

### Redirect

开始我们把它当成redirect来处理了，即让server返回一个301，告诉用户新的地址即可。

在Varnish的配置文件中加入：

sub vcl_recv {
    if (req.url ~ &quot;^/login&quot;) {
        set req.http.Location = &quot;https://some.server.com/myserver/user/login.html&quot;;
        error 750 &quot;Permanently moved&quot;;
    }
}

sub vcl_error {
    if (obj.status == 750) {
      set obj.http.location = req.http.Location;
      set obj.status = 301;
      return (deliver);
    }
}


第一块检查url后，把`Location`改成目标地址，并且抛一个错误。第二块捕获错误并处理，可以看到它直接把`Location`拿过来，并把`status`设成了301。

这样用户访问`http://abc.com/login`时，浏览器就会跳转到`https://some.server.com/myserver/user/login.html`页面。

可是，不合需求！

看来我们需要的是`rewrite`，而不是`redirect`

### rewrite

参考一些例子后，发现可以按下面的方式来进行rewrite:

sub vcl_recv {
    if (req.url ~ &quot;^/login&quot;) {        
        set req.http.x-host = req.http.host;
        set req.http.x-url = req.url;
        set req.http.host = &quot;www.varnish-cache.org&quot;;
        set req.url = &quot;/some-page.html&quot;;
    }
}


结果我发现，这种方式，只是把`host`和`url`作为header中的参数传给了某个`backend`。

我的default的backend的配置是这样的：

backend default {
    .host = &quot;127.0.0.1&quot;;
    .port = &quot;9999&quot;;
}


它实际上是我用`python -m SimpleHTTPServer 9999`开的一个简单服务器。

然后当我在浏览器中访问时，发现python这边输出了类似下面这样的日志：

[23/Mar/2014 20:19:14] &quot;GET /some-page.html HTTP/1.1&quot; 404 -


看来Varnish只能向一个预先定义好的backend上发送请求，并不会“聪明地”根据host的内容去外部网站拿数据。

## 猜想的解决方案

通过文档以及实验，可以确定Varnish在处理请求的转发方面方面，规则的确比较“简单”。

我们需要事先定义好一些backend，每个backend只能给定一个域名(或IP)和端口，它们必须能够接受HTTP请求。然后我们在配置文件中，设置一些规则，比如：当我们访问某个url时，Varnish以哪种方式检查请求的路径，使用哪个backend（或者默认），同时还可以修改请求的参数。在运行时，Varnish就会把我们发起的请求，转给相应的backend，拿到回复后，再返回给用户。

可以看到，它只能在已经定义好的backend列表中选择一个，而不会从之外的地方拿数据。

所以我目前想到的解决方案就是：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先拿到&lt;code&gt;https://some.server.com/myserver&lt;/code&gt;对应的ip，或者专门给它配置一个独立的域名，以防止写死IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Varnish中为它添加一个backend&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;判断用户请求的路径，满足条件时转发给该backend&lt;/p&gt;
&lt;h3&gt;https&lt;/h3&gt;
&lt;p&gt;还有一个https问题，因为看到有些文档说Varnish还不支持https，只支持http，不知道最新版怎么样。另外也不知道项目中使用的版本是不是支持，明天看看。&lt;/p&gt;
&lt;p&gt;如果不支持的话，只能改用http协议。&lt;/p&gt;
&lt;p&gt;或者：Apache2似乎支持对https进行反向代理，那可以在后台再加一个Apache，两次反向代理。。。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;p&gt;实际上不用配置独立的域名，直接使用&lt;code&gt;some.server.com&lt;/code&gt;就行，配置一个这样的backend:&lt;/p&gt;
&lt;p&gt;backend someServer {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.host = &quot;some.server.com&quot;;
.port = &quot;80&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;vcl_recv&lt;/code&gt;中：&lt;/p&gt;
&lt;p&gt;if(req.url ~ &apos;^/login&apos;) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set req.http.host = &quot;some.server.com&quot;;
set req.url = &quot;/myserver&quot; req.url;
set req.backend = someServer;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;p&gt;另外发现不一定要用&lt;code&gt;https&lt;/code&gt;，所以就直接用80端口了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>正向代理与反向代理</title>
                <link>http://freewind.in/posts/2431-forward-proxy-and-reverse-proxy</link>
                <pubDate>Sun, 23 Mar 2014 16:11:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2431</guid>
                <description><![CDATA[&lt;p&gt;前两天在配置varnish的时候，我看到配置文件中有不少后端服务器的设置，觉得这是在配“反向代理”，但同事说这是“正向代理”。我不确定哪个对，以及它们之间有何区别，便查了一下。&lt;/p&gt;
&lt;p&gt;网上资料很多，便不再重复。我自己的理解是这样的：&lt;/p&gt;
&lt;h2&gt;正向代理&lt;/h2&gt;
&lt;p&gt;我们想访问某个网站，但是访问不了，需要借助另一台服务器的帮助。比如我们番羽墙时会设一些代理服务器(http的，socks的等），然后输入我们要访问的网站，代理服务器便会替我们把内容取回来。这些代理服务器所做的事情就是“正向代理”。&lt;/p&gt;
&lt;p&gt;在正向代理中，目标网站是主角，代理服务器是助手，通常我们都知道自己正在使用代理。&lt;/p&gt;
&lt;p&gt;现实举例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们在火车票代售点买票：“我要买一张明天中午从西安到北京的火车票”&lt;/li&gt;
&lt;li&gt;我们托人从海外代购：“某某某，能帮我从美国买一个nexus5手机吗”&lt;/li&gt;
&lt;li&gt;发快递：“快递员，请帮我把这个东西发到某个地方”&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;反向代理&lt;/h2&gt;
&lt;p&gt;我们访问某个网址，它在自己的域名下提供了很多内容，看起来都像是它自己的。我们以为自己访问的就是原始的网站，实际上它只是一个代理服务器。它根据我们的请求路径，从某一个我们不知道的地方拿到了内容，然后当成它自己的东西提供给我们。&lt;/p&gt;
&lt;p&gt;在反向代理中，代理服务器是主角，内容提供者是助手，通常我们并不知道自己正在访问一个代理服务器。&lt;/p&gt;
&lt;p&gt;现实举例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们在超市买东西：买了很多，各个牌子都有，但是我们不知道它们从哪儿来的，只知道超市有卖，好像是超市提供的似的&lt;/li&gt;
&lt;li&gt;我们把项目外包给某人做：我们要求在规定时间能完成，但他是自己做还是转包给别人，我们并不清楚，只知道他能帮我完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;对于公司项目，我们是想用varnish作为前端，让用户在同一个域名下访问所有的内容。而varnish会根据请求路径的不同，到不同的服务器和网站中拿到相应内容，提供给用户。&lt;/p&gt;
&lt;p&gt;对于这种需求，很明显就是“反向代理”了。&lt;/p&gt;
&lt;p&gt;同时，在varnish的文档上写着：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Varnish is a reverse HTTP proxy, sometimes referred to as a HTTP accelerator or a web accelerator.&lt;/p&gt;
&lt;/blockquote&gt;
]]></description>
            </item>
        
            <item>
                <title>参加了下午的TDD open workshop有收获</title>
                <link>http://freewind.in/posts/2427-xian-tdd-open-workshop</link>
                <pubDate>Sun, 23 Mar 2014 00:56:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2427</guid>
                <description><![CDATA[&lt;p&gt;今天下午在西安办公室举行了面向大众的一个open workshop活动，主要是让参与者体验结对编程与TDD。我加入公司快一年了，还从没有机会参加过这样的活动，所以便过来。今天来的人不多，只有七八个人，跟宣传有点仓促有关，其中有一些学生，有一些在周围上班的人，还有一些培训机构的老师。&lt;/p&gt;
&lt;p&gt;今天的活动让我收获很大，讲师仝(tong2)键很给力，很多困扰我已久的问题终于得到了解答，让我觉得非常开心。&lt;/p&gt;
&lt;p&gt;在加入公司之前，我虽然听过TDD这个概念并且也写过很多单元测试，但其实并不是真的清楚应该怎么去写测试，很多时候是为写而写。在客户现场这段时间，我一边向同事学习，一边跟客户探讨，虽然对于测试有了不少经验，但还不足以向别人讲清楚，遇到一些复杂的情况自己也经常犯迷糊。&lt;/p&gt;
&lt;p&gt;仝老师的选题是一道经典题目：猜数字游戏。这个题目经常被拿来作为TDD的培训，可能大家有听说过。仝老师并没有一次把题目全说出来，而是把它分成了几个小题，一步步让大家做，每道题都对应了一个测试方面的重点。&lt;/p&gt;
&lt;h2&gt;第一题&lt;/h2&gt;
&lt;p&gt;我们要在游戏机上玩一个猜数字游戏，机器会想好一个不重复的4位数让我们猜，然后检查我们的输入，最后输出一个形如&lt;code&gt;?A?B&lt;/code&gt;这样的字符串。其中A左边的数字是指，你输入的数字中有多少个它有并且位置也一模一样，而B左边数字是指它有但位置不一样。&lt;/p&gt;
&lt;p&gt;举个例子，假如游戏想到的数字是&lt;code&gt;1234&lt;/code&gt;，你输入&lt;code&gt;5678&lt;/code&gt;，则它输出&lt;code&gt;0A0B&lt;/code&gt;。你输入&lt;code&gt;1678&lt;/code&gt;，它输出&lt;code&gt;1A0B&lt;/code&gt;；你输入&lt;code&gt;1243&lt;/code&gt;，它输出&lt;code&gt;2A2B&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们要做的，就是要实现这样的一个函数，当然要通过先写测试把它驱动出来。&lt;/p&gt;
&lt;p&gt;这个题目的难点在于：测试写多少才够？&lt;/p&gt;
&lt;p&gt;如果把所有情况都考虑到，那么四个不重复的数字，就有几千种情况，而用户的输入也有几千种情况，全测显然是不可能的事情。后来我们缩小范围，打算按&amp;rdquo;?A?B&quot;来分，比如&quot;0A0B&amp;rdquo;,&amp;ldquo;0A1B&amp;rdquo;,直到&quot;4A0B&amp;rdquo;，每种想一个测试数据，但这样的话也会有十几个。伙伴说只测边界情况，比如&quot;0A0B&amp;rdquo;,&amp;ldquo;4A0B&amp;rdquo;,&amp;ldquo;0A4B&amp;rdquo;，其它的再挑几个。但由于我们都拿不定主意，我索性把问题放大，如何便给每一种情况写了一个测试。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ComparatorTest {
    private Comparator comparator;
    @Before
    public void setup() {
       comparator = new Comparator();
    }

    @Test
    public void test0A0B() {
        String result = comparator.compare(&quot;1234&quot;, &quot;5678&quot;);
        assertThat(result).isEqualTo(&quot;0A0B&quot;);
    }
    @Test
    public void test0A1B() {
        String result = comparator.compare(&quot;1234&quot;, &quot;4678&quot;);
        assertThat(result).isEqualTo(&quot;0A1B&quot;);
    }
    @Test
    public void test0A2B() {
        String result = comparator.compare(&quot;1234&quot;, &quot;3478&quot;);
        assertThat(result).isEqualTo(&quot;0A2B&quot;);
    }
    // here are some more tests
    // ...
    @Test
    public void test4A0B() {
        String result = comparator.compare(&quot;1234&quot;, &quot;1234&quot;);
        assertThat(result).isEqualTo(&quot;4A0B&quot;);
    }
}


这里会定义十几个测试用例，每一个都非常简单，仅仅是数据和结果不同。伙伴提出了疑问，认为这样的测试实在太累人了，这么简单的逻辑要写这么多测试代码，太痛苦了。而且以后测试的维护成本也会很高，一旦需求变了，要从这么大堆代码里一一修改，更痛苦。

在showcase时候，我们的代码作为成功的反面教材，很好的警示了大家。大家在仝老师的指导下，讨论了以下几个问题：

### 测试应该写多少才够

对于这个题目，我们的第一种方案测的太多了，实际上只需要测边界条件和一两个普通条件即可。下面是一个比较好的例子：

@Test
public void should_output_0A0B_when_we_guess_5678_for_1234() {
    String result = comparator.compare(&quot;1234&quot;, &quot;5678&quot;);
    assertThat(result).isEqualTo(&quot;0A0B&quot;);
}

@Test
public void should_output_4A0B_when_we_guess_1234_for_1234() {
    String result = comparator.compare(&quot;1234&quot;, &quot;1234&quot;);
    assertThat(result).isEqualTo(&quot;4A0B&quot;);
}

@Test
public void should_output_0A4B_when_we_guess_2341_for_1234() {
    String result = comparator.compare(&quot;1234&quot;, &quot;2341&quot;);
    assertThat(result).isEqualTo(&quot;0A4B&quot;);
}

@Test
public void should_output_0A0B_when_we_guess_5678_for_1234() {
    String result = comparator.compare(&quot;1234&quot;, &quot;5678&quot;);
    assertThat(result).isEqualTo(&quot;0A0B&quot;);
}

@Test
public void should_output_2A1B_when_we_guess_1273_for_1234() {
    String result = comparator.compare(&quot;1234&quot;, &quot;1273&quot;);
    assertThat(result).isEqualTo(&quot;2A1B&quot;);
}


可以看到，它只测了3种边界情况和一种普通情况，代码数量不多，方法的命名也很清楚。

那么，这样够了吗？

我们写单元测试，有一个重要的原因是用来防止自己犯低级错误的。我们不能把写实现代码的人当作我们的敌人，一定要把全部情况都测到，以防止他们在里面故意留下各种隐蔽的陷阱。测试写的再多可能也没有办法覆盖全部情况，所以只要能让自己感到安全即可。怎样才能让自己感到安全呢？这是没有标准答案的，只能是写多了测试以后慢慢体会。

另外，写测试也要花时间的，比如`compare`这个方法的实现部分，我们只花了一两分钟就写完了，而这些测试代码，我们花了足足半个多小时，这样做值得吗？对于简单的业务逻辑来说，当然是不值得的，毕竟我们还很多工作等着做，老板花钱是为了我们的产品代码，而不是测试代码。

再考虑一种情况，我要创业，想了一个点子，做了一个网站，我当然是想以最快的速度把它做成型让别人用。如果我在完全不知道人们会不会喜欢的时候，先花大量时间写测试，最后发现没人用只能丢掉，这些测试岂不是白写了。

所以还是上面那句话：单元测试是让你提升自己对代码的信心的，只要你感觉安全可以继续开发时就够了，不是越多越好。

所以对于这个题目，推荐的方案就已经足够了。

再考虑一个场景，假设上面那个`compare`方法不是你写的，而是一个复杂的遗留系统的一部分，而你要对它进行重构，那么测试应该写多少？

遗留系统的特点一般都是测试少，文档过时，需求没法追踪，只能通过已有代码反推需求。在这种情况下，想达到同样“安全”的感觉，势必需要补更多的测试，考虑更多的复杂情况，以保证我们重构之后不会破坏它原有的功能。

所以，就算是同样的代码，在不同的场景下，我们需要写的测试数量也是不一样的，关键还是安全感。

### 测试方法应该怎么命名

在看大家的代码时，我发现对于测试的方法，有三种不同的命名方式：

public class ComparatorTest {
    public void test0A1B() {}
    public void should_output_0A1B_when_guess_5671_for_1234() {}
    public void should_output_0A1B() {}
}


哪种方式才对呢？

第二种是比较推荐的，因为我们写测试的一个重要目的，是把它当作可执行的文档来用的，每一个测试通常会覆盖一个需求点，让以后维护的人知道你的产品代码实现了哪些需求。

使用第二种方法，读起来像是一句话，比较流畅，也能够突出“在什么情况下应该做什么”，让人一看名字就知道这个测试在做什么。

我们在写测试时，有时候会觉得命名没有那么重要，给个大概就行了，因为：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这个需求点这么明显，一看产品代码就知道了，难道还会错？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试意图在测试代码里已经体现的很清楚了，直接看代码就行了&lt;/p&gt;
&lt;p&gt;对于第一点，开发的时候的确很清楚需求，但是几个月之后，甚至被别人接手修改后呢？产品代码可能已经被人修改过了，原作者很可能已经不记得当时为什么要做这个功能、写这些代码，而修改者只是在原来的代码上修修补补。最开始简单的代码慢慢变得复杂，直到让人难以理解。而当时单独写的文档可能已经过期，它描述的功能与实际的代码之间已经对应不上，最后接手的人不知道该相信文档还是相信代码。&lt;/p&gt;
&lt;p&gt;对于第二点，测试代码本身可能会比较复杂，让人难以一眼看明白逻辑。同时测试代码可能也会在多次修改之后，偏离了原本的意图。这个时候，通过读测试代码反推需求同样不可靠了。&lt;/p&gt;
&lt;p&gt;而如果我们在测试方法名上尽可能简洁而准确的表明“产品代码在什么情况下应该做什么”，同时测试代码和产品代码都以它作为基准，这样就可以把测试看成“可执行的文档”，长久保持有效性。以后维护的人要修bug或者修改什么功能，只需要找到测试，看看名字就能知道代码有什么功能，然后再看测试代码和产品代码，就能很快定位到修改点。&lt;/p&gt;
&lt;p&gt;所以我们在写测试时，不要想着自己是在写代码，而要想成是在写文档，如何保证它准确、可读才是最重要的。&lt;/p&gt;
&lt;p&gt;第二种方案，使用下划线分隔单词以提高可读性，在方法名中提供输入条件和预期结果以保证准确性，是比较好的方式。&lt;/p&gt;
&lt;h3&gt;是否使用0A0B&lt;/h3&gt;
&lt;p&gt;关于测试名，仝老师还补充了一个问题：我们是否应该在测试名上使用如0A0B这样的词。&lt;/p&gt;
&lt;p&gt;仝老师说这个问题曾经在thoughtworks有过激烈的争论，因为有人认为应该尽量使用人们都能理解的词，而不是一些不懂业务就看不懂的词。比如这个0A0B，我们应该写成“既没有位置和内容都正确的数字，也没有内容正确和位置不对的数字”。&lt;/p&gt;
&lt;p&gt;后来争论的结果是，我们可以把它当作“业务名词”，是可以写在方法名里的。因为作为参与到项目中的开发者，是必须要理解这些业务名词的意思的。既然大家都理解，为什么还要想办法把它变成另一种说法呢？&lt;/p&gt;
&lt;p&gt;至少我觉得&quot;0A0B&quot;既好写又好懂，如果真要写成“既没有位置和内容都正确的数字，也没有内容正确和位置不对的数字”，我不知道自己能不能用英文写的出来，也不知道别人能不能看得懂。&lt;/p&gt;
&lt;h3&gt;我们可不可以准备好大量数据，在一个测试里循环验证&lt;/h3&gt;
&lt;p&gt;我们其实还想出了一种方案：把数据都放在一个二维数组里，只需要写一个测试，循环一下就可以了。代码如下：&lt;/p&gt;
&lt;p&gt;public class ComparatorTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static final TEST_DATA = {
    {&quot;1234&quot;, &quot;5678&quot;, &quot;0A0B&quot;},
    {&quot;1234&quot;, &quot;5671&quot;, &quot;0A1B&quot;},
    {&quot;1234&quot;, &quot;5612&quot;, &quot;0A2B&quot;},
    // more data
    {&quot;1234&quot;, &quot;1234&quot;, &quot;4A0B&quot;},  
};
@Test
public void testAll() {
    for(String[] testCase: TEST_DATA) {
        String result = comparator.compare(testCase[0], testCase[1]);
        assertThat(result).isEqualTo(testCase[2]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;伙伴对这个方案很满意，因为代码少了，而关键的测试数据都放在了一起，好查看好修改，以后要是需要添加新的测试数据，直接加一行就行了。&lt;/p&gt;
&lt;p&gt;这种做法是否推荐呢？&lt;/p&gt;
&lt;p&gt;仝老师的意思是，这主要看客户有没有这种大数据量测试的需求。如果有的话，当然可以采用这种方式，甚至还可以利用jUnit提供的“数据驱动”的功能，更好的实现：比如不需要手动写循环，哪一行出错还可以直接定位错误数据。&lt;/p&gt;
&lt;p&gt;但对于这道题目来说，使用前面推荐的方案就可以了。&lt;/p&gt;
&lt;h2&gt;第二题&lt;/h2&gt;
&lt;p&gt;我们要写一个生成随机数的函数，并且要保证它是一个长度为4位的数字。&lt;/p&gt;
&lt;p&gt;这个题目的难点在于：如何测试随机数？&lt;/p&gt;
&lt;p&gt;我们很快完成了，测试代码如下（产品代码略）：&lt;/p&gt;
&lt;p&gt;public class NumberGeneratorTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private NumberGenerator numberGenerator;
@Before
public void setup() {
    numberGenerator = new NumberGenerator();
}
@Test
public void should_generate_numbers_with_length_of_4() {
    for(int i=0;i&amp;lt;10000;i++) {
        String number = numberGenerator.generate();
        assertThat(number.length()).isEqualTo(4);
    }
}
@Test
public void should_generate_string_with_digits_only() {
    for(int i=0;i&amp;lt;10000;i++) {
        String number = numberGenerator.generate();
        // assert number contains digits only
    }
}
@Test
public void should_generate_string_without_duplicate_characters() {
    for(int i=0;i&amp;lt;10000;i++) {
        String number = numberGenerator.generate();
        // assert number has no duplicate digits
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;对于这个题目，大家又一起讨论下面几个问题：&lt;/p&gt;
&lt;h3&gt;我们需要循环一万次吗&lt;/h3&gt;
&lt;p&gt;在我们的测试里，每一个测试都把待测方法运行了一万次，以表明我们是在测试一个随机数，多测几次保险。而其它人的代码里，并没有这次循环，只测了一次。&lt;/p&gt;
&lt;p&gt;到底哪种更好一些呢？&lt;/p&gt;
&lt;p&gt;最后大家比较认同的是，只测一次就足够了，因为这些单元测试我们经常会遇到，如果有问题很容易发现。同时功能代码是我们自己写的，我们有信心自己会输出一个随机数，不测也可。另外，由于随机数的不确定性，我们很难在测试中保证它一定会满足某种条件，所以不太好写，不测也罢。&lt;/p&gt;
&lt;p&gt;但我的伙伴还是觉得只跑一次不可靠，因为如果算法比较复杂，运行多次更容易暴露出它的问题，所以倾向于在不影响性能的前提下，尽可能多跑。&lt;/p&gt;
&lt;p&gt;对于这个疑问，仝老师的意思是，多跑几次也没关系，加上就行了，有争论这些问题的时间早把功能完成了。对于这种小问题，我们一般采用“随便”的态度。&lt;/p&gt;
&lt;h3&gt;需要保证两次不相同吗&lt;/h3&gt;
&lt;p&gt;仝老师又提出一个问题：如果用户来玩游戏，结果发现机器第二次想好的数跟第一次一样，会不会觉得很郁闷？我们要不要加个测试来证明它不会连续两次生成同一个数字吗？&lt;/p&gt;
&lt;p&gt;大家普遍表示这个测试没法写，因为随机数的不确定性，我们没法保证第二次跟第一次不一样。&lt;/p&gt;
&lt;p&gt;对于这个问题，仝老师的意思是，这时开发者应该向业务分析师提出这个问题，由业务分析师来决定。如果他们说要，那我们就要修改代码，保证第二次产生的跟前一次不同，并且加上相应测试；否则连测试都不用加了。&lt;/p&gt;
&lt;p&gt;仝老师说，从这个问题我们可以发现，业务需求并不总是由业务分析师发现的，开发者也有机会向他们提出建议和帮助。&lt;/p&gt;
&lt;h2&gt;第三题&lt;/h2&gt;
&lt;p&gt;前面我们已经写了两个类，一个用于生成随机数，一个用于比较两个数字，现在要写一个新的类，把它们集成起来，就像胶水一样把它们两个的功能结合在一起，提供一个方法让用户只需要输入一个数字即可。&lt;/p&gt;
&lt;p&gt;这个题目的难点：如何对集成本身进行测试？&lt;/p&gt;
&lt;p&gt;这时候需要用mock了，在Java里一般使用mockito这个大杀器。&lt;/p&gt;
&lt;p&gt;我们的测试代码如下：&lt;/p&gt;
&lt;p&gt;public class GameTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private NumberGenerator numberGenerator;
private Comparator comparator;
private Game game;
@Before
public void setup() {
    numberGenerator = mock(NumberGenerator.class);
    comparator = mock(Comparator.class);
    game = new Game(numberGenerator, comparator);
}

@Test
public void should_output_0A0B_if_user_input_5678_when_answer_is_1234() {
    when(numberGenerator.generate()).thenReturn(&quot;1234&quot;);
    when(comparator.compare(&quot;1234&quot;, &quot;5678&quot;)).thenReturn(&quot;0A0B&quot;);

    String result = game.guess(&quot;5678&quot;);
    assertThat(result).isEqualTo(&quot;0A0B&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;大家讨论了下面几个问题：&lt;/p&gt;
&lt;h3&gt;一个测试够了吗&lt;/h3&gt;
&lt;p&gt;可以看到，这个测试只有一个用例，够了吗？&lt;/p&gt;
&lt;p&gt;由于这个测试测的是胶水类与其它类之间的交互，一个测试就可以覆盖。而“其它类”都有各自的测试代码，不需要在这里重复测。&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;我的伙伴提出了一个问题：&lt;code&gt;Game&lt;/code&gt;这个类的构造函数居然要传入两个参数，这样做好吗？我们要不要再给它提供一个无参的构造函数，默认提供相应的对象，而把有参的仅仅作为测试用？&lt;/p&gt;
&lt;p&gt;就像下面这样：&lt;/p&gt;
&lt;p&gt;public class Game {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private NumberGenerator numberGenerator;
private Comparator comparator;
public Game() {
    this(numberGenerator, comparator);
}
public Game(NumberGenerator numberGenerator, Comparator comparator) {
    this.numberGenerator = numberGenerator;
    this.comparator = comparator;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;仝老师使用反问来回答：做这样不好吗？我们为什么一定要提供一个无参的构造函数，为什么不能只提供一个有两个参数的构造函数？&lt;/p&gt;
&lt;p&gt;仝老师的观点是：我们没有证据来说哪个好哪个不好，而只提供一个有两个参数的构造函数这种方案，可以有更好的可测试性和可扩展性。提供无参构造函数，说明这个类会自己来管理生命周期，这样做是不好的，会对扩展性产生阻碍。而我们一般会使用如spring这样的工具，把这些生命周期的管理和对象之间的依赖放在外部，由容器管理。&lt;/p&gt;
&lt;p&gt;看起来构造函数里参数多了有点吓人，实际上使用了spring这样的容器后，我们基本上不需要手动调用它们，并不会带来麻烦。&lt;/p&gt;
&lt;h3&gt;需要测调用次数吗&lt;/h3&gt;
&lt;p&gt;我提了一个问题：我们需要在测试中验证Game类对另外两个类的方法的调用次数吗？&lt;/p&gt;
&lt;p&gt;仝老师的意思是，如果我们没写，就表示调用一次。如果对调用次数有要求，则应该写。&lt;/p&gt;
&lt;p&gt;我感觉，对于这个例子来说，&lt;code&gt;numberGenerator.generate()&lt;/code&gt;的调用次数是有要求的：在一次游戏中只应该生成一次答案，可以加上验证。而对于&lt;code&gt;comparator.compare(...)&lt;/code&gt;，我们更关注的是它的返回值，所以没有必要验证。&lt;/p&gt;
&lt;h3&gt;mock的分类&lt;/h3&gt;
&lt;p&gt;仝老师还讲了一个mock的分类，大意是，曾经mock分为了很多种，比如stub, fake, dummy等等，它们之间都有微小的差别，我们在调用时还需要指定用哪个。但是后来人们发现，分这么细没用，没人关注你是什么，只关注你的行为，所以到最后都统一成mock了。&lt;/p&gt;
&lt;h2&gt;第四题&lt;/h2&gt;
&lt;p&gt;再对题目进行扩展：现在要增加人机交互界面了，用命令行即可。机器会提示让用户输入一个数字，它检查并给出结果。如果输入的数字跟它预想的一样，直接输出&quot;Congratulations!&amp;ldquo;，否则输出&amp;rdquo;?A?B&quot;这样的提示。如果失败6次，则输出&quot;You lose&quot;并退出。&lt;/p&gt;
&lt;p&gt;这道题的重点在于：我们如何写一个集成测试来测试这些功能？&lt;/p&gt;
&lt;p&gt;由于当时我们在跟仝老师讨论一些类设计的问题，没做这个题，只能把一些讨论过的问题记录下来：&lt;/p&gt;
&lt;h3&gt;集成测试中怎么测随机数&lt;/h3&gt;
&lt;p&gt;仝老师说在集成测试里，我们需要用一个mock来替代&lt;code&gt;NumberGenerator&lt;/code&gt;，让我觉得非常惊讶。因为我以为集成测试里是不能用mock的，要尽量使用系统中真实的类。&lt;/p&gt;
&lt;p&gt;仝老师说：集成测试的目的是要测试不同单元之间的集成，重点在于交互时的行为，而不是用不用真实的类。如果你的系统依赖于一些复杂的外部环境，就像随机数这样不可控，你的集成测试怎么写？&lt;/p&gt;
&lt;p&gt;差不多明白了，因为想起在上个项目，为了测JMS queue，自己还是用了一些mock来替代真实的模块。&lt;/p&gt;
&lt;h3&gt;Happy pass 就够了吗&lt;/h3&gt;
&lt;p&gt;仝老师还提到，这个集成测试我们只需要写一个happy pass的用例就行了，我感到很奇怪：不是有赢和输两种情况吗？难道不是两个用例吗？&lt;/p&gt;
&lt;p&gt;仝老师说我们要测的是模块间的交互行为，只需要测happy pass就满足了，其它的情况在其它的测试里都已经覆盖了，没必要再测。&lt;/p&gt;
&lt;h3&gt;如何进行端对端的测试&lt;/h3&gt;
&lt;p&gt;七夕同学问到如何进行“端对端的测试”，即针对输入和输出进行测试，直接替换掉&lt;code&gt;System.in&lt;/code&gt;和&lt;code&gt;System.out&lt;/code&gt;就行了吗？&lt;/p&gt;
&lt;p&gt;仝老师认为这种做法就可以了，再低就要考虑从操作系统层面入手了。&lt;/p&gt;
&lt;p&gt;这一点我还不太理解，因为我在想能否直接以脚本形式启动这个类，然后拦截输入输出进行验证，因为我上个项目就是这么做的，我感觉可行。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;活动结束后，大家一起做了一个回顾，都觉得这个活动很好，不够好的地方主要在时间安排和讲解上，感觉比较紧张，有点跟不上。还有就是不少同学对Java不熟悉，只能看不能写。&lt;/p&gt;
&lt;p&gt;仝老师说这个活动一般是十个小时的，这次只安排了四个小时，的确有点紧张，因为一开始考虑参与者都是有一些经验的。&lt;/p&gt;
&lt;p&gt;总体来说，我觉得这个活动很成功，的确有很多收获，希望能多参加一些这样的活动，最后感谢仝老师和所有的参与者们。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;p&gt;参考代码：https://github.com/lxdcn/ut-workshop/tree/master/java/maven/src/test/java&lt;/p&gt;
&lt;p&gt;这是仝老师后来发过来的参考代码，有些地方值得注意：&lt;/p&gt;
&lt;h3&gt;随机数的测试&lt;/h3&gt;
&lt;p&gt;看到一个很酷的测试：&lt;/p&gt;
&lt;p&gt;https://github.com/lxdcn/ut-workshop/blob/master/java/maven/src/test/java/GuessNumberTest.java#L40&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Real integrate test
&lt;br  /&gt;*/
&lt;br  /&gt;@Test
&lt;br  /&gt;public void integrate_test_RandomNumberGenerate_and_CompareTwoNumbers_should_work() {
&lt;br  /&gt;Random random = mock(Random.class);
&lt;br  /&gt;when(random.nextInt(10)).thenReturn(1).thenReturn(2).thenReturn(3).thenReturn(4);&lt;/p&gt;
&lt;p&gt;RandomNumberGenerator randomNumberGenerator = new RandomNumberGenerator(random);
&lt;br  /&gt;CompareTwoNumbers compareTwoNumbers = new CompareTwoNumbers();&lt;/p&gt;
&lt;p&gt;GuessNumber guessNumber = new GuessNumber(compareTwoNumbers, randomNumberGenerator);
&lt;br  /&gt;assertThat(guessNumber.guess(&amp;ldquo;1234&amp;rdquo;)).isEqualTo(&amp;ldquo;4A0B&amp;rdquo;);
&lt;br  /&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要以看到，作者创建的&lt;code&gt;RandomNumberGenerator&lt;/code&gt;类还可以接受一个&lt;code&gt;Random&lt;/code&gt;对象，这样通过对&lt;code&gt;Random&lt;/code&gt;进行mock来测试随机数的生成，是一个很好的思路。&lt;/p&gt;
&lt;p&gt;这是一个&quot;Real integrate test&amp;rdquo;。因为我们可以把&lt;code&gt;Random&lt;/code&gt;类看作是一个外部单元，而我们的代码又是一个单元。通过指定&lt;code&gt;Random&lt;/code&gt;的行为来对两个单元进行集成测试。&lt;/p&gt;
&lt;h3&gt;测随机数连续5次不同&lt;/h3&gt;
&lt;p&gt;看到有一个测试，测连续5次生成的随机数不相同：&lt;/p&gt;
&lt;p&gt;https://github.com/lxdcn/ut-workshop/blob/master/java/maven/src/test/java/RandomNumberGeneratorTest.java#L57&lt;/p&gt;
&lt;p&gt;@Test
&lt;br  /&gt;public void numbers_should_not_duplicate_within_five_generates() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; l = new ArrayList&amp;lt;String&amp;gt;();
for (int i = 0; i &amp;lt; 5; i++) {
    l.add(randomNumberGenerator.generate());
}
for (int i = 0; i &amp;lt; l.size(); i++) {
    for (int j = 0; j &amp;lt; l.size() &amp;amp;&amp;amp; i != j; j++) {
        assertThat(l.get(i)).isNotEqualTo(l.get(j));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;记得昨天说这个情况可以不用测，需要向BA确认。如果要测的话，我们还需要在代码中确保连续五次生成的随机数一定不相同。&lt;/p&gt;
&lt;p&gt;另外发现，&lt;code&gt;GuessGame&lt;/code&gt;这个类的功能好像还没有完成。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (8) – 在项目中使用及总结（完结）</title>
                <link>http://freewind.in/posts/2422-write-template-engine-yourself-8-use-it-in-project-end</link>
                <pubDate>Sat, 22 Mar 2014 11:12:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2422</guid>
                <description><![CDATA[&lt;p&gt;模板引擎用了，我们如何在项目中使用呢？&lt;/p&gt;
&lt;h2&gt;如何在项目中调用&lt;/h2&gt;
&lt;p&gt;由于SharkDart是编译型的，将会把模板文件生成一个个dart文件，所以对于我们的程序来说，我们只需要知道这些dart文件的存在，并调用它们的&lt;code&gt;render&lt;/code&gt;方法就行了，可以完全忽略模板文件的存在。&lt;/p&gt;
&lt;p&gt;比如说，现在在一个web框架里，&lt;code&gt;index.shark&lt;/code&gt;被编译成了&lt;code&gt;index.dart&lt;/code&gt;，那么我们在controller或者action里，只需要调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &quot;./path/of/index.dart&quot; as view_index;

get(&apos;/index&apos;, (request, response) {
  var content = view_index.render(user:&apos;Shark&apos;);
  response.write(content);
})


相应的`index.shark`跟我们没有任何关系了。

## 自动编译修改过的模板

Shark模板修改后，并不会自动被编译为dart文件，需要我们手动调用一下相关的编译函数。虽然我们可以在SharkDart中加入监视模板目录并自动编译的功能，但是我没做，所以只能先用第三方的方案了，比如[node-supervisor](https://github.com/isaacs/node-supervisor)

node-supervisor可以监视某一个目录的变化，并自动调用另一个脚本。

supervisor -w lib -i lib/packages,lib/gen -n exit -e shark,html -x ./shark0 dummy-but-required-argu


这行命令是说，让supervisor监视`lib`目录中`shark`和`html`类型的文件，但忽略掉`lib/packages`与`lib/gen`目录，并且在发生错误时不退出。每当发现文件变化时，便调用`./shark0`脚本。最后一个`dummy-but-required-argu`只是个占位符，用不上但必须提供，不过你也可以根据自己需求传一个有意义的参数。（不知道最新版的有没有什么变化，我这里引用的是一年前的旧代码）

然后我们可以在`shark0`中加上自己的命令，如调用SharkDart的编译器等：

dart --package-root=packages/ bin/shark_compiler.dart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后在&lt;code&gt;shark_compiler&lt;/code&gt;里，写一个可执行的&lt;code&gt;main()&lt;/code&gt;，调用SharkDart提供的&lt;code&gt;compileTemplateDir&lt;/code&gt;函数编译指定的模板根目录。&lt;/p&gt;
&lt;p&gt;上面所说的是笨办法，如果每个项目都这么做太麻烦了。在dart中也有一些构建工具，如&lt;a href=&quot;https://github.com/dart-lang/hop&quot;&gt;hop&lt;/a&gt;，可以让我们自定义一些构建任务，我们可以考虑使用它写一些可复用的任何来做这件事。（我还没有用它实践过，不确定能否满足需求）&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;到此整个“自动动手写模板引擎”系列就结束了。&lt;/p&gt;
&lt;p&gt;这个模板引擎比较简单，技术含量不高，但是可以从中了解到一些基本的思路。有一些套路是固定的，但我们可以选择更合适的工具来实现，比较解析库的选择。&lt;/p&gt;
&lt;p&gt;虽然这里实现的是一个简单的模板引擎，但是如何扩展一下，可以用同样的思路去实现一些DSL，甚至一门语言，只是难度会更大。在现在相关工具越来越成熟的情况下，实现对一套语法的解析越来越容易，但是这只是一个开始，还有很多地方需要完善：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何在程序中实现模板修改后，刷新可用？&lt;/li&gt;
&lt;li&gt;当模板中的语法有错误时，如何准确的定位错误位置和类型，并展示给用户？&lt;/li&gt;
&lt;li&gt;如何将模板中某个元素的位置与生成后的dart文件中的位置对应起来？&lt;/li&gt;
&lt;li&gt;如何在模板中添加更强大的功能？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;留待以后考虑。&lt;/p&gt;
&lt;p&gt;（终于以每天一篇的速度，没有辜负大大的嘱托~）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (7) – 自定义标签</title>
                <link>http://freewind.in/posts/2418-write-template-engine-yourself-7-custom-tags</link>
                <pubDate>Sat, 22 Mar 2014 02:16:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2418</guid>
                <description><![CDATA[&lt;p&gt;在前面我们定义了一些常用标签，本篇将会看看如何实现它们。&lt;/p&gt;
&lt;h2&gt;常用标签&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;li&gt;else&lt;/li&gt;
&lt;li&gt;elseif&lt;/li&gt;
&lt;li&gt;for&lt;/li&gt;
&lt;li&gt;dart&lt;/li&gt;
&lt;li&gt;plainText&lt;/li&gt;
&lt;li&gt;params&lt;/li&gt;
&lt;li&gt;extends&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;renderBody&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基础类&lt;/h2&gt;
&lt;p&gt;为了能够让用户自定义标签处理器，并让它可以被SharkDart的编译器识别，我们需要定义一些基础类和约定。&lt;/p&gt;
&lt;p&gt;首先我们会有一个全局的标签处理器仓库，可以让我们把自定义的处理器注册上去，同时也可以让编译器来查询。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var tagRepository = new TagRepository();

class TagRepository {
  var store = new Map&amp;lt;String, TagHandler&amp;gt;();
  TagHandler find(String tagName) =&amp;gt; store[tagName];
  void register(String tagName, TagHandler handler) =&amp;gt; store[tagName] = handler;
}


然后是处理器的基类和返回结果类：

abstract class TagHandler {
  TagHandleResult handle(SharkTag tag, List nodesAfterTag);
}

class TagHandleResult {
  List&amp;lt;CompilableElement&amp;gt; elements;
  List tail;

  TagHandleResult(this.elements, this.tail);
}


我们自定义的处理器需要继承自`TagHandler`，并实现其`handle(...)`方法。

另外，在模板中经常需要生成一些不重复的变量名，所以我们再提供一个全局的id生成函数：

int idForTags = 0;
nextId() =&amp;gt; idForTags++;


由于Dart代码只能在单线程中运行，所以不用担心拿到重复的值。

最后需要提供一个函数，把SharkDart内置的处理器注册上去：

registerBuiltInTags() {
  tagRepository
    ..register(&apos;xxx&apos;, new XxxTagHandler())
    ..register(&apos;yyy&apos;, new YxxTagHandler())
}
var builtInTags = registerBuiltInTags();


后面一句定义的`builtInTags`变量实际上没有用，只是dart语法不允许在library的全局域里直接调用一个函数，真正起作用的是后面的`registerBuiltInTags()`

有了这些基础设施，我们就可以来实现自己的标签了。

## if

`if`的实现比较简单，基本上就是在代码中写上dart的`if`语句即可：

class IfTagHandler extends TagHandler {
  TagHandleResult handle(SharkTag tag, List nodesAfterTag) {
    var condition = tag.tagParams.first.paramVariable;
    return new TagHandleResult([
      stmt(&apos;if ($condition) {&apos;),
      tag.body.toCompilable(),
      stmt(&apos;}&apos;)
    ], nodesAfterTag);
  }
}


注意`if(...){`和`}`都是`stmt`，表示它们将会以代码形式原样输出在最终代码里。另外它把`nodesAfterTag`原封不动的传了回去，因为它不需要处理后续结点。

## else

`else`的实现也很简单，连参数都不需要：

class ElseTagHandler extends TagHandler {
  TagHandleResult handle(SharkTag tag, List nodesAfterTag) {
    return new TagHandleResult([
      stmt(&apos;else {&apos;),
      tag.body.toCompilable(),
      stmt(&apos;}&apos;)
    ], nodesAfterTag);
  }
}


跟`if`一样，不需要多讲。

## elseif

`elseif`跟前面差不多，只是它要输出为`else if`:

class ElseIfTagHandler extends TagHandler {
  TagHandleResult handle(SharkTag tag, List nodesAfterTag) {
    var condition = tag.tagParams.first.paramVariable;
    return new TagHandleResult([
      stmt(&apos;else if ($condition) {&apos;),
      tag.body.toCompilable(),
      stmt(&apos;}&apos;)
    ], nodesAfterTag);
  }
}


### 模板实例

将前面三个标签结合起来，写一个SharkDart的模板：

if_elseif_else1.shark

@params(int num)

Hello,
@if(num == 1) {
  air!
} @elseif(num == 2) {
  sky!
} @else {
  world!
}


### 生成dart代码

将会编译成以下代码：

library shark.views.tags.if_elseif_else1;

String render({int num, String implicitBody_()}) {
  if (implicitBody_ == null) {
    implicitBody_ = () =&amp;gt; &apos;&apos;;
  }
  var _sb_ = new StringBuffer();
  _sb_.writeln(&apos;Hello,&apos;);
  _sb_.write(&apos;&apos;);
  if (num == 1) {
    _sb_.writeln(&apos;&apos;);
    _sb_.writeln(&apos;  air!&apos;);
    _sb_.write(&apos;&apos;);
  }
  else if (num == 2) {
    _sb_.writeln(&apos;&apos;);
    _sb_.writeln(&apos;  sky!&apos;);
    _sb_.write(&apos;&apos;);
  }
  else {
    _sb_.writeln(&apos;&apos;);
    _sb_.writeln(&apos;  world!&apos;);
    _sb_.write(&apos;&apos;);
  }
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;&apos;);
  return _sb_.toString();
}


## for

`for`标签要编译为dart中的`for(var item in list)`，但为了能让用户使用更方便，它额外提供了一些变量供使用，如`index`, `isFirst`等。同时还可以给定一个分隔符，自动放在两个元素之间，在生成json类似的数据时很有用。

它的定义如下：

class ForTagHandler extends TagHandler {
  TagHandleResult handle(SharkTag tag, List nodesAfterTag) {
    var separator = tag.getParamAsString(&apos;separator&apos;, &apos;&apos;);

    var main = tag.tagParams.first;
    var type = (main.paramType == null ? &apos;var&apos; : main.paramType);
    var variable = main.paramVariable;
    var collections = (main.paramDescription as SharkExpression).expression;
    var indexVar = &apos;index_${nextId()}&apos;;
    var countVar = &apos;total_${nextId()}&apos;;
    return new TagHandleResult([
      stmt(&apos;if ($collections != null) {&apos;),
      stmt(&apos;  int ${indexVar} = 0;&apos;),
      stmt(&apos;  int ${countVar} = ${collections}.length;&apos;),
      stmt(&apos;  for (var $variable in $collections) {&apos;),
      stmt(&apos;    int ${variable}_index = ${indexVar};&apos;),
      stmt(&apos;    bool ${variable}_isFirst = ${indexVar} == 0;&apos;),
      stmt(&apos;    bool ${variable}_isLast = ${indexVar} == ${countVar} - 1;&apos;),
      stmt(&apos;    bool ${variable}_isOdd = ${indexVar} % 2 == 1;&apos;),
      stmt(&apos;    bool ${variable}_isEven = ${indexVar} % 2 == 0;&apos;),
      stmt(&apos;    if(!${variable}_isFirst) {&apos;),
      text(separator),
      stmt(&apos;    }&apos;),
      stmt(&apos;    ${indexVar}++;&apos;),
      tag.body.toCompilable(),
      stmt(&apos;  }&apos;),
      stmt(&apos;}&apos;)
    ], nodesAfterTag

    );
  }
}


有这几点需要注意：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用了很多&lt;code&gt;stmt&lt;/code&gt;来插入多行dart代码，以实现前面所说的额外变量的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;nextId()&lt;/code&gt;是一个全局函数，每次调用都会生成一个增1的数字，以保证变量名不相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增加了&lt;code&gt;if(collection!=null)&lt;/code&gt;的判断，是为了让&lt;code&gt;for&lt;/code&gt;后面可加上&lt;code&gt;else&lt;/code&gt;标签&lt;/p&gt;
&lt;h3&gt;模板实例&lt;/h3&gt;
&lt;p&gt;for3.shark&lt;/p&gt;
&lt;p&gt;@params(List&lt;String&gt; users)&lt;/p&gt;
&lt;p&gt;@for(user: users, separator: &apos;***&apos;) {&lt;/p&gt;
&lt;h1&gt;index: @user_index&lt;/h1&gt;
&lt;h1&gt;isFirst: @user_isFirst&lt;/h1&gt;
&lt;h1&gt;isLast: @user_isLast&lt;/h1&gt;
&lt;h1&gt;isOdd: @user_isOdd&lt;/h1&gt;
&lt;h1&gt;isEven: @user_isEven&lt;/h1&gt;
&lt;p&gt;Hello, @user&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;} @else {
&lt;br  /&gt;There is no user found
&lt;br  /&gt;}&lt;/p&gt;
&lt;h3&gt;生成dart代码&lt;/h3&gt;
&lt;p&gt;library shark.views.tags.for3;&lt;/p&gt;
&lt;p&gt;String render({List&lt;String&gt; users, String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();
&lt;br  /&gt;if (users != null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int index_2 = 0;
int total_3 = users.length;
for (var user in users) {
  int user_index = index_2;
  bool user_isFirst = index_2 == 0;
  bool user_isLast = index_2 == total_3 - 1;
  bool user_isOdd = index_2 % 2 == 1;
  bool user_isEven = index_2 % 2 == 0;
  if (!user_isFirst) {
    _sb_.write(&apos;***&apos;);
  }
  index_2++;
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;  # index: &apos;);
  _sb_.write(user_index);
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;  # isFirst: &apos;);
  _sb_.write(user_isFirst);
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;  # isLast: &apos;);
  _sb_.write(user_isLast);
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;  # isOdd: &apos;);
  _sb_.write(user_isOdd);
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;  # isEven: &apos;);
  _sb_.write(user_isEven);
  _sb_.writeln(&apos;&apos;);
  _sb_.write(&apos;  Hello, &apos;);
  _sb_.write(user);
  _sb_.writeln(&apos;&apos;);
  _sb_.writeln(&apos;  ------------&apos;);
  _sb_.write(&apos;&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;else {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_sb_.writeln(&apos;&apos;);
_sb_.writeln(&apos;  There is no user found&apos;);
_sb_.write(&apos;&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;return &lt;em&gt;sb&lt;/em&gt;.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;h2&gt;dart&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dart&lt;/code&gt;标签可以让我们在模板中嵌入一段dart代码，它的实现也比较简单：&lt;/p&gt;
&lt;p&gt;class DartTagHandler extends TagHandler {
&lt;br  /&gt;TagHandleResult handle(SharkTag tag, List nodesAfterTag) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var content = &apos;&apos;;
if (!tag.body.isEmpty) {
  var trim = tag.getParamAsBool(&apos;trim&apos;);
  if (trim) {
    tag.body.trim();
  }
  content = tag.body.elements.elements.first.toString();
}
return new TagHandleResult([
  stmt(content),
], nodesAfterTag);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;注意它可以接受一个&lt;code&gt;trim&lt;/code&gt;参数，用于把代码段前后的空白去掉。&lt;/p&gt;
&lt;h3&gt;模板实例&lt;/h3&gt;
&lt;p&gt;dart1.shark&lt;/p&gt;
&lt;p&gt;@!dart {{{
&lt;br  /&gt;hello(who) =&gt; &apos;Hello, $who!&apos;;
&lt;br  /&gt;}}}&lt;/p&gt;
&lt;div&gt;@{hello(&apos;SharkDart&apos;)}&lt;/div&gt;
&lt;h3&gt;生成dart代码&lt;/h3&gt;
&lt;p&gt;library shark.views.tags.dart1;&lt;/p&gt;
&lt;p&gt;String render({String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();&lt;/p&gt;
&lt;p&gt;hello(who) =&gt; &apos;Hello, $who!&apos;;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&lt;div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(hello(&apos;SharkDart&apos;));
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&lt;/div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;return &lt;em&gt;sb&lt;/em&gt;.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;h2&gt;plainText&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;plainText&lt;/code&gt;跟&lt;code&gt;dart&lt;/code&gt;标签很相似，不同的是它会把内容当作文本输出。&lt;/p&gt;
&lt;p&gt;class PlainTextTagHandler extends TagHandler {
&lt;br  /&gt;TagHandleResult handle(SharkTag tag, List nodesAfterTag) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var content = &apos;&apos;;
if (tag.body != null) {
  var trim = tag.getParamAsBool(&apos;trim&apos;, false);
  if (trim) {
    tag.body.trim();
  }
  content = tag.body.elements.elements.first.toString();
}
return new TagHandleResult([
  text(content)
], nodesAfterTag);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;它也同样可以接受一个&lt;code&gt;trim&lt;/code&gt;参数，用于去除文本两端的空白。&lt;/p&gt;
&lt;h3&gt;模板实例&lt;/h3&gt;
&lt;div&gt;
@!plainText {{{

  @hello() {}

}}}
&lt;/div&gt;
&lt;h3&gt;生成dart代码&lt;/h3&gt;
&lt;p&gt;library shark.views.tags.plainText1;&lt;/p&gt;
&lt;p&gt;String render({String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&lt;div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;  @hello() {}&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&lt;/div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;return &lt;em&gt;sb&lt;/em&gt;.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;h2&gt;params&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;params&lt;/code&gt;可以用来给生成的&lt;code&gt;render()&lt;/code&gt;入口函数指定参数。&lt;/p&gt;
&lt;p&gt;class ParamsTagHandler extends TagHandler {
&lt;br  /&gt;TagHandleResult handle(SharkTag tag, List nodesAfterTag) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var params = &quot;&quot;;
if (tag.tagParams.isNotEmpty) {
  params = tag.tagParams.map((param) =&amp;gt; param.toString()).join(&apos;, &apos;);
}
if (tag.hasNoBody) {
  return new TagHandleResult([
    functionParams(params),
    new SharkNodeList(nodesAfterTag).toCompilable(),
  ], []);
} else {
  return new TagHandleResult([
    functionParams(params),
    tag.body.toCompilable(),
  ], nodesAfterTag);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;需要注意的是，如果&lt;code&gt;params&lt;/code&gt;标签没有提供花括号括起来的主体，它会把后续结点当作主体，所以在处理时需要判断一下。&lt;/p&gt;
&lt;h3&gt;模板实例&lt;/h3&gt;
&lt;p&gt;params1.shark&lt;/p&gt;
&lt;p&gt;@params(String user) {&lt;/p&gt;
  &lt;div&gt;hello, @user!&lt;/div&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3&gt;生成dart代码&lt;/h3&gt;
&lt;p&gt;library shark.views.tags.params1;&lt;/p&gt;
&lt;p&gt;String render({String user, String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;  &lt;div&gt;hello, &apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(user);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;!&lt;/div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;return &lt;em&gt;sb&lt;/em&gt;.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;h2&gt;extends&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;的实现比较复杂，因为它需要把当前模板的内容以某种方式传递给另一个模板，再把最终的结果渲染出来。有这几个地方需要注意：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;和&lt;code&gt;render&lt;/code&gt;标签共用了同一个处理器，不同的是，当没有提供标签主体时，&lt;code&gt;extends&lt;/code&gt;会把后续结点当主体，而&lt;code&gt;render&lt;/code&gt;不会。当然这个默认行为也可以在标签参数中改变：传入&lt;code&gt;enableImplicitBody:true/false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当继承另一个模板时，如果模板路径以&lt;code&gt;.&lt;/code&gt;开头，如&lt;code&gt;extends(./another)&lt;/code&gt;，则会直接导入，否则会当作相对于模板根目录的相对路径。对于后者，我们需要先算出它的绝对路径，再计算出与当前模板的相对路径，然后导入它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继承另一个模板，实际上会调用另一个模板生成的&lt;code&gt;render()&lt;/code&gt;函数，然后把自己的内容以&lt;code&gt;another.render(implicitBody: ()=&amp;gt; { current content }&lt;/code&gt;的方式得到结果。&lt;/p&gt;
&lt;p&gt;下面的代码有些长，但应该可以快速理解它的意思。&lt;/p&gt;
&lt;p&gt;class RenderTagHandler extends TagHandler {
&lt;br  /&gt;bool enableImplicitBodyByDefault;&lt;/p&gt;
&lt;p&gt;RenderTagHandler(this.enableImplicitBodyByDefault);&lt;/p&gt;
&lt;p&gt;TagHandleResult handle(SharkTag tag, List nodesAfterTag) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return new _RenderTagInternalHandler(tag, nodesAfterTag, this.enableImplicitBodyByDefault).handle();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;class &lt;em&gt;RenderTagInternalHandler {
&lt;br  /&gt;final targetTemplateVar = &apos;&lt;/em&gt;shark_render_${nextId()}&apos;;
&lt;br  /&gt;bool enableImplicitBody;
&lt;br  /&gt;List&lt;_ParamForRenderTag&gt; renderParams;
&lt;br  /&gt;SharkTag tag;
&lt;br  /&gt;List nodesAfterTag;&lt;/p&gt;
&lt;p&gt;_RenderTagInternalHandler(this.tag, this.nodesAfterTag, enableImplicitBodyByDefault) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.enableImplicitBody = this.tag.getParamAsBool(&apos;enableImplicitBody&apos;, enableImplicitBodyByDefault);
this.renderParams = _compileRenderParams();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;TagHandleResult handle() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var compilableItems = [ buildImportPathStmt() ];
for (var p in renderParams) {
  compilableItems.addAll(_preCalculateParamValue(p));
}
compilableItems.addAll(_renderTargetTemplate());

if (tag.hasNoBody &amp;amp;&amp;amp; enableImplicitBody) {
  return new TagHandleResult(compilableItems, []);
} else {
  return new TagHandleResult(compilableItems, nodesAfterTag);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;_ImportPath buildImportPathStmt() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var targetTemplateName = tag.tagParams.first.paramVariable;
if (targetTemplateName.startsWith(&apos;.&apos;)) {
  return importStmt(&apos;import \&apos;${targetTemplateName}.dart\&apos; as $targetTemplateVar;&apos;);
} else {
  return importStmtFromTemplate((CompilableTemplate template) {
    var templateParentPath = new File(path.join(template.templateRootDir.path, template.relativePath)).parent.path;
    var targetTemplateFilePath = path.join(template.templateRootDir.path, targetTemplateName);
    var relative = path.relative(targetTemplateFilePath, from:templateParentPath);
    return &apos;import \&apos;${relative}.dart\&apos; as $targetTemplateVar;&apos;;
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;List&lt;_ParamForRenderTag&gt; _compileRenderParams() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return tag.tagParams.sublist(1).map((param) =&amp;gt; new _ParamForRenderTag(
  param.paramVariable,
  &apos;${param.paramVariable}_${nextId()}&apos;,
  param.paramDescription.toCompilable()
)).toList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;List&lt;CompilableElement&gt; &lt;em&gt;preCalculateParamValue(&lt;/em&gt;ParamForRenderTag p) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [
  stmt(&apos;var ${p.paramGeneratedVariable} = () {&apos;),
  stmt(&apos;  var _sb_ = new StringBuffer();&apos;),
  p.paramValue,
  stmt(&apos;  return _sb_.toString();&apos;),
  stmt(&apos;}();&apos;)
];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;List&lt;CompilableElement&gt; _renderTargetTemplate() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var items = [];
var paramStr = renderParams.map((p) =&amp;gt; &quot;${p.paramName}: ${p.paramGeneratedVariable}&quot;).join(&apos;, &apos;);
items.add(stmt(&apos;_sb_.write(${targetTemplateVar}.render($paramStr, implicitBody_ : () {&apos;));
items.add(stmt(&apos;  var _sb_ = new StringBuffer();&apos;));
if (tag.hasNoBody &amp;amp;&amp;amp; enableImplicitBody) {
  items.add(new SharkNodeList(nodesAfterTag).toCompilable());
} else if (tag.body != null) {
  items.add(tag.body.toCompilable());
}
items.add(stmt(&apos;  return _sb_.toString();&apos;));
items.add(stmt(&apos;}));&apos;));
return items;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;class _ParamForRenderTag {
&lt;br  /&gt;String paramName;
&lt;br  /&gt;String paramGeneratedVariable;
&lt;br  /&gt;CompilableElement paramValue;&lt;/p&gt;
&lt;p&gt;_ParamForRenderTag(this.paramName, this.paramGeneratedVariable, this.paramValue);&lt;/p&gt;
&lt;p&gt;toString() =&gt; &apos;$paramName : $paramGeneratedVariable : $paramValue&apos;;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;class _ImportPath {
&lt;br  /&gt;String targetFilePath;
&lt;br  /&gt;String asName;
&lt;br  /&gt;}&lt;/p&gt;
&lt;h3&gt;模板实例&lt;/h3&gt;
&lt;p&gt;layout1.shark&lt;/p&gt;
&lt;p&gt;@params(String user)&lt;/p&gt;
&lt;div&gt;Hello, @user!&lt;/div&gt;
&lt;div&gt;@renderBody()&lt;/div&gt;
&lt;p&gt;extends1.shark&lt;/p&gt;
&lt;p&gt;@params(String user)&lt;/p&gt;
&lt;p&gt;@extends(./layout1, user: user)&lt;/p&gt;
&lt;p&gt;This is inner page with @user!&lt;/p&gt;
&lt;h3&gt;生成dart代码&lt;/h3&gt;
&lt;p&gt;将会生成以下dart代码：&lt;/p&gt;
&lt;p&gt;layout1.dart&lt;/p&gt;
&lt;p&gt;library shark.views.tags.layout1;&lt;/p&gt;
&lt;p&gt;String render({String user, String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&lt;div&gt;Hello, &apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(user);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;!&lt;/div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&lt;div&gt;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(implicitBody&lt;em&gt;());
&lt;br  /&gt;&lt;/em&gt;sb&lt;em&gt;.writeln(&apos;&lt;/div&gt;&apos;);
&lt;br  /&gt;&lt;/em&gt;sb&lt;em&gt;.write(&apos;&apos;);
&lt;br  /&gt;return &lt;/em&gt;sb_.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;extends1.dart&lt;/p&gt;
&lt;p&gt;library shark.views.tags.extends1;&lt;/p&gt;
&lt;p&gt;import &apos;./layout1.dart&apos; as _shark_render_0;&lt;/p&gt;
&lt;p&gt;String render({String user, String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();
&lt;br  /&gt;var user_1 = () {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var _sb_ = new StringBuffer();
_sb_.write(user);
return _sb_.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}();
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&lt;em&gt;shark_render_0.render(user: user_1, implicitBody&lt;/em&gt; : () {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var _sb_ = new StringBuffer();
_sb_.write(&apos;This is inner page with &apos;);
_sb_.write(user);
_sb_.writeln(&apos;!&apos;);
_sb_.write(&apos;&apos;);
return _sb_.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}));
&lt;br  /&gt;return &lt;em&gt;sb&lt;/em&gt;.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;h2&gt;render&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;render&lt;/code&gt;标签与上面的&lt;code&gt;extends&lt;/code&gt;标签使用的是同一个标签处理器，因为它们的逻辑实际上非常相似，但通过不同的命名可以更准确的表达出使用者的意愿。&lt;/p&gt;
&lt;p&gt;不同的地方在于，当标签没有提供主体时，&lt;code&gt;extends&lt;/code&gt;默认会使用后续节点当主体，而&lt;code&gt;render&lt;/code&gt;不会。&lt;/p&gt;
&lt;p&gt;通过查看两者注册到&lt;code&gt;tagReposity&lt;/code&gt;的代码就能看出：&lt;/p&gt;
&lt;p&gt;tagRepository.register(&apos;extends&apos;, new RenderTagHandler(true));
&lt;br  /&gt;tagRepository.register(&apos;render&apos;, new RenderTagHandler(false));&lt;/p&gt;
&lt;p&gt;后面的&lt;code&gt;true/false&lt;/code&gt;是指是否&lt;code&gt;enableImplicitBody&lt;/code&gt;的功能。&lt;/p&gt;
&lt;h2&gt;renderBody&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;renderBody&lt;/code&gt;的内容比较简单，它直接输出调用&lt;code&gt;implicitBody_()&lt;/code&gt;的内容。可与&lt;code&gt;extends&lt;/code&gt;和&lt;code&gt;render&lt;/code&gt;标签使用，处理它们通过标签主体传过来的内容。&lt;/p&gt;
&lt;p&gt;class RenderBodyTagHandler extends TagHandler {
&lt;br  /&gt;TagHandleResult handle(SharkTag tag, List nodesAfterTag) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return new TagHandleResult([
  expr(&apos;implicitBody_()&apos;)
], nodesAfterTag);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;h2&gt;注册到标签仓库&lt;/h2&gt;
&lt;p&gt;下面我们把上面定义的各标签处理器注册到全局的标签仓库中：&lt;/p&gt;
&lt;p&gt;var builtInTags = initializeBuiltInTags();
&lt;br  /&gt;initializeBuiltInTags() {
&lt;br  /&gt;tagRepository.register(&apos;params&apos;, new ParamsTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;if&apos;, new IfTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;else&apos;, new ElseTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;elseif&apos;, new ElseIfTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;for&apos;, new ForTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;extends&apos;, new RenderTagHandler(true));
&lt;br  /&gt;tagRepository.register(&apos;render&apos;, new RenderTagHandler(false));
&lt;br  /&gt;tagRepository.register(&apos;renderBody&apos;, new RenderBodyTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;dart&apos;, new DartTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;plainText&apos;, new PlainTextTagHandler());
&lt;br  /&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到这里大家已经明白如何实现自己的标签了吧。再结合前几篇的内容，相信大家对模板引擎应该有一些感性的认识了吧。&lt;/p&gt;
&lt;p&gt;下一篇将介绍如何利用第三方工具实现自动监视模板目录，自动编译修改过的模板文件，以及对SharkDart的一些总结。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (6) – 语法树与compiler</title>
                <link>http://freewind.in/posts/2406-write-template-engine-yourself-6-syntax-tree-and-compiler</link>
                <pubDate>Thu, 20 Mar 2014 23:45:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2406</guid>
                <description><![CDATA[&lt;p&gt;在前面我们已经通过PetitParser可以成功的解析出模板文件中的内容，识别出标签、表达式等等，如果我们想对它们进行进一步处理，比如生成dart代码等，则需要构建出一棵语法树，再针对这棵语法树处理。&lt;/p&gt;
&lt;h2&gt;语法节点类&lt;/h2&gt;
&lt;p&gt;首先我们要定义一堆节点类，与解析出来的语法元素对应，方便后续处理。&lt;/p&gt;
&lt;h3&gt;SharkNode&lt;/h3&gt;
&lt;p&gt;定义一个基类，表示一个节点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class SharkNode {
  String toString();
  CompilableElement toCompilable();
}


其中的`toString()`方便测试及调试，在产品代码中基本上用不到。`toCompilable()`用来把该节点转换成一个可编译的元素。

与前面为了解析而定的规则对应，下边定义了如下几个类。为了方便表述，仅列出成员变量。

### SharkDocument

`SharkDocument`表示整个模板，可看作根。它里面是一个列表，包含各子节点。

class SharkDocument extends SharkNode {
  SharkNodeList children;
}


### SharkTag

`SharkTag`与标签结构对应，同时对应两种标签结构。定义如下：

class SharkTag extends SharkNode {
  String tagName;
  List&amp;lt;TagParam&amp;gt; tagParams;
  SharkBlock body;
}


如果参数是一段代码，而不是普通的参数列表，则下面的`List&amp;lt;tagParam&amp;gt;`仅会有一个元素，且其`paramVariable`的值就是这段代码。

### TagParam

`TagParam`对应标签中的一个参数，它的定义如下：

class TagParam extends SharkNode {
  String paramType;
  String paramVariable;
  SharkNode paramDescription;
}


### SharkBlock

`SharkBlock`对应标签的主体部分，也可以用于`TagParam`的`paramDescription`，定义如下：

class SharkBlock extends SharkNode {
  SharkNodeList elements;
}


它的内容也是一组节点。

### SharkExpression

`SharkExpression`对应于一个表达式，包括简单和复杂的。它的内容比较简单，就是一个字符串，用于保存匹配到的表达式字符串。

class SharkExpression extends SharkNode {
  String expression;
}


### SharkText

`SharkText`用于表达模板中的各种纯文本内容。

class SharkText extends SharkNode {
  String content;
}


### SharkNodeList

这是一个工具类，表示由一组节点组成的列表。之所以把它独立出来，是因为把一个节点列表转换为`CompilableElement`的时候，逻辑比较复杂，而它在多处被引用，所以抽出来。它的实现细节将在本文最后讨论，这里先提一下。

可以看到节点类还是比较少的，这也正是由于我们设计了通用标签结构，否则的话，需要为每一个特点的语法标签准备一个单独的节点类。

## 目标代码模板

在最开始说过，SharkDart模板是编译型的，它会生成相对应的可执行的dart代码供调用。我们应该考虑一下，生成的代码是什么样子才行？

### 基本结构

由于dart中通过`library`关键字来区分模块，并且类的定义不是必须的，所以我打算为每一个模板文件生成一个独立的dart文件，并且有一个独立的包。在里面提供一个`render`方法，返回一个字符串，供调用。

最基本的代码结构应该是这样的：

library shark.views.mytemp;

String render() {
  var _sb_ = new StringBuffer();

  // fill the buffer with template nodes

  return _sb_.toString()
}


### library

首先考虑`library`名称。为了跟别的包不冲突，我决定加上`shark.views`前缀。后面的部分，则是当前模板相对于模板根目录的路径。

比如模板根目录是`app/templates`，而模板文件是`app/templates/abc.shark`，则它产生的`library`声明应该是：

library shark.views.abc;


如果模板文件是`app/templates/tags/menu.shark`，则`library`为：

library shark.views.tags.menu;


### 纯文本和表达式

然后是模板内容，考虑一个简单的模板，有文本和表达式：

Hello, @name!


那么在生成的代码中，将会添加：

_sb_.write(&apos;Hello, &apos;);
_sb_.write(name);
_sb_.write(&apos;!&apos;);


即把纯文本当字符串输出，而变量原样输出。

### 参数

再考虑参数，如果模板里有`@params`标签，用来说明自己可授受哪些参数调用，比如：

@params(String user, List&amp;lt;String&amp;gt; favors)


那么输出代码中的`render()`签名就应该变化：

String render({String user, List&amp;lt;String&amp;gt; favors})


### import

如果模板中有`@extends`或`@render`标签，说明它会引用其它模板，则会生成相应的`import`语句：

import &apos;./layout1.dart&apos; as _shark_render_0;
import &apos;./tags/menu.dart&apos; as _shark_render_1;


这里会为每一个导入的模板生成一个独立的名字供引用。

### 继承及调用

考虑一下模板继承的问题。假如我现在有一个`layout.shark`和一个`index.shark`，定义如下：

layout.shark

&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;@renderBody()&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;


index.shark

@extends(layout)
&amp;lt;div&amp;gt;
  inner content
&amp;lt;/div&amp;gt;


我应该怎么生成代码，才能让`index.shark`能成功的继承`layout.shark`的内容呢？

我想到的最简单的办法就是在`index`中调用`layout`的`render`函数，然后把自己的内容当作参数传过去，比如：

layout.dart

library shark.views.layout;

String render({String body()}) {
  if (implicitBody_ == null) {
     implicitBody_ = () =&amp;gt; &apos;&apos;;
  }
  var _sb_ = new StringBuffer();
  _sb_.write(&apos;&amp;lt;html&amp;gt;&apos;);
  _sb_.write(&apos;&amp;lt;body&amp;gt;&apos;);
  _sb_.write(body());
  _sb_.write(&apos;&amp;lt;/body&amp;gt;&apos;);
  _sb_.write(&apos;&amp;lt;/html&amp;gt;&apos;);
  return _sb_.toString();
}


index.dart

library shark.views.index;
import &apos;./layout.dart&apos; as _shark_render_0;

String render() {
  var _sb_ = new StringBuffer();
  _sb_.write(_shark_render_0.render(body: () {
    var _sb_ = new StringBuffer();
    _sb_.write(&quot;&amp;lt;div&amp;gt;&quot;);
    _sb_.write(&quot;  inner content&quot;);
    _sb_.write(&quot;&amp;lt;/div&amp;gt;&quot;);
    return _sb_.toString();
  });
  return _sb_.toString();
}


这样的话，我就需要为`render()`函数添加一个类似于`body()`这样的函数了。

但是马上就有一个新的问题：`render()`的参数是由用户在`@params`标签中声明的，难道要强迫用户在每个模板中都声明一个`@params(String body())`，哪怕它完全用不到？

为了解决这个问题，我打算直接在`render()`里添加一个`String implicitBody_()`参数，不让用户指定。并且，这个参数仅仅在模板间有调用的时候才会用到。所以名字中有`implicit`这个词。

String render({String implicitBody_()}) {
  if (implicitBody_ == null) {
    implicitBody_ = () =&amp;gt; &apos;&apos;;
  }

  var _sb_ = new StringBuffer();
  // ...
  return _sb_.toString();
  }
}


之所以不是`_implicitBody_`，是因为在dart中，如果函数或参数是public的，则不能以`_`开头。

### 目标文件类

从上面的分析，我们已经可以确定生成的dart代码结构是什么样了。为了能体现这种结构，并在生成过程有让模板的各个部分有机会被修改，所以定义了下面这个类：

class CompilableTemplate {
  Directory templateRootDir;
  final String relativePath;

  String libraryStatement;
  List&amp;lt;String&amp;gt; importStatements = [];
  String params;
  static const defaultBodyParam = &quot;String implicitBody_()&quot;;
  List&amp;lt;_IndentCompilableElement&amp;gt; functionBody = [];

  String generate() {
    // generate library statment
    // generate immport statments
    // generate `render` function with params
    // generate function body
  }
}


前两个是与模板根目录和模板文件路径相关的，放在这里是因为有些代码生成需要使用这两个信息。后面的五个就分别对应了前面考虑的各个点。

而在`generate`函数中，将会从上向下，依次生成各块代码。具体代码这里不列出，因为比较细碎，最好直接看源代码。

## 语法节点类的编译

现在是时候把前面定义的各语法节点类编译成相应的dart代码了。

### SharkDocument

`SharkDocument`比较简单，因为它是个虚拟出来的根，所以直接把任务交给子节点了：

class SharkDocument extends SharkNode {
  SharkNodeList children;
  CompilableElement toCompilable() =&amp;gt; children.toCompilable();
}


### SharkTag

`SharkTag`也比较偷懒，直接把自己变成数组，把任务转交给`SharkNodeList`类了：

class SharkTag extends SharkNode {
  CompilableElement toCompilable() =&amp;gt; new SharkNodeList(this).toCompilable();
}


### TagParam

`TagParam`没有提供对应的`toCompilable()`方法，因为如何编译完全要看具体的标签，没法预先判断。

### SharkBlock

`SharkBlock`将会包含很多子结点，所以也转交了。

class SharkBlock extends SharkNode {
  SharkNodeList elements;
  CompilableElement toCompilable() =&amp;gt; elements.toCompilable();
}


### SharkExpression

`SharkExpression`自己处理了，它把自己持有的字符串变成了一个标记为`expression`的对象，告诉编译器要把这段内容当作一个表达式处理，而不要当成普通文本。

class SharkExpression extends SharkNode {
  String expression;
  CompilableElement toCompilable() =&amp;gt; expr(expression);
}


`expr()`的内容将在后面统一介绍，先不急。

### SharkText

`SharkText`最简单，直接把持有的字符串标记为`text`，当编译器当成文本来处理。

class SharkText extends SharkNode {
  String content;
  CompilableElement toCompilable() =&amp;gt; text(content);
}


## SharkNodeList

前面有好几个类都把自己的编译任务交给这个类了，是因为它需要对标签进行一些特别的处理。特别之处有两个：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一旦发现某节点是标签，则需要寻找一个TagHandler去处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在处理一个标签时，需要把它后面跟着的同级节点一起带上&lt;/p&gt;
&lt;h3&gt;TagHandler&lt;/h3&gt;
&lt;p&gt;由于我们的标签结构是通用结构，不跟某一个具体的标签绑定，所以当编译器看到一个&lt;code&gt;SharkTag&lt;/code&gt;的时候，它不知道怎么做，只能根据标签名去寻找我们给出的TagHandler.&lt;/p&gt;
&lt;p&gt;SharkDart有一个全局对象，名为&lt;code&gt;tagRepository&lt;/code&gt;，它是一个map，将标签名与相应的处理器保存起来。比如SharkDart内置的各处理器，是这样的：&lt;/p&gt;
&lt;p&gt;initializeBuiltInTags() {
&lt;br  /&gt;tagRepository.register(&apos;params&apos;, new ParamsTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;if&apos;, new IfTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;else&apos;, new ElseTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;elseif&apos;, new ElseIfTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;for&apos;, new ForTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;extends&apos;, new RenderTagHandler(true));
&lt;br  /&gt;tagRepository.register(&apos;render&apos;, new RenderTagHandler(false));
&lt;br  /&gt;tagRepository.register(&apos;renderBody&apos;, new RenderBodyTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;dart&apos;, new DartTagHandler());
&lt;br  /&gt;tagRepository.register(&apos;plainText&apos;, new PlainTextTagHandler());
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SharkNodeList&lt;/code&gt;一旦发现自己遇到了一个&lt;code&gt;SharkTag&lt;/code&gt;对象，则会执行以下代码：&lt;/p&gt;
&lt;p&gt;var tagHandler = tagRepository.find(tag.tagName);
&lt;br  /&gt;if (tagHandler == null) {
&lt;br  /&gt;throw &apos;No tag handler found for tag: ${tag.tagName}&apos;;
&lt;br  /&gt;}
&lt;br  /&gt;tagHandler.handle(tag, list);&lt;/p&gt;
&lt;p&gt;可以看出它将会寻找相应的标签处理器，并转交给它们去处理&lt;/p&gt;
&lt;h3&gt;后续结点&lt;/h3&gt;
&lt;p&gt;还记得在之前设计常用标签时，多次提到&lt;code&gt;@params&lt;/code&gt;和&lt;code&gt;@extends&lt;/code&gt;的主体部分可以不用花括号括起来吗？&lt;/p&gt;
&lt;p&gt;@params(String user)&lt;/p&gt;
&lt;div&gt;
  long long content
&lt;/div&gt;
&lt;p&gt;对于这种情况，解析出来的&lt;code&gt;params&lt;/code&gt;标签的主体实际上是空的，但是标签又需要把后面的内容拿过来使用。&lt;/p&gt;
&lt;p&gt;所以我们在处理一个标签时，不但要把标签本身传给处理器，还要把它的后续同级节点一起传过去，让处理器自己决定用还是不用。&lt;/p&gt;
&lt;p&gt;看回前面的这行代码：&lt;/p&gt;
&lt;p&gt;tagHandler.handle(tag, list);&lt;/p&gt;
&lt;p&gt;它里面的&lt;code&gt;list&lt;/code&gt;就是&lt;code&gt;tag&lt;/code&gt;后续的同级节点。&lt;/p&gt;
&lt;p&gt;所谓同级，就是说如果一个标签是嵌入在另一个标签里的，则它的后续节点只会是外层标签内部的，不会超出。比如：&lt;/p&gt;
&lt;p&gt;@if(test1) {
&lt;br  /&gt;@if(test2) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;hello&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
  &lt;div&gt;inner&lt;/div&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;div&gt;out&lt;/div&gt;
&lt;p&gt;对于里面的&lt;code&gt;@if(test2)&lt;/code&gt;来说，它的后续结点只会是&lt;code&gt;&amp;lt;div&amp;gt;inner&amp;lt;/div&amp;gt;&lt;/code&gt;，而没有&lt;code&gt;&amp;lt;div&amp;gt;out&amp;lt;/div&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了实现这个逻辑，所以才把节点列表抽出来处理。在遍历列表的时候，如果发现某一个节点是标签，则把它跟之后的所有元素一起传给标签处理器。标签处理器的返回结果是一个&lt;code&gt;TagHandleResult&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;class TagHandleResult {
&lt;br  /&gt;List&lt;CompilableElement&gt; elements;
&lt;br  /&gt;List tail;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;elements&lt;/code&gt;是处理器成功编译后的元素列表，而tail是用剩下的。如果某个标签处理器需要用后续结点，它就可以使用，然后把剩下的还回来；如果不用，则直接把传入的再还回来即可。&lt;/p&gt;
&lt;p&gt;对于个功能，我开始不打算提供，因为会让思路有些难以理解。但是在用的时候，实在不想把长长的html内容放在花括号里，因为总觉得自己不是在编辑一个html文件。所以最后还是加上了这个功能。&lt;/p&gt;
&lt;h2&gt;不同类型的编译元素&lt;/h2&gt;
&lt;p&gt;前面提到了&lt;code&gt;expr&lt;/code&gt;和&lt;code&gt;text&lt;/code&gt;，这是两种不同类型的编译元素，编译器要做不同的处理。&lt;/p&gt;
&lt;p&gt;实际上我定义了六种类型，如下：&lt;/p&gt;
&lt;p&gt;class CompilableElementType {
&lt;br  /&gt;static final LIBRARY = new CompilableElementType();
&lt;br  /&gt;static final IMPORT = new CompilableElementType();
&lt;br  /&gt;static final FUNCTION_PARAM = new CompilableElementType();
&lt;br  /&gt;static final FUNCTION_BODY_TEXT = new CompilableElementType();
&lt;br  /&gt;static final FUNCTION_BODY_STATEMENT = new CompilableElementType();
&lt;br  /&gt;static final FUNCTION_BODY_EXPRESSION = new CompilableElementType();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;这是由于标签处理器需要有灵活的方式去改变模板的内容。&lt;/p&gt;
&lt;p&gt;比如不同的点，如&lt;code&gt;library&lt;/code&gt;、&lt;code&gt;import&lt;/code&gt;、 &lt;code&gt;param&lt;/code&gt;等位置，编译器会把它们的内容覆盖或添加到&lt;code&gt;CompilableTemplate&lt;/code&gt;相对应的字段里。&lt;/p&gt;
&lt;p&gt;对于不同的类型，如&lt;code&gt;text&lt;/code&gt;、&lt;code&gt;statement&lt;/code&gt;、&lt;code&gt;expression&lt;/code&gt;，编译器会在生成dart代码时，使用不同的输出方式：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;text: &lt;code&gt;buffer.writeln(&quot;_sb_.writeln(&apos;${_escapeQuotes(line)}&apos;);&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;expression: &lt;code&gt;buffer.writeln(&apos;_sb_.write($expression);&apos;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;statement: &lt;code&gt;buffer.writeln(statement)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;buffer&lt;/code&gt;是用来收集输出的dart代码的，而&lt;code&gt;_sb_&lt;/code&gt;是生成的dart里用来收集输出的，在前面应该多次看到。&lt;/p&gt;
&lt;p&gt;看一段生成的dart代码，应该能就明白；&lt;/p&gt;
&lt;p&gt;library shark.views.tags.if1;&lt;/p&gt;
&lt;p&gt;String render({int num, String implicitBody&lt;em&gt;()}) {
&lt;br  /&gt;if (implicitBody&lt;/em&gt; == null) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;implicitBody_ = () =&amp;gt; &apos;&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var &lt;em&gt;sb&lt;/em&gt; = new StringBuffer();
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;Hello, the number is:&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;if (num == 1) {         // statement&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_sb_.writeln(&apos;&apos;);
_sb_.write(num);      // expression
_sb_.write(&apos;&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}                       // statement
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.writeln(&apos;&apos;);
&lt;br  /&gt;&lt;em&gt;sb&lt;/em&gt;.write(&apos;&apos;);
&lt;br  /&gt;return &lt;em&gt;sb&lt;/em&gt;.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;其中的statement和expression都已经标出，其它的则是text.&lt;/p&gt;
&lt;p&gt;为了让调用方便一些，我专门定义了一些简单的函数：&lt;/p&gt;
&lt;p&gt;libraryStmt(String input) =&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new CompilableElement(CompilableElementType.LIBRARY, input);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;importStmt(String input)
&lt;br  /&gt;importStmtFromTemplate(FromTemplate func)
&lt;br  /&gt;functionParams(String input)
&lt;br  /&gt;stmt(String input)
&lt;br  /&gt;expr(String input)
&lt;br  /&gt;text(String input)&lt;/p&gt;
&lt;p&gt;这些函数将会在下一篇“自定义标签处理器”里用得比较多。&lt;/p&gt;
&lt;h2&gt;编译模板文件&lt;/h2&gt;
&lt;p&gt;前面编译的基本流程都差不多了，我们现在看看如何从输入到输出吧。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Compiler&lt;/code&gt;类里，提供了三个方法：&lt;/p&gt;
&lt;h3&gt;编译一段文本&lt;/h3&gt;
&lt;p&gt;可以给出一段文本，直接让编译器把它编译成最终的dart代码，返回给调用者：&lt;/p&gt;
&lt;p&gt;String compileTemplateString(String template)&lt;/p&gt;
&lt;h3&gt;编译单个文件&lt;/h3&gt;
&lt;p&gt;编译单个文件，需要提供模板根目录和模板文件相对于根目录的相对路径，这是因为需要由相对路径来确定&lt;code&gt;library&lt;/code&gt;名：&lt;/p&gt;
&lt;p&gt;Future&lt;String&gt; compileTemplateFile(Directory root, String relativeFilePath)&lt;/p&gt;
&lt;p&gt;它返回的是一个&lt;code&gt;Future&amp;lt;String&amp;gt;&lt;/code&gt;对象，表示这是一个异步对象，我们可以在它的&lt;code&gt;then()&lt;/code&gt;方法中，取得生成的dart代码：&lt;/p&gt;
&lt;p&gt;compileTemplateFile(&amp;ldquo;/myapp/templates&amp;rdquo;, &amp;ldquo;user/index.shark&amp;rdquo;).then((dart) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print(dart);
// or save to a file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;之所以要弄个&lt;code&gt;Future&lt;/code&gt;回来，这是因为dart跟nodejs一样，也是单线程基于事件的模型，IO操作都应该用异步。&lt;/p&gt;
&lt;h3&gt;编译指定目录&lt;/h3&gt;
&lt;p&gt;还可以直接编译整个目录下的所有模板文件，并给出目标目录，让编译器把生成的dart文件写过去。&lt;/p&gt;
&lt;p&gt;Future&lt;List&lt;File&gt;&gt; compileTemplateDir(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Directory templateRoot, 
{Directory targetDir, List&amp;lt;String&amp;gt; templateExtensions: const [&apos;shark&apos;, &apos;html&apos;]})
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在默认情况下，只在模板根目录下寻找后缀名为&apos;shark&apos;或&apos;html&apos;的文件，目标目录默认跟模板根目录一致。&lt;/p&gt;
&lt;p&gt;与编译相关的基本流程就到这里，下一篇将讲解如何自定义标签处理器。&lt;/p&gt;
&lt;p&gt;（大家都累了吧，快结束了）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (5) – 标签结构的解析</title>
                <link>http://freewind.in/posts/2402-write-template-engine-yourself-5-parse-tag-structure</link>
                <pubDate>Thu, 20 Mar 2014 09:18:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2402</guid>
                <description><![CDATA[&lt;p&gt;终于到了最关键的标签结构的解析了。对于标签结构，最难的地方在于主体外面的花括号，因为花括号的个数不限，所以这个匹配是动态的。为了简单起见，我将把主体与前面分开解释。&lt;/p&gt;
&lt;h2&gt;结构一：带参数列表的标签&lt;/h2&gt;
&lt;p&gt;结构形如（不包括主体部分）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@tagname(type1 var1: desc1, type2 var2: desc2, ...)


可以看出每个参数都有三部分组成：类型、变量名、描述信息。提供这三个部分，使得它既可以用作参数的声明，又可以当作调用，总之你在编译过程中可以拿到这三个信息，想怎么用都可以。

### tagname

标签名的定义跟在前一篇中表达式中的变量名是一样的，所以可以直接引用：

def(&apos;tagName&apos;, ref(&apos;variable&apos;));


### type

Dart中的类型支持泛型，所以它的定义如下：

def(&apos;paramType&apos;, pattern(r&apos;a-zA-Z_$&amp;lt;&amp;gt;&apos;).plus().flatten());


### var

变量名就相对宽松一些，因为除了普通的变量名以外，我还希望它可以接受路径等格式，所以它的定义如下：

def(&apos;paramVariable&apos;, pattern(r&apos;0-9a-zA-Z_$./&apos;).plus().flatten());


### description

描述信息更加宽松，它可以接受多种形式的内容，比如数字，字符串，普通变量，甚至一大块可嵌入更多标签的文本。

所以它的定义如下：

def(&apos;paramDescription&apos;, ref(&apos;variableExpression&apos;) 
                      | ref(&apos;numberExpression&apos;) 
                      | ref(&apos;singleString&apos;) 
                      | ref(&apos;doubleString&apos;) 
                      | ref(&apos;normalBlock&apos;));


其中的`singleString`和`doubleString`在前一篇已经已经讲过，这里不重复了。而`numberExpression`的定义如下：

def(&apos;numberExpression&apos;, (digit() | char(&apos;.&apos;)).plus().flatten());


另一个`normalBlock`的规则其实跟标签主体的规则一样，所以这里就直接引用了。具体定义要放在后面讲。

### 组合起来

上面定义了三部分，我们可以把它们当成一个整体来看待，所以新定义一个`tagParam`，把它们组合在一起。

这里有两点需要注意：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;type和description都是可选的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;type与var的解析规则有重复&lt;/p&gt;
&lt;p&gt;这两点导致这个规则要比预想的难。&lt;/p&gt;
&lt;p&gt;最开始我写的规则如下：&lt;/p&gt;
&lt;p&gt;def(&apos;tagParam&apos;, ref(&apos;paramType&apos;).trim().optional()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;          &amp;amp; ref(&apos;paramVariable&apos;).trim()
          &amp;amp; (char(&apos;:&apos;) &amp;amp; ref(&apos;paramDescription&apos;).trim()).optional());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简洁明了，可惜行不通。主要原因是，在PetitParser中，一旦某个parser成功匹配到了内容，则它后面的&lt;code&gt;optional()&lt;/code&gt;就被忽略。&lt;/p&gt;
&lt;p&gt;例如，当参数形如&lt;code&gt;abc&lt;/code&gt;（即没有type和desc）的时候，我期待它将会被&lt;code&gt;paramVariable&lt;/code&gt;匹配，但&lt;code&gt;paramType&lt;/code&gt;也能匹配上，所以它的&lt;code&gt;optional()&lt;/code&gt;尾巴就忽略了，将会报&lt;code&gt;paramVariable&lt;/code&gt;无法匹配成功的错误。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我把代码写得复杂一些：&lt;/p&gt;
&lt;p&gt;def(&apos;tagParam&apos;, (
&lt;br  /&gt;(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(ref(&apos;paramType&apos;).flatten().trim() &amp;amp; ref(&apos;paramVariable&apos;).trim())
| ref(&apos;paramVariable&apos;).trim()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;)
&lt;br  /&gt;&amp;amp; (char(&apos;:&apos;) &amp;amp; ref(&apos;paramDescription&apos;).trim()).optional()
&lt;br  /&gt;));&lt;/p&gt;
&lt;p&gt;这样竟然有时候也会报错，比如：&lt;/p&gt;
&lt;p&gt;@extends(tags/menu, items: items)&lt;/p&gt;
&lt;p&gt;我期待&lt;code&gt;tags/menu&lt;/code&gt;整体被&lt;code&gt;paramVariable&lt;/code&gt;匹配，可惜的是&lt;code&gt;paramType&lt;/code&gt;会把&lt;code&gt;tags&lt;/code&gt;匹配走，只留下了&lt;code&gt;/menu&lt;/code&gt;给&lt;code&gt;paramVariable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我再改成：&lt;/p&gt;
&lt;p&gt;def(&apos;tagParam&apos;, (
&lt;br  /&gt;(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(ref(&apos;paramType&apos;).seq(whitespace().and()).flatten().trim() &amp;amp; ref(&apos;paramVariable&apos;).trim() )
| (epsilon() &amp;amp; ref(&apos;paramVariable&apos;).trim())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;)
&lt;br  /&gt;&amp;amp; (char(&apos;:&apos;) &amp;amp; ref(&apos;paramDescription&apos;).trim()).optional()
&lt;br  /&gt;));&lt;/p&gt;
&lt;p&gt;主要是增加了&lt;code&gt;.seq(whitespace().and())&lt;/code&gt;，它的作用是，判断后面跟着的是不是一个空格，这样才成功解决这个问题。&lt;code&gt;and()&lt;/code&gt;的作用是判断parser是否可匹配，但不消耗内容，常用来它检查一个parser的边界。&lt;/p&gt;
&lt;p&gt;另外还添加了一个&lt;code&gt;epsilon()&lt;/code&gt;的函数，它其实就是alwaysMatch的意思，不知道为什么起了这样一个奇怪的名字。加上它是为了让两行匹配结果的个数能匹配上，都是两个元素的数组，后面好处理。&lt;/p&gt;
&lt;h3&gt;参数列表&lt;/h3&gt;
&lt;p&gt;上面已经定义了单个参数的格式&lt;code&gt;paramType&lt;/code&gt;，如果是多个以逗号分隔的参数列表，则应该定义成下面这种形式：&lt;/p&gt;
&lt;p&gt;def(&apos;multiParamArray&apos;, (
&lt;br  /&gt;char(&apos;(&apos;)
&lt;br  /&gt;&amp;amp; ref(&apos;tagParam&apos;).separatedBy(char(&apos;,&apos;), includeSeparators:false).optional([])
&lt;br  /&gt;&amp;amp; char(&apos;)&apos;)
&lt;br  /&gt;).pick(1));&lt;/p&gt;
&lt;p&gt;其中的&lt;code&gt;separatedBy&lt;/code&gt;正是为这种情况定义的，我们提供一个相应的分隔符（在这里是&lt;code&gt;char(&apos;,&apos;)&lt;/code&gt;），就可以了。如果想在最后匹配的内容中丢掉匹配到的分隔符，则可传入参数&lt;code&gt;includeSeparators:false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，参数列表也可以空，即&lt;code&gt;()&lt;/code&gt;也是可以的，所以我们要在最后加上&lt;code&gt;optional()&lt;/code&gt;及参数&lt;code&gt;[]&lt;/code&gt;，它的意思是，当中间部分完全没有匹配到时，返回&lt;code&gt;[]&lt;/code&gt;，以方便后面的处理。&lt;/p&gt;
&lt;p&gt;最后的&lt;code&gt;pick(1)&lt;/code&gt;是说我们只需要&lt;code&gt;()&lt;/code&gt;之间的内容即可。&lt;/p&gt;
&lt;h2&gt;结构二：代码当参数&lt;/h2&gt;
&lt;p&gt;如果参数不满足第一种结构，我们将会把它当作一块代码看待。需要注意的是，如果代码中含有&lt;code&gt;)&lt;/code&gt;，可能会让我们的匹配提前结束，比如：&lt;/p&gt;
&lt;p&gt;@if(name.toLowerCase()==&apos;shark&apos;)&lt;/p&gt;
&lt;p&gt;所以我们不能单线的匹配&lt;code&gt;()&lt;/code&gt;。这里跟前一篇中的复杂表达式匹配非常相似，所以代码也很相似：&lt;/p&gt;
&lt;p&gt;def(&apos;codeParam&apos;, (
&lt;br  /&gt;char(&apos;(&apos;) &amp;amp; (&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ref(&apos;codeParam&apos;)
| ref(&apos;singleString&apos;)
| ref(&apos;doubleString&apos;)
| char(&apos;)&apos;).neg()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;).star().flatten() &amp;amp; char(&apos;)&apos;)
&lt;br  /&gt;).pick(1));&lt;/p&gt;
&lt;h2&gt;标签主体{}&lt;/h2&gt;
&lt;p&gt;标签主体两边的花括号的个数是不限定的，只要能对应即可。这个规定是为了方便包含大量纯文本或代码时，能否有唯一的边界。比如你在文本中最多有5个连续的&lt;code&gt;}&lt;/code&gt;，那我直接把主体花括号写成6个就行了。&lt;/p&gt;
&lt;p&gt;这也给我们的解析带来一个难题：匹配规则是动态的。我只有知道起始花括号的个数后，才能确定结束花括号应该有几个。&lt;/p&gt;
&lt;p&gt;如果我们利用PetitParser提供的parser也能做，但会非常麻烦，因为要动态修改结束花括号的定义，并且要支持嵌套，必须有类似堆栈这样的结构去处理嵌套时结束花括号的变化，并且小心处理任一parser匹配或没匹配时会结束花括号的影响，非常复杂且不健壮。&lt;/p&gt;
&lt;p&gt;所以我们将要自定义一个parser来处理，逻辑其实也比较简单：&lt;/p&gt;
&lt;p&gt;我们首先用&lt;code&gt;char(&apos;{&apos;).plus()&lt;/code&gt;去匹配起始花括号，成功后将得到相应的字符串，并计算出结束花括号是什么样的。然后继续向下匹配，直到匹配到相应的结束花括号为止。&lt;/p&gt;
&lt;p&gt;final blockStartDelimiter = char(&apos;{&apos;).plus().flatten();&lt;/p&gt;
&lt;p&gt;final blockEndDelimiterBound = char(&apos;}&apos;).not();&lt;/p&gt;
&lt;p&gt;class BlockParser extends Parser {&lt;/p&gt;
&lt;p&gt;final Parser contentParser;&lt;/p&gt;
&lt;p&gt;BlockParser(this.contentParser);&lt;/p&gt;
&lt;p&gt;@override
&lt;br  /&gt;Result parseOn(Context context) {
&lt;br  /&gt;var result = blockStartDelimiter.parseOn(context);
&lt;br  /&gt;if (result.isFailure) return result;&lt;/p&gt;
&lt;p&gt;var endParser = _createEndParser(result.value);
&lt;br  /&gt;var body = new CompressList();
&lt;br  /&gt;while (true) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final entry = result;

result = endParser.parseOn(entry);
if (result.isSuccess) {
  var elements = convertStringToTextNode(body.compress());
  return result.success(new SharkBlock(elements));
}

result = contentParser.parseOn(entry);
if (result.isSuccess) {
  body.add(result.value);
  continue;
}

return result.success(new SharkBlock(result.value));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;Parser &lt;em&gt;createEndParser(String start) {
&lt;br  /&gt;return string(&lt;/em&gt;toEndString(start)).seq(char(&apos;}&apos;).not());
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;String _toEndString(String capturedStart) {
&lt;br  /&gt;var sb = new StringBuffer();
&lt;br  /&gt;for (var i = 0;i &amp;lt; capturedStart.length;i++) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sb.write(&apos;}&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;return sb.toString();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;其中的&lt;code&gt;CompressList&lt;/code&gt;类的作用，是把接收到的连续字符拼成一个字符串。&lt;/p&gt;
&lt;h3&gt;普通和纯文本主体块&lt;/h3&gt;
&lt;p&gt;需要注意的是，主体块有两种：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;普通主体块：里面可嵌入其它标签、表达式等，标签由&lt;code&gt;@&lt;/code&gt;开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;纯文本主体块：里面所有内容不做解析，保持原样，标签由&lt;code&gt;@!&lt;/code&gt;开头&lt;/p&gt;
&lt;p&gt;其实两者的逻辑还是比较相似的，不同点在于对于花括号间的内容，前者使用的解析器要多一些，后者仅仅是&lt;code&gt;any()&lt;/code&gt;就行了。&lt;/p&gt;
&lt;p&gt;在我的代码里，分别给它们定义为：&lt;/p&gt;
&lt;p&gt;def(&apos;normalBlock&apos;, new BlockParser(
&lt;br  /&gt;ref(&apos;atAt&apos;) | ref(&apos;sharkTag&apos;) | ref(&apos;sharkPlainTextTag&apos;) | ref(&apos;sharkExpression&apos;) | any())
&lt;br  /&gt;);
&lt;br  /&gt;def(&apos;plainTextBlock&apos;, new BlockParser(any()));&lt;/p&gt;
&lt;p&gt;可以看到前者要传入更多的parser.&lt;/p&gt;
&lt;h2&gt;整个标签&lt;/h2&gt;
&lt;p&gt;为了让代码方便处理，我定义了两个规则，分别对应普通标签和纯文本标签：&lt;/p&gt;
&lt;p&gt;def(&apos;sharkTag&apos;, &lt;em&gt;block(char(&apos;@&apos;), ref(&apos;normalBlock&apos;)));
&lt;br  /&gt;def(&apos;sharkPlainTextTag&apos;, &lt;/em&gt;block(string(&apos;@!&apos;), ref(&apos;plainTextBlock&apos;)));&lt;/p&gt;
&lt;p&gt;Parser _block(Parser startMarkParser, Parser blockParser) {
&lt;br  /&gt;return startMarkParser &amp;amp; ref(&apos;tagName&apos;) &amp;amp; (&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(ref(&apos;tagParams&apos;).trim() &amp;amp; blockParser.optional())
| (whitespace().star().trim().map((_) =&amp;gt; null) &amp;amp; blockParser)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;);
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;由于标签的参数部分和主体部分，两者至少要提供一个，所以我在&lt;code&gt;_block()&lt;/code&gt;中，提供了两种情况对应的代码：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一定有参数部分，主体部分可选
&lt;br  /&gt;ref(&apos;tagParams&apos;).trim() &amp;amp; blockParser.optional()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只有主体部分
&lt;br  /&gt;whitespace().star().trim().map((_) =&gt; null) &amp;amp; blockParser&lt;/p&gt;
&lt;h2&gt;整个模板的解析&lt;/h2&gt;
&lt;p&gt;最后是整个模板内容的解析，就是把前面的几个主要解析规则拼在一起就行了：&lt;/p&gt;
&lt;p&gt;def(&apos;start&apos;, (
&lt;br  /&gt;ref(&apos;atAt&apos;)
&lt;br  /&gt;| ref(&apos;sharkTag&apos;).separatedBy(whitespace().star(), includeSeparators:false)
&lt;br  /&gt;| ref(&apos;sharkPlainTextTag&apos;)
&lt;br  /&gt;| ref(&apos;sharkExpression&apos;)
&lt;br  /&gt;| any()
&lt;br  /&gt;).star());&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里为止，SharkDart所有的解析规则都讲完了。正因为采用了通用的标签结构设计，解析这块的内容就比较少了。通过这两篇，应该可以看到文本解析大体上是怎么回事了。如果想了解更细节的东西，可以直接看&lt;a href=&quot;https://github.com/freewind/SharkDart/blob/master/lib/src/parser.dart&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下一篇要讲如果设计语法树了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (4) – @@及表达式的解析</title>
                <link>http://freewind.in/posts/2391-write-template-engine-yourself-4-@@-parse-expressions</link>
                <pubDate>Wed, 19 Mar 2014 09:12:51 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2391</guid>
                <description><![CDATA[&lt;p&gt;在本篇将会使用&lt;a href=&quot;https://github.com/renggli/PetitParserDart&quot;&gt;PetitParser&lt;/a&gt;来实现解析器。&lt;/p&gt;
&lt;p&gt;关于PetitParser的基础知识，在这里不多做介绍，因为会另写一个系列。可以在这里看&lt;a href=&quot;http://freewind.me/blog/20140318/2393.html&quot;&gt;入门教程&lt;/a&gt;，或自行到官网了解更多信息。&lt;/p&gt;
&lt;p&gt;我们将使用PetitParser，由简单到难分别实现以下元素的解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@@&lt;/li&gt;
&lt;li&gt;表达式&lt;/li&gt;
&lt;li&gt;标签&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;@@ -&gt; @&lt;/h2&gt;
&lt;p&gt;由于&lt;code&gt;@&lt;/code&gt;在Shark模板中有特殊作用，所以如果我们想要输出一个单纯的&lt;code&gt;@&lt;/code&gt;，需要多做一点事：写成&lt;code&gt;@@&lt;/code&gt;。所以我们在解析的过程中，如果看到&lt;code&gt;@@&lt;/code&gt;，就应该把它变成&lt;code&gt;@&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;PetitParser代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string(&apos;@@&apos;).map((each) =&amp;gt; &apos;@&apos;)


它的意思是，如果遇到了`@@`，就返回一个`@`。

对于要完全匹配给定的字符串，PetitParser提供了`string()`这个函数，`string(&apos;@@&apos;)`的意思非常直白，就是要从模板中匹配到`@@`这个字符串。

在SharkDart里，这句话拆成了两部分，如下：

class SharkParser extends CompositeParser {

  @override
  void initialize() {
    grammar();
    parser();
  }

  grammar() {
    def(&apos;atAt&apos;, string(&apos;@@&apos;));
  }

  parser() {
    action(&apos;atAt&apos;, (_) =&amp;gt; &apos;@&apos;);
  }

}


我们人为把代码分成了两部分，`grammar()`中只定义解析规则，`parser()`中只负责对匹配的内容进行转换，这样看起来更加清晰一些。

另外需要了解的是，`SharkParser`继承了`CompositeParser`这个由PetitParser提供的基类。它里面提供了一些如`def()`和`ref()`这样的方法，可以让我们在任意地方定义和引用另一个parser，哪怕它可能还没有来得及定义。在一个复杂的文法中，经常会出现循环引用的情况，所以PetitParser提供了多种解决方案，这里的CompositeParser是一种。另外还有先定义一个`undefined()`的占位符，先用后更新，也是一种常用的做法，但这里没用上，就不多说。

## 简单表达式 @expr

这里表达式变量的定义应该跟dart语言一致：它可以包含字母、数字、下划线和$，但数字不能出现有首位。

为了方便复用，我先把首位定义出来：

def(&apos;variableHead&apos;, pattern(r&apos;a-zA-Z_$&apos;));


其中`pattern()`也是PetitParser提供的一个parser。PetitParser是不支持正则表达式的，但有时候正则中的一些写法，比如`a-z`,`0-9`等又的确方便，所以它便提供了`pattern()`这个函数，有限的支持这种写法。

对于非首位的字符，使用以下定义：

ref(&apos;variableHead&apos;) | digit()


即在`variableHead`的基础上，增加了数字的支持。

把它们合并在一起，就是整个变量：

def(&apos;variable&apos;, (ref(&apos;variableHead&apos;) &amp;amp; (ref(&apos;variableHead&apos;) | digit()).star()).flatten());


即一个首位字符，再加上任意多个非首位字符。看到那个奇怪的`&amp;amp;`和`|`操作符了吗？在Dart中允许重载操作符，而`&amp;amp;`可看作是另一个方法`seq(...)`的别名，用来表示两个parser是相邻的，`|`可看作是`or(...)`的别名，表示一个不行试另一个。

最后的`flatten()`用来把整个匹配结果合成一个单独的字符串，不然到时候拿到的就是一个由字符和列表组成的列表了。

完整的定义如下：

def(&apos;simpleExpression&apos;, char(&apos;@&apos;) &amp;amp; ref(&apos;variable&apos;));


## 复杂表达式

复杂表达式里会包含调用或者参数传递，用`@{}`括起来，比如：

@{hello(&quot;world&quot;)}
@{names.map((name)=&amp;gt;name.toUpperCase())}


如果我们细心考虑，会发现我们不能简单的用`@{`和`}`作为首尾来匹配，因为有这样的情况存在：

@{hello(&quot;wor}}}}}ld&quot;)}


或者

@{names.map((name){return name.toUpperCase()})}


中间的`}`会让我们的匹配提前结束，所以我们必须把“字符串”和“花括号对”挑出来，不让它们干扰真正的匹配。

### 字符串

在Dart中，可以使用单引号和双引号来括字符串，就像javascript一样。其实还有更复杂的情况，如三个连接双引号或单引号，在字符串中嵌入表达式等，但我们不予考虑，太复杂了。

另外，如果用单引号括起来的字符串里还有单引号，则需要在前面加&apos;\&apos;，对于双引号来说也一样。

def(&apos;singleString&apos;, _sharkString(&quot;&apos;&quot;).flatten());
def(&apos;doubleString&apos;, _sharkString(&apos;&quot;&apos;).flatten());


因为两者的逻辑很像，所以提供了一个`_sharkString()`的函数：

Parser _sharkString(String boundChar) {
  return (
    char(boundChar)
    &amp;amp; (string(r&quot;\&quot; + boundChar) | char(boundChar).neg()).star()
    &amp;amp; char(boundChar)
  );
}


以单引号举例，这段代码的意思是，首先要有一个单引号，然后把`\&apos;`及非单引号字符尽可能匹配掉，直到最后遇到另一个单引号。

其中`neg()`表示negative，比如`digit()`表示匹配数字，则`digit().neg()`就表示匹配“非数字”。`r&quot;\&quot;`这个字符串前面有一个前缀`r`，它表示字符串里的内容不需要转义，其值就是`\`。

### 花括号对

再然后就是“花括号对”了。由于复杂表达式自己就带了一对花括号，所以我们可以巧妙的利用上它，即对自己迭代：

def(&apos;complexExpression&apos;, char(&apos;@&apos;) &amp;amp; ref(&apos;complexExpressionBody&apos;));
def(&apos;complexExpressionBody&apos;, (
  char(&apos;{&apos;) 
  &amp;amp; (
      ref(&apos;complexExpressionBody&apos;)
      | ref(&apos;singleString&apos;)
      | ref(&apos;doubleString&apos;)
      | char(&apos;}&apos;).neg()
    ).star().flatten() 
  &amp;amp; char(&apos;}&apos;)
).pick(1));


最后的`pick(1)`表示结果列表中的第2个元素。因为`complexExpressionBody`的内容可分为三部分，`{`、中间内容、结尾的`}`，它们用`&amp;amp;`连接在一起，匹配的结果将会是一个由三个元素组成的列表，而我们只对中间内容感兴趣，所以`pick(1)`，在这里处理一下可提前丢掉不要的内容，方便后面的处理。

上面这段代码不多讲解，请自己体会，关键就在于自己在内部调用自己，可以匹配内部嵌套的花括号对。

## 表达式action

前面分别定义了简单表达式和复杂表达式。为了方便处理，我们把它们合在一起：

def(&apos;sharkExpression&apos;, ref(&apos;simpleExpression&apos;) | ref(&apos;complexExpression&apos;));


然后在`parser()`方法中添加下面的action:

action(&apos;sharkExpression&apos;, (each) {
  var expr = each[1];
  return new SharkExpression(expr);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意each将会是一个长度为2的数组，&lt;code&gt;each[0]&lt;/code&gt;是&lt;code&gt;@&lt;/code&gt;，&lt;code&gt;each[1]&lt;/code&gt;是&lt;code&gt;@{&lt;/code&gt;与&lt;code&gt;}&lt;/code&gt;中间的内容，是我们需要的。最后的&lt;code&gt;SharkExpression&lt;/code&gt;类是将在后面介绍的语法树结点类之一，用来表示匹配到了一个表达式，这里暂不用考虑。&lt;/p&gt;
&lt;p&gt;标签结构的解析比较复杂，将放在下一篇。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>易用强大的解析器PetitParser – (1) 安装及Hello World</title>
                <link>http://freewind.in/posts/2393-good-dart-parser-petitparser-1-install-hello-world</link>
                <pubDate>Tue, 18 Mar 2014 19:38:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2393</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://github.com/renggli/PetitParserDart&quot;&gt;PetitParser&lt;/a&gt;是一个强大、易用、灵活的解析工具，使用Dart写成。&lt;/p&gt;
&lt;p&gt;它文档丰富，代码易懂，作者也非常热情。在学习的过程中，我曾经有过很多疑问，都得到了作者及时详尽的解答，在这里要特别表示感谢。如果大家对解析器的实现感兴趣，或者想自己写一些复杂的解析规则，建议把它的代码看懂再动手。&lt;/p&gt;
&lt;p&gt;我花了一些学习了它的使用，并且研读了一下它的源代码，感觉收获很大。最大的收获就是知道了：解析器这么高大上的东西，竟然是用一些非常简单和基本的功能实现的，这真是太神奇了。&lt;/p&gt;
&lt;p&gt;在这里先讲一下如何使用它写出最简单的Hello world.&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;我们需要先到Dart的官网安装SDK：http://dartlang.org&lt;/p&gt;
&lt;p&gt;Dart支持windows/linux/mac，并且默认包里内置了基本eclipse的DartEditor，如果不想用的话，可以到&lt;a href=&quot;https://www.dartlang.org/tools/sdk/&quot;&gt;Tools页面&lt;/a&gt;下载独立版本。&lt;/p&gt;
&lt;p&gt;将Dart解压到本地后，将dart-sdk下的bin目录加入path，然后运行dart命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  bin  dart --version
Dart VM version: 1.2.0 (Tue Feb 25 07:31:27 2014) on &quot;macos_x64&quot;


应该能看到类似上面的输出。

在Dart里还内置了一个`pub`命令，用来管理和下载依赖包，我们一会儿要用它。

## 下载依赖

创建一个test目录，在里面创建一个dartpub.yaml文件，内容如下：

name: SharkDart
version: 0.1.0
dependencies:
  petitparser:
    git: https://github.com/renggli/PetitParserDart.git


如果执行：

pub install


如果一切成功，你将会看到项目目录下多了一个`packages`目录，里面有下载好的各依赖库，如petitparser.

(注意：该命令会访问国外的一些地址，由于某些众所周知的原因，有时可能无法成功运行，自备梯子）

## hello world

我们将使用petitparser实现一个很简单的功能：找到一个字符串里所有的数字，并把它们相加。

比如对于字符串：`aa12bb23cc5`，它应该能从里面取到数字`12`和`23`和`5`，可计算出结果`40`

创建文件test.dart，代码如下：

import &quot;package:petitparser/petitparser.dart&quot;;

main() {
  var str = &apos;aa12bb23cc5&apos;;
  var parser = (digit().plus().flatten() | any().map((_) =&amp;gt; null)).star().map((each) {
    print(each);
    var total = 0;
    for (String numStr in each) {
      if (numStr != null) {
        total += int.parse(numStr);
      }
    }
    return total;
  });
  var total = parser.parse(str);
  print(total);
}


运行它：

$ dart test.dart


得到结果：

[null, null, 12, null, null, 23, null, null, 5]
Success[1:12]: 40


可以看到它的确成功解析出了所有数字，并得到了正确的和。

## 匹配语法

下面这一行代码是关键：

(digit().plus().flatten() | any().map((_) =&amp;gt; null)).star()


里面各函数都是在PetitParser里定义好的
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;digit() 解析一个数字，相当于正则中的&lt;code&gt;\d&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;any() 解析任意一个字符，相当于正则中的&lt;code&gt;.&lt;/code&gt;（包括换行符）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;plus() 重复一次或多次，相当于正则中的&lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;star() 重复零次或多次，相当于正则中的&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flatten() 将匹配到的结果变成一个字符串，否则是一个字符数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;map() 用来对匹配到的内容进行变换&lt;/p&gt;
&lt;p&gt;这行代码的意思就是：先匹配多个连在一起的数字，如果匹配不到，则匹配一个任意字符并返回null代替。然后不断重复这个过程，直到解析完字符串的全部内容。&lt;/p&gt;
&lt;h2&gt;计算&lt;/h2&gt;
&lt;p&gt;后面那个大的map块，是用来拿出匹配的数字并计算和：&lt;/p&gt;
&lt;p&gt;.map((each) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var total = 0;
for (String numStr in each) {
  if (numStr != null) {
    total += int.parse(numStr);
  }
}
return total;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;其中each是前面全部匹配到的内容，由于前面是一个star()，所以它是一个数组，并且里面的内容将会由&lt;code&gt;null&lt;/code&gt;和数字组成。然后取出里面的数字并计算结果返回。&lt;/p&gt;
&lt;h2&gt;parse&lt;/h2&gt;
&lt;p&gt;下面这句代码执行解析过程：&lt;/p&gt;
&lt;p&gt;parser.parse(str);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的返回结果可为success和failure。如果匹配成功，则会显示最后的结果，失败的话，会提示在哪一步没有匹配成功。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (3) – 常用标签设计</title>
                <link>http://freewind.in/posts/2383-write-template-engine-yourself-3-design-tags</link>
                <pubDate>Tue, 18 Mar 2014 13:19:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2383</guid>
                <description><![CDATA[&lt;p&gt;大大催了，得赶紧写，这一系列大概还要五六篇。&lt;/p&gt;
&lt;p&gt;在前一篇中定义了我定义了Shark中标签的通用结构，它有两种形态，主要区别在参数上。&lt;/p&gt;
&lt;p&gt;结构1：涉及到参数的传递，形如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@mytag(type1 var1: desc1, type2 var2: desc2) {
    body
}


结构2：对一段代码进行操作，如对值进行判断等，形如：

@mytag(some dart code) {
    body
}


注意参数块`(...)`和主体块`{...}`都是可选的，但至少要提供一个。

我们可能会有一个疑问：使用这两种结构，是否可以设计出优雅好用的标签？

为了回答这个问题，我找了一些在模板引擎中常用的标签，按上面两种结构来定义，以验证可行性。

## 常用标签

流程控制：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;elseif&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;else&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;for&lt;/p&gt;
&lt;p&gt;模板交互：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;params&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;extends&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;renderBody&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;render&lt;/p&gt;
&lt;p&gt;文本内嵌:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dart&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;plainText&lt;/p&gt;
&lt;p&gt;上面这些基本的标签，再加上表达式：&lt;/p&gt;
&lt;p&gt;@simpleVar
&lt;br  /&gt;@{complexVar.more.more()}&lt;/p&gt;
&lt;p&gt;基本上就可以满足各常用的需求了。如果有更复杂的需求，我们还可以有两种做法：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用dart标签，内嵌一些dart代码，如函数定义等。Shark并不禁止在模板中嵌入代码，该出手时就出手&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义标签。注意上面的这些标签对于模板来说，都不是侵入式的，我们甚至可以用自己的实现替代它们。Shark将提供强大的自定义标签功能，让我们实现复杂的功能&lt;/p&gt;
&lt;h2&gt;标签api设计&lt;/h2&gt;
&lt;p&gt;下面我们将从用户角度考虑这些标签的设计，先不管它们如何实现，甚至是否能实现。&lt;/p&gt;
&lt;h3&gt;if&lt;/h3&gt;
&lt;p&gt;功能不用多说，它可以用结构2实现：&lt;/p&gt;
&lt;p&gt;@if(name==&apos;Shark&apos;) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;Hello, @name&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;@if(name.startsWith(&amp;ldquo;thought&amp;rdquo;)) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;@{name}works&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;@if (names.where((name) =&gt; name.startsWith(&amp;ldquo;X&amp;rdquo;)).isNotEmpty) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;There is at least one name starts with X&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3&gt;elseif&lt;/h3&gt;
&lt;p&gt;它基本上跟@if一模一样：&lt;/p&gt;
&lt;p&gt;@if(num==1) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} @elseif(num==2) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3&gt;else&lt;/h3&gt;
&lt;p&gt;这个不需要参数，最简单&lt;/p&gt;
&lt;p&gt;@if(ok) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} @else {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在很多类似的模板引擎中，对于这种情况，&lt;code&gt;else&lt;/code&gt;前面的&lt;code&gt;@&lt;/code&gt;是不需要的：&lt;/p&gt;
&lt;p&gt;@if(ok) { &amp;hellip; } else { &amp;hellip; }&lt;/p&gt;
&lt;p&gt;看起来更简洁一些。但对于Shark来说，稍麻烦一点，但也不是很难接受。&lt;/p&gt;
&lt;h3&gt;for&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt;在dart中的语法形如：&lt;/p&gt;
&lt;p&gt;for(int i=0; i&lt;10; i++) { ... }
&lt;br  /&gt;for(var name in names) { &amp;hellip; }&lt;/p&gt;
&lt;p&gt;虽然照搬也可以，但如果采用类似于java的形式，可能更简单一些：&lt;/p&gt;
&lt;p&gt;@for(name: names) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index&lt;/code&gt;哪儿去了？在这里，我参考了play中的模板语法，将会在body内生成一些特别的变量，提供更丰富的信息：&lt;/p&gt;
&lt;p&gt;@for(name: names) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Following varaibles are valid in the body:
- @name_index
- @name_isFirst
- @name_isLast
- @name_isOdd
- @name_isEven
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这样就是一个功能超强的for了。&lt;/p&gt;
&lt;p&gt;还要再为它增加一个自动添加分隔符的功能，这在生成JSON数据时特别有用:&lt;/p&gt;
&lt;p&gt;[
&lt;br  /&gt;@for(name: names, separator: &apos;,&apos;) {
&lt;br  /&gt;{ &amp;ldquo;name&amp;rdquo;: &amp;ldquo;@name&amp;rdquo; }
&lt;br  /&gt;}
&lt;br  /&gt;]&lt;/p&gt;
&lt;p&gt;假如&lt;code&gt;names&lt;/code&gt;值为&lt;code&gt;[&apos;Shark&apos;, &apos;Bird&apos;, &apos;Chicken&apos;]&lt;/code&gt;，它将会生成：&lt;/p&gt;
&lt;p&gt;[
&lt;br  /&gt;{ &amp;ldquo;name&amp;rdquo;: &amp;ldquo;Shark&amp;rdquo; },
&lt;br  /&gt;{ &amp;ldquo;name&amp;rdquo;: &amp;ldquo;Bird&amp;rdquo; },
&lt;br  /&gt;{ &amp;ldquo;name&amp;rdquo;: &amp;ldquo;Chicken&amp;rdquo; }
&lt;br  /&gt;]&lt;/p&gt;
&lt;p&gt;注意它会在两个元素之间自动添加上指定的separator，不多不少。&lt;/p&gt;
&lt;p&gt;对了，&lt;code&gt;for&lt;/code&gt;还可以跟&lt;code&gt;else&lt;/code&gt;搭配：&lt;/p&gt;
&lt;p&gt;@for(user: users) {&lt;/p&gt;
   &lt;div&gt;User: @user&lt;/div&gt;
&lt;p&gt;} @else {&lt;/p&gt;
   &lt;div&gt;Sorry, no user found!&lt;/div&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3&gt;params&lt;/h3&gt;
&lt;p&gt;这个标签一般放在页首，用来指定当前模板可以传入哪些参数，比如：&lt;/p&gt;
&lt;p&gt;user.shark&lt;/p&gt;
&lt;p&gt;@params(String name, String blog) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;User: @name, blog: @blog&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;如果我们要写很长的html，还可以选择忽略&lt;code&gt;{}&lt;/code&gt;符号：&lt;/p&gt;
&lt;p&gt;@params(String name, String blog)&lt;/p&gt;
&lt;div&gt;
  Very long content
  Many lines here
  You don&apos;t want it to be wrapped in a `{}` block
&lt;/div&gt;
&lt;p&gt;由于模板文件&lt;code&gt;user.shark&lt;/code&gt;将被编译为&lt;code&gt;user.dart&lt;/code&gt;，则我们可以这样调用它：&lt;/p&gt;
&lt;p&gt;import &amp;ldquo;user.dart&amp;rdquo; as view$user;&lt;/p&gt;
&lt;p&gt;showUser(User user) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return view$user.render(name: user.name, blog: user.blog);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h3&gt;extends&lt;/h3&gt;
&lt;p&gt;对于网站来说，将页面划分为布局页和内容页是很常用的需求，所以我们会提供&lt;code&gt;extends&lt;/code&gt;标签实现这个功能。&lt;/p&gt;
&lt;p&gt;布局页：layout.shark&lt;/p&gt;
&lt;p&gt;&lt;html&gt;
&lt;br  /&gt;&lt;head&gt;&amp;hellip;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;@renderBody()&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;内容页: index.shark&lt;/p&gt;
&lt;p&gt;@extends(layout) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;main content of index page&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这样在渲染index模板时，它会自动把它的内容嵌入到layout.shark中的&lt;code&gt;@renderBody()&lt;/code&gt;处。&lt;/p&gt;
&lt;p&gt;同&lt;code&gt;@params&lt;/code&gt;一样，&lt;code&gt;@extends&lt;/code&gt;的&lt;code&gt;{}&lt;/code&gt;也可以省略：&lt;/p&gt;
&lt;p&gt;@extends(layout)&lt;/p&gt;
&lt;div&gt;
  Very long content
  Many lines here
  You don&apos;t want it to be wrapped in a `{}` block
&lt;/div&gt;
&lt;p&gt;并且还可以向layout.shark中传参数：&lt;/p&gt;
&lt;p&gt;layout.shark&lt;/p&gt;
&lt;p&gt;@params(String pageTitle)
&lt;br  /&gt;&lt;html&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;@pageTitle&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;@renderBody()&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;index.shark&lt;/p&gt;
&lt;p&gt;@extends(layout, pageTitle: &apos;Index page, welcome&apos;)&lt;/p&gt;
&lt;div&gt;
  Very long content
&lt;/div&gt;
&lt;p&gt;标签参数中的paramDescription位置，实际上可以传入多种类型的参数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一个变量名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以单引号括起来的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以双引号括起来的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以&lt;code&gt;{}&lt;/code&gt;括起来的一块内容&lt;/p&gt;
&lt;p&gt;这么规定，是考虑到有时候我们需要向另一个标签中传入丰富的内容，比如一个复杂的extends:&lt;/p&gt;
&lt;p&gt;@extends(layout,
&lt;br  /&gt;name: someName,
&lt;br  /&gt;pageTitle: &apos;Index page&apos;,
&lt;br  /&gt;pageCopyright: &amp;ldquo;Copyright&amp;rdquo;,
&lt;br  /&gt;moreJs: {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;script src=&quot;...&quot;&amp;gt;&amp;lt;/script&amp;gt;
 &amp;lt;script src=&quot;...&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;)&lt;/p&gt;
&lt;div&gt;
  content
&lt;/div&gt;
&lt;h3&gt;renderBody&lt;/h3&gt;
&lt;p&gt;这个标签在前面已经出现过，它是个占位符。如果有另一个页面继承或调用它所在的模板，则会用另一个模板的内容填充它。它实际上不需要任何额外信息，但为了表示它是一个标签，所以我们会在后面加个&lt;code&gt;()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;layout.shark&lt;/p&gt;
&lt;p&gt;&lt;html&gt;
&lt;br  /&gt;&lt;body&gt;@renderBody()&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;h3&gt;render&lt;/h3&gt;
&lt;p&gt;有时候我们想把一个大页面分解为多个小页面，以获得更清晰的结构；有时候我们想定义一些小页面，在多个大页面中复用，这时候可以使用&lt;code&gt;render&lt;/code&gt;标签。&lt;/p&gt;
&lt;p&gt;先定义两个小页面：&lt;/p&gt;
&lt;p&gt;left.shark&lt;/p&gt;
&lt;p&gt;@param(List&lt;String&gt; operations)&lt;/p&gt;
&lt;ul&gt;
  @for(op: operations) {
    &lt;li&gt;@op&lt;/li&gt;
  }
&lt;/ul&gt;
&lt;p&gt;big.shark&lt;/p&gt;
&lt;div&gt;
  @renderBody()
&lt;/div&gt;
&lt;p&gt;然后在大页面中调用:&lt;/p&gt;
&lt;p&gt;@!dart {
&lt;br  /&gt;var operations = [&apos;add&apos;, &apos;delete&apos;, &apos;update&apos;];
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;@render(left, operations: operations)
&lt;br  /&gt;@render(big) {
&lt;br  /&gt;More content
&lt;br  /&gt;}&lt;/p&gt;
&lt;h3&gt;dart&lt;/h3&gt;
&lt;p&gt;有时候我们需要在页面中嵌入一些dart代码，实现一些复杂的功能，如定义一个函数，初始化一些数据等，这时可使用&lt;code&gt;dart&lt;/code&gt;标签。&lt;/p&gt;
&lt;p&gt;@!dart {
&lt;br  /&gt;here is all kinds of dart code
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;由于主体中的内容是dart代码，一般应该当成纯文本看待，不应该对其内容进行任何解析或转义，所以我们通常会有&lt;code&gt;@&lt;/code&gt;后加上&lt;code&gt;!&lt;/code&gt;，用来告诉解析器，请把&lt;code&gt;{}&lt;/code&gt;中的代码当作纯文本看待。&lt;/p&gt;
&lt;p&gt;同时，由于&lt;code&gt;{}&lt;/code&gt;中内容为纯文本，它可以包含任意字符，所以很可能出现一个&lt;code&gt;}&lt;/code&gt;，让&lt;code&gt;{}&lt;/code&gt;提早结束。为了避免这种情况，我们可以重复&lt;code&gt;{&lt;/code&gt;和&lt;code&gt;}&lt;/code&gt;，只要它们个数相等：&lt;/p&gt;
&lt;p&gt;@!dart {{{&lt;/p&gt;
&lt;p&gt;hello() { world() {
&lt;br  /&gt;}}&lt;/p&gt;
&lt;p&gt;}}}&lt;/p&gt;
&lt;p&gt;被dart标签包起来的内容，将会当作dart代码嵌入到生成的dart文件中。&lt;/p&gt;
&lt;h3&gt;plainText&lt;/h3&gt;
&lt;p&gt;有时候只想把一大段内容原封不动的嵌入到最终生成的文本中，这时候可以使用plainText标签。&lt;/p&gt;
&lt;p&gt;@!plainText(trim: true) {&lt;/p&gt;
&lt;p&gt;A lot of text here&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加上trim参数，可以控制是否把文本两边的空白去掉，默认为false&lt;/p&gt;
&lt;h2&gt;这不是使用教程吗&lt;/h2&gt;
&lt;p&gt;通过上面对各常用标签的解释，可以认为开头定义的两种标签通用结构是可行的，下一篇我们将利用PetitParser来解析它。而这些常用标签的实现过程，将在后面与编译相关的内容中实现。&lt;/p&gt;
&lt;p&gt;PS:&lt;/p&gt;
&lt;p&gt;另外，写到最后，有没有发现这简直就是SharkDart的使用教程？没错，对于开发者来说，这是设计，但对用户来说，就和教程差不多了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (2) – 语法设计</title>
                <link>http://freewind.in/posts/2354-write-template-engine-yourself-2-design-syntax</link>
                <pubDate>Thu, 13 Mar 2014 23:14:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2354</guid>
                <description><![CDATA[&lt;p&gt;首先不考虑实现，从用户的角度想想，这个模板应该有什么样的语法。&lt;/p&gt;
&lt;p&gt;我们可能已经用过或见过很多模板引擎，大多数都是提供了一些特别的标记，可以让我们在HTML或其它文本中，嵌入我们自己的标签，以实现如数据展示、逻辑控制等功能。每一种都有自己独特的标记和语法定义，但实际使用起来，多数都差不多的。每种模板都提供了一些常用的标签，比如for, if, 变量显示等，都是居家必备的。&lt;/p&gt;
&lt;p&gt;SharkDart也不例外。&lt;/p&gt;
&lt;h2&gt;主要特点&lt;/h2&gt;
&lt;p&gt;SharkDart语法上的主要特点有几下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用字母&lt;code&gt;@&lt;/code&gt;作为特殊字符&lt;/li&gt;
&lt;li&gt;提供通用tag结构，而不为具体的tag自定义语法&lt;/li&gt;
&lt;li&gt;使用字母&lt;code&gt;!&lt;/code&gt;表示取用原始文本&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Magic &lt;code&gt;@&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;SharkDart采用了字母&lt;code&gt;@&lt;/code&gt;作为特殊的标识符，用于标示可由SharkDart处理的标签。这种做法参考了&lt;a href=&quot;http://rythmengine.org/&quot;&gt;Rythm Template Engine&lt;/a&gt;和&lt;a href=&quot;http://www.playframework.com/documentation/2.2.x/ScalaTemplates&quot;&gt;Play2的模板&lt;/a&gt;，而它们又参考了.net的&lt;a href=&quot;http://www.w3school.com.cn/aspnet/razor_intro.asp&quot;&gt;Razor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;不过也仅此而已，其它的部分，SharkDart都有自己的特色，很快就能看到。&lt;/p&gt;
&lt;h2&gt;通用型标签结构&lt;/h2&gt;
&lt;p&gt;很多模板都为某些内置标签提供了量身定做的语法。比如&lt;code&gt;for&lt;/code&gt;，在Play2中是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@for(order &amp;lt;- orders) {
}


这模仿了scala中的for语法。

而if-else则是：

@if(items.isEmpty) {
  &amp;lt;h1&amp;gt;Nothing to display&amp;lt;/h1&amp;gt;
} else {
  &amp;lt;h1&amp;gt;@items.size items!&amp;lt;/h1&amp;gt;
}


它跟前面的for完全不同，无法使用同一种解析规则。所以在模板的解析阶段，必须为每一个标签提供相应的解析规则。

这样做的好处是，每个标签的语法都可定制，相当灵活，缺点则是，一旦想提供自定义的标签，可能需要修改解析规则的源代码，工作量挺大的，对于扩展也不利。

在SharkDart之前我还做过一个叫RythmDart的模板引擎，里面就采用了上面的方式，为每一个标签都提供了相应的解析规则。这一次我想换种方式。

通用规则的难点在于，要想出一个结构，可以满足大部分内置标签的需要，比如如何把上面的for和if-else统一成一种格式。

经过几天的思考与推敲，我最后定义了两种标签结构（一种实在搞不定）：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可接受多个参数的标签
&lt;br  /&gt;@tagname(paramType paramVar1: paramDesc, paramType paramVar2: paramDesc) {
&lt;br  /&gt;&amp;hellip;
&lt;br  /&gt;}
&lt;br  /&gt;其中paramType和paramDesc都是可选项。即也可以为：
&lt;br  /&gt;@tagname(paramVar1, paramVar2) {}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可接受一段代码作为参数的标签
&lt;br  /&gt;@tagname(some code here) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;使用这两种结构，基本上可满足我想到的各内置标签的功能。比如：&lt;/p&gt;
&lt;ul&gt;
@for(name: names) {
    &lt;li&gt;Hello @name !&lt;/li&gt;
}
&lt;/ul&gt;
&lt;p&gt;@params(String name: &apos;Shark&apos;) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;It&apos;s all about @name&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;@extends(anotherTemplate, name: &apos;Freewind&apos;) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;Custom content&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这些都使用了第一种结构。（注意上面的@name，表示显示变量name的值）&lt;/p&gt;
&lt;p&gt;再比如：&lt;/p&gt;
&lt;p&gt;@if(name==&apos;Shark&apos;) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Enter the ocean!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} @elseif(name==&apos;Bird&apos;) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Fly!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} @else {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sleep ~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;使用了第二种结构。&lt;/p&gt;
&lt;p&gt;实际上，我设计出的各内置标签（数量不多），都可以用它们实现。&lt;/p&gt;
&lt;p&gt;另外，为了跟后面的“表达式”结构作为区分，标签必须至少有参数部分&lt;code&gt;()&lt;/code&gt;或主体部分&lt;code&gt;{}&lt;/code&gt;之一，哪怕是空的也行。&lt;/p&gt;
&lt;h2&gt;表达式&lt;/h2&gt;
&lt;p&gt;表达式是指在页面中显示一个变量或者一些调用代码的值，也是必不可少的功能。为了一致，它也使用了&lt;code&gt;@&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;简单表达式，直接在前面加&lt;code&gt;@&lt;/code&gt;，如：&lt;/p&gt;
&lt;p&gt;@name
&lt;br  /&gt;@age&lt;/p&gt;
&lt;p&gt;复杂表达式，可用&lt;code&gt;@{}&lt;/code&gt;包起来：&lt;/p&gt;
&lt;p&gt;@{name.toLowerCase()}
&lt;br  /&gt;@{users.map((u)=&gt;&amp;ldquo;[$u]&amp;ldquo;).join(&apos;, &apos;)}&lt;/p&gt;
&lt;p&gt;当然单个变量也可以包：&lt;/p&gt;
&lt;p&gt;@{name}&lt;/p&gt;
&lt;h2&gt;纯@字符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@&lt;/code&gt;字符有了特殊的意义，那我想显示一个单纯的&lt;code&gt;@&lt;/code&gt;怎么办？为了解决这个问题，规定&lt;code&gt;@@&lt;/code&gt;会被解析为单个&lt;code&gt;@&lt;/code&gt;。比如:&lt;/p&gt;
&lt;p&gt;@@name&lt;/p&gt;
&lt;p&gt;会被解析为纯文本：&lt;/p&gt;
&lt;p&gt;@name&lt;/p&gt;
&lt;h2&gt;@!&lt;/h2&gt;
&lt;p&gt;有的时候，我希望标签的主体就是一段纯文本，里面的所有内容都原封不动的取出。为了实现这个功能，我定义了一个&lt;code&gt;@!&lt;/code&gt;，即在&lt;code&gt;@&lt;/code&gt;字符后加一个&lt;code&gt;!&lt;/code&gt;，表示主体将会被当作纯文本看待。&lt;/p&gt;
&lt;p&gt;它不跟任何一个具体的标签相关，即可以添加到任何标签前。而标签的其它部分都跟以前一样。比如，我想定义一段Dart代码：&lt;/p&gt;
&lt;p&gt;@!dart {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;print(&quot;Hello, Shark!&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;或者一段普通文本：&lt;/p&gt;
&lt;p&gt;@!plainText {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; I&apos;m plainText, @@ is @@.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;里面的&lt;code&gt;@@&lt;/code&gt;还是&lt;code&gt;@@&lt;/code&gt;，而不会被解析为&lt;code&gt;@&lt;/code&gt;。但如果去掉那个&lt;code&gt;!&lt;/code&gt;，就不一样了。&lt;/p&gt;
&lt;h2&gt;多重括号 {{{ &amp;hellip; }}}&lt;/h2&gt;
&lt;p&gt;仔细看前一段，很快会发现一个问题：如果纯文本中有一个&lt;code&gt;}&lt;/code&gt;，会怎样？&lt;/p&gt;
&lt;p&gt;@!dart {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s = &quot;}&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;回答：dart标签的主体会提前结束，我们为dart标签取得的内容，实际上为：&lt;/p&gt;
&lt;p&gt;var s = &quot;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我对标签主体两边的花括号进行了调整，允许使用多个花括号，以保证内容不会被意外截断：&lt;/p&gt;
&lt;p&gt;@!dart {{{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s = &quot;}&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}}}&lt;/p&gt;
&lt;p&gt;多长都行：&lt;/p&gt;
&lt;p&gt;@!dart {{{{{{{{{{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// oh my God, I can&apos;t breath
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}}}}}}}}}}&lt;/p&gt;
&lt;h2&gt;不想要{}&lt;/h2&gt;
&lt;p&gt;有些标签主体外面的花括号有点烦人，比如说&lt;code&gt;@params&lt;/code&gt;和&lt;code&gt;@extends&lt;/code&gt;。它们两个一般放在页面的最顶端，用来指定整个页面接受的参数，以及继承了哪个页面。如果有花括号，会写成：&lt;/p&gt;
&lt;p&gt;@params(String name) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;...&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;...&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;及：&lt;/p&gt;
&lt;p&gt;@extends(anotherTemp) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;如果去掉花括号，则可以写成：&lt;/p&gt;
&lt;p&gt;@params(String name)&lt;/p&gt;
&lt;p&gt;&lt;html&gt;
&lt;br  /&gt;&lt;head&gt;&amp;hellip;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&amp;hellip;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;及：&lt;/p&gt;
&lt;p&gt;@extends(anotherTemp)&lt;/p&gt;
&lt;div&gt;...&lt;/div&gt;
&lt;div&gt;...&lt;/div&gt;
&lt;div&gt;...&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样看起来标签就像是页面顶上的一个注释，不会对主要内容产生干扰，还能省下一个不必要的缩进。&lt;/p&gt;
&lt;p&gt;这种需求实际上对语法的解析不产生影响，因为它并不跟前面列出的规则矛盾。只是在后面将语法树翻译成dart代码时，需要考虑如何让标签决定它后面跟着的内容是标签的一部分（主体），还是排在它后面的普通内容。&lt;/p&gt;
&lt;h2&gt;语法搞定&lt;/h2&gt;
&lt;p&gt;经过以上几个简单的规则，SharkDart的语法就定义好了！&lt;/p&gt;
&lt;p&gt;看起来很简单，但让我想了好几天，多次推翻才定下这种方案。中间过程不提，只能说，这真是一项特别费脑子的事情。&lt;/p&gt;
&lt;p&gt;今天到此为止，下一篇将会尝试使用这里定义的标签通用结构设计一些常用标签，看看是否真的可行。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>自己动手写模板引擎 – SharkDart (1) – 原理</title>
                <link>http://freewind.in/posts/2336-write-template-engine-yourself-1-principle</link>
                <pubDate>Wed, 12 Mar 2014 23:27:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2336</guid>
                <description><![CDATA[&lt;p&gt;近段时间在学习Dart，想用它多造几只轮子，以巩固自己的基本功。忙里偷闲，实现了一个小巧的模板引擎，名为SharkDart，前后花了大约一个月的时间。之所以叫Shark，是因为这段时间在客户这里做的项目也叫这个名字，所以以此作为纪念。&lt;/p&gt;
&lt;p&gt;另外选择“模板引擎”这只轮子，是因为编译原理相关的东西，是相当基础且重要的东西，自己也比较感兴趣。&lt;/p&gt;
&lt;h2&gt;项目代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/freewind/SharkDart&quot;&gt;https://github.com/freewind/SharkDart&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;外观&lt;/h2&gt;
&lt;p&gt;模板的语法，以字母&lt;code&gt;@&lt;/code&gt;作为标识符，大体上看起来是这样的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lang.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@params(List&amp;lt;String&amp;gt; languages)

&amp;lt;ul&amp;gt;
@for(String lang: languages) {
   &amp;lt;li&amp;gt;Hello, @lang!&amp;lt;/li&amp;gt;
}
&amp;lt;/ul&amp;gt;


它将会编译为一个`lang.dart`文件，并且提供了一个`render({List&amp;lt;String&amp;gt; languages})`函数以供调用。如果我们这样调用它：

import &quot;lang.dart&quot; as lang;

main() {
    var langs = [&quot;Dart&quot;, &quot;Java&quot;, &quot;Scala&quot;];
    lang.render(languages: langs);
}


它生成的最终结果将会是：

&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;Hello, Dart!&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Hello, Java!&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Hello, Scala!&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SharkDart是一个通用型的模板引擎，可以用于各种文本的生成，比如html, js, css等。配合一个web框架，就可以做出简单的网站了。&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;对于一个简单的模板引擎来说，一般需要这几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义模板语法，比如前面的&lt;code&gt;@for() { ... }&lt;/code&gt;的结构和功能等&lt;/li&gt;
&lt;li&gt;词法分析，在模板文本中识别出各语法成分，一般会利用第三方解析库或者纯手写&lt;/li&gt;
&lt;li&gt;定义各元素对应的类，生成一棵语法树&lt;/li&gt;
&lt;li&gt;对于编译型引擎来说，需要将该树转化为一段目标语言的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几步里，第一步最费脑筋，因为需要创造性的思维，才能想出一套与别人不同的、让自己满意的语法。&lt;/p&gt;
&lt;p&gt;第二步最难最需要耐心，因为不论采用哪种方案，都需要定义一套准确、完整的解析规则来识别各种语法成分，这需要思考和反复的调试。&lt;/p&gt;
&lt;p&gt;第三步相对要简单一些。&lt;/p&gt;
&lt;p&gt;第四步要看情况，如果语法定的很细，比如直接把&lt;code&gt;@for&lt;/code&gt;、&lt;code&gt;@if&lt;/code&gt;作为语法成分，编译的难度要小一些；但如果语法比较灵活，比如只定义了一套通用的标签结构，如&lt;code&gt;@tagname(paramType paramVariable: paramDescription) { ... }&lt;/code&gt;，然后根据tagname的不同，实现不同的功能，灵活度大，但编译就麻烦一些。&lt;/p&gt;
&lt;h2&gt;SharkDart的选择&lt;/h2&gt;
&lt;p&gt;根据我的偏好，SharkDart做出了以下的选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用Dart主要是我打算使用Dart来巩固一下基本功。用Java的话没什么激情，Scala又觉得有点难了。Dart比较轻量，语法也比较简单，虽然IDEA对它的支持还有点弱，但也基本够用了。另外在Dart社区现在正处于各种造轮子的阶段，大家一起造比较有气氛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译型由于Dart语言本身不支持动态执行代码，所以如果想实现一些较复杂的功能，比如在模板中直接使用Dart语法，则必须采用编译型，而不是解析型。我对于在模板是否允许嵌入代码持支持态度，因为一项功能用不用得好还是看使用者。另外采用编译型，在性能上有先天优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;采用灵活的语法即定义了标签的结构为&lt;code&gt;@tagname(paramType paramVariable: paramDescription) { ... }&lt;/code&gt;，但不在语法层面支持某一个具体的标签，而是根据tagname去找到对应的handler，实现相应的功能。这样可以让语法的解析变得简洁，并且容易扩展新的标签。其实之前已经做过了一个类似的模板引擎了，叫&lt;a href=&quot;https://github.com/freewind/RythmDart&quot;&gt;RythmDart&lt;/a&gt;，它采用了详细的语法定义，在语法分析阶段就已经可以识别出各标签了。这次想使用一种不同的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用PetitParser作为解析库据我所知，在Dart中目前有四种方式实现语法解析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯手写 比如&lt;a href=&quot;https://github.com/prujohn/dart-xml/blob/master/lib/src/xml_tokenizer.dart&quot;&gt;dart-xml&lt;/a&gt;，使用了自定义的语法解析，代码相当长。这种方式是多数编译原理课程上讲授的。&lt;/li&gt;
&lt;li&gt;PetitParser &lt;a href=&quot;https://github.com/renggli/PetitParserDart&quot;&gt;PetitPaserDart&lt;/a&gt;是一个简洁、灵活且强大的语法分析器，它本身也使用Dart写成。代码清晰易懂、文档和示例丰富，且直接内置了对json/xml/lisp/dart语法的解析程序。作者也非常热心，解答了我遇到的各种疑问，非常感谢他。还有一个好处是，PetitParser系列还有Java版与Smalltalk版，如果有一天想把该模板移植到java上，也很方便。&lt;/li&gt;
&lt;li&gt;parsers &lt;a href=&quot;https://code.google.com/p/parsers/&quot;&gt;parsers&lt;/a&gt;是另一个解析器，使用了更多的符号来减化语法的定义。因为PetitParser让我很满意，所以暂未尝试它。&lt;/li&gt;
&lt;li&gt;antlr for dart 这里有两个，一个是&lt;a href=&quot;https://github.com/tiagomazzutti/dartlr&quot;&gt;dartlr&lt;/a&gt;，使用antlr3的语法；另一个是&lt;a href=&quot;https://github.com/tiagomazzutti/antlr4dart-runtime&quot;&gt;antlr4dart&lt;/a&gt;，使用antlr4的语法，都是同一个作者。对于antlr我一直没有尝试，也许以后会试试它。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这四种方式中，我采用了PetitParser，因为对它比较熟悉，遇到问题也很容易向作者请教。事实证明，对于一个小型的模板引擎，采用它是相当方便的。&lt;/p&gt;
&lt;p&gt;下面就让我们一起，自己动手来实现这个模板引擎吧！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart中关于List.map的一个奇怪问题</title>
                <link>http://freewind.in/posts/2329-strange-problem-of-list.map-or-dart</link>
                <pubDate>Fri, 07 Mar 2014 23:47:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2329</guid>
                <description><![CDATA[&lt;p&gt;在写Dart时遇到了一个奇怪的问题，为了复现问题，把相关代码简化成下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int id = 0;

nextId() {
  print(&quot;########## currnet id: $id&quot;);
  return id++;
}

main() {
  var list = [1, 2, 3];
  var users = list.map((n) =&amp;gt; new User(&quot;user_${nextId()}&quot;));
  for (int i = 0; i &amp;lt; 10; i++) {
    print(users.first.name);
  }
}

class User {
  String name;
  User(this.name);
  toString() =&amp;gt; name;
}


我的本意是得到另一个users列表，然后调用它里面的元素。在循环里，反复输出`users.first.name`，直觉上应该都是`user_0`。

但结果却很意外：

########## currnet id: 0
user_0
########## currnet id: 1
user_1
########## currnet id: 2
user_2
########## currnet id: 3
user_3
########## currnet id: 4
user_4
########## currnet id: 5
user_5
########## currnet id: 6
user_6
########## currnet id: 7
user_7
########## currnet id: 8
user_8
########## currnet id: 9
user_9


看以看到，每次调用的结果竟然都不一样。

经过反复尝试(过程略)，发现问题出在`map`方法上。很多语言都为List提供了map方法，用于把List中的各元素转换为另一个对象。我一开始以为它返回的是另一个List呢，内容应该是确定的才对。

打印类型看看：

print(users.runtimeType)


发现是`MappedListIterable`. 这个类很神秘，在网上和Dart SDK里都找不到它的定义，但从行为上分析，发现它每次调用first，似乎都会重新执行一遍map中的代码。所以每次调用`.first.name`，都会生成一个新的User对象，于是调用了多次`nextId()`。

查了一下`List.map`的文档，发现它的确是这样的：

/**
 * Returns a lazy [Iterable] where each element [:e:] of `this` is replaced
 * by the result of [:f(e):].
 *
 * This method returns a view of the mapped elements. As long as the
 * returned [Iterable] is not iterated over, the supplied function [f] will
 * not be invoked. The transformed elements will not be cached. Iterating
 * multiple times over the the returned [Iterable] will invoke the supplied
 * function [f] multiple times on the same element.
 */
Iterable map(f(E element));


如果想拿到一个确定的List，不要忘了再调用一下`toList()`:

var users = list.map((n) =&amp;gt; new User(&quot;user_${nextId()}&quot;)).toList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再运行该代码，发现每次打印的值都是user_0了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart中unittest用法详解</title>
                <link>http://freewind.in/posts/2324-guide-of-unittest-in-dart</link>
                <pubDate>Fri, 31 Jan 2014 23:36:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2324</guid>
                <description><![CDATA[&lt;p&gt;这半年的项目经验告诉我：要想稳打稳扎的学习一门语言，首先应该学习它的测试框架，然后以测试为基础，逐步学习更多的语言细节、每三方库。&lt;/p&gt;
&lt;p&gt;这样做的好处是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们可以快速尝试并验证新的知识点，得到一个确定的结果&lt;/li&gt;
&lt;li&gt;可以留下一份活文档，可随时运行和回顾&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是一门还不太成熟稳定、API经常变化的语言，还有一个额外的好处：运行一遍测试就知道新版本中破坏了以前的哪些功能，可以立刻更新原有的知识。&lt;/p&gt;
&lt;p&gt;我打算重拾Dart，来实现我建立一棵知识树的学习计划，结果发现以前的代码全都跑不起来了，非常郁闷。所以便以此为机会，先把Dart的单元测试框架搞懂。&lt;/p&gt;
&lt;p&gt;Dart内置了一个单元测试框架，就叫unittest。它从jUnit中借鉴了不少，尤其是类似于harmcrest的api，如果你熟悉的话，可以很快上手。但由于Dart语言中大量使用Future，所以需要特别学习一下它的异步测试。&lt;/p&gt;
&lt;p&gt;这篇文章将分成四个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础用法&lt;/li&gt;
&lt;li&gt;异步测试&lt;/li&gt;
&lt;li&gt;自定义matcher等高级用法&lt;/li&gt;
&lt;li&gt;内部实现机制（以后补）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;边学边写，不断补充。&lt;/p&gt;
&lt;p&gt;（如果有同学也对Dart感兴趣，欢迎加入QQ群：322215472）&lt;/p&gt;
&lt;h2&gt;Unittest基本用法&lt;/h2&gt;
&lt;p&gt;一个最简单的单元测试&lt;code&gt;test.dart&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &apos;package:unittest/unittest.dart&apos;;
main() {
    test(&quot;simple test&quot;, () {
        expect(1 + 2, 3);
    });
}


相应的项目依赖文件`pubspec.yaml`：

name: learn-dart-unittest
dependencies:
  unittest: any


### 命令行运行该测试

下载依赖：

pub install


运行测试：

dart test.dart


输出如下：

unittest-suite-wait-for-done
PASS: simple test

All 1 tests passed.
unittest-suite-success


### IDEA dart插件运行

我使用IDEA中的dart插件运行该测试，会报错。原来必须为`test.dart`指定一个`library`，名字随便写，比如：

library mytest;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以参考这个问题：&lt;a href=&quot;http://stackoverflow.com/questions/17388363/how-to-run-unittest-with-idea-dart-plugin&quot;&gt;http://stackoverflow.com/questions/17388363/how-to-run-unittest-with-idea-dart-plugin&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>用最简单的gradle代码，解决java项目中的jar依赖之苦</title>
                <link>http://freewind.in/posts/2311-use-simplest-gradle-code-to-solve-dependencies-of-java-project</link>
                <pubDate>Sat, 25 Jan 2014 16:41:51 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2311</guid>
                <description><![CDATA[&lt;p&gt;有时候我们会随手建立一些小的java项目，写点代码，尝试点什么功能。如果使用到什么第三方库，把它们导入起来总觉得是一件麻烦事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手动下载jar包，在IDE中层层设置，还要处理它们的依赖&lt;/li&gt;
&lt;li&gt;使用IDE提供的从maven库下载&lt;/li&gt;
&lt;li&gt;使用maven, gradle等构建工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我尝试从零开始，使用最简单的gradle代码来解决这个麻烦，结果让人开心，比较方便。&lt;/p&gt;
&lt;h2&gt;下载gradle&lt;/h2&gt;
&lt;p&gt;在mac下使用brew:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install gradle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后可输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看是否安装成功。&lt;/p&gt;
&lt;p&gt;在linux下有apt-get或yum可用，windows可能也有类似工具，不过多数时候还是手动下载了。&lt;/p&gt;
&lt;p&gt;这是个一次性的工作，麻烦一次即可。&lt;/p&gt;
&lt;h2&gt;在项目下建立build.gradle文件&lt;/h2&gt;
&lt;p&gt;然后输入内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;groovy&quot;&gt;apply plugin: &apos;java&apos;

repositories {
    mavenCentral()
}

dependencies {
    compile(
            &apos;org.apache.commons:commons-lang3:3.2.1&apos;,
            &apos;org.apache.commons:commons-io:1.3.2&apos;,
            &apos;com.google.guava:guava:16.0&apos;
    )
    testCompile(
        &apos;junit:junit:4.11&apos;
    )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;依赖就定义好了。&lt;/p&gt;
&lt;p&gt;小技巧：需要jar包时，可到 &lt;a href=&quot;http://search.maven.org&quot;&gt;http://search.maven.org&lt;/a&gt; 上搜一下，将上面的格式写过来就行了&lt;/p&gt;
&lt;h2&gt;生成idea或eclipse项目文件&lt;/h2&gt;
&lt;h3&gt;Idea&lt;/h3&gt;
&lt;p&gt;对于intellij-idea，加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply plugin: &apos;idea&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后到项目根目录，输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle idea
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它就会自动下载依赖并生成idea需要的文件，全部搞定。&lt;/p&gt;
&lt;h3&gt;Eclipse&lt;/h3&gt;
&lt;p&gt;如果是eclipse，则加入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply plugin: &apos;eclipse&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再进行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle eclipse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;p&gt;上面的内容相当简单，背下来即可。如果不要求更多，这些内容就够用了。&lt;/p&gt;
&lt;h2&gt;Jetty&lt;/h2&gt;
&lt;p&gt;如果我们的项目是一个web项目，可以添加jetty插件，快速启动一个jetty server。&lt;/p&gt;
&lt;p&gt;只需要在build.gradle中添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apply plugin: &quot;jetty&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可。然后执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle jettyRun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就会启动server，默认以8080端口提供http服务。&lt;/p&gt;
&lt;h2&gt;wrapper&lt;/h2&gt;
&lt;p&gt;有时候我们希望在项目中提供一个gradle脚本，这样用户在clone下代码库后，就算机器上没有装gradle，也可以快速执行。&lt;/p&gt;
&lt;p&gt;我们需要在&lt;code&gt;build.gradle&lt;/code&gt;中添加一个task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;groovy&quot;&gt;task wrapper(type: Wrapper) {

gradleVersion = &apos;1.11&apos;;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面可以指定使用的gradle版本，我这里写的是最新版1.11&lt;/p&gt;
&lt;p&gt;然后在命令行执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gradle wrapper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就会自动在项目下生成几个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gradlew&lt;/li&gt;
&lt;li&gt;gradlew.bat&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及相应的jar。&lt;/p&gt;
&lt;p&gt;把这些文件都提交到服务器上即可。&lt;/p&gt;
&lt;p&gt;用户使用时，需要使用当前项目中的gradlew命令去执行gradle操作，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./gradlew idea
./gradlew jettyRun
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Java内置序列化与Gson性能比较</title>
                <link>http://freewind.in/posts/2306-java-serialization-and-gson-performance</link>
                <pubDate>Sat, 25 Jan 2014 16:20:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2306</guid>
                <description><![CDATA[&lt;p&gt;昨天与同事讨论问题，我犯了一个想当然的错误：我认为Java内置的Serialization机制（即java.io.Serializable）的性能要比Gson快很多，因为前者只是向流中写入或读出一些数据，而后者还需要对字符串进行词法分析等。&lt;/p&gt;
&lt;p&gt;今天写了一个测试之后，才发现事情并不是这样的，或者说，事情并不是这么简单。上代码。&lt;/p&gt;
&lt;p&gt;首先定义了一个java bean，名为User，它实现了java.io.Serializable接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User implements Serializable {
    private String aaa;
    private String bbb;
    private String ccc;
    private String ddd;
    private String eee;
    private String fff;
    private String ggg;

    // setters and getters for the fields
}


相应的一个`createUser`方法：

private static User createUser() {
    User user = new User();
    user.setAaa(newValue());
    user.setBbb(newValue());
    user.setCcc(newValue());
    user.setDdd(newValue());
    user.setEee(newValue());
    user.setFff(newValue());
    user.setGgg(newValue());
    return user;
}

private static String newValue() {
    return &quot;&quot; + System.currentTimeMillis();
}


下面是使用java内置序列化机制循环1000000万次：

long start = System.currentTimeMillis();
for (int i = 0; i &amp;lt; MAX_LOOP; i++) {
    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
    ObjectOutputStream stream = new ObjectOutputStream(byteStream);
    stream.writeObject(createUser());
    byte[] binary = byteStream.toByteArray();

    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(binary);
    ObjectInputStream input = new ObjectInputStream(byteArrayInputStream);
    input.readObject();
}
long end = System.currentTimeMillis();
System.out.println(&quot;Serialization cost: &quot; + (end - start) + &quot;ms&quot;);


结果是：

Serialization cost: 12339ms


然后是Gson版：

long start = System.currentTimeMillis();
Gson gson = new Gson();
for (int i = 0; i &amp;lt; MAX_LOOP; i++) {
    String json = gson.toJson(createUser());
    gson.fromJson(json, User.class);
}
long end = System.currentTimeMillis();
System.out.println(&quot;Gson cost: &quot; + (end - start) + &quot;ms&quot;);


结果是：

Gson cost: 3971ms


Gson的性能居然是Java内置序列化的3倍！

这个结果让我非常意外，猜想是不是默认序列化需要用到如反射之类的方式去取值才导致变慢呢？于是修改代码，在User类中增加了定制的内容：

private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    aaa = stream.readUTF();
    bbb = stream.readUTF();
    ccc = stream.readUTF();
    ddd = stream.readUTF();
    eee = stream.readUTF();
    fff = stream.readUTF();
    ggg = stream.readUTF();
}

private void writeObject(ObjectOutputStream stream) throws IOException {
    stream.writeUTF(aaa);
    stream.writeUTF(bbb);
    stream.writeUTF(ccc);
    stream.writeUTF(ddd);
    stream.writeUTF(eee);
    stream.writeUTF(fff);
    stream.writeUTF(ggg);
}


再重新测试，结果并没有好多少：

Serialization cost: 10793ms


又搜了一下资料，得知内置的序列化还需要处理与对象自身的一些信息，而这些信息对我们来说是没有用的。我们可以用Externalizable代替Serializable接口，如下：

class User implements java.io.Externalizable {
    // add new code to implement the methods

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(aaa);
        out.writeUTF(bbb);
        out.writeUTF(ccc);
        out.writeUTF(ddd);
        out.writeUTF(eee);
        out.writeUTF(fff);
        out.writeUTF(ggg);
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        aaa = in.readUTF();
        bbb = in.readUTF();
        ccc = in.readUTF();
        ddd = in.readUTF();
        eee = in.readUTF();
        fff = in.readUTF();
        ggg = in.readUTF();
    }
}


测试代码如下：

private static void tryExternal() throws Exception {
    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; MAX_LOOP; i++) {
        User user = createUser();
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        ObjectOutputStream stream = new ObjectOutputStream(byteStream);
        user.writeExternal(stream);
        stream.flush();
        byte[] binary = byteStream.toByteArray();

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(binary);
        ObjectInputStream input = new ObjectInputStream(byteArrayInputStream);
        user.readExternal(input);

    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;External cost: &quot; + (end - start) + &quot;ms&quot;);
}


结果：

External cost: 2740ms


这次很快，总算打败了Gson，代价就是需要自己手动维护写和读，这样的代码维护起来很麻烦，而Gson那边是不需要的。而且，性能差的也不远。

继续google，又发现了一个序列化相关的对比，而一个叫Kryo的开源项目提供的，参看网页：https://github.com/eishay/jvm-serializers/wiki

从里面可以看到，性能好坏与是否使用json无关，还是要看具体实现。比如阿里提供的fastjson的性能就远远好于其它，再比如排名第一的keyo（王婆卖瓜：）使用了二进制。

好奇之下，又测了一下它们两者的性能：

private static void tryKryo() {
    long start = System.currentTimeMillis();
    Kryo kryo = new Kryo();
    for (int i = 0; i &amp;lt; MAX_LOOP; i++) {
        // ...
        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
        Output output = new Output(byteOut);
        User user = createUser();
        kryo.writeObject(output, user);
        output.close();
        byte[] bytes = byteOut.toByteArray();
        // ...
        ByteArrayInputStream byteInput = new ByteArrayInputStream(bytes);
        Input input = new Input(byteInput);
        kryo.readObject(input, User.class);
        input.close();
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Kryo cost: &quot; + (end - start) + &quot;ms&quot;);
}


结果为：

Kryo cost: 3551ms


比Gson略好，但比Externalizable略差。不过它不需要手动维护写入读出的实现，所以还是比较方便的。

再看fastjson:

private static void tryFastjson() {
    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; MAX_LOOP; i++) {
        String json = JSON.toJSONString(createUser());
        JSON.parseObject(json, User.class);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Fastjson cost: &quot; + (end - start) + &quot;ms&quot;);
}


结果让人非常振奋：

Fastjson cost: 1691ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把其它对手都远远的抛在了后面，温少好样的~~&lt;/p&gt;
&lt;p&gt;上面的测试代码虽然比较粗糙，但还是可以感受到之间性能的差别。&lt;/p&gt;
&lt;p&gt;作为结论，我觉得如果使用合适的库，我们的确可以使用json作为序列化的中间格式，既高效，又易读。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http://stackoverflow.com/questions/21347670/why-java-built-in-serialization-is-worse-than-gson&lt;/li&gt;
&lt;li&gt;https://github.com/eishay/jvm-serializers/wiki&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>项目技术栈</title>
                <link>http://freewind.in/posts/2289-the-technical-stack-of-a-project</link>
                <pubDate>Sun, 19 Jan 2014 23:42:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2289</guid>
                <description><![CDATA[&lt;p&gt;总结一下当前项目使用的各技术。&lt;/p&gt;
&lt;h2&gt;基本工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt; 这是一个Java项目，我们用的是1.6版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt; 经过我们的推广，项目组全部使用IDEA community version。它对Java和git的支持相当好，对web开发要弱一些，不过我们项目里web占的比重很小。在结对以及团队培训的过程中，我们熟练的快捷键操作让新成员对IDEA有相当的期待。IDEA中各种流畅贴心的功能，实在是太方便了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git&lt;/strong&gt; 在多人团队里，git强大灵活的功能，让我们对代码提交、合并和管理有相当大的控制能力。不过对于新成员来说，git的难度还是比较大。另外在客户提供的电脑上，windows xp+cygwin，让git操作非常慢，随便一个操作都以分钟计。这对于当前情况来说是一个没法解决的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jenkins&lt;/strong&gt; 为了持续集成。Dev和Tester各有一条pipeline，从编译到单元测试到部署到端对端的测试，一条龙服务。虽然红多绿少，但这是从开始到现在所有人都强烈支持的东西。主要由刘峰同学负责维护，用得很熟练&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gradle&lt;/strong&gt; 构建工具。开始用的是maven，后来觉得太繁琐，在志恒同学的大力支持下，终于换成了gradle。虽然感觉速度上没快多少，但是用起来的体验要好很多，比如干净的输出，干净的语法。虽然自己还没写过代码，但是看到它详细丰富的文档，我觉得心里上没太多压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cygwin&lt;/strong&gt; 由于程序将部署在linux机上，所以本地也搞了一个cygwin仿真一下。由于客户机上各种安全限制，在cygwin上vi/git用起来经常各种出错，另外访问文件系统特别慢。只能忍。&lt;/p&gt;
&lt;h2&gt;程序库和框架&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring, Hibernate, Spring MVC&lt;/strong&gt; 企业开发的老三样。不过同样的东西，用得好跟用得不好完全是两回事。我们来之前的代码就不说了，后来在志恒同学的主导下，有一个模块里展示了它们比较好的用法之后，我总算觉得代码好看多了。现在的用法应该是主流的用法：注解+xml配置，声明性事务，注解标示controller。唯一的问题就是感觉现在的配置文件太多太乱，经常理不清头绪，还有spring在启动时报错实在不好调。我总觉得我们在项目里解耦解得有点多了，追求让每个模块都尽量保持独立，但最后又需要做不少额外的工作再把它们串到一起&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jetty&lt;/strong&gt; 项目主要是个后台程序，但需要通过web提供一些功能，所以内嵌了Jetty，由java代码启动Jetty，在web.xml里再初始化spring等。这样那些用来启动Jetty的类就无法被spring托管，有时候让人感觉别扭。我觉得还不如直接把项目做成一个web程序，更加方便一些。既可以直接以命令行的方式指定用jetty来启动它，也可以放到某个web容器里，更加灵活一些。不过现在前期已经做了太多，所以只能这样了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;commons系列和guava&lt;/strong&gt; 这差不多属于必备的了。我用commons比较多，志恒用guava比较多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMS&lt;/strong&gt; 程序与外部交换数据时，使用了一些商业产品的Jms server。内部也使用了一些开源的jms server，将某些操作分割为多个不同模块。我个人赞同作为数据源外部使用，但对于内部，似乎增加了不必要的“解耦”成本。有时候用多线程或并发库就能搞定的事情，用了jms queue以后，总觉得像是把一个整体硬生生的切成了几块，然后在它们之间插上了细管来保持交流。同一个模块里的东西，不是应该强调“高内聚”吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HttpClient&lt;/strong&gt; 项目需要通过Http与外部某些服务进行交互，使用了坑爹的HttpClient。这家伙从3.x到4.x，代码几乎全部重写；从4.0到4.3，又几乎重写两遍。在网上找的例子和代码，基本上都是过时的，一贴过来就报各种各样的Deprecated。我认为HttpClient是典型的过度设计，代码写得复杂无比，什么模式都往里面套。其实多数人用它也就是连个网页，下载或上传点什么数据。应该是一把水果刀，怎么就做成了铁锹。最为郁闷的是它对连接池的管理和各种超时设置，这种最容易出错、不清不楚的东西，很难找到文档详细描述它，我只能靠看源代码和写各种测试、连蒙带猜，到最后心里还是不太有底。最坑爹的是，它居然没有默认提供一个合理的超时时间，曾经我们本该几分钟跑完的程序，卡了十几个小时，就是因为它跟服务器端的http连接，怎么就卡着不动十几个小时。以后做项目一定避开它。&lt;a href=&quot;http://stackoverflow.com/questions/5415111/alternatives-to-apache-httpcomponents&quot;&gt;http://stackoverflow.com/questions/5415111/alternatives-to-apache-httpcomponents&lt;/a&gt;，里面提到了Jetty的HttpClient，有机会试一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Junit和Mockito&lt;/strong&gt; 单元测试必备，不多说。需要提一下的是，之前客户使用重型武器PowerMock来写测试，后来总算被我们干掉了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Args4j&lt;/strong&gt; 很不错的库。当我们需要给一个Java程序传大量参数时，用它可以优雅的解决参数传递的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dom4j&lt;/strong&gt; 需要解析XML，并使用Xpath从里面提供一些数据。我不喜欢XML，它本不应该这么笨重，多数时候我们只是简单的用到部分功能。我同样不喜欢Xpath，因为我没有找到以某个节点为根去定位元素的方法。（这里&lt;a href=&quot;http://stackoverflow.com/questions/2618136/running-xpath-on-child-node&quot;&gt;http://stackoverflow.com/questions/2618136/running-xpath-on-child-node&lt;/a&gt;提到了一种方式，以后试试。）不过对于企业内部不同系统之间交换数据，XML可能是最普遍的选择了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;snakeyaml&lt;/strong&gt; 测试里用它读取一些文件，根据测试数据生成一些实例，比较方便&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;moco&lt;/strong&gt; 没错，还用到了moco，不过只是在测HttpClient的那些超时参数时，用它来模拟一个会延时发送数据的http server。总体来说还是比较方便，不过可能我的用法比较偏，还是有一些问题。也许有时间时会再试试，提个Issue什么的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jquery&lt;/strong&gt; 有一些网页需要javascript。志恒同学开始想用Angularjs，被我们否决，毕竟到客户手里之后，基本上没人能维护了。最后还是用了最稳妥的jqurey和最普通的javascript写法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bash和Python&lt;/strong&gt; 用来写Shell脚本。简单的直接Linux的bash，繁杂的用python。这块主要由刘峰同学复杂，是他的强项。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>CleanCode读书笔记</title>
                <link>http://freewind.in/posts/2271-notes-of-book-clean-code</link>
                <pubDate>Sun, 19 Jan 2014 00:05:59 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2271</guid>
                <description><![CDATA[&lt;p&gt;正在看《代码整洁之道 Clean code》，本文将持续更新，记录学习中的疑问和重点。&lt;/p&gt;
&lt;h3&gt;书中第1章1.1到1.3.3写得太好了&lt;/h3&gt;
&lt;p&gt;太有共鸣了，简直就是对我当前项目情况的写实。一直在想当前项目的情况是不是特例，看到这里才发现，这种事果然是不断重复的。&lt;/p&gt;
&lt;p&gt;短短的三页，没经历过的人看着可能没感觉，一翻就过了，只有经历过的人才知道文字下的血泪。。。&lt;/p&gt;
&lt;h3&gt;书中多处提到了一个项目FitNesse，它是干什么的，有人用吗？&lt;/h3&gt;
&lt;p&gt;官网在这里：&lt;a href=&quot;http://fitnesse.org&quot;&gt;http://fitnesse.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;介绍：The fully integrated standalone wiki and acceptance testing framework&lt;/p&gt;
&lt;p&gt;公司内网一个很好的关于测试类型、工具、实践的PPT，里面把FitNesse归于BDD工具，跟[Cucumber]&lt;a href=&quot;http://cukes.info/&quot;&gt;http://cukes.info/&lt;/a&gt;分在一起&lt;/p&gt;
&lt;p&gt;好资料值得一看：&lt;a href=&quot;https://my.thoughtworks.com/docs/DOC-19567&quot;&gt;https://my.thoughtworks.com/docs/DOC-19567&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SO上一个关于它的问题：&lt;a href=&quot;http://stackoverflow.com/questions/598863/why-fit-fitnesse&quot;&gt;http://stackoverflow.com/questions/598863/why-fit-fitnesse&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大意是为了非程序员或非技术人士写测试用的。不过我大略扫了一眼FitNesse的文档，感觉让他们学习使用也不会是太简单的事。&lt;/p&gt;
&lt;p&gt;另外根据在公司论坛里的搜索结果，发现似乎用得不多哦。&lt;/p&gt;
&lt;h3&gt;P22 关于“接口和实现”中给名字加前后缀的问题&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;如果接口和实现必须选一个来编码的话，我宁可选择实现。ShapeFactoryImpl甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题：CShapeFactory前面的C，代码什么意思？是什么缩写？&lt;/p&gt;
&lt;p&gt;回答：[不知道，欢迎留言]&lt;/p&gt;
&lt;h3&gt;P23 类名&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;避免使用Manager, Processor, Data或Info这样的类名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我能说现在项目里全用上了吗？另外，不光有Processor，还有PreProcessor、PostProcessor，硬生生的以时间划分的方式，把代码逻辑切成了三部分。每次想搜点代码，都要在脑袋里想一遍这几个Processor到底有什么不同。类名完全没有体现出实际的功能。&lt;/p&gt;
&lt;p&gt;为什么不动手改呢？因为这些代码属于缺少测试的遗留代码，虽然我们已经多次靠加班把一些最难以忍受的地方改了，但是对于这种相对来说危害小一点问题，还是忍忍算了。&lt;/p&gt;
&lt;h3&gt;P24 每个概念对应一个词&lt;/h3&gt;
&lt;p&gt;目前项目中，经常有多个词对应同一个概念。比如一个在系统中作为id的值，有的地方叫uuid，有的地方叫guid，有的地方叫systemId。比如目录，有的地方叫directory，有的地方叫folder。再比如本地用于存放临时文件的目录，有的地方叫作dataDir，有的地方叫作processingDir。&lt;/p&gt;
&lt;p&gt;想把这些东西统一起来还真不容易。比如，团队里有的人坚持自己的命名方式，有的人坚持在命名方面每个人有自己的自由，有的人宣称自己无所谓所以一会儿用这个一会儿用那个。再比如，我们使用的第三方类库中，也出现不同的用词(folder/directory)。所以到最后就没人提了，反正大家都习惯了。&lt;/p&gt;
&lt;h3&gt;P27 不要添加没用的语境&lt;/h3&gt;
&lt;p&gt;文中说有一个Gas Station Deluxe的应用，在其中每个类前都加上GSD前缀。我们项目中，客户就曾经提议，把每个类的前面都加上XYZ(化名)的前缀，被我们强烈否决。&lt;/p&gt;
&lt;h3&gt;P3 勒布朗法则：Later equals never&lt;/h3&gt;
&lt;p&gt;有时候我们发现了问题，但手头上还有任务，就会说“我晚点再改”，十有八九就不会改，所以久而久之，这句话就等同于“我不想改”。所以现在一旦有人这么说，我们就会说这句法则“Later equals never”，不过对于客户来说，只能算玩笑。&lt;/p&gt;
&lt;p&gt;“晚点再改”，到底改还是不改，还是要看个人。我目前的做法是，简单的问题随手改掉，麻烦一点的记在便利贴上，等卡做完后再改。不过还是经常发现自己面前积了好多张已经变色的便利贴。&lt;/p&gt;
&lt;h3&gt;P12 童子军军规：让营地比你来时更干净&lt;/h3&gt;
&lt;p&gt;作为本年度获得“无底线团队”称号的团队，我们只能用这句话来提醒其他的同事了。“重构”之类差不多是奢望，毕竟在一个由多公司员工组成的团队中，有不少成员可能没听说过这个词。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;P33 一个函数只做一件事&lt;/h3&gt;
&lt;p&gt;这是一句听起来和说起来都很简单、很有道理的话，但看自己或别人的代码，一不小心就看到长长的函数，里面一口气把所有的事情做完。这种函数一般都会有一个模棱两可的名字，比如run/handle，然后把所有的逻辑放在一起，顶多抽几个被反复调用的工具方法出来。有的时候，还会添加空行和注释，把代码分成几块，帮助阅读。我相信随便打开一个项目，都能看到不少这样的函数。&lt;/p&gt;
&lt;p&gt;两种方法判断一个函数是否做了太多的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用以TO开头的一句话描述这个函数的功能，看是否能够轻松的描述清楚&lt;/li&gt;
&lt;li&gt;看能不能再拆出一个函数，这个函数不只是单纯的重新诠释一遍它的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;P34 每个函数一个抽象层级&lt;/h3&gt;
&lt;p&gt;这句话非常有用，和上一句一起，解答了我的一个很大的疑惑。&lt;/p&gt;
&lt;p&gt;在客户现场，我给新同事做了一个简单的重构培训，把项目中的一个长长的函数，重构成多个小函数，每个才几行甚至一两行。虽然新同事觉得现在的代码读起来比以前清楚了，但他们有一个担心：函数太多了，有时候很难清楚地看到它们之间的关系，不知道从哪儿入手。而写成一个长函数的话，只需要从上到下读完，就知道函数的功能了。如果把握分解函数的度呢？&lt;/p&gt;
&lt;p&gt;我对这个度实际上也不太清楚。之前在分解函数时，更多的是一种感觉。比如正在看一个函数，想了解它的作用，突然看到几行代码做了非常琐碎的事情，有种不耐烦的感觉。我不想知道它们是怎么做的，只想知道它们做了什么，这时就会顺手抽一个方法出去，并起一个合适的名字。&lt;/p&gt;
&lt;p&gt;有时候写完代码看回头看时，又发现刚才抽出去的方法过于抽象，就会把它们inline回来，再参照前后，考虑是否把它们抽成更多的方法。&lt;/p&gt;
&lt;p&gt;实际上这个过程，就是在努力的让一个函数里的代码，保持在同一个抽象层次。就像讲故事要娓娓道来，不能突然一句话一笔带过，让人没听懂怎么回事，也不能突然就找到一件小事啰嗦讲个不停，让人听得着急。所以有时候会把一些只有一两行的代码抽成一个函数，就是因为它们虽然短，但过于细节，跟前后的代码不在同一个抽象层次，这时就算抽出很多只有一两行的函数，也是值得的。&lt;/p&gt;
&lt;p&gt;说到这里，想起来我曾经在看play1的代码时，看到它有很多很长的方法，由于写得还比较清楚，所以当时并没有觉得应该再抽出更多的方法来。之前和别人讨论，我还用这个例子来说明，只要代码用心写，长点也可以很清楚。今天又找到了那些代码，发现又看不懂了，如果不一行行的仔细读下去，很难看懂它的主要逻辑。于是试着把它们重构一下，结果发现虽然方法多了，但逻辑的确比以前清楚多了。本想把相关代码全部重构好，发上来作个对比，但发现自己的重构功力还是不足，当需要对代码结构进行大的修改时，很难做到“不破坏编译”，于是打算等完全看完CleanCode和重构这两本书后再做。&lt;/p&gt;
&lt;h3&gt;P88 对象和数据结构&lt;/h3&gt;
&lt;p&gt;这一章触动相当大，值得好好思考。一般我们在代码里，很少使用public的fields，而是先定义一个private的field，再添加对应的getter/setter。很多的书和文章都告诉我们应该避免使用public字段，久而久之人们就视其为洪水猛兽。&lt;/p&gt;
&lt;p&gt;这种全部使用public字段定义出来的类，可视为一种数据结构，而不是对象。它跟我们通常所说的对象式的代码，正好是对立的。对立的意思是说，有一些事，使用数据结构很方便，但用对象式很麻烦；另一些事，可能正好相反。到底选择哪种实现方式，关键是要在这套系统中，我们是添加新类型的情况多，还是添加新行为的情况多。如果是前者，用对象更好；如果是后者，用数据结构更好。并没有说，因为java是面向对象的，我们就应该在任何情况都使用对象的方式。&lt;/p&gt;
&lt;p&gt;关于这一点，在coursera的《programming language》课中，也反复强调，甚至有一节，专门选用了一个题目，分别使用函数式加数据结构的方式，和面向对象的方式来实现。从中可以深切体会到，某些修改对于数据结构相当容易，另一些修改对于对象来说更加容易。&lt;/p&gt;
&lt;p&gt;书中这句话是一个很好的总结：老练的程序员知道，一切都是对象只是一个传说。有时候你真的想要在简单数据结构上做一些过程式的操作。&lt;/p&gt;
&lt;p&gt;不过结合到现实情况，大多数时候我们用java做的项目，都是企业应用或者网站之类，这类项目通常更适合使用对象式。而且平时使用的很多库，如spring/hibernate等，都会使用字节码增强，这种增强通常都能在方法层面上做，所以getter/setter是必要的。所以我们很少有机会使用public字段的数据结构。&lt;/p&gt;
&lt;p&gt;只是需要注意，我们不用，不是说明它就是邪恶的，只是我们的项目类型不合适。&lt;/p&gt;
&lt;h3&gt;P91 火车失事&lt;/h3&gt;
&lt;p&gt;我们经常会在代码中写这样的长长的调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String path = ctx.getOptions().getScratchDir().getAbsolutePath();


一直以来都觉得这没什么问题，直到看到这一章，才知道这是一种不好的调用。因为我需要知道`ctx`的内部实现，才能实现我的功能，这是一种耦合。相对应有一个叫“得墨忒耳律”来解释这个问题，相应的页面为[http://en.wikipedia.org/wiki/Law_of_Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter)，里面详细解释了定义、优势与劣势。我觉得里面有一句话很好：“你命令你的狗走路，而不是它的腿”。

但书中也提到，如果我们调用的是一堆数据结构，那么是没有问题的。因为数据结构就是要暴露实现，所以下面的代码反而是没问题的：

String path = ctx.options.scratchDir.absolutePath;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前提是它们都是数据结构，只有public字段，而没有方法。但是在Java中，这样的情况很少见，就算是数据结构，也会被包装成一个个javabean，由方法调用，让人搞不清它到底是数据结构还是对象。&lt;/p&gt;
&lt;p&gt;对于这样的代码，文中建议结合上下文，搞清楚那个&lt;code&gt;path&lt;/code&gt;到底是谁在用怎么用，然后把这串代码移到相应的类里去，暴露出一个方法来。&lt;/p&gt;
&lt;p&gt;我对这种代码还是很有疑惑。正如wiki里所说，它的劣势在于会产生很多wrapper方法，所以如果这样的串很长很多，我可能需要在很多类中建立很多wrapper方法，感觉会很乱。还有一种情况，前面说如果都是数据结构，那这样是没问题的，但如果我想提供一个方法（如getFullName()），仅仅是把几个字段（如firstName, lastName）组合一下返回过去，这到底还数据结构还是对象呢？那我还应不应该用长串调用？&lt;/p&gt;
&lt;p&gt;所以如果这个火车不长，我还是可以接受的，或者看看有没有更好的方法避免它们，但不会建立一大堆没有意义的wrapper来绕开。&lt;/p&gt;
&lt;p&gt;如wiki最后所说，这个律普通是用来衡量代码话味道的一种标准，而不是一种解决方法。&lt;/p&gt;
&lt;h3&gt;P92 混杂&lt;/h3&gt;
&lt;p&gt;这里提到了一些类，一半是数据结构，一半是对象。既把一些私有值直接或通过getter暴露给外部，让外部处理，又提供了一些方法隐藏内部实现。这种做法是两边都不讨好的做法，让以后的维护变得困难。&lt;/p&gt;
&lt;p&gt;这样的代码应该很常见，特别是当我们习惯于无理由添加很多getter把private field暴露出去的时候。希望能意识到这个问题，在平时写代码时注意。&lt;/p&gt;
&lt;h3&gt;P93 DTO&lt;/h3&gt;
&lt;p&gt;DTO是数据传送对象，我们一般是写成一个java bean，一个private field对应一对getter/setter。按书中的说法，这种情况我们其实可以直接使用public字段。写成java bean的形式，更多是会让某些OO纯化论者感觉舒服一些，并没有更多的好处。&lt;/p&gt;
&lt;h3&gt;P94 Active Record&lt;/h3&gt;
&lt;p&gt;它的定义是：是一种特殊的DTO，除了拥有可公共访问的数据结构，通常还会有如save, find这样的方法。它们一般是对数据库表或其他数据源的直接翻译。&lt;/p&gt;
&lt;p&gt;我们应该把它们当作数据结构来用，而不要往它里面塞入业务方法。如果需要的话，可以新建一些对象提供这些方法，在内部使用它们。&lt;/p&gt;
&lt;h3&gt;P99 如果我们调用的第三方方法抛出很多种异常&lt;/h3&gt;
&lt;p&gt;经常会遇到这样的情况，调用一个第三方库提供的方法，它里面抛出了三四种受控异常。通常我们会在自己的业务代码中，使用多个catch来分别捕获分别处理，代码就会看起来很乱，真正有价值的业务代码被淹没在大片的错误处理之中。在多数情况下，对于这多个异常的处理方式都是相似或者相同的。&lt;/p&gt;
&lt;p&gt;对于这种情况，书中推荐的做法是，自己定义一个类去包装那个第三方类，提供等价的方法把各异常捕获后，统一抛出一个自定义的异常，在自己的代码中只处理它即可。这样做可以让我们的代码看起来很干净，同时又能将第三方实现隔离开。&lt;/p&gt;
&lt;p&gt;不过在实际中，对于一些不太重要的系统，我们往往直接catch那个Exception类，一了百了，然后在最外层的某个地方，再统一处理一下。虽然感觉有点草率，但相对于“分别处理错误”而增加的代码和复杂度相比，这样可能还会减少一些出错的可能性。毕竟见过太多程序员连正常的业务功能都很难实现好，更别说错误处理这么有技术含量的事情了。而且所谓的“出错处理”大多数情况只是记下日志而已。&lt;/p&gt;
&lt;h3&gt;P98 关于可控异常和不可控异常之争&lt;/h3&gt;
&lt;p&gt;“辩论已经结束！”&lt;/p&gt;
&lt;p&gt;使用可控异常是一种不好的做法，因为当我们在底层代码的方法签名中增加了一个可控异常时，所有调用了这个方法的高层代码都需要修改，然后重新构建、发布，哪怕它们自身所关注的任何东西都没改动过。这种方式破坏了封装。&lt;/p&gt;
&lt;p&gt;同时几乎其它所有语言都不支持可控异常，但并不阻碍使用它们写出健壮的代码。所以可控异常不是必须的，而且是不好的。&lt;/p&gt;
&lt;p&gt;只有当我们编写一套关键代码库，里面的每一个异常都必须小心处理时，可控异常才有用，因为它会强迫提醒你处理这些异常。但对于大多数一般的应用开发，它的依赖成本要高于收益。&lt;/p&gt;
&lt;p&gt;这一节解答了我多年的疑惑，因为这个争论持续了很多年。特别是当年我在topcoder上做项目时，也看到相关的讨论，当时人们的结论是它有很必要，因为就算是不可控的异常，我们也必须一一小心处理，这样的话，使用可控异常更保险一些。&lt;/p&gt;
&lt;p&gt;但现在我认为小心处理是必要的，但是可控异常却不是必要的。因为我们会有单元测试去保证我们对异常的处理是正确的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>项目困境</title>
                <link>http://freewind.in/posts/2266-predicament-of-project</link>
                <pubDate>Wed, 08 Jan 2014 01:29:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2266</guid>
                <description><![CDATA[&lt;p&gt;今天又是饿着肚子在公司加班到九点多才回去，情绪非常低落。感觉当前的项目已经陷入了困境，不知道如何是好，对目前这种状态也非常的无奈。&lt;/p&gt;
&lt;p&gt;从七月份过来，在这个项目上已经快半年了，也许年后就会撤离。我以前没有参与过像现在这种状况的项目，所以迷茫过，思考过，努力过，但是到了现在，更多的是一种无奈感。&lt;/p&gt;
&lt;p&gt;大概从两个月前开始，我们这几个派到这个项目的成员就进入了每日加班的状态。八点离开算是比较早的，通常都会在九点左右，而在每个sprint快结束的两天，基本都是11点多才走。更郁闷的是，因为客户公司位置比较偏，四周连快餐店也没有，所以都是饿着肚子，吃点小东西垫一下。&lt;/p&gt;
&lt;p&gt;如果加班是在爽快的写代码，但是没什么可抱怨的，但实际情况却是把时间和精力花在了各种让人心情不爽的事情上。&lt;/p&gt;
&lt;h2&gt;一、本地编译和测试，实在太漫长了&lt;/h2&gt;
&lt;p&gt;每个人在把代码push到git repo前，都需要先在本地跑一遍测试，都通过了才能提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./gradlew clean build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要10分钟！如果中间再出个错修一下，再来一次，半个小时就进去了。最郁闷的就是，好不容易跑完了，&lt;code&gt;git push&lt;/code&gt;，结果发现被人抢先了，只能重新&lt;code&gt;pull&lt;/code&gt;，再merge，再跑测试，再提交，超级浪费时间。&lt;/p&gt;
&lt;p&gt;另外，在一个有十多人提交的团队里，如果你不尽快push，就只能在本地攒着很多commit，等到push的时候merge是少不了的，一个不小心就把代码搞坏了，再一点点的修真让人欲哭无泪。但如果尽快push，那就意味着要经常在本地跑clean build，而那每次10分钟左右的时间是跑不了的。&lt;/p&gt;
&lt;p&gt;这10分钟花在哪些方面了呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目由十多个module组成，每次clean build，都需要先删除所有临时文件，然后处理资源文件、编译代码、跑单元测试、集成测试、打包等。module越多，意味着步骤越多，时间越长&lt;/li&gt;
&lt;li&gt;集成测试需要连接到远在国外的数据库和存储服务器上操作，有时间一个测试要跑半分多钟&lt;/li&gt;
&lt;li&gt;有一个测试专用的module，里面有几千个文件，需要打包，要花不少时间&lt;/li&gt;
&lt;li&gt;程序运行于windows xp上的cygwin中，超慢&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;项目一开始用的是maven，后来改成了gradle，但运行时间并没有多少改善，只是代码灵活可读一些。&lt;/p&gt;
&lt;h2&gt;二、每个人的测试都可能受别人的影响&lt;/h2&gt;
&lt;p&gt;如果每个人的环境是确定的，10分钟到也不是不能接受，更大的问题是：每个人的测试都可能因为别人的操作而失败！&lt;/p&gt;
&lt;p&gt;因为测试中依赖于外部的jms server，数据库。对于jms，每个人都有自己独立的帐号，但也难避免有人误操作把自己的数据误发送到别人的broker里，导致别人的测试失败。数据库更惨了，大家用的都是同一个帐号（因为客户公司的限制）。如果有两人同时在跑，很可能就会有人失败。所以整天经常能听到有人在吼：“是不是有人在跑本地测试？！”&lt;/p&gt;
&lt;p&gt;对于数据库的问题，我们早已申请多套帐户了，但直到现在也没有下文。我们还申请在本地安装数据库，在长久的等待之后，IT们终于在今天装上了，但好像装的不对（只管装，不管对），没法用。&lt;/p&gt;
&lt;p&gt;这只能再催那些IT老爷们了。要知道，在这里提出一个请求，合理的响应时间是按周算的。&lt;/p&gt;
&lt;h2&gt;三、CI灯一红一整天，不敢提交&lt;/h2&gt;
&lt;p&gt;我们安装了CI灯来监视Jenkins上的pipeline，如果失败灯就是红的。现在的情况是，一天中有大半天是红的。&lt;/p&gt;
&lt;p&gt;原因很简单，在本地跑测试实在太浪费时间，而每天的任务又很多，所以不少人偷懒，觉得自己改的没问题，直接就提交了，红了之后再修。&lt;/p&gt;
&lt;p&gt;还有就是有些测试太费时间，所以在本地跑测试时就把它们跳过了，结果到Jenkins上跑全套时才发现问题。&lt;/p&gt;
&lt;p&gt;修的时候要现场分析原因，看是自己改错了，还是别人跑测试影响了自己。修完之后自然就要老老实实的跑完全套测试才敢提交，又要花不少时间。这样一来一回，平均红一次要修一个小时，还没绿一会儿又红了。&lt;/p&gt;
&lt;p&gt;今天我好几次想提交代码，发现灯都是红的，只好等，一直到下班攒了十几个commit才有机会提交。然而出现了merge上的问题，再加上多次跑测试，一共花了我一个多小时，才把代码提交上去。&lt;/p&gt;
&lt;p&gt;注：由于红光太刺眼，我们拿白纸给它做了一个套子罩着。&lt;/p&gt;
&lt;h2&gt;四、坑爹的sign off测试&lt;/h2&gt;
&lt;p&gt;客户要求，对我们完成的每一个story，在当前迭代结束时，都要进行验收，达到他们的认可才给sign off签字。而他们的验收测试，是“自动化的端对端测试”，即写一套测试工具，通过脚本启动产品系统，然后模拟外部系统向产品发数据，再到数据库、存储服务器中检查产品是否写入了正确的数据。&lt;/p&gt;
&lt;p&gt;这种测试非常脆弱，因为每一个sign off过的story中的代码，在做其它story时都可能修改。另外外部依赖的数据库，jms server等，很容易受影响出错。一旦出错，麻烦事就来了。因为测试人员需要从四个方面考虑出错的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产品代码有误&lt;/li&gt;
&lt;li&gt;测试工具的代码有误&lt;/li&gt;
&lt;li&gt;提供的测试数据有误&lt;/li&gt;
&lt;li&gt;测试环境被人影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后打开长长的各log文件，根据错误日志去跟踪代码的处理流程，一点点排查。往往解决一个问题就花一天，然后第二天又伤心地看着它又出错了。&lt;/p&gt;
&lt;p&gt;哦，我还忘了说，测试人员一下子提供了2000多种不同的测试数据，一条条测，一次下来需要一个半小时。所以test pipeline基本上都没见绿过。&lt;/p&gt;
&lt;p&gt;这还是在项目的开头，就把三个测试人员忙得不行了。而马上还会有基于页面元素的模拟手动操作的测试，而且每个迭代过后，都会多出几十上百条新的测试。。。&lt;/p&gt;
&lt;p&gt;我只想说，测试人员，你们实在太命苦了。（我会告诉你，在两周之前，所有的测试工作都是我做的吗？！好在现在被新加入的测试小组接手了）&lt;/p&gt;
&lt;h2&gt;五、奇慢无比的cygwin和git&lt;/h2&gt;
&lt;p&gt;我们的工作机是windows xp，上面装了cygwin，cygwin上装了git。可怜的git，现在被拖累得有多么慢知道吗？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git stash 超过1分钟&lt;/li&gt;
&lt;li&gt;git pull -rebase 每个commit要花1分钟&lt;/li&gt;
&lt;li&gt;git commit 每个commit要花1分钟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些每天要运行无数次的命令，实在是让人等得吐血。要知道我们都换了SSD了，但还是这么慢！&lt;/p&gt;
&lt;p&gt;客户的IT部门有严格的管理政策。不开放管理权限，不允许自己装软件。连git都是通过cygwin装上的。&lt;/p&gt;
&lt;p&gt;而当我们想装什么软件时，只能在IT提供的一套看着就不像是技术人员提供的软件清单中找，然后提申请，等他们在以周为单位的“合理时间”内回应。&lt;/p&gt;
&lt;p&gt;由于我们不能自己装软件，所以我们无法在自己的电脑上部署一套适合开发的环境，并选择适合自己的开发工具，所以才会在测试里去连国外的服务器，才会多人共用帐号，才会有各种冲突，才会奇慢无比。&lt;/p&gt;
&lt;p&gt;无能的IT部门提拖累整个开发团队的重要原因。&lt;/p&gt;
&lt;h2&gt;六、只挑刺不干活的manager们&lt;/h2&gt;
&lt;p&gt;在国内办公室的这群开发人员都是干活的，而国外那边的各manager们都是只挑刺不干事的。比如项目经理，总是高高在上的问我们进度，或者开会，却几乎不为我们分担压力；比如拥有sign off权限的测试经理，只会布置测试任务，然后挑代码让这边解释为什么这么写。你又不写代码，管这些干什么？！有这功夫把你们提供的测试数据写对先。每次给的测试数据都有各种问题，还要让这边的测试组和开发人员花大量的时间找原因，告诉你们哪里有误。还有这个坑爹的端对端测试，你们省事了，这边被你们累死了。从来都是看到你们准点下班。&lt;/p&gt;
&lt;p&gt;那一帮拥有管理权限但不干事的manager们，布置了各种听起来很有道理很有必要的任务，实际上只是一帮只动嘴不做事的人。&lt;/p&gt;
&lt;h2&gt;七、代码&lt;/h2&gt;
&lt;p&gt;最后不能不说的就是代码了。我们进入的有点晚，来的时候客户已经写了不少有各种问题的代码了。从过来的第一周，客户就在准备“下周”的上线，所以我们不好尽早参与到代码的改进中。结果这个“下周”，在推迟了8次以后，终于上线了。而我们失去了在一开始改进代码的宝贵机会。因为上线的代码是不允许随便改的（特别是客户的代码基本上没有测试），而后来的任务越来越多，并且都要基于第一次上线的代码，我们只能想各种办法把新代码与原来的代码隔离开，用了各种别扭的手段。结果终于在一个月前，我们不能不承认，第一次上线的代码是绕不开的，这才下定决定进行重构。可惜的是，我们已经在它的基本上写了更多的代码，重构时困难重重，因为现在的测试跑一次可是要十分钟以上，并且很容易跟其它人冲突，导致更多的问题。&lt;/p&gt;
&lt;p&gt;今天有点晚了，就写这么多，可能还漏掉了不少关键的东西。这些东西看起来像是抱怨，就当作是无可奈何的一种发泄吧。现在我们几个的生活已经简化为：“上班-&gt;加班-&gt;睡觉” 这样的循环了。&lt;/p&gt;
&lt;p&gt;上面说的这些问题，我们几个私下也讨论了很多次，也想过很多办法解决，但是看现在的情况，都不报多少信心了。我们这两周正在重构那些代码，经常一干就干到夜里三点（辛苦恒恒同学了），但能起到多少作用，都不抱希望，只能当做是在做一些对得起自己内心的事情了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>分解的粒度</title>
                <link>http://freewind.in/posts/2257-the-scope-of-splitting-code</link>
                <pubDate>Sun, 22 Dec 2013 18:53:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2257</guid>
                <description><![CDATA[&lt;p&gt;这篇日志真不好写，已经重写了两遍，每次都是写到一大半时，发现自己对于问题本质的理解不对，于是删了重写，内容也完全不同。希望这次能把它写完。&lt;/p&gt;
&lt;p&gt;日志的起因是我们项目里需要写一个测试工具，我写的代码受到了同事的质疑，他认为我的方案要写太多的类，而且宁愿用&lt;code&gt;if...else&lt;/code&gt;来做。&lt;/p&gt;
&lt;p&gt;简单的说，这个测试工具，需要对不同Module的不同检查点进行检查。可以假设我们有下面一张表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ||---------------||---------------||---------------||------------------||
 || Module Name   ||  Dir Checker  ||  DB Checker   || Storage Checker  ||
 ||---------------||---------------||---------------||------------------||
 ||    ModuleA    ||       Y       ||     OK        ||    /aaa.xml      ||
 ||---------------||---------------||---------------||------------------||
 ||    ModuleB    ||       Y       ||     OK        ||    /bbb.xml      ||
 ||---------------||---------------||---------------||------------------||
 ||    ModuleC    ||       N       ||   FAILED      ||    /ccc.xml      ||
 ||---------------||---------------||---------------||------------------||


我们的测试工具，需要读取这样的一个表，根据其内容对相应的Module和检查点进行检查。

## 我的方案

我的方案是将每个Module的每个检查点，都作为一个独立的类。这样当以后有新的Module或检查点出现时，可以不用修改已有任何代码，只需要创建新类。

对于上表中的ModuleA，定义了三个类:

class ModuleADirChecker {
     void check(String shouldInOrNot);
}
class ModuleADbChecker {
     void check(String expectedStatus);
}
class ModuleAStorageChecker {
     void check(String remotePath);
}


对于ModuleB和C，也将会各有三个类，这样就会有9个类。

如何将每个类与module/checkpoint匹配起来呢？最简单的方式是通过一堆`if...else...`来判断：

public void getChecker(String module, String checkPoint) {
    if(module.equals(&quot;ModuleA&quot;)) {
         if(checkPoint.equals(&quot;Dir Checker&quot;)) {
              return new ModuleADirChecker();
         } else if(checkPoint.equals(&quot;DB Checker&quot;)) {
              return new ModuleADbChecker();
         } else if(checkPoint.equals(&quot;Storage Checker&quot;)) {
              return new ModuleAStorageChecker();
         }
    } else if(module.equals(&quot;ModuleB&quot;)) {
         ...
    } else if(module.equals(&quot;ModuleC&quot;)) {
         ...
    }
}


我想到用注解，可以会让代码更加独立一些，于是写了一个`CheckerAnno`注解，这么用：

@CheckerAnno(module=&quot;ModuleA&quot;, checkPoint=&quot;Dir Checker&quot;)
class ModuleADirChecker {
     void check(String shouldInOrNot);
}


每个checker上，都放一个`CheckerAnno`，指示它匹配的是哪个module和checkPoint。在程序运行时，将会扫描代码，根据`CheckerAnno`中的数据，自动把各checker与excel表中的单元格匹配起来，生成实例，传入数据进行检查。这样我们就不需要写上面那个长长的`getChcker`方法了，并且以后添加新的Module或者Column时，也不需要修改**任何**已有代码。

## 同事的方案

同事觉得我的方案不好，因为他觉得我的类太多了。而且他发现，某些检查点虽然要检查多个Module，但它们的逻辑非常相似。比如`Dir Checker`仅仅需要不同的Module提供一个不同的值，实际的检查逻辑是一样的。

他给出的方案是：每个检查点一个类，在类里通过`if...else`来针对不同的Module做不同的检查。比如对于`DirChecker`，他是这么做的：

class DirChecker {
    public void check(String moduleName, String shouldInOrNot) {
        File dir = getDir(moduleName);
        checkDir(dir, shouldInOrNot);
    }
    private File getDir(String moduleName) {
        if(moduleName.equal(&quot;ModuleA&quot;) {
            return localTempDirOfModuleA();
        } else if(moduleName.equals(&quot;ModuleB&quot;)) {
            return localTempDirOfModuleB();
        } else if(moduleName.equals(&quot;ModuleC&quot;)) {
            return localTempDirOfModuleC();
        } else {
            throw new IllegaArgumentException(&quot;Unknown module:&quot; + moduleName);
        }
    }
}


对于其它的每一个检查点，也都需要定义一些这样的类，每个类中通过`if...else`来决定哪个Module进行哪种检查。

我觉得他这种方式的关键，不在于是否使用了`if...else`，因为他也可以使用注解来实现，跟我那种一样：

@CheckPoint(&quot;Dir Checker&quot;)
class DirChecker {
    @CheckModule(&quot;ModuleA&quot;)
    public void check1(String shouldInOrNot) {
         ...
    }
    @CheckModule(&quot;ModuleB&quot;)
    public void check2(String shouldInOrNot) {
         ...
    }
    @CheckModule(&quot;ModuleC&quot;)
    public void check3(String shouldInOrNot) {
         ...
    }
}


然后可使用相同的方式扫描注解，将每个check方法与相应的module和checkpoint匹配起来。虽然每当增加一个新Module时，他需要修改已有的类，添加一个新的方法并加上相应的注解，但由于这样的方法相当于一个入口，不会修改已有的逻辑，所以也是可以接受的。

## 第三种方案

可以很自然的想到第三种方式：以行为类。即为每个Module定义一个类，里面提供多个方法分别对应每个检查点。如果用注解的话，大约是这样的：

@CheckerModule(&quot;ModuleA&quot;)
class ModuleA {
    @CheckPoint(&quot;Dir Checker&quot;)
    public void check1(String shouldInOrNot) {}
    @CheckPoint(&quot;Db Checker&quot;)
    public void check2(String expectedStatus) {}
    @CheckPoint(&quot;Storage Checker&quot;)
    public void check3(String remotePath) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;问题的本质&lt;/h2&gt;
&lt;p&gt;所以问题的关键就在于粒度：对于这个例子，哪种粒度更好？行？列？还是单元格？&lt;/p&gt;
&lt;p&gt;如果说这三种方案都是差不多的，随便选一个就行，那就省事了，看自己的喜好即可。否则的话，我应该以什么为考虑的重点，来决定采用哪一种粒度呢？&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;有同学说看不懂我在问什么。&lt;/p&gt;
&lt;p&gt;的确我也感觉不知道自己在问什么，因为这个问题产生于真实的项目，很多影响我思考的因素也许在本文外，但我还没有意识到。从一个复杂项目中，把一个问题以最简方式完整的剥离出来，本身就是一件很难的事吧。如果真的能把所有有关联的因素抽出来了，所有没有关联的因素都留下了，也许答案自然就出来了，不需要再问了。&lt;/p&gt;
&lt;p&gt;看来这个问题只能等我自己解决了。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;杨博&lt;/h3&gt;
&lt;p&gt;你的同事对，你错。&lt;/p&gt;
&lt;p&gt;你用的技巧，耦合更低，如果基类要提供给第三方，让第三方自己实现派生类，那就很好。&lt;/p&gt;
&lt;p&gt;但这个例子是你们的内部测试代码，属于一个模块内部的实现，当然应该遵循“高内聚”而不是“低耦合”原则。那么你同事代码短，耦合重，都是优点。&lt;/p&gt;
&lt;p&gt;当然，如果你们部门决定把测试时常用模式提成一个框架，让所有测试代码遵守这个框架的限制。那么作为框架的设计，也许可以重新考虑你用的基类方式。&lt;/p&gt;
&lt;h4&gt;我&lt;/h4&gt;
&lt;p&gt;@杨博，谢谢你高质量的回复。你提到的几点，我想了一下，现在这个测试工具的确已经成了一个测试框架，由测试组的成员使用，不过仅仅是当前项目的测试组内部使用。他们在未来所写的所有测试代码，都要按同样的规则来写。&lt;/p&gt;
&lt;p&gt;另外我刚才又回想了一下，发现当时我这么设计还有一个原因：&lt;/p&gt;
&lt;p&gt;虽然会以excel表格的形式来定义一些测试，但同时还需要支持纯手写java代码的方式，来实现一些特殊的测试用例。&lt;/p&gt;
&lt;p&gt;这些测试用例通常只会对应某一个module，这样我就可以方便的直接实例化某个特定的类，如new ModuleADbChecker().check(…)，非常干净。如果用同事的方法，就会变成new DbChecker().check(“ModuleA”,…)，感觉调用了一个很大的方法，实际上只用到了其中很小的一块代码。&lt;/p&gt;
&lt;p&gt;这样分析的话，我认为我的粒度还是最合适的。多谢你的意见！&lt;/p&gt;
&lt;h3&gt;liusong1111&lt;/h3&gt;
&lt;p&gt;类多类少不重要，是否采用switch/case不重要;代码朴素很重要。你怎么也犯java系的通病了呢，”未来扩展”、”代码优美”，这些事在真正发生之前根本一点都不重要，一点都不应该考虑。面向对象，尤其是java系的面向对象，就是纸老虎，还不如手写utils静态方法接地气。&lt;/p&gt;
&lt;p&gt;你的方式合理。那个StorageService就是一个util&lt;/p&gt;
&lt;h4&gt;我&lt;/h4&gt;
&lt;p&gt;@liusong1111，哈哈，在现在的公司的大环境下，朴素不起来啊。这些天正在看设计模式、重构这些书，不自觉就想在工作里练练手。&lt;/p&gt;
&lt;p&gt;另外还有两个原因：&lt;/p&gt;
&lt;p&gt;一是这个项目的客户要对每一个完成的功能点签字，一旦上线再想修改就非常麻烦，所以只能趁上线前多想一点。&lt;/p&gt;
&lt;p&gt;二是我们来之前的代码，一方面到处是完全没用上的扩展点，另一方面是朴素的连单元测试都没法加的代码，已经让我们加了两个月的班。&lt;/p&gt;
&lt;p&gt;所以我们正在吸取教训，让现在写的代码方便测试，耦合度低一点儿。&lt;/p&gt;
&lt;h3&gt;AlsoTang&lt;/h3&gt;
&lt;p&gt;我也觉得你同事的方法或许比剩下两种方法更加能够抽出共性来。&lt;/p&gt;
&lt;p&gt;例子太小，怎么做都足够灵活。
&lt;br  /&gt;凡是能够用继承做的地方，用组合做其实都很容易。&lt;/p&gt;
&lt;p&gt;但在这个地方明显是 is-a 的关系嘛。&lt;/p&gt;
&lt;p&gt;这么说吧，如果以后 StorageService 提供了更丰富的功能的话，那么 UserStorageService 用不用跟进去实现？
&lt;br  /&gt;如果总是要跟进的话，那么就应该是继承的；如果不必跟进，只是简单利用 StorageService 的 save 和 get 接口的话，那么就组合。&lt;/p&gt;
&lt;p&gt;在这个地方来说，难道 UserStorageService 不是应该一直跟进 StorageService 的新功能的吗？&lt;/p&gt;
&lt;h4&gt;我&lt;/h4&gt;
&lt;p&gt;回答@AlsoTang的问题，在我们实际的使用中，发现是把UserStorageService当作一个窄化的接口来用的，即只会使用它里面定义的方法，而不会用到父类里的。所以我现在更肯定它用组合好一些，也许命名方面应该改改。&lt;/p&gt;
&lt;h3&gt;kou_zx&lt;/h3&gt;
&lt;p&gt;我觉得不用非得定死按行还是按列分粒度，我觉得对于一个checker，如果逻辑相似（比如你说的DirChecker）就写一个类里，逻辑差距比较大就按module分类&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>项目中的一处java代码，是否应该使用继承？</title>
                <link>http://freewind.in/posts/2241-do-i-need-to-use-inheritance-in-this-java-code</link>
                <pubDate>Sat, 21 Dec 2013 22:31:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2241</guid>
                <description><![CDATA[&lt;p&gt;在项目中遇到过几次使用了继承的情形，有的是别人用了但我认为不该用，有的是我用的但别人认为不该用。对于这些代码，虽然我有一些思考，但还是很不确定，所以记录下来，希望与更多的人交流。&lt;/p&gt;
&lt;p&gt;由于项目有保密要求，所以我对代码进行了一些修改，让它们成为更能用的问题。&lt;/p&gt;
&lt;h2&gt;例一&lt;/h2&gt;
&lt;p&gt;项目中使用了一个第三方存储设备，它提供了一些api供保存和读取。我们先定义了一个通用的存取类：&lt;code&gt;StorageService&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StorageService {
    public void save(String key, String content) { ... }
    public String get(String key) { ... }
}


可以看出这是一个很通用的服务类，可以根据key保存或读取一些文本。

项目中定义了很多module，都要用到这个StorageService，但要提供一些跟自己module相关的方法供调用，通常会提供与module相关的key。比如有一个`UserStorageService`:

public class UserStorageService extends StorageService {
    public void saveUser(String userId, String userInfoInXmlFormat) {
        super.save(&quot;user.info.&quot; + userId, userInfoInXmlFormat);
    }
    public String getUser(String userId) {
        return super.get(&quot;user.info.&quot; + userId);
    }
}


可以看到，`UserStorageService`继承了`StorageService`，同时提供了自己的方法供调用。看到这段代码时，我感觉似乎没有必要使用“继承”。如果是我的话，我会这么来写：

public class UserStorageService {
    private StorageService storageService = new StorageService();
    public void saveUser(String userId, String userInfoInXmlFormat) {
        storageService.save(&quot;user.info.&quot; + userId, userInfoInXmlFormat);
    }
    public String getUser(String userId) {
        return storageService.get(&quot;user.info.&quot; + userId);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里使用了“组合”（我不知道是不是该用这个词，如果有误请指正）。相对于前面用继承的代码，它有两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户只能调用&lt;code&gt;saveUser&lt;/code&gt;和&lt;code&gt;getUser&lt;/code&gt;这两个作用非常明确的方法。如果是继承的版本，则用户还可以调用&lt;code&gt;save&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;这两个通用的方法，会让人疑惑及误用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UserStorageService&lt;/code&gt;还有机会继承其它的类，因为在java中，只能单继承&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是这两个好处是不是决定性的因素呢？如果&lt;code&gt;StorageService&lt;/code&gt;中还提供了一些其它需要被调用的方法，或者我们根本不需要让&lt;code&gt;UserService&lt;/code&gt;继承别的类，是不是这两种方案的优劣对比就不明显了呢？&lt;/p&gt;
&lt;p&gt;老猪说，判断是否该使用继承要看&quot;is_a&amp;rdquo;，是否该用组合要看&quot;has_a&amp;rdquo;。但&lt;code&gt;UserStorageService&lt;/code&gt;与&lt;code&gt;StorageService&lt;/code&gt;的关系，是&quot;is_a&amp;rdquo;，还是&quot;has_a&quot;呢？我好像也没法确定。&lt;/p&gt;
&lt;p&gt;（注：本文本来有两个例子，由于内容增加，并且例子的差别较大，我分成了两篇）&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;杨博&lt;/h3&gt;
&lt;p&gt;两种做法都可以。但StorageService里的两个方法应该标上final关键字。&lt;/p&gt;
&lt;h3&gt;Steve Hsu&lt;/h3&gt;
&lt;p&gt;关于是否使用继承的问题, 可以从需要 instance 生成的时机点跟多线调用的方向来思考. 跟整个系统设计有很大的关联。&lt;/p&gt;
&lt;p&gt;如果基类只是用做一个接口应用而不存在壮态资讯，那就没有必要每次生成新的 instance， 但是仍需考虑多线程的调用冲突。&lt;/p&gt;
&lt;p&gt;如果基类存在了许多状态资讯，那就要看该类状态资讯是属于那一端的，比如说是 storage 的，而继承类是为了保留 user 端状态的，则因为状态属性不同，用组合较好。但如果继承类也是要留存 storage 状态，只是针对不同使用者，当然是使用继承较合适。如果没有保留状态则用接口或静态类去做，对于多线程，优化，除错等都有较大的好处。&lt;/p&gt;
&lt;p&gt;总之针对单一功能很难去判断该用何种方式，反之应该去回推系统设计时是否有做更为严谨与灵活的考虑。&lt;/p&gt;
&lt;p&gt;漏了instance生成时机，这比较难说明，简单来说组合或继承的写法对 vm 有着完全不同的意义。可以去看bytecode得知，两者对memory heap及stack等运用完全不同，在空间与效率的取舍中，还是要看整个系统架构的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>我想向java的main()传入大量参数，怎么做最优雅？</title>
                <link>http://freewind.in/posts/2234-the-most-elegant-way-to-pass-lots-of-arguments-to-java-main</link>
                <pubDate>Thu, 19 Dec 2013 22:29:45 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2234</guid>
                <description><![CDATA[&lt;p&gt;项目中有一些用java写成的可执行的工具，需要调用者传入大量的参数。最开始，我使用的是最传统的方式，直接一个传入参数数组，于是有如下这么壮观的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    String aaa = args[0];
    String bbb = args[1];
    String ccc = args[2];
    String ddd = args[3];
    String eee = args[4];
    String fff = args[5];
    String ggg = args[6];
    String hhh = args[7];
    // do something with these arguments
}


调用者：

java MyTool hello world1 world2 world3 world4 world5 world6 world7


客户同事拿去用后，感觉十分不便，向我抱怨。原来他在写脚本调用的时候，必须反复查看我的java源代码，才知道每个参数是做什么的。写完之后，下次需要修改的时候，又忘了还得来查。而且参数顺序还不能错，个数也不能多不能少，总之就是很麻烦。

我也认识到这个问题确实存在，便问客户同事有没有什么好办法，他给了我这样的例子：

public static void main(String[] args) {
    String aaa = System.getProperty(&quot;aaa&quot;);
    String bbb = System.getProperty(&quot;bbb&quot;);
    String ccc = System.getProperty(&quot;ccc&quot;);
    String ddd = System.getProperty(&quot;ddd&quot;);
    String eee = System.getProperty(&quot;eee&quot;);
    String fff = System.getProperty(&quot;fff&quot;);
    String ggg = System.getProperty(&quot;ggg&quot;);
    String hhh = System.getProperty(&quot;hhh&quot;);
    // do something with these arguments
}


调用者：

 java -Daaa=hello -Dbbb=world1 -Dccc=world2 -Dddd=world3 -Deee=world4 -Dfff=world5 -Dggg=world6 -Dhhh=world7 MyTool


客户同事的意思是，这种做法可以“完美”的解决他提到的那几个不便之处，比如：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-D&lt;/code&gt;后面的参数名可用于提醒参数的意思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顺序怎么写都行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果哪个参数是可选的，可以直接删除即可&lt;/p&gt;
&lt;p&gt;虽然我第一感觉是“竟然敢用这种方式来传参数！”，但一时之间竟想不出什么话来反对，因为他这种方式能做到的，我那种方式的确做不到。&lt;/p&gt;
&lt;p&gt;细想一下，这两种方式倒是相当互补，我有你无，我无你有。虽然相比起来，我觉得后者问题更多，因为它会污染System属性环境，更容易产生一些不可预料的问题，但也不失为一种有思考价值的方案。&lt;/p&gt;
&lt;p&gt;然后，我想到了这样一种试图结合两者优点的方案：&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map&amp;lt;String,String&amp;gt; map = new HashMap&amp;lt;String,String&amp;gt;();
for(int i=0; i&amp;lt;args.length; i+=2) {
    map.put(args[i], args[i+1]);
}
String aaa = map.get(&quot;-aaa&quot;);
String bbb = map.get(&quot;-bbb&quot;);
String ccc = map.get(&quot;-ccc&quot;);
String ddd = map.get(&quot;-ddd&quot;);
String eee = map.get(&quot;-eee&quot;);
String fff = map.get(&quot;-fff&quot;);
String ggg = map.get(&quot;-ggg&quot;);
String hhh = map.get(&quot;-hhh&quot;);
// do something with these arguments
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;调用者：&lt;/p&gt;
&lt;p&gt;java MyTool -aaa hello -bbb world1 -ccc world2 -ddd world3 -eee world4 -fff world5 -ggg world6 -hhh world7&lt;/p&gt;
&lt;p&gt;看起来似乎清楚了一些，虽然更长了一点。现在，它也可以：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参数列表中有用作提示参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顺序怎么写都行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有可选参数，直接删除对应项&lt;/p&gt;
&lt;p&gt;而且不污染System属性环境，相比前面的&lt;code&gt;-D&lt;/code&gt;方案，要稍好一些。&lt;/p&gt;
&lt;p&gt;只能做到这个程度了吗？看上面的三种方案，实际上都存在着一些问题，需要写更多代码：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打印usage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对参数进行检查，如果有缺少的或不合理的，要提示错误&lt;/p&gt;
&lt;p&gt;这些缺失的工作实际上相当烦琐，让我们的代码更加混乱，却又不可或缺。&lt;/p&gt;
&lt;p&gt;有没有优雅一些的方式呢？答案是有，我们可以利用java的annotation去描述我们的参数，使用这些信息对参数进行验证、取值以及打印使用帮助。&lt;/p&gt;
&lt;p&gt;市面上有不少这样的库，比如args4j, jcommands等，我最后选用了args4j。&lt;/p&gt;
&lt;p&gt;首先我们需要写一个类，里面用annotation来描述我们的程序需要什么样的参数：&lt;/p&gt;
&lt;p&gt;public class Args {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Option(required=true, name=&quot;-aaa&quot;,usage=&quot;aaa is something&quot;)
private String aaa;
@Option(name=&quot;-bbb&quot;,usage=&quot;bbb is something&quot;)
private String bbb;
@Option(name=&quot;-ccc&quot;,usage=&quot;ccc is something&quot;)
private String ccc;
@Option(name=&quot;-ddd&quot;,usage=&quot;ddd is something&quot;)
private String ddd;
@Option(name=&quot;-eee&quot;,usage=&quot;eee is something&quot;)
private String eee;
@Option(name=&quot;-fff&quot;,usage=&quot;fff is something&quot;)
private String fff;
@Option(name=&quot;-ggg&quot;,usage=&quot;ggg is something&quot;)
private String ggg;

// getters for them
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这样可以很清楚的方式知道每个参数的作用、描述等。&lt;/p&gt;
&lt;p&gt;然后取值：&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Args myArgs = new Args();
CmdLineParser parser = new CmdLineParser(myArgs);
parser.parseArgument(myArgs);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这时，&lt;code&gt;myArgs&lt;/code&gt;实例中的各fields，就已经自动赋予了相应的值，是由CmdLineParser通过反射赋值的。&lt;/p&gt;
&lt;p&gt;想打印使用提示呢？&lt;/p&gt;
&lt;p&gt;parser.printUsage(System.out);&lt;/p&gt;
&lt;p&gt;它会根据&lt;code&gt;Args&lt;/code&gt;里的定义，自动组织成一种可读性较好的格式，输出使用提示，十分贴心。&lt;/p&gt;
&lt;p&gt;调用者：&lt;/p&gt;
&lt;p&gt;java MyTool -aaa hello -bbb world1 -ccc world2 -ddd world3 -eee world4 -fff world5 -ggg world6 -hhh world7&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然看起来调用方式跟之前没什么变化，但内涵却更加丰富了，而我们要做的，仅仅是定义一个描述类，和调用三两行代码而已。&lt;/p&gt;
&lt;p&gt;这是我目前认为最优雅的解决方案。&lt;/p&gt;
&lt;p&gt;Args4j还提供了更加丰富的参数定义及获取等功能，有兴趣的同学可自行google。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;对于程序员来说，wordpress怎么都不够好用，哪怕我这次还安装了一个markdown插件。看到代码块里多余的&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;和被错误转义的&lt;code&gt;&amp;amp;lt;&lt;/code&gt;了吗？&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;caofei&lt;/h3&gt;
&lt;p&gt;http://commons.apache.org/proper/commons-cli/&lt;/p&gt;
&lt;p&gt;支持各种类型&lt;/p&gt;
&lt;p&gt;Commons CLI supports different types of options:&lt;/p&gt;
&lt;p&gt;POSIX like options (ie. tar -zxvf foo.tar.gz)
&lt;br  /&gt;GNU like long options (ie. du –human-readable –max-depth=1)
&lt;br  /&gt;Java like properties (ie. java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo)
&lt;br  /&gt;Short options with value attached (ie. gcc -O2 foo.c)
&lt;br  /&gt;long options with single hyphen (ie. ant -projecthelp)&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>终于把Programming Languages课学完了</title>
                <link>http://freewind.in/posts/2222-finished-the-programming-languages-course-on-coursera</link>
                <pubDate>Thu, 05 Dec 2013 23:41:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2222</guid>
                <description><![CDATA[&lt;p&gt;今天提交了Programming Languages课程的期末考试，得了86分，虽然不太理想，但总算把这门课学完了。回想起过去的十周时间，收获很多，最开心的是终于坚持了学完了，没有半途而废。&lt;/p&gt;
&lt;p&gt;Programming Languages是coursera网站上的一门免费公开课：https://www.coursera.org/course/proglang，主讲人是华盛顿大学的Dan Grossman。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/2222-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这门课通过多种风格不同的编程语言来讲解贯穿于函数式和面向对象语言中的各个概念，比较同一个概念在不同语言中的实现方式，以及类型系统的知识。课程中使用了三种语言作为主要的教学语言，分别是SML(Standard ML)，Racket和Ruby。其中前两种语言对于多数人来说都比较陌生，但它们简洁有特色，用来讲解某些概念非常合适。&lt;/p&gt;
&lt;p&gt;SML是一门静态类型的函数式编程语言，有我们熟悉的模式匹配和类型推断，Haskell有很多地方跟它很像，都属于ML家族。Dan说之所以使用SML而不是更热门的Haskell，是因为Haskell里表达式默认都是lazy的，不太好讲，而SML更简洁一些。&lt;/p&gt;
&lt;p&gt;而Racket是Scheme的增强，跟Lisp一个家族。它的特点是语法极为简洁，动态类型，函数式，当然，满眼都是括号。&lt;/p&gt;
&lt;p&gt;而Ruby是一种动态类型的面向对象语言，这个不多说了。&lt;/p&gt;
&lt;p&gt;课程共分为8讲，每周都有两个小时左右的视频讲解以及一个大作业，每周需要大约10个小时完成学业。还有一个期中和期末考试，每个考试90分钟。其中有两周作业难度比较大，一个是在Racket中实现一个简化的语言和相应的解释器（帅！），另一个是使用SML和Ruby分别使用函数式和面向对象来实现同一个功能（酷！）。&lt;/p&gt;
&lt;p&gt;这门课非常值得一学，当然难度和挑战也比较大，因为对于多数程序员来说，并没有多少函数式语言的经验，里面的很多概念都需要学习。但这门课的质量非常高，可以算得上是course里编程类课程中最好之一。Dan说话简洁流畅，重点突出，深入浅出，教学方式互动，布置的作业既有趣又有难度。上了这门课以后，再看其它类似的课程，总有种失望的感觉。&lt;/p&gt;
&lt;p&gt;有一个让我印象深刻的片断。在讲到函数类型参数是逆变时，Dan离开座位，弯着腰，像青蛙一样不停的跳，说“这是一个连聪明人也很容易弄错的问题，希望你以后在看到它时，会想到有一个博士跳来跳去，就是为了提醒你”。&lt;/p&gt;
&lt;p&gt;虽然学完了，但没有学好，一是因为这门课的信息量很大，很多概念还没有掌握清楚；二是由于这段时间工作实在太忙，很多地方勿勿看过，现在已经记不太清了。所以我打算再重头好好学一遍，力争把每一个概念都搞清楚，彻底掌握。我认为这才是重要的基础知识，如果不能把这些东西都弄懂，就没有必要去学Scala，浪费时间。&lt;/p&gt;
&lt;p&gt;好久没有写博客了，以后会尽量多写一些博客来记录学到的知识点。&lt;/p&gt;
&lt;p&gt;最后要感谢群里的老猪同学，他是我这门课唯一的同学，给了我很多指点和帮助。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>maven使用笔记</title>
                <link>http://freewind.in/posts/2200-notes-of-maven</link>
                <pubDate>Mon, 05 Aug 2013 10:30:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2200</guid>
                <description><![CDATA[&lt;p&gt;-o 运行于offline，不下载&lt;/p&gt;
&lt;p&gt;-DfailIfNoTests=false 当找不到测试时，不失败。默认为false&lt;/p&gt;
&lt;p&gt;-Dsurefire.useFile=false 直接在控制台显示错误栈。默认不显示。浪费不少时间&lt;/p&gt;
&lt;p&gt;-e 显示所有错误&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>为什么要抛弃maven</title>
                <link>http://freewind.in/posts/2195-why-dont-use-maven-any-more</link>
                <pubDate>Sun, 04 Aug 2013 00:07:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2195</guid>
                <description><![CDATA[&lt;p&gt;项目需要，开始学习maven，今天花了一整天的时间，看完了《Maven实战》这本书。书是好书，看完之后，对maven整体有了较多的了解，也知道了在项目中怎么去使用，感觉收获很大。&lt;/p&gt;
&lt;p&gt;我感觉maven这一套还是很严谨的，虽然繁杂，但是感觉很规范，各种情况它都考虑到了。而且跟Jenkins结合起来，也是很方便的。我想不到还有什么更好的办法可以解决它所要解决的问题。&lt;/p&gt;
&lt;p&gt;突然想到：为什么我以前不喜欢用maven？为什么似乎人们也不喜欢maven呢？&lt;/p&gt;
&lt;p&gt;我不喜欢是因为我以前没有掌握maven，看到那大堆的xml，总有种无法下手的感觉。而且在使用中时老是遇到问题，却很难在短时间内找到答案。总觉得它太笨重了。&lt;/p&gt;
&lt;p&gt;今天看完书也证实了我之前的看法是正常的。maven设计了一套复杂的体系，比如库的坐标、依赖、生命周期、插件等，环环相扣，如果不把这一套东西都搞明白，是没法下手的。这种情况，跟angularjs很像，都是设计了一套相对封闭但又有特色的体系，虽然内部配合很好，但对于外界就没那么友好了。在花时间了解、适应、认同它之前，会经常撞墙的。&lt;/p&gt;
&lt;p&gt;但为什么人们也不喜欢maven呢？应该有很多人对maven很熟悉的，但为什么他们还在寻找更好的工具呢？比如buildr，比如gradle?&lt;/p&gt;
&lt;p&gt;今天带着疑问，我搜索了一些文章，大概明白了。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;首先要提一下ant，ant与maven是两个极端。&lt;/span&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;ant很灵活，如同瑞士军刀，但没有统一的流程，需要写很多的代码，且每个人都有自己的一套。&lt;/span&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;而maven则相反，定义了严谨、繁琐的流程，考虑了很多，但具体到某一个任务的时候，又不够灵活。要么你去搜别人写好的插件，要么自己写，不论哪种方式，都会让人觉得束手束脚，感觉被maven设计出来的锁链绑着。一想到随便来点什么都要上插件，让人压力巨大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看到thoughtworks以前有一篇讲maven的文章，提到说，对于构建工具，在plugin的层面上抽象，还是不够灵活。还是需要一种能语言层面上抽象的工具。比如buildr，比如gradle。（原文找不到了，这是我根据搜到的片断自己理解的）&lt;/p&gt;
&lt;p&gt;而gradle正好填上了这两个极端的中间。它利用groovy提供的dsl，写起来要比xml舒服很多，而且可以直接如果函数调用般调用ant提供的工具，还可以直接写groovy(Java)代码。相比ant/maven，人们反映使用它的感觉要舒服多了。&lt;/p&gt;
&lt;p&gt;希望这个项目有机会尝试一下gradle。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;p&gt;想不到这篇不太有营养的文章上了“tw好声音”。正好这几天在志恒同学的努力下，成功的把项目中的maven换成了gradle，所以赶紧上来补充两句。&lt;/p&gt;
&lt;p&gt;首先关于maven，大家可以看看评论中杨博这篇霸气的文章：&lt;a href=&quot;http://www.ac.net.blog.163.com/blog/static/13649056201111793412935/&quot;&gt;《如果我来设计Maven》&lt;/a&gt;，深度有营养。&lt;/p&gt;
&lt;p&gt;然后讲讲项目的情况。&lt;/p&gt;
&lt;p&gt;客户的项目是一个java项目，用maven管理。虽然代码不多，但是分成了好几个模块。在根目录下放一个总的POM.xml，然后每个子模块里一个POM.xml，包含在总POM里。这几个月我们一直在它的甚础上开发，对它进行了多次修补，感觉如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;运行慢。运行一次&lt;code&gt;mvn clean test&lt;/code&gt;，差不多要五分钟时间，够上个厕所泡杯水再聊聊天了。而且每多一个模块，就会多出一截时间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;日志乱。maven的日志真是超乱，非常难以阅读。每次出点问题想从日志里找线索，都是一场折磨&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;文档难。遇到问题想从maven官网上找点资料，感觉很难。满屏幕都是文字，为什么看不到自己需要的？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;插件烦。P大的一点事也要加插件！比如，我们想建个跟src平级的integationTest目录，也要下插件！一堆配置！&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;心情差。每次编辑POM、看到POM、甚至想到POM，都感觉压力巨大，直接影响写代码心情~&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前些天终于要开始开始一个新模块了，志恒同学实在忍不住，喊出“风险我担！周末加班我也干！”的壮语后，花了两天时间，不仅在新模块里配好了gradle，还把之前多个maven模块也换好了，包括POM里调用的所有插件。在此向志恒同学致敬：）&lt;/p&gt;
&lt;p&gt;现在的gradle脚本看起来舒服多了。代码简洁、结构清晰、配置简单，再配上它的吉祥色绿色，有种春风拂面的感觉：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;gradle代码是由groovy写成的dsl，写起来有种json的感觉，简洁清晰，一句废话都很难找到。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;文档很好。由于gradle语法不像XML那样能提示，所以它的网站文档很好。清晰、解释清楚，示例丰富，很有帮助&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;插件丰富。gradle内置了对ant任务的支持，表示各种ant任务你都可以直接拿过来用。并且在gradle里，可以用一种很简洁的语法去调用它们，像调用函数一般&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;功能强大。gradle代码实际上就是groovy代码，所以可以方便地嵌入groovy代码。你既可以在里面加个&lt;/span&gt;&lt;code&gt;println &quot;hello&quot;&lt;/code&gt;&lt;span style=&quot;font-size: 13px; line-height: 19px;&quot;&gt;什么的帮助调试，又能写一些较复杂的groovy代码实现一些复杂的功能。既强大，又灵活。如果需要，不要怕学习另一门语言，因为比起你“精通maven”所花费的时间精力可要少多了。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于项目保密的原因，不方便贴出实际代码，不过在网上应该可以搜到很多maven与gradle代码的对比例子。我个人感觉因为有了gradle，groovy终于有了一个杀手级的项目。&lt;/p&gt;
&lt;p&gt;等在项目中有更多的gradle使用经验时，再来更新。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;Ivolianer&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;pom.xml 太繁复
&lt;br  /&gt;不论用何种表现形式，关键的就是，公司名、项目名和版本号。
&lt;br  /&gt;用 Gradle 能少打包名？ 好吧，也许看着顺眼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;依赖冲突
&lt;br  /&gt;Maven 最大的问题应该就是个。
&lt;br  /&gt;虽然 Maven 有最近原则和第一生命原则来解决依赖冲突，但实际还是有问题。
&lt;br  /&gt;不过，既然 Gradle 用的还是 Maven 的仓库，那它在这方面有何建树？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地Jar依赖
&lt;br  /&gt;某个版本的Maven不能引用本地架包，但现在可以用个 system scope 引入了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在考虑用 gradle ，但觉得优点不大。&lt;/p&gt;
&lt;h3&gt;杨博&lt;/h3&gt;
&lt;p&gt;http://www.ac.net.blog.163.com/blog/static/13649056201111793412935/&lt;/p&gt;
&lt;p&gt;如果你的项目用到的所有底层技术都不用自己开发，都是“成熟解决方案”，那么Maven挺适合的。&lt;/p&gt;
&lt;p&gt;不过，任何软件存在的意义，就是为了解决前人没有解决的问题。&lt;/p&gt;
&lt;p&gt;如果你只用“成熟解决方案”，那么你的软件必定毫无存在的意义&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart实战 (2) Dart语言特点</title>
                <link>http://freewind.in/posts/2176-dart-practice-2-language-features</link>
                <pubDate>Sat, 03 Aug 2013 23:20:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2176</guid>
                <description><![CDATA[&lt;p&gt;第一眼看起来，Dart的语法有点像Java/C#/JavaScript，据说是为了让人们容易上手。不过Dart有它自己的原则和特点，这导致它和它们在某些方面是有明显的不同，还是得花一些时间思考和研究的。&lt;/p&gt;
&lt;p&gt;首先是语法上一些比较熟悉的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法整体看起来跟Java很相似&lt;/li&gt;
&lt;li&gt;Dart中有class，但没有nested class&lt;/li&gt;
&lt;li&gt;有properties，还可用get/set关键字定义getter/setter&lt;/li&gt;
&lt;li&gt;有static method&lt;/li&gt;
&lt;li&gt;有一等函数，可当作值传递&lt;/li&gt;
&lt;li&gt;参数可声明为函数的形式&lt;/li&gt;
&lt;li&gt;参数可声明为可选参数，和具名参数&lt;/li&gt;
&lt;li&gt;使用大括号&lt;/li&gt;
&lt;li&gt;每行以分号结尾&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-size: 13px;&quot;&gt;有library，用于分模块，跟js里的module比较像。暂无nested library&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可导入另一个library，可起别名，或只导入部分&lt;/li&gt;
&lt;li&gt;this指向当前类的实例&lt;/li&gt;
&lt;li&gt;语句分为expr和statement，其中前者有返回值，后者无&lt;/li&gt;
&lt;li&gt;有annotation&lt;/li&gt;
&lt;li&gt;有型泛&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一些比较独特的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有private/protected/public等关键字，而将所有以下划线_开头的作为private，普通字母开头的作为public&lt;/li&gt;
&lt;li&gt;library的双向声明，part与part of&lt;/li&gt;
&lt;li&gt;同时有final和const两个关键字&lt;/li&gt;
&lt;li&gt;不能动态修改类，比如添加删除方法等，但提供了noSuchMethod()，可捕获未声明的调用&lt;/li&gt;
&lt;li&gt;没有eval，不能动态执行代码&lt;/li&gt;
&lt;li&gt;每一个类都有一个隐含的对应接口，所以我们可以直接implement另一个类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;关于类型：&lt;/h2&gt;
&lt;p&gt;Dart提供了可选的类型系统，在声明变量、定义函数的时候，可以指定类型，也可以不指定，不指定的话就是dynamic。&lt;/p&gt;
&lt;p&gt;Dart的类型系统比较独特的地方在于，类型仅仅是给编辑器和编译器看的，它不应也不会对代码的行为产生任何影响。在production模式下，类型会被忽略，以获得更好的性能。我们在执行dart代码时，可以指定-checked参数，打开或关闭运行时的类型检查（默认未开启）。&lt;/p&gt;
&lt;p&gt;由于类型系统不对代码行为产生影响，所以没法通过参数类型来区分两个同名方法，没法进行重载。同时也没法实现像C#中的扩展方法，即声明一个static方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public static void fullName(User user) { return user.firstName + user.lastName; } 

然后调用:

 User user = getUserFromSomewhere(); user.fullName(); 

开发团队说正在想其它办法提供类型的功能。

所以我们只能把类型看作是对编辑器的提示，可用来让编辑器帮我们提示方法、变量，以及检查我们调用时是否打错了字。也因此我们可以实现一些在别处做不到的魔术：随便给一个变量指定任意一个类型，让编辑器帮我们提示，同时利用noSuchMethod()，来处理我们对该对象的调用：

 class User { String name; } class Animal { String roaring; } class Ghost { noSuchMethod(Invocation msg) { // handle missing invocations } } User user = new Ghost(); user.name = &quot;Freewind&quot;; Animal animal = new Ghost(); animal.roaring = &quot;hahaha&quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;虚拟机、线程、isolate&lt;/h2&gt;
&lt;p&gt;Dart运行在自己的虚拟机DartVM上，它跟nodejs所在的v8有点像。虽然有了虚拟机，但并不像java/c#那样，下面还有一些字节码，Dart本身就相当于字节码。关于这个选择，开发团队在一个文章中说了很多原因，不过最后总结为一句：对于Dart来说，使用字节码没有更多好处，使用Dart语言本身也没有更多坏处，所以就没搞字节码了。&lt;/p&gt;
&lt;p&gt;关于线程，Dart代码运行于单线程环境中，这跟nodejs很像。这意味着我们不需要担心多线程的那些锁啊同步什么的问题，就算对一个全局变量进行读写，也不用考虑会不会被其它线程改了（当然还是建议少使用全局变量）。dart内置库中提供了Future，很多IO或耗时的操作，都返回的是Future对象，然后在它的then()方法中传个回调进去，这跟nodejs也是很像的。好在Dart直接内置了这种标准做法，不像js那里，有无数的库想来解决这个问题。&lt;/p&gt;
&lt;p&gt;由于单线程无法很好的利用多核，所以Dart提供了一个 isolate库。我们在可以在自己的代码中，使用spawnFunction(&amp;hellip;)函数，新起一个isolate出来，执行指定的函数。一个isolate跟一个线程有点像，比如普通的Dart代码也是运行在一个isolate中。但不同的是，两个isolate之间是不共享内存的，所以同一个全局变量，在不同的isolate中是互相独立的，改了这边不会影响那样。这样看起来，每个isolate像是一个进程。两个isolate之间可以互相发消息进行通信，风格有点像actor，消息会clone后发出去。除了通过spawnFunction()指定函数启动外，还可以spawnUrl指定另一个dart文件来启动，然后也之通信。如果是前者，可以传各种对象当消息，如果是后者，只能传一些基本类型，比如string,int之类，作用就有限了。&lt;/p&gt;
&lt;h2&gt;动态修改&lt;/h2&gt;
&lt;p&gt;Dart是一门很保守的语言。虽然看它的介绍“要替代JavaScript”时，以为它会是一个比较动态的语言，实际上相当静态。比如：&lt;/p&gt;
&lt;p&gt;不支持eval()，不能动态执行一段Dart代码。官方说这是基于性能的考虑，js里不是也不建议使用eval吗？&lt;/p&gt;
&lt;p&gt;不能动态添加方法。不过提供了noSuchMethod作为解决方案，可以做到相似的效果&lt;/p&gt;
&lt;p&gt;不能导入修改后的代码、不能动态扩展代码。这点比较郁闷，因为就算在java中，我们也可以通过classloader来读取新代码，加入到当前的运行时中，提供新功能。而在Dart中，目前仅有一个spawnUrl能以一种非常有限、基本没用的方式来模拟。这导致我们没法在不重启的情况下，执行新生成的代码（如模板引擎）。&lt;/p&gt;
&lt;h2&gt;编辑器支持&lt;/h2&gt;
&lt;p&gt;官方在发布Dart的同时，也提供了一个基于eclipse的Dart Editor，功能还比较丰富，高亮、格式化、代码检查、重构、单步调试等都有了。只是不能跟eclipse结合起来，因为不是插件形式。这让人感觉不太方便，因为很多有用的eclipse插件都用不了了。&lt;/p&gt;
&lt;p&gt;Idea也提供了一个Dart的插件，基本功能也有，但有些功能有问题，比如调试用不了，代码检查经常不正常。终于Idea有Dart上落后于eclipse了。&lt;/p&gt;
&lt;p&gt;另外，sublime也提供了Dart的高亮文件，但其它功能都比较弱。&lt;/p&gt;
&lt;p&gt;我现在基本上就是同时开着IDEA和Eclipse，基本操作在Idea中完成，遇到问题时，切换到Eclipse看看它的错误提示，不能不说，这还是非常有用的。&lt;/p&gt;
&lt;p&gt;Dart的开发团队还是相当活跃的，我相信Dart现在那些比较弱的地方，很快就会有改进的。现在非常希望它增加类型于“扩展方法”和“动态导入”这两个功能，不然感觉很多想法都实现不了。&lt;/p&gt;
&lt;p&gt;（看到上面的代码又乱了吗！最痛恨wordpress的就是这个了，白排了半天版。所以要尽快把我的dartblog弄好转过去。）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart实战 (1) 我的最初计划</title>
                <link>http://freewind.in/posts/2174-dart-practice-1-my-first-plan</link>
                <pubDate>Wed, 31 Jul 2013 00:34:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2174</guid>
                <description><![CDATA[&lt;p&gt;这一个多月的业余时间都花在了Dart上。本想出点成果写个长篇，但最后因为种种原因，仅勉强以最低标准完成了最初的计划，看来只能写个短篇了。&lt;/p&gt;
&lt;p&gt;Dart是Google正在开发中的一门语言，用于替代Javascript。相比javascript，它的语言基础更加牢靠，有利于创建更可靠的程序。鉴于现在web开发的情况为，后端有各种成熟的web框架，前端被风头正盛的各种js框架统治，所以Dart的目标只好定在“未来”，希望能在将来成为人们构建结构化web程序的首选语言。另外，&lt;span style=&quot;font-size: 13px;&quot;&gt;Dart的作者是v8引擎的作者，仅这一点就能人以强大的信心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我曾在很久以前简单了解了一下Dart，那个时候的它还太弱。这段时间看到Dart team正在开发一个叫&lt;a href=&quot;http://www.dartlang.org/articles/web-ui/&quot;&gt;web-ui&lt;/a&gt;的前端框架，与AngularJS相似，但有一些特性很吸引人，比如web components以及跟DOM的直接交互(AngularJS这点很弱)。我试用了一下，发现基本可用，而且生成的js文件也不大（如果你还记得&lt;a href=&quot;https://news.ycombinator.com/item?id=3097105&quot;&gt;这个故事&lt;/a&gt;）。所以又动了心，看看能不能用Dart做点什么可用的东西出来，同时实际体验一下Dart的开发。&lt;/p&gt;
&lt;p&gt;我最初的计划如下：&lt;/p&gt;
&lt;p&gt;使用Dart做一个简单的博客程序，然后把自己的博客都转过去。其特点是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全部以Dart实现，包括前后台&lt;/li&gt;
&lt;li&gt;可以用Markdown写日志，并且可以直接ctrl+v将剪贴板中的图片上传至服务器并添加到编辑器中&lt;/li&gt;
&lt;li&gt;使用sqlite作为数据库，不需要安装，拷走可用&lt;/li&gt;
&lt;li&gt;可以稳定运行于一个128M内存的小型vps上，并承受一个普通博客的访问量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;像我们购买的普通PHP空间，一年大约要100元左右，而一个128M的国外vps，一年也差不多100，这样在花费上差不多；面向的用户群为程序员，功能简单实用，特别是markdown和贴图片的支持；不考虑扩展性，想定制请直接fork改代码。&lt;/p&gt;
&lt;p&gt;在实际执行过程中，发现估计得有点乐观，因为Dart的第三方资源实在太少，并且Dart本身某些功能的缺失，导致某些功能几乎没法实现。期间多次想放弃，不过最终坚持下来了，遇到的困难有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有可用的模板引擎，只好自己写了一个：&lt;a href=&quot;https://github.com/freewind/RythmDart&quot;&gt;https://github.com/freewind/RythmDart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;没有orm可用，只能自己写了一个极简单的：&lt;a href=&quot;https://github.com/freewind/dartblog/blob/master/lib/src/orm.dart&quot;&gt;https://github.com/freewind/dartblog/blob/master/lib/src/orm.dart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;因为Dart更新很快，sqlite驱动多次过期，执行出错，差点倒在它上面&lt;/li&gt;
&lt;li&gt;Dart无法处理form上传文件，最后用html5的api，把文件变成base64格式传上去了&lt;/li&gt;
&lt;li&gt;编辑器支持比较差，Idea在Dart上居然落后于官方的eclipse插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后的成品在这里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;博客源代码：&lt;a href=&quot;https://github.com/freewind/dartblog&quot;&gt;https://github.com/freewind/dartblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;演示：&lt;a href=&quot;http://198.56.248.28:3000/topic/e070498a2f7a44f7b705cf2868eb56bc&quot;&gt;http://198.56.248.28:3000/topic/e070498a2f7a44f7b705cf2868eb56bc&lt;/a&gt; （注意可能随时无法访问，后台管理暂未开放）&lt;/li&gt;
&lt;li&gt;模板引擎：&lt;a href=&quot;https://github.com/freewind/RythmDart&quot;&gt;https://github.com/freewind/RythmDart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模板引擎中大量使用了这个库：&lt;a href=&quot;https://github.com/renggli/PetitParserDart&quot;&gt;https://github.com/renggli/PetitParserDart&lt;/a&gt;，期间得到了作者的大量帮助，在此对他表示十二分的谢意。&lt;/p&gt;
&lt;p&gt;你可以看到这个博客非常的简单，且代码也很丑，主要原因是因为Dart的一些功能上的缺失（以后会慢慢说），导致现阶段还没法做出一个漂亮的web框架，所以这些代码仅仅用来验证可行性。不过虽然丑，Dart现在的确已经有能力实现一个简单的网站，具备最基本的可行性了。我打算等Dart提供了必要的功能后，再重新实现，希望能把我最喜欢 的Play Framework 1的思想移植到Dart上。&lt;/p&gt;
&lt;p&gt;插个插曲：这次尝试Dart是被&lt;a href=&quot;http://www.dartlang.org/articles/web-ui/&quot;&gt;web-ui&lt;/a&gt;吸引过来的，杯具的是，正当我准备用它的时候，&lt;a href=&quot;http://www.infoq.com/cn/news/2013/07/dart-polymer-web-ui&quot;&gt;听说它被废了&lt;/a&gt;。。。&lt;/p&gt;
&lt;p&gt;最后做个广告：对Dart感兴趣的同学，欢迎加入我的Dart热情交流群：322215472&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala的类型系统居然可以解题</title>
                <link>http://freewind.in/posts/2153-scala-type-systems-to-solve-problems</link>
                <pubDate>Wed, 12 Jun 2013 22:23:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2153</guid>
                <description><![CDATA[&lt;p&gt;曾经听说scala的类型系统很强大，是“图灵完备”的，而“图灵完备”的语言的计算能力是相同的。这岂不是说，利用scala的类型系统，就可以完成普通编程语言才能做的事情？&lt;/p&gt;
&lt;p&gt;这一直是我心里的一个疑问，类型系统怎么看都只是一些定义，怎么能编程，还能解题？连想都不知道如何去想。直到前几天再次看到了老高在09年（没错，四年前）写的那一篇文章，豁然开朗，仿佛推开了一道光亮的门。&lt;/p&gt;
&lt;p&gt;老高的文章地址：&lt;a href=&quot;http://www.blogjava.net/sean/archive/2009/11/23/303374.html&quot;&gt;http://www.blogjava.net/sean/archive/2009/11/23/303374.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;老高的文章太低调了，标题仅为&quot;用Scala解Hanoi塔&amp;rdquo;，里面也只提到了利用了implicit和递归等，而没有突出“类型系统”四字，让人一眼看上去，还以为是用普通的scala代码再加上递归算法去做题。所以在2012年我看到这篇文章时，只是扫了一眼就那么错过了。实际上，该文章讲的是如何利用scala的类型系统去解题，通过implicit指示编译器寻找合适类型的时候，在类型的层面上使用了递归。如果你仔细看那段代码，会发现几乎所有的方法实现都是空的，真正起到解题的作用的，是里面各种类型定义和它们在声明时参数位置的变化，再加上implicit关键字，让编译器帮我们实现了解题过程。&lt;/p&gt;
&lt;p&gt;为了理解方便，我把代码复制在这里，并修改了里面的一些类型名称以帮助理解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.reflect.Manifest

object Hanoi extends App {

  def simpleName(m: Manifest[_]): String = {
    val name = m.toString
    name.substring(name.lastIndexOf(&apos;$&apos;) + 1)
  }

  trait Num
  final class Next[Pre &amp;lt;: Num] extends Num
  final class _1 extends Num
  type _2 = Next[_1]
  type _3 = Next[_2]
  type _4 = Next[_3]

  case class Move[ALL &amp;lt;: Num, FROM, TO, TEMP]()

  implicit def move1[FROM, TO, TEMP](implicit from: Manifest[FROM], to: Manifest[TO]): Move[_1, FROM, TO, TEMP] = {
    System.out.println(&quot;Move from &quot; + simpleName(from) + &quot; to &quot; + simpleName(to))
    null
  }

  implicit def moveN[HEAD &amp;lt;: Num, FROM, TO, TEMP](implicit
    m1: Move[HEAD, FROM, TEMP, TO],
    m2: Move[_1, FROM, TO, TEMP],
    m3: Move[HEAD, TEMP, TO, FROM]
  ): Move[Next[HEAD], FROM, TO, TEMP] = null

  def run[ALL &amp;lt;: Num, FROM, TO, TEMP](implicit m: Move[ALL, FROM, TO, TEMP]) = null

  case class Left()
  case class Center()
  case class Right()

  run[_3, Left, Right, Center]

}


为了看懂这段代码，我们需要有这些背景知识：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;1, &lt;/em&gt;2, &lt;em&gt;3, &lt;/em&gt;4 这些，是手动定义出来的整数序列，每一个都是Num的子类型，它们之间是依次递增的关系。这个递增并不是数学上“加1”的关系，而是“下一个”的关系。在函数式语言中，似乎经常有这种写法。2.  我们需要多少数字，就需要手动定义多少个这样的类型，因为scala没有批量定义类型的功能（类型系统的目的不是解题） 。所以如果你想解20个盘子的汉诺塔，你需要定义_1,&lt;em&gt;2,&lt;/em&gt;3,..&lt;em&gt;9,&lt;/em&gt;10,&lt;em&gt;11,&amp;hellip;,&lt;/em&gt;19,_203.  Manifest对象保存了与类型相关的信息， 它由系统提供，我们只需要用implicit来声明它。scala在运行时会自动产生合适的对象传进来，有点像依赖注入。4.  implicit参数和implicit方法是关键。它们的作用是告诉scala编译器，在编译时请帮我寻找合适的对象注入进来。从哪里找呢？看所在域中有没有合适的implicit对象或者implicit方法。5.  implicit是由编译器在编译期自己调用的，所以我们在代码中不需要写调用代码。但我们需要巧妙地定义各类型参数，通过类型和顺序，来指示编译器做什么。这就是为什么定义了一些方法，但它们实现为空，因为我们要看的仅仅各参数的类型值。6.  当一个implicit方法的参数也是implicit时，编译器会先为该参数寻找合适的implicit来源，递归就这么产生了。7.  解题过程体现在参数和返回值的类型上，看代码时要把目光放在它们身上，跟我们平时写scala代码时的注意力正好相反。&lt;/p&gt;
&lt;p&gt;先来一个简单的例子，看一下implicit和manifest的运作：&lt;/p&gt;
&lt;p&gt;class User&lt;/p&gt;
&lt;p&gt;def hello(implicit user: Manifest[User]) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println(user.toString)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;hello&lt;/p&gt;
&lt;p&gt;在REPL中运行这几行代码，会打印出：&lt;/p&gt;
&lt;p&gt;$line30.$read$$iw$$iw$User&lt;/p&gt;
&lt;p&gt;即那个参数user的内容。而我们调用hello时，并没有传入user对象，这说明是由scala自己产生了合适的Manifest对象并传了进去。&lt;/p&gt;
&lt;p&gt;回到原题，从后往前看。&lt;/p&gt;
&lt;p&gt;run[_3, Left, Right, Center]&lt;/p&gt;
&lt;p&gt;这一句代码是解题的入口。在调用run的时候，我们没有为它传入implicit m这个参数，而是指明了各类型参数的实际类型。这些信息，将决定其implicit参数m的实际类型为Move[_3, Left, Right, Center]。对于本题来说，这样的一个类型，代表我现在要处理的是一个有3个盘子的汉诺塔，目的是把盘子从Left柱移到Right柱，移动过程中可以用Center柱子作为中转。&lt;/p&gt;
&lt;p&gt;然而这个类型不存在，且m前面有implicit关键字，所以编译器要去找看能不能找到某个implicit object正好是这个类型，又或者某个implicit method的返回值正好是这个类型。&lt;/p&gt;
&lt;p&gt;编译器很幸运，看到了moveN这个implicit方法，它的返回值类型是：Move[Next[HEAD], FROM, TO, TEMP]，正好跟Move[_3, Left, Right, Center]能对上。所以它将会尝试调用这个方法，以便它的返回值传给m。&lt;/p&gt;
&lt;p&gt;注意，由于_3对应了类型Next[&lt;em&gt;2]，所以在这次调用中，moveN的HEAD类型将会是_2。所以编译器将调用方法 moveN[&lt;/em&gt;2, Left, Right, Center]。&lt;/p&gt;
&lt;p&gt;编译器还没松口气，又看到它有三个implicit参数，分别是：&lt;/p&gt;
&lt;p&gt;m1: Move[HEAD, FROM, TEMP, TO],
&lt;br  /&gt;m2: Move[_1, FROM, TO, TEMP],
&lt;br  /&gt;m3: Move[HEAD, TEMP, TO, FROM]&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;m1: Move[&lt;em&gt;2, Left, Center, Right],
&lt;br  /&gt;m2: Move[&lt;/em&gt;1, From, Right, Center],
&lt;br  /&gt;m3: Move[_2, Center, Right, Left]&lt;/p&gt;
&lt;p&gt;由于这三个参数又是implicit的，所以编译器只好再去寻找相应的implicit object或implicit method。首先它会寻找第一个参数m1对应的类型Move[&lt;em&gt;2, Left, Center, Right]，发现只有moveN方法能返回一个符合要求的类型，于是再次调用moveN[&lt;/em&gt;1, Left, Center, Right]，递归就这么产生了。编译器一层层地找下去，直到遇到了某个参数要求的类型是：&lt;/p&gt;
&lt;p&gt;[_1, FROM, TO, TEMP]&lt;/p&gt;
&lt;p&gt;编译器终于开心地发现move1方法的返回值正好满足其要求，并且不需要再递归，于是它调用move1方法，打印出了一句“Move from x to y“的话，然后再一层层回去，直接成功地返回m1所要求的Move[_2, Left, Center, Right]类型。&lt;/p&gt;
&lt;p&gt;然后编译器处理m2，这次直接调用move1函数即可。&lt;/p&gt;
&lt;p&gt;接着处理m3，又需要经过一层层递归，才能产生Move[_2, Center, Right, Left]类型的对象。&lt;/p&gt;
&lt;p&gt;而当编译器松了最后一口气，为run方法产生了合适的类型的时候，题目就这么自然而然的解出来了。&lt;/p&gt;
&lt;p&gt;它将会在console中打印：&lt;/p&gt;
&lt;p&gt;Move from Left to Right
&lt;br  /&gt;Move from Left to Center
&lt;br  /&gt;Move from Right to Center
&lt;br  /&gt;Move from Left to Right
&lt;br  /&gt;Move from Center to Left
&lt;br  /&gt;Move from Center to Right
&lt;br  /&gt;Move from Left to Right&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这正是我们移动三个盘子的汉诺塔所需要的步骤。&lt;/p&gt;
&lt;p&gt;从这个例子可以看出，scala的类型系统很强大，而且implicit的作用要比我之前以为的大得多，它是我们操作scala类型的一种手段。&lt;/p&gt;
&lt;p&gt;最后要感谢老高的文章，希望老高多写一些这样的文章，并且把标题起得花哨一点：）&lt;/p&gt;
&lt;p&gt;最后还有点疑问，关于scala的类型系统，还有别的类似的例子吗？&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;Vincent Xu&lt;/h3&gt;
&lt;p&gt;Scala因为受限于擦拭法，做出来的还是有限。06年熊桑在C++里用类型系统做了个MarsRover，我用Haskell的类型系统做过简单的解释器。这都不是厉害的。老袁用C++类型系统做了电信产品的DSL，这是我知道的，最厉害的一个应用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何一步步把dart的web-ui框架的示例程序todomvc编译成可在普通浏览器上浏览的网站</title>
                <link>http://freewind.in/posts/2132-how-to-compile-the-web-ui-framework-of-dart-to-a-normal-website</link>
                <pubDate>Fri, 31 May 2013 00:16:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2132</guid>
                <description><![CDATA[&lt;p&gt;Dart的web-ui框架看起来似乎比较成熟了，看了一下它的示例代码，觉得很清晰，web-component的方式比较新颖，再加上可以用dart来写，隐隐有超越angularjs之势，所以想把它的示例跑起来，看看浏览器兼容性及生成代码大小有没有什么问题，是否可以用它来写点什么东西。&lt;/p&gt;
&lt;p&gt;首先看效果：http://freewind.me/test/dart/web-ui-todomvc/&lt;/p&gt;
&lt;p&gt;源代码来自web-ui官方提供的示例代码，我做的只是在IDE下试了看对dart的支持程度，以及调用相关命令生成最终的js版，技术含量不高，不过也遇到了不少坑。应老猪要求，把过程记录下来，他可能想自己动手试试。&lt;/p&gt;
&lt;p&gt;先分析一下这个程序，看看它有什么特点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器兼容性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在chrome/firefox/IE10，以及安卓4.0上的浏览器中成功运行。安卓4.0上的QQ浏览器没有任何问题，而自带浏览器有时候会正常显示某些项，可能是css的问题。在IE8下无法运行。看官网上说支持多数浏览器，IE系只支持9和10，看来不太适合做面向普通中国大众的网站。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;index.html 829B&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; index.html.css 2.14K

 base.css 5.81K

 dart.js  8.27K

 index.html_bootstrap.dart.js 276.63K
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里最后那个js文件是最重要的，它已经经过minify操作，原始大小好像是500多K。它是由dart代码转换过来的，文件名里的bootstrap跟twitter的bootstrap没有关系。&lt;/p&gt;
&lt;p&gt;dart.js是一个引导文件，不论我们是用web-ui，还是用dart提供的最基本的dart:html库，都会（且必须）用到它。好在它个头不大。&lt;/p&gt;
&lt;p&gt;index.html很小，里面基本上没有什么内容。原来web-ui会把所有html页面都转换dart代码，还会变态地把某些html代码嵌入到dart里面，最后生成了一个奇大无比的js文件。不过，虽然这个看着有点大，想到它已经包含了dart的js、web-ui的js、html代码以我们手写的dart，其实已经不大了。再经过gzip一样，这个尺寸就算对于一个互联网应用来说也可接受。（你不需要再包含各种js库如jquery、underscore什么的）&lt;/p&gt;
&lt;p&gt;由于它把html代码放到了js里，并且还可以minify，这个应用对于搜索引擎来说是基本上不友好的。而且它默认通过url上的hash的变化来局部切换页面，所以只能用来做单页应用，看来它的设计定位还是相当明确的。如果需要做SEO，可能还得专门做一些静态页面供搜索引擎使用。&lt;/p&gt;
&lt;p&gt;关于语言特性和框架特色这里就不多讲，虽然有很多激动人心的地方。这里只讲如何从零开始一步步把它跑起来。&lt;/p&gt;
&lt;p&gt;我们需要这几个东西：dart-sdk（包括dart命令行、dart2js转换器、pub包管理程序等），dartium(嵌入了dartvm的浏览器），web-ui相关的库，web-ui提供的todomvc源代码，IDEA的dart插件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dart-sdk&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在dart官网http://dartlang.org上，它默认提供了dart editor的下载。它是一个基于eclipse的dart编辑器，里面还包含了dart-sdk, dartium等。你可以直接下载它就全齐了，或者，像我一样不想用eclipse，那就分开下载。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先是http://www.dartlang.org/tools/sdk/上看到sdk的下载链接，不过不要点那个大按钮下stable版，而要在下面找未经测试的流血受伤版。因为web-ui要求的dartsdk版本比较高，stable版的没法编译。我下载的是latest的mac-64。

下载后解压到某地，然后把其中的bin目录加到PATH中，运行dart、dart2js、pub等命令看看是否安装成功了。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;IDEA插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装两个插件，一个Dart，一个File Watcher。前者不用多说，提供了对Dart和web-ui的支持，后者可以监视目录中的dart文件，发现修改时自动编译为js，比较方便。不过如果我们使用Dartium来开发，实际上用到它的机会不多，因为dartium可直接运行dart代码，修改后一刷新即可，省了编译的时间，非常方便。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;安装后，要记得配置dart sdk路径，不然你会发现虽然可以识别dart语法，但不能编译、检查和提示方法。我在这里被坑了一下，还以为是dart的插件太弱了呢。

有几个工具和命令需要注意一下。工具栏里有个dart的图标，可以很方便的设置dart sdk。点文件右键菜单里有run，可以执行一个dart文件（当然不能引用dart:html等前端库，还要有main()方法）。右键里还有一个dart2js，可以把一个dart文件转换为js，并且提供了checked和minify两个选项，很方便。其中checked是指在生成的js里添加上类型方面的检查方便调试，minify是对源代码进行处理变小一些。一般情况下会只勾选minify，以得到最小的js文件。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Dartium&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它是一个跟chrome很像的浏览器，基于同一个内核，不同的是它内嵌了dartvm，所以我们可以直接用它来执行dart代码，大大方便了开发，实现改完就刷的效果。由于dartsdk更新很快，所以注意要使用最新的dartium，经常更换，否则可能出现IDE与浏览器打架的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;安装过程比较简单，到http://www.dartlang.org/tools/dartium/下载后，解压即可。这里又有一个坑需要注意：你可以用它直接浏览引用了dart:html的库的应用，但不能正常运行web-ui的代码，虽然看起来页面里也是dart代码。这是因为，web-ui写出来的程序，还必须经常dwc这个编译工具的处理，才能转换为可正常执行的dart代码。

我在这里卡了不少时间，因为我写了一个web-ui的hello world，但怎么都没法正常运行，还以为我装错了或没设置好，装了几遍。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;pub&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pub是dart自带的包管理程序。一般需要在项目目录下提供一个pubspec.yaml的文件，里面写上一些内容，比如项目名，依赖项等，示例如下（web-ui提供的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: web_ui
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;author: &amp;ldquo;Web UI Authors &lt;a href=&quot;&amp;#x6d;&amp;#97;&amp;#x69;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#119;&amp;#101;&amp;#x62;&amp;#x2d;&amp;#x75;&amp;#x69;&amp;#x2d;&amp;#x64;&amp;#101;&amp;#118;&amp;#x40;&amp;#100;&amp;#x61;&amp;#x72;&amp;#x74;&amp;#108;&amp;#97;&amp;#110;&amp;#x67;&amp;#x2e;&amp;#x6f;&amp;#x72;&amp;#103;&quot;&gt;w&amp;#101;&amp;#98;&amp;#x2d;&amp;#117;&amp;#105;&amp;#x2d;&amp;#100;&amp;#101;&amp;#118;&amp;#x40;&amp;#100;&amp;#x61;&amp;#x72;&amp;#116;&amp;#x6c;&amp;#97;&amp;#x6e;&amp;#x67;&amp;#46;&amp;#111;&amp;#x72;&amp;#103;&lt;/a&gt;&amp;rdquo;
&lt;br  /&gt;homepage: https://github.com/dart-lang/web-ui
&lt;br  /&gt;description: An easy way to build web apps in Dart.
&lt;br  /&gt;version: 0.4.9
&lt;br  /&gt;dependencies:
&lt;br  /&gt;args: &amp;ldquo;&gt;=0.4.5&amp;rdquo;
&lt;br  /&gt;analyzer_experimental: &amp;ldquo;&gt;=0.5.12&amp;rdquo;
&lt;br  /&gt;browser: &amp;ldquo;&gt;=0.4.5&amp;rdquo;
&lt;br  /&gt;logging: &amp;ldquo;&gt;=0.4.5&amp;rdquo;
&lt;br  /&gt;pathos: &amp;ldquo;&gt;=0.4.5&amp;rdquo;
&lt;br  /&gt;unittest: &amp;ldquo;&gt;=0.4.5&amp;rdquo;&lt;/p&gt;
&lt;h1&gt;Pin these github packages so we don&apos;t get breaks from publishing them:&lt;/h1&gt;
&lt;p&gt;csslib: &amp;ldquo;&gt;=0.4.7 &lt;0.4.8&quot;
&lt;br  /&gt;html5lib: &amp;ldquo;&gt;=0.4.3 &lt;0.4.4&quot;
&lt;br  /&gt;source_maps: &amp;ldquo;&gt;=0.4.5&amp;rdquo;
&lt;br  /&gt;dev_dependencies:
&lt;br  /&gt;js: any
&lt;br  /&gt;benchmark_harness: &amp;ldquo;&gt;=1.0.2 &lt;1.0.3&quot;
&lt;br  /&gt;environment:
&lt;br  /&gt;sdk: &amp;ldquo;&gt;=0.5.12&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;然后在命令行执行：

     pub install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它就会自动寻找各依赖，下载后放在packages目录下。具体详情可参看其官网：http://pub.dartlang.org/&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最后是web-ui&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先到项目主页https://github.com/dart-lang/web-ui上把它clone下来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://github.com/dart-lang/web-ui.git
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;它里面包含了所有的源代码以及example目录，其下有todomvc这个例子。

    首先在web-ui目录下执行`pub install`，如果dart sdk版本不对，它会提示。成功的话会看到它下载了不少依赖。

    然后进行example下的todomvc目录，执行：

    ./build.dart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它实际上是通过代码方式，调用了web-ui的编译器，根据html文件生成了一堆dart文件。生成的文件会放在out目录下，这是写死的，只能是out这个目录名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;进入out目录，可以看到里面多了很多文件。我们可以用dartium浏览器直接打开其中的index.html，正常情况下会看到todolist的经典界面，也可以经行操作。但此时用其它浏览器打开它，是没法正常运行的。

要想让各浏览器正常运行，还需要一条命令。在out目录下：

dart2js index.html_bootstrap.dart -oindex.html_bootstrap.dart.js
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;它会把最主要的那个dart文件转成js文件，只需要转这一个即可，其它的dart实际上被包含到里面去了。我们不需要对index.html进行修改，就可以使用普通的浏览器查看了，似乎里面有自动判断是否有js版的功能。

    另外，通过dart2js转换的，没有minify选项。所以我还是到IDEA中用它的dart2js菜单来做。

    这里总结一下，web-ui写出来的代码是不能直接运行的，它必须首先用build.dart编译一次，生成可正常运行的dart文件，才可以在dartium上查看。然后还要执行dart2js的编译，才能在普通的浏览器上执行。这意味着，我们修改文件后，还是需要至少编译一次，才能看到效果。看来需要试试file watcher，能不能增加一个文件变化时自动调用build.dart的功能。

    看到这里 https://groups.google.com/a/dartlang.org/forum/?fromgroups#!topic/misc/vqdCPt-OKB8 说，dartium有一个web-ui的插件，可以让我们不用编译就可以直接在dartium查看，实现即改即刷。刚安装试了一下没成功，如果能行的话就方便了。

6.  上传到网上

这时你可以把out目录下的文件上传到网上，供人们浏览。它会引用到packages目录下的一些东西，而packages可能是一个目录的软链接，所以需要手动在上传目录中建立packages目录，并根据浏览器的提示把缺少的文件补上去。

安装过程结束，有问题到群里问我。等我好好研究web-ui，做点练手的程序之后，再写一些关于它的心得。
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Lift小记</title>
                <link>http://freewind.in/posts/2128-notes-of-lift</link>
                <pubDate>Fri, 24 May 2013 22:27:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2128</guid>
                <description><![CDATA[&lt;p&gt;我参与一个Lift的项目已经三周了，现在的程度是基本上能用了。它的流程、原理等基本了解，可以独立实现一些常用的功能，但考虑到Lift处处是坑的现状，要用它做一个完整的、功能较复杂的网站，可以肯定这决不是一件容易的事。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;（注：随着项目的深入，发现了lift一些真正有趣的地方，改变了我的看法。也许到项目结束时，会有全新的认识，到时候再记录一下。本文你可以看作是一个初学者刚尝试lift时不深入的看法）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;按我目前所感受到的，lift有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lift的安全性极高。比如form/input等，它们的name都是临时生成的，每刷新一次页面都不相同，这样让人无法通过伪造post请求来侵入系统。&lt;/li&gt;
&lt;li&gt;lift内置了ajax支持，我们可以不用手写js代码，就能实现单页程序。让一个页面元素产生ajax调用、取得数据再局部更新页面，是一件非常容易的事&lt;/li&gt;
&lt;li&gt;lift的css transform功能极为强大。它提供了类似于jquery的css selector，再配上自定义的操作符，可以让我们极为方便且准确地更新某块html代码中的数据&lt;/li&gt;
&lt;li&gt;lift不是mvc结构，而是view-first。在一个html页面中，嵌入了很多小块的snippet，它们在运行时，可以取得业务逻辑数据，通过css transform功能替换掉自己范围内的html代码，形成最终的代码&lt;/li&gt;
&lt;li&gt;另外，lift还有actor、comet等，用来做聊天室之类的程序很方便，不过目前项目还没有此类需求，我也没有机会尝试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以说lift的这几个特点都是很有特色的，跟我们常用的大多数mvc框架都不一样，甚至某些方面更好相反。学习和使用lift，可以让我们开拓自己的思路：原来不是所有的web框架都是一样的，我们用另一种不同或者相反的方式，也能够一样做好。&lt;/p&gt;
&lt;p&gt;从这快一个月的项目经验，我认为lift不是一个容易掌握的框架，而且对于我们常见的大多数类型的网站，都不是一个很好的选择。我认为lift框架适合以下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安全性要求极高的网站，如银行等。使用lift不需要做任何特别的设置，就已经解决了绝大多数平时可能遇到的安全问题&lt;/li&gt;
&lt;li&gt;聊天室之类的实时展示类网站。lift对这方面的支持非常强大。&lt;/li&gt;
&lt;li&gt;需要ajax局部更新网页，但是不熟悉javascript，或者不想写javascript代码的人&lt;/li&gt;
&lt;li&gt;只想用scala做网站的人（因为scala的web框架选择不多，lift是最成熟的那个）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而其它时候，我们往往有更好的选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传统的多页面网站。市面上大多数的框架都适合做这种，随便找一个的开发效率都要超过lift&lt;/li&gt;
&lt;li&gt;单页程序，且功能比较炫的。选择前端框架（如angularjs）和随便一个能提供json交互接口的后台语言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们这个项目属于&amp;ldquo;传统的多页面&amp;rdquo;网站，使用lift可以实现，但没有发挥出它的优势。这个项目如何使用play1或者ror等框架，可以很轻松的做出来，哪怕中途很多修改，也会比较容易。不过我们之所以使用lift，主要原因是为了尝试scala，而lift作为scala中最成熟的web框架，使用它也算是理所应当了。&lt;/p&gt;
&lt;p&gt;这里说一下lift中的做法和优缺点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成form表单&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;lift中的安全性极高，是因为所有的表单，都是由scala生成的。我们不在html上设计表单，也不写form/input，而是定义一个继承于LiftScreen的类，在里面声明各input，给它写明label、默认值、验证函数等，然后lift在生成html的时候，自动产生相应的html代码。&lt;/p&gt;
&lt;p&gt;优点是可以在生成时产生随机的name更加安全，另一点是使用它默认的form样式，可以省掉很多html代码。不过如果想设计一个效果特殊的form表单时，就需要覆盖其toForm方法，在scala代码里写一些html代码，这种方式让人感觉很束手束脚。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View-First模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;跟传统的MVC模式不同，lift是view-first模式，它的意思是，页面是首先被访问的，它是老大。我们写的业务逻辑代码分成一块一块的叫snippet，我们把它们引用在html标签上的某些位置，它们所在的标签的里面的html代码即可被它们访问或修改。&lt;/p&gt;
&lt;p&gt;这个感觉非常像一个JSP页面，里面嵌入了一些jsp tag，只不过jsp tag只能向里面的html模板传一些变量，而lift的snippet拥有随意改变其中html代码的功能。&lt;/p&gt;
&lt;p&gt;说到优点，这种方式更符合我们的直觉，在view-first的眼里，页面似乎是由一堆积木拼在一起，添加或者减去什么，只需要关注变化的那一小块。而在mvc中，页面上的变化都会影响到controller，因为controller需要添加或者减少相应的数据才能适应view层的变化。当页面中的数据多的时候，controller里到处充斥的混在一起的代码，会让人觉得很难理清头绪。&lt;/p&gt;
&lt;p&gt;但在另一种情况，使用mvc又方便一些，比如一些相同的小数据，分散在页面的各处。如果是mvc，直接传一个变量进去即可，而view-first，可能要在多个snippet中分别取一次。&lt;/p&gt;
&lt;p&gt;我略倾向于view-first，因为当网站的页面中有很多可重用的小块，使用view-first可以很方便地把它们变成一个个小组件。而使用MVC想做到相同的效果要麻烦很多，除非你的view层也提供了类似snippet这样的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;css transform&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lift中的css transform功能十分强大。之前见到的其它框架或者模板引擎，都是向view中提供一些数据，让view自己在合适的地方展示它们。而lift通过css transform，可以让我们对某块html以类似于jquery的方式对它们随意修改。在修改的过程中，我们即可以尽量保持html代码原来的结构和内容，也可以大刀阔斧地修改，实现出完全不同的效果。甚至还可以对产生的html代码再进行新一轮的transform。使用这种方式，我们可以实现非常强大的组件，而只需要定义一些结构不那么严格的html模板，这种能力太神奇了。&lt;/p&gt;
&lt;p&gt;但从另一个角度来看，使用css transform，当替换的东西一多时，可读性就不那么好了。我们眼前看到的html代码，很可能跟最终的html完全没有关系，而想知道最终是什么样子，我们只能一句句地读定义的css transform代码，同时在脑海中想像出每一句执行之后的效果，这是一个相当费脑子的事情。同时css transform的代码是字符串，只要里面写错一点，最终的效果可能就跟预想的不同，而要想查出问题，只能一边开着html页面，一边开着css transform页面，然后眼睛在两边一一对比，这种痛苦经历过一次就很难忘了。&lt;/p&gt;
&lt;p&gt;另外，lift似乎推荐使用id和class来定位代码，所以当你想修改一句html代码&lt;div class=&quot;nickname highlight&quot;&gt;user name&lt;/div&gt;的时候，你会有一种不敢下手的感觉。因为nickname可能被lift用了，也可能被css用了。除非你小心地查找并确定没有混用的时候，你才敢修改它。&lt;/p&gt;
&lt;p&gt;今天看到css transform支持@name，即name属性，所以我们可以写成&lt;div name=&quot;nickname&quot;&gt;..&lt;/div&gt;，这样可以让lift与css隔离开，修改的时候也不会迷茫。会不会好一点？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Scala语言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lift使用Scala语言，并且利用了它的很多强大的功能，比如隐式转换等，在lift中用得非常多。一方面我们可以让代码写得简单一些，但同时增加了调试与查错的难度，经常发现自己的代码编译不过却又找不到原因。&lt;/p&gt;
&lt;p&gt;正是因为Scala语言的强大，xml的内置支持等，才有了lift框架，但同时又因为Scala语言的难度、编译的缓慢、IDE的支持不好，又让我们在使用lift时，经常由于外在原因而很受打击。比如在一个i7/8G/SSD的macbook上，用Idea的Scala插件来写lift程序时，经常卡顿，而使用sbt运行单元测试或者重启jetty时，要等很久的编译时间。如果你的上司经常查看你的进度，问你为什么老是发呆不工作的时候，你会有砸电脑的冲动。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对Ajax的内置支持以及生成js代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lift中提供了一些类，对应js中的相关结构，让我们可以用scala的思路来写代码，而它们会生成正确的js代码在浏览器端执行。在大多数情况下，它们运行得很好并且很简单。但如果某个时候，我们必须实现一些较复杂的js效果，但又不想手写js的时候，利用lift来生成js代码还是比较痛苦的。因为它写出来的代码可读性往往不太好，而且臃肿复杂，所以有时候还不如直接写js来得方便。想通过lift来逃避js的想法往往难以实现，但如果不怕写js代码了，采用前端js框架来做网站，又不必使用lift了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lift中处处是坑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lift中坑很多，非常多。一方面是因为相关的文档和说明很少，很多时候都需要看源代码才知道怎么回事，另一方便lift中有很多隐晦的约定，比如它在生成表单时，会去寻找模板中class为next的input，替换为它生成的submit按钮。这只有看了源代码才知道有这么回事，我们怎么能凭空想到它要去找一个叫next的东西？&lt;/p&gt;
&lt;p&gt;我们在写代码的过程中，往往会遇到一些问题，而这些东西早已有了相应的解决方案，只是隐藏在lift的源代码里，没有文档、没有注释，就一个方法或者几行代码。我们只有读了它的源代码，并且推出了那些代码的作用，才知道该怎么去使用。&lt;/p&gt;
&lt;p&gt;我怀疑这是lift的作者故意这么做的，因为lift本身就是一个比较高端的框架，对使用者的要求很高。如果一个使用者没有阅读源代码的习惯和能力，也许就不应该成为lift的用户。&lt;/p&gt;
&lt;p&gt;我目前所感受到的东西都差不多写在这里了。Lift是一个很有特色的框架，但我想我不会在自己的项目中使用它。因为我很少会遇到lift最适合的那种类型的网站。如果是普通的多页面网站，我用play1搞定，如果是单页面网站，我会用angularjs来做，这两种都会比lift的开发效率高很多。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;guxiangguo&lt;/h3&gt;
&lt;p&gt;但在另一种情况，使用mvc又方便一些，比如一些相同的小数据，分散在页面的各处。如果是mvc，直接传一个变量进去即可，而view-first，可能要在多个snippet中分别取一次。
&lt;br  /&gt;=&gt;　可以用Menu.param只取一次&lt;/p&gt;
&lt;p&gt;Lift是一个很有特色的框架，但我想我不会在自己的项目中使用它。
&lt;br  /&gt;＝》恰恰相反，研究源代码是一种乐趣，自己的项目第一选择Lift。&lt;/p&gt;
&lt;h3&gt;coolwasp&lt;/h3&gt;
&lt;p&gt;年初，听从作者的建议，在用play1写一个网站，感觉就像在写php代码，比其他框架使用起来方便多了，我们模板是集成japid，前端kissy+jquery，感觉还不错。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Kotlin临忘前小记一下</title>
                <link>http://freewind.in/posts/2127-notes-of-kotlin</link>
                <pubDate>Fri, 24 May 2013 20:37:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2127</guid>
                <description><![CDATA[&lt;p&gt;这段时间由于想尝试使用Kotlin来写js代码，所以试用了一下它，主要用它改写了一个angularjs的todomvc的示例，总体感觉还不错，具体过程可参看我的另一个日志。&lt;/p&gt;
&lt;p&gt;不过，Kotlin在语法层面，特别是与js结合的方面，还是有一些缺失。另外angularjs本身为了最大的利用js的灵活性，导致使用带类结构的静态语言来编写它时，无法很好的利用上其类结构，写出来的代码总让人觉得有些别扭。所以我决定暂时还是不以Kotlin为主力语言，先观望，等它更成熟一些后再试。&lt;/p&gt;
&lt;p&gt;现在Kotlin在jvm端应该能达到可用的程度了，我用的一个idea插件acejump就是用它写的。所以如果有时间，我也许会用Kotlin写写服务器端代码，修改一下这个插件的bug，感受一下idea插件的写法。不过这个就不太确定了，因为现在的工作有点忙。&lt;/p&gt;
&lt;p&gt;由于很可能在未来的一段时间里不再接触Kotlin，为了避免到时候完全忘记，所以趁现在小记一下，方便到时候恢复记忆。&lt;/p&gt;
&lt;p&gt;Kotlin的定位是比Java强大，但比Scala易用，位置处于两者的中间偏scala一点。它的竞争对手xtend，处于两者中间偏java一点。Scala中的大部分特性在Kotlin中都有所体现，但是Kotlin为了能让做法简单一点，简化了Scala中的一些较复杂的概念，一些复杂的特性也没有提供，不像scala那么函数式。在Kotlin中更多体现的是对java的改进，所以对于Java程序员来说，上手会比较快和自然。&lt;/p&gt;
&lt;p&gt;在Kotlin中，有类、有包，没有public字段，而是属性。比如在User类中定义了val name:String，实际上它会生成get_name和set_name这两个方法供使用，而name变成了$name被隐藏起来。这在与js交互时不太方便，因为我们在js中，很少会使用getter/setter，两者结合起来各种别扭。&lt;/p&gt;
&lt;p&gt;Kotlin中有trait，trait和interface之间的区别是trait中定义的方法可以带实现，而不像interface那样必须是空的。一个类可以继承多个trait，如果两个trait中有同名的方法，则我们可以在代码是指定使用哪个超类的方法，而不像Scala那样，它们实际上是个链，嵌套在一起。Kotlin的这种实现比较简单和直观，而Scala的作法可以实现AOP。&lt;/p&gt;
&lt;p&gt;Kotlin中有object，它声明在一个class的内部，通常用作工厂方法，不像Scala那样可以单独声明。对了，Kotlin中也可以用object关键字后面带一个类似JSON那样格式的声明，实现一个单例对象。这点记不太清，不想去查资料了。&lt;/p&gt;
&lt;p&gt;Kotlin可以扩展某个类，添加字段或者方法。它的语法跟ruby有点像，即fun String.abc() = {} 这样的形式。&lt;/p&gt;
&lt;p&gt;Kotlin中定义方法用的关键字是fun而不是def，这在最开始时还有一些争论，很多人支持用def。后来作者说fun写起来会让人感觉开心，同时想突出一下function的概念，所以用fun。不过现在fun定义出来的感觉更像是方法，而不是函数，不能像函数值那样当参数传给其它函数。这有点不太方便，不过据说很快会加上一个语法::method，把method转为function value。&lt;/p&gt;
&lt;p&gt;在Kotlin中可执行代码不能放在顶层，必须放在一个方法里，比如main()。这一点在生成js代码时不太方便，因为我们必须手写一行js代码，去找到并调用那个main()执行初始化操作。&lt;/p&gt;
&lt;p&gt;Kotlin中有一个native关键字，在写js代码时很常用，因为我们经常需要引用一些由第三方库提供的js对象或方法，这时可用native标记一下，实现就写成noImpl，它就只起到了一个声明的作用。Kotlin中的变量不能使用$，它被Kotlin内部使用了，而在js中这个需要经常用，如果需要我们可写成native(&amp;ldquo;\$scope&amp;rdquo;) var scope这样的形式，让它生成的js变量与我们在Kotlin中使用的不一样。&lt;/p&gt;
&lt;p&gt;Kotlin中可以声明函数字面量，形如{(a:String, b:Int): User -&gt; User(a,b) }，这种形式有时候有点啰嗦，特别是有嵌套的时候。我希望能提供这样的写法：(a:String,b:int):User -&gt; { User(a,b) }或 { a:String, b:Int -&gt; User(a,b) }，但被作者否决了。&lt;/p&gt;
&lt;p&gt;Kotlin中有类型推断，像Scala一样，在声明变量，传入函数字面量时，可以少写很多类型，还是很方便的。&lt;/p&gt;
&lt;p&gt;Kotlin中没有return，行尾也不需要写分号。&lt;/p&gt;
&lt;p&gt;Kotlin的集合也提供了很多好用的如filter这样的方法，可以这么用：list.filter { it &gt; 2  map { it*2 }&lt;/p&gt;
&lt;p&gt;Kotlin的函数，如果最后一个是() -&gt; Any类型，则可以把它拿到外面，用花括号括起来写。这样可以实现一些dsl，如html builder。例如：html { body { &amp;hellip; } }&lt;/p&gt;
&lt;p&gt;Kotlin中的 () -&gt; Any类型的函数，如果写成函数字面量，则是 { mycode }，而不需要像Scala那样写成：() =&gt; { mycode }。由于Kotlin这种写法比较简单，所以不需要Scala中的传名参数，少了个概念，但可以做同样的事。这样想想，似乎Scala的传名函数不太有必要。（或者有其它的好处我还不知道？）&lt;/p&gt;
&lt;p&gt;Kotlin中使用in和out这两个关键字来表示逆变和协变，写成&lt;in T&gt;和&lt;out T&gt;，相比Scala中的-T和+T，简单很多，让人一看就能记住。如果是传函数中传，就可以声明为&lt;in&gt;，如果是返回值，就声明为&lt;out&gt;。&lt;/p&gt;
&lt;p&gt;在Kotlin中，有一个有趣的特性是null safety，在声明一个变量时，可以在类型后面加个?，如var s :String?。如果有问号，表示它可能为null，在使用时必须先判断一下它不等于null，否则编译不过。这跟Scala的Option[String]相比，概念和写法上都要简单很多，更有Java的味道。我想吐槽一下Scala的Option[String]，写起来很麻烦，用起来getOrElse也不很爽，特别是有时候有嵌套，如Option[Option[String]]的时候，让人欲哭无泪。&lt;/p&gt;
&lt;p&gt;Kotlin中还有一个特性叫代理。据说使用它可以有一些特别的好处，不过这个东西我比较陌生，所以没法展开，以后再好好看看。&lt;/p&gt;
&lt;p&gt;语法方面的，现在只能想到这么多了，应该照顾到大部分了。没有去翻文档，因为想不起来的可能都不是那么重要了。&lt;/p&gt;
&lt;p&gt;最后是IDE方面，使用Idea的Kotlin插件，体验还是很流畅的，错误提供等很快捷，不像Scala那么卡。但IDE的功能还没有Java那么强，还有不少的改进空间。&lt;/p&gt;
&lt;p&gt;最后祝福Kotin，在Andrey的领导下能更快的成熟起来，因为它是我在以后替代Java的一个有力候选者。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>value.foreach( println(_.toInt) ) 为什么编译不过？</title>
                <link>http://freewind.in/posts/2124-why-value-foreach-println-toint-cannot-be-compiled</link>
                <pubDate>Sun, 19 May 2013 21:28:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2124</guid>
                <description><![CDATA[&lt;p&gt;这其实是一个困扰我许久的问题，看起来十分简单。&lt;/p&gt;
&lt;p&gt;Scala代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val value = Some(&quot;100&quot;)
value.foreach( println(_.toInt) )   // !!! can&apos;t be compiled

它还给出了错误提示：

&amp;gt; missing parameter type for expanded function ((x$1)=&amp;gt;x$1.toInt)

按我之前的理解，下划线_可用来代替前面提供的参数，所以上面第二句应该等价于：

value.foreach( x =&amp;gt; println(x.toInt) ) // 这一句可以编译

既然后来这个可以编译，为什么前面的写法不行？

在stackoverflow网友和scala群友（特别感谢mustang）的帮助下，终于基本上搞清楚了这个问题，我觉得值得记录一下。

首先， _.toInt 是一种简写，它等价于：

(x) =&amp;gt; x.toInt

这里的x的类型没有指定，它靠scala推导。所以它必须依赖它所属的函数，看它需要什么类型的参数。

如果是这样的代码：

value.foreach( _.toInt )

就没有问题，这是因为，它等价于：

value.foreach ( x =&amp;gt; x.toInt )

由于value是一个Option[String]，所以foreach的参数类型是(String)=&amp;gt;Unit，所以x的类型被成功推导为String，没有任何问题。

当_.toInt放在println中，代码就等价于：

println( x =&amp;gt; x.toInt )

问题在于println的参数类型是：

println(x:Any)

并没有办法为x指定一个具体的类型，所以上面的代码就出错了。

再看一眼println(_.toInt)，似乎它可以有两种展开方式：

println( x =&amp;gt; x.toInt )
x =&amp;gt; println(x.toInt)

如果是后一种，放在value.foreach中，不就没有任何问题了吗？

没错，但是正因为存在多种可能的展开方式，所以scala必须做出一种选择，最终它选择了简单的第一种。

总结规则如下：

1. 如果_后面有调用，比如_.toInt, _.toString这样的，那么它就是展开的单位

2. 如果_作为整体占位符，比如println(_), 那么所在的函数就是展开单位

所以:

println(_.toInt) 将会展开为 println( (x) =&amp;gt; x.toInt )
println(_) 将会展开为 (x) =&amp;gt; println(x)
user.setName(_)将会展开为 (x) =&amp;gt; user.setName(x)
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>使用kotlin重写todomvc上的angularjs示例</title>
                <link>http://freewind.in/posts/2123-use-kotlin-to-rewrite-angularjs-todomvc</link>
                <pubDate>Sun, 19 May 2013 00:55:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2123</guid>
                <description><![CDATA[&lt;p&gt;经过几天的努力，终于成功把todomvc上的angularjs示例，由原生javascript代码，改成了Kotlin代码-即用Kotlin来写代码，然后把它编译成js代码。整个过程比较流畅，有一些地方值得记录下来。&lt;/p&gt;
&lt;p&gt;首先说下Kotlin。Kotlin是一个极其低调的项目，一直在默默地开发，如果不是主动关注的话，都不知道它现在开发到了什么状态，而且至今还没有推出1.0版。这可能跟作者的个性有关，感觉其作者是一个比较温和及低调的人。&lt;/p&gt;
&lt;p&gt;Kotlin现在的状态如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本可用，语法层面已经比较完善，已经看到有一些小项目（比如Idea插件acejump）使用它来开发&lt;/li&gt;
&lt;li&gt;它的IDE支持不错，高亮、格式化、错误检查、基本的代码重构等，都已经提供，而且用起来不卡（不像scala或者xtend)&lt;/li&gt;
&lt;li&gt;Kotlin的卖点之一&amp;ldquo;生成javascript&quot;目前看来基本可用，但与第三方框架集成，还有一些不方便的地方，主要是不能生成JSON形式的代码，以及不能方便的传递函数&lt;/li&gt;
&lt;li&gt;生态环境还没有建立起来，比如web框架、一些成熟java项目的wrapper、比较有亮点的库等，目前都没有看到&lt;/li&gt;
&lt;li&gt;在语法层面上，还缺少一些比较有用的特性，比如传递函数值、macro、或者xml/json的语法支持（这个是我希望直接支持的）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过正因为Kotlin的低调，以及IDEA这些年在高端开发人员中的流行，让我相信它比较靠谱。毕竟它的出发点&amp;rdquo;代替java作为IDEA的开发语言&amp;ldquo;，我想对于Jetbrains公司来说，应该是一个强需求。而Kotlin在开发过程中的稳扎稳打，小步前进，让我们用起来会比较放心：提供了的都是好用的。&lt;/p&gt;
&lt;p&gt;这里正好跟它的竞争对手xtend进行一下对比, Xtend跟Kotlin的行事作风正好相反。当它推出2.x（还是3.x?)版的时候，让人误以为已经是一个成熟可用的版本了，哪知一试，到处都bug。编辑器支持不好，连基本的格式化功能都没提供，随便写几行代码就能遇到一堆bug，IDE还经常卡死。开发团队似乎只顾着开发&amp;rdquo;next big feature&amp;rdquo;，我当时提的一些很基本的issue，值到一年以后才部分修复。所以我现在基本上不再相信Xtend，虽然更喜欢它&amp;ldquo;生成java源代码而非字节码&amp;rdquo;这个功能。&lt;/p&gt;
&lt;p&gt;言归正传，说一下Kotlin的&amp;ldquo;生成Javascript&quot;代码的功能。作为Kotlin的卖点之一，现在只能说基本可用。它目前基本上还没有考虑与第三方js库的集成，而主要是&amp;rdquo;把Kotlin中定义的类及代码以自己特定的方式转为Javascript，并可以操作DOM及Canvas&amp;rdquo;。希望以后Kotlin提供某种方式，能够更好的支持那些比较成熟的前端框架，让代码写起来更加自然。&lt;/p&gt;
&lt;p&gt;Kotlin代码转js代码，目前采用的是code to code，所以我们没有办法使用Java或Kotlin自己提供的jar库。如果我们想使用第三方Kotlin库，需要把它们的源代码加到自己的项目中，并且要保证它没有用到不支持的包和类，且能正确编译。这种方式比我预期中的弱很多，但在实际使用中，发现并不成问题，因为已经有很多好用的js库可供使用，我们只需要定义一些native接口就可以直接用了，还是非常方便的。&lt;/p&gt;
&lt;p&gt;下面是一些与js库集成时必须注意的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;某些js函数要求参数是一处JSON形式的对象，但Kotlin不能生成那种格式，怎么办。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Js code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function save(user) {}
save({ name: &quot;Freewind&quot;, age: 100 })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Kotlin中，首先要生成一个native接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;native fun save(user: User)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里自定义了一个类型User。怎么定义它才对呢？最直观的写法是这样的（错的）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User(val name:String, val age:Int)
save(User(&quot;Freewind&quot;, 100))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码很简洁，可惜这样生成的是Kotlin特有的类代码，不能被save识别，因为它会发现 user.name和user.age都是undefined。(实际上Kotlin生成的 $name以及get_name和set_name）。&lt;/p&gt;
&lt;p&gt;正确的写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;native(&quot;Object&quot;) class User {
    var name:String = noImpl
    var age: Int = noImpl
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的noImpl是由Kotlin提供的一个占位符，如果在native中使用它，并不会对生成的代码产生影响，因为用native声明的类并不会生成对应的js代码，它们仅仅起到辅助类型检查的作用。&lt;/p&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var user = User()
user.name = &quot;Freewind&quot;
user.age = 100
save(user)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它生成的js代码如下（伪代码）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var user = new Object(); // TODO: new function() ?
user.name = &quot;Freewind&quot;;
user.age = 100;
save(user);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样代码虽然啰嗦一点，但生成的js代码能用。目前只能这样做了，希望以后Kotlin能提供一种更直接的转换方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何引用一个已经存在的js对象或方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如引入了angular.js后，在js中就可以直接使用angular这个对象。在Kotlin中，我们应该这么做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;native trait Angular {
    fun module(name:String, deps: Array[String])
}
native var angular: Angular = noImpl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即使用native来声明一个已经存在的对象，同时为了以类型安全的方式调用它的方法，还要定义一个native的trait。&lt;/p&gt;
&lt;p&gt;如果想让声明的变量的名字跟原有的不同，可以这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;native(&quot;\$&quot;) val jq: Any = noImpl
native(&quot;_&quot;) val underscore : Any = noImpl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同理，如果是function，可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;native fun forEach(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;如何给array增加方法？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kotlin为js提供的array，缺少了很多js中对应的方法。我们可以用native的方式补全它们：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;native fun &lt;T&gt; Array&lt;T&gt;.push(x: T) = js.noImpl
&lt;br  /&gt;native fun &lt;T&gt; Array&lt;T&gt;.splice(i1: Int, i2: Int) = js.noImpl
&lt;br  /&gt;native fun &lt;T&gt; Array&lt;T&gt;.indexOf(x: T) = js.noImpl
&lt;br  /&gt;native fun &lt;T&gt; Array&lt;T&gt;.filter(x: (T)-&gt;Boolean) = js.noImpl
&lt;br  /&gt;native fun &lt;T&gt; Array&lt;T&gt;.forEach(x: (T)-&gt;Unit) = js.noImpl
&lt;br  /&gt;native val &lt;T&gt; Array&lt;T&gt;.length: Int = js.noImpl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2.  如何传一个函数当参数

Js中经常有一些参数实际上是函数类型的，比如：

    ```
function filter(arr, test) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的test，实际上可以看成是一个 (item)-&gt;Boolean的函数。我们在Kotlin中，可以这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;native fun filter&lt;T&gt;(arr: Array&lt;T&gt;, test: (T)-&gt;Boolean)
&lt;br  /&gt;filter(array(1,2,3), { it&gt;1 })
&lt;br  /&gt;filter(array(1,3,3), { x -&gt; x&gt;1 })&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;由于在Kotlin中定义一个可传递的function很不方便，它的标准格式是这样的：

    ```
val test = { (a:String, b:Int, c:User) -&amp;gt; true }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们需要声明类型的时候，必须要写外面的大括号和里面的小括号，当嵌套较多时，代码可读性很差。如果能让我们写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;val test = { a:String, b:Int, c:User -&gt; true }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;或者

    ```
val test = (a:String, b:Int, c:User) -&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就好了，可惜现在还不支持。虽然我们可以换一种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;native fun doit( crazy: (a:String, b:Int, c:User) -&gt; Boolean)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;那就可以写成：

    ```
doit { a,b,c -&amp;gt; ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但实际上这种方式并没有那么好用，因为很多js库的参数都非常灵活，很难在native定义时，给它指明各个类型，这么做太别扭了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始化代码
&lt;br  /&gt;&lt;p&gt;在Kotlin中，不能在全局域中调用方法，也就是说，你不能这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val app = angular.module(&quot;test&quot;, array())
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;而必须这么做：

    ```
fun main() {
    val app = angular.module(&quot;test&quot;, array())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，Kotlin中定义的代码，都会放在一个module中，在js里也没有办法直接调用，必须选取得其module。上面那段代码，我们必须在html或者某个js文件中，手动调用它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;script type=&quot;text /javascript&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Kotlin.modules[&quot;some-module&quot;].main();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/script&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;基本问题这么多，更多的是要在实际写代码时体会。在改写todomvc的代码时，开始遇到了很多错误，但当我把它们一个个解决以后，再刷新页面，一下子全都运行正常了，让我当时有点难以相信。

项目代码放在这里：[http://github.com/freewind/kotlin-angularjs](http://github.com/freewind/kotlin-angularjs)，有兴趣的同学可以看看。

最后想说的是，等Kotlin再成熟一些之后（半年？一年？），可以尝试使用它来同时写前后端代码。可以跟第三方js框架结合（比如angularjs等），甚至会有某个Kotlin框架直接把前后端搞定。之前用js写Angularjs代码时，当业务逻辑一旦复杂，我就很难记得一个scope里到底定义了多少字段和多少函数，而用Kotlin时可以声明好，大大减少了记忆量和手误。

由于这次的尝试还比较顺利，我将会在以后用它写一些更复杂的程序，尝试用Kotlin同时搞定前后端。
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>尝试用Kotlin写angularjs</title>
                <link>http://freewind.in/posts/2117-try-to-use-kotlin-to-write-angularjs</link>
                <pubDate>Wed, 15 May 2013 21:07:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2117</guid>
                <description><![CDATA[&lt;p&gt;Kotlin在主页上的介绍是这样的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Kotlin&lt;/p&gt;
&lt;p&gt;is a statically typed programming language that compiles to JVM byte codes and JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出它的卖点之一是生成javascript。&lt;/p&gt;
&lt;p&gt;我想尝试用它写angularjs程序，如果能够顺利实现，以后就尝试用它同时写前后端。&lt;/p&gt;
&lt;p&gt;目前的感觉是Kotlin在语法层面还是比较死板，在支持angularjs中一些比较灵活的写法时，代码相当难看。&lt;/p&gt;
&lt;p&gt;先看这一段很常见的标准的directive写法，以下是javascript代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;todomvc.directive(&apos;todoFocus&apos;, function todoFocus($timeout) {
    return function (scope, elem, attrs) {
        scope.$watch(attrs.todoFocus, function (newVal) {
            if (newVal) {
                $timeout(function () {
                    elem[0].focus();
                }, 0, false);
            }
        });
    };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看在kotlin中怎么写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val todoFocus = {(timeout: Timeout) -&amp;gt;
    {(scope: BaseScope, elem: Elem, attrs: Attrs) -&amp;gt;
        scope.`$watch`(attrs.todoFocus, { (newVal: Any) -&amp;gt;
            if(newVal as Boolean) {
                timeout({ elem[0].focus() }, 0, false);
            }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不能不说Kotlin这种写法，可读性实在太差了。在Kotlin中，对于函数值的支持不太好，而且语法形式也不太好看。它只支持这种声明方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ (a:String, b:Int) -&amp;gt;
    // do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当嵌套一多，就是前面那种效果。另外kotlin的变量中不能使用&lt;code&gt;$&lt;/code&gt;，而在angularjs中大量使用，所以我们还需要用反引号包一下。&lt;/p&gt;
&lt;p&gt;我希望Kotlin能提供类似javascript中的那种声明方式，即使用fun来声明变量值，这样的话，代码可以写成与javascript版本基本一致，可读性就好很多。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://devnet.jetbrains.com/message/5487375#5487375&quot;&gt;http://devnet.jetbrains.com/message/5487375#5487375&lt;/a&gt;上提了个问，看看有没有给出更好的写法，不过目前看来应该是没有了。如果是这样，只能再等等看了，毕竟现在的这种写法，实在让人没法接受。&lt;/p&gt;
&lt;p&gt;刚看到这个问题有人回答，给出了一种直接引用函数的写法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun test(): (Int) -&amp;gt; Int {
    fun inner(i: Int) = i
    return ::inner
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但在我的最新版的Kotlin上编译不过，听说是一个正在实现中的功能。如果实现的话，的确会有很大程度上解决上面的问题（不过嵌套多的时候，还是有点麻烦，毕竟要起多个名字）。&lt;/p&gt;
&lt;p&gt;保持关注。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>黑苹果信息</title>
                <link>http://freewind.in/posts/2114-black-apple-information</link>
                <pubDate>Sat, 11 May 2013 10:25:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2114</guid>
                <description><![CDATA[&lt;p&gt;使用Macbook Pro一周了，感觉非常舒适，特别是它的触摸板操作，不仅可以代替鼠标，而且操作起来更加流畅方便。这个东西真是没用过的人很难想像的。&lt;/p&gt;
&lt;p&gt;所以我在想要不要在家里也弄一台苹果，最省事的方式是直接买一台原装的mac mini，大约三千到四千。不过因为资金有限，所以我还考察了一下黑苹果的方案。目前了解到的信息如下。&lt;/p&gt;
&lt;p&gt;首先自己diy一台苹果主机难度还是比较大的，因为要买到正好被苹果系统支持的各种硬件，有很大的运气成分，而且装驱动调试什么的，不是一般人搞得定的，所以最好是直接买别人diy好的。&lt;/p&gt;
&lt;p&gt;如果想买笔记本，可以在淘宝上搜到很多。根据配置不同，价格在2000到4000之间。它们安装了苹果的操作系统，大部分功能都可以直接使用，只是普通笔记本的触摸板功能太弱，使用很不方便。比如大多数只支持单指，少数支持两指，但在苹果系统中经常会用到三指和四指。触摸板是苹果系统的精华所在，所以我们可以考虑再购买一块苹果触摸板配合使用，如果是原装的，价格在350到400之间，还有一些从旧笔记本上拆机的，价格比较便宜在100左右。有了它基本上就不需要鼠标了。如果不想买触摸板，用鼠标也行，只是使用体验会大大降低，那还不如用windows机了。&lt;/p&gt;
&lt;p&gt;如果买台式机，淘宝上的选择也很多。有使用e3 1230 cpu的，价格在4000左右，对于编程开发和日常使用，已经非常足够了。低端一点的有不到2000的，配置略低，一般用来开发iphone应用的，应该也够用。如果我要买的话，会买一台e3 1230的机器，做scala编程肯定够用。&lt;/p&gt;
&lt;p&gt;还有一些外观仿mac mini的，个头很小巧，2000靠下，也是苹果系统，可以用来作为简单的应用。&lt;/p&gt;
&lt;p&gt;不论选哪种方案，我觉得触摸板都是一定要的，不然就没有意义了。另外需要注意的是，淘宝上有的只是外观仿苹果，系统还是windows，一定要买装了苹果系统的。&lt;/p&gt;
&lt;p&gt;对于程序员，我觉得应该尝试一下苹果系统。使用触摸板+快捷键，可以让我们的操作更快捷流畅，苹果的命令行功能又很强大，简直就是为开发人员准备的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>通过修改键盘布局使用mac的option键，为idea设置方便的快捷键</title>
                <link>http://freewind.in/posts/2111-change-mac-option-key-to-provide-more-keyshorts-for-idea</link>
                <pubDate>Thu, 09 May 2013 21:11:14 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2111</guid>
                <description><![CDATA[&lt;p&gt;Mac上的辅助键有4个：control, option(alt), command, shift，比windows上多一个。（注意windows上的ctrl键的大部分功能，在苹果上是command）&lt;/p&gt;
&lt;p&gt;在Idea中，发现很多option键+字母组合的快捷键不能用。比如我想像vim那样，用option加上hjkl来移动光标，但按option+j的时候居然没反应。使用其它的键又怕跟别人冲突，因为现在工作中经常需要结对编程。而在editor中按option+j的时候，它会输入一些奇怪的字符，完全浪费了这么一个好键。如果能把它利用起来就好了。&lt;/p&gt;
&lt;p&gt;经过搜索，发现有人问了同样的问题，并且给出了多个解决方案。经过我的测试，最方便的是这个：&lt;a href=&quot;http://stackoverflow.com/a/16019737/342235&quot;&gt;http://stackoverflow.com/a/16019737/342235&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说，就是它里面提到的那个网站，自定义一份mac下使用的键盘布局方案。由于默认值已经把option处理好了，所以我们直接下载即可。下载后，把它拷贝到~/Library/Keyboard Layouts目录下，再在系统设置的“语言与文字”那里，找到并选中我们刚拷过去的那个方案名即可。&lt;/p&gt;
&lt;p&gt;这时注意在右上角的输入法图标处，会多出一行，我们需要把它选中才能看到效果。（这里需要注意，因为我在这里浪费了半个小时）。然后再到Idea中试试，没有意外的话，就可以用option+字母来作为快捷键了。用它定义的快捷键，既简短，又很少会跟原有的冲突，非常好。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Lift项目零散笔记</title>
                <link>http://freewind.in/posts/2108-notes-from-a-lift-project</link>
                <pubDate>Thu, 09 May 2013 10:19:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2108</guid>
                <description><![CDATA[&lt;h2&gt;SBT&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;alias&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;alias rr=;container:stop;container:start&lt;/p&gt;
&lt;p&gt;还没找怎么把它放到sbt的全局文件中&lt;/p&gt;
&lt;h2&gt;lift&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;想在lift关闭时执行一些操作（如关闭数据库连接池），可以Boot.boot中加入LiftRules.unloadHook.append(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;可使用field(&amp;hellip;)代替addField(&amp;hellip;)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;druid&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;druid是阿里的项目，它的特点是性能好，监控功能强（还未试），有sql parser解析检查sql注入、统计等（这个有点变态），官网上说parser是手写的，比用javacc/antlr生成的效率要高很多&lt;/li&gt;
&lt;li&gt;在lift中使用druid，需要以编程构造一个datasource，传入&lt;code&gt;SquerylRecord.initWithSquerylSession(Session.create(DruidInitializer.ds.getConnection(), adapter))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;druid会先找依次找log4j及其它logger，如果发现哪个找不到，就会把ClassNotFound异常打印到console，这个做法有点邪门，因为我还以为哪里出错了，找了一圈，最后看到源代码(LogFactory.tryImplementation)才知道。它起码应该加个提示信息才对。&lt;/li&gt;
&lt;li&gt;druid的统计信息，是通过filter扩展进去的，还要注册一个MBean，才能在jconsole中查看到实时信息（需验证）&lt;/li&gt;
&lt;li&gt;还可以定制druid的logger，比如打印哪些数据（需验证）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;scala&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;java: &lt;code&gt;void close()&lt;/code&gt;, scala: &lt;code&gt;append( ()=&amp;gt; unit)&lt;/code&gt;，则可以&lt;code&gt;append(close _)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;font-family: monospace;&quot;&gt;XML字面量&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;/b&gt;的类型是NodeSeq&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>ACM网站搜集</title>
                <link>http://freewind.in/posts/2097-acm-websites</link>
                <pubDate>Wed, 01 May 2013 22:21:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2097</guid>
                <description><![CDATA[&lt;p&gt;常用的：&lt;a href=&quot;http://poj.org&quot;&gt;http://poj.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持Scala的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://acm.timus.ru/problemset.aspx?space=1&amp;amp;page=all&quot; title=&quot;http://acm.timus.ru/problemset.aspx?space=1&amp;amp;page=all&quot;&gt;http://acm.timus.ru/problemset.aspx?space=1&amp;amp;page=all&lt;/a&gt;，还支持如clojure/go等语言&lt;/li&gt;
&lt;li&gt;spoj&lt;/li&gt;
&lt;li&gt;codeforces&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以下载测试数据的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;codeforce，不过大数据还是下不下来&lt;/li&gt;
&lt;li&gt;usaco，全部的测试数据都有，一开始做oi的都推荐刷这个，很全面&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>新的旅程</title>
                <link>http://freewind.in/posts/2096-new-way-to-thoughtworks</link>
                <pubDate>Sun, 28 Apr 2013 21:44:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2096</guid>
                <description><![CDATA[&lt;p&gt;有很长一段时间没有写博客了，主要是因为找工作及家里琐事较多，没多少时间放在技术方面，无话可写。&lt;/p&gt;
&lt;p&gt;前段时间在一个大学朋友的推荐下，经过前后一个月左右的面试与等待，终于进了武汉IBM GDC，准备开发一个J2EE的项目。这是一段短暂而深有感触的经历，因为我两周之后离了职。在这里我先得向我的项目经理吴经理说声抱歉，我的离开辜负了他的期望，也打乱了他的项目计划。关于公司有一些感触，不过有些不好说出来，毕竟呆的时间太短，难免狭隘。总体感受就是这里不太适合喜欢钻研技术的朋友，各种繁琐的流程制度会让人很压抑也很无奈；但非常适合英语好、有一定技术、遵规守矩、并且希望工作轻闲的朋友，这里简直就是天堂了。如果你打算在武汉定居，不妨首先考虑一下这个公司。另外在这里向尹同学和新认识的几位朋友打个招呼，很高兴认识你们。&lt;/p&gt;
&lt;p&gt;离开IBM的原因是因为有机会加入另一家我期待已久的公司。在群友大魔头的推荐下，我有幸参与了面试。在与北京的人事MM交流的过程中，与上海几位同事一起进行面试的过程中，与上海主管的视频交流中，都有太多让我感动的细节了。大家都以一种非常平等而且真诚的方式交流，不像以往面试时那样，总有种例行公事般的客气实际感觉遥远，或者如货柜上的商品被挑选的感觉。他们很真切地考虑了我远离湖北去上海可能遇到的困难以及给家庭带来的不便，嘱咐我一定要与亲人们沟通好，让他们放心，并且在最后确定工资的时候，竟然比我提出来的还要高。人事MM说“因为你远离家乡到上海，一定会遇到很多困难，我们这么做只是希望能帮你减轻一些压力”。在这里我只能先向你们说一声感谢，并以实际行动来证明自己不会让你们失望。&lt;/p&gt;
&lt;p&gt;群里有很多朋友，特别是搞scala的一帮，基本上都在上海，这次过去，有种回到组织的感觉。曾经以为会一直呆在湖北，没想到最终还是要去上海，希望以后能与大家多多交流、共同进步，多结识几个好友。&lt;/p&gt;
&lt;p&gt;新的旅程要开始了，马上就要上海贼船了，向One Piece出发！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>JavaCC练习题</title>
                <link>http://freewind.in/posts/2093-javacc-practices</link>
                <pubDate>Wed, 03 Apr 2013 17:23:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2093</guid>
                <description><![CDATA[&lt;ol&gt;
&lt;li&gt;给一段文本中，从中找到可作为合法的java变量名的字符串片断。即以字母、_和$开头，后面还可以有数字。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如：sdj08f8dHH^563d8E&amp;amp;2eewef&lt;/p&gt;
&lt;p&gt;里面可以找到&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;sdj08f8dHH&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;d8E&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;eewef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;四则运算计算器，包含加减乘除和括号运算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用javafx写一个gui界面，实现一个完整的计算器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个json parser，可解析json字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;完善4中的json parser，可以将json字符串格式化后输出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个解析器，可以解析play1的routes文件格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个html解析器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个简单的sql解析器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个markdown格式的解析器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个java代码解析器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>调用eclipse的JDT编译java源代码</title>
                <link>http://freewind.in/posts/2090-invoke-eclipse-jdt-to-compile-java-source-code</link>
                <pubDate>Sun, 31 Mar 2013 20:06:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2090</guid>
                <description><![CDATA[&lt;p&gt;Play的源代码是一个宝库，从里面学到了很多。&lt;/p&gt;
&lt;p&gt;Play为了能够对java源代码的编译过程进行控制，以实现一些魔术效果，使用了eclipse的JDT来手动进行编译。今天我把相关的代码抽出来，写成了一个独立运行的例子，并且成功地将指定目录下的java源文件编译成了.class文件。&lt;/p&gt;
&lt;p&gt;当我们安装了eclipse后，它里面就自带了jdt的库，并且以jar的形式提供了字节码文件和源文件。以我下载的eclipse 4.2为例，可以在其plugins目录下找到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;org.eclipse.jdt.core_3.8.3.v20130121-145325.jar&lt;/li&gt;
&lt;li&gt;org.eclipse.jdt.core_3.8.3_source.v20130121-145325.jar&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前者是字节码，后者是源文件。最好把两个都拷贝到项目中，因为在调用ecilpse相关的类时，肯定需要查看源代码和注释。&lt;/p&gt;
&lt;p&gt;org.eclipse.jdt包下还有其它几个jar，不过对于编译这个基本功能来说，都用不上。&lt;/p&gt;
&lt;h2&gt;这里先简单的描述一下jdt编译的过程&lt;/h2&gt;
&lt;p&gt;我们需要传入一些参数生成一个org.eclipse.jdt.internal.compiler.Compiler的实例，然后调用其compile方法，就可以编译指定的java源文件。“如何编译”这些复杂的事情，都由JDT内部解决了，由我们需要需要帮助它寻找到正确的信息（如类、包等）。&lt;/p&gt;
&lt;p&gt;首先看一下Compiler庞大的构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public Compiler(
    INameEnvironment environment,
    IErrorHandlingPolicy policy,
    CompilerOptions options,
    final ICompilerRequestor requestor,
    IProblemFactory problemFactory) {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个参数都有自己的作用，这里一一道来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;INameEnvironment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们需要自己写个类实现该接口，它用于根据JDT传过来的包名类名，找到正确的字节码或者源文件给它。比如它会传过来类似于java.lang.String这样的数据，我们就需要调用classloader.getResourceAsString(“java/lang/String.class”)找到正确的字节码文件对应的二进制数据，回传过去。如果传来的是我们自己的文件路径，比如&quot;aaa.BBB&amp;rdquo;，那我们就要去寻找自己指定的目录下的&quot;aaa/BBB.java&quot;文件，把该文件传过去，让它继续编译。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IErrorHandlingPolicy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇到错误时怎么办。一般采用DefaultErrorHandlingPolicies.exitOnFirstError()，即遇到第一个错误就退出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CompilerOptions&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制编译的参数，比如OPTION_LineNumberAttribute，OPTION_SourceFileAttribute，OPTION_LocalVariableAttribute等等，可让JDT在编译时，是否保留某些信息。&lt;/p&gt;
&lt;p&gt;对于上面的三个参数，Play都指定为GENERATE，让JDT在字节码中尽可能多的保留源文件中的信息，以方便后面使用javassist进行字节码增强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ICompilerRequestor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取回编译结果。如果编译成功，则可以拿到编译后的字节码二进制数据，否则可以拿到错误信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IProblemFactory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制错误信息的locale、格式等。这里可直接使用new DefaultProblemFactory(Locale.ENGLISH)，即返回英文的错误信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ICompilationUnit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，我们还要自己实现一个ICompilationUnit。当我们把一个java源文件传给JDT时，不是简单地传一个File过去，而是用ICompilationUnit包装起来，以方便JDT取得文件名、类名和源代码等数据。由于ICompilationUnit并不要求一定得是一个文件，所以我们还可以直接在程序中返回源代码。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;下面是具体的代码，需要注释说明的地方都已经注明，另外强烈建议查看JDT相关类的注释，写得很详细：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.eclipse.jdt.core.compiler.IProblem;
import org.eclipse.jdt.internal.compiler.ClassFile;
import org.eclipse.jdt.internal.compiler.CompilationResult;
import org.eclipse.jdt.internal.compiler.Compiler;
import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;
import org.eclipse.jdt.internal.compiler.ICompilerRequestor;
import org.eclipse.jdt.internal.compiler.IErrorHandlingPolicy;
import org.eclipse.jdt.internal.compiler.IProblemFactory;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;
import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;
import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;
import org.eclipse.jdt.internal.compiler.env.INameEnvironment;
import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;
import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

/**
 * User: Freewind
 * Date: 13-3-31
 * Time: 下午5:22
 * Blog: http://freewind.github.io
 */
public class CompileWithJDT {

    private static final File CURRENT = new File(&quot;X:\\WORKSPACE\\dive_in_play\\EclipseJDT\\data&quot;);
    private static final File SOURCES_DIR = new File(CURRENT, &quot;sources&quot;);
    private static final File BYTECODES_DIR = new File(CURRENT, &quot;bytecodes&quot;);

    public static void main(String[] args) {

        /**
         * To find types ...
         */
        INameEnvironment nameEnvironment = new INameEnvironment() {

            /**
             * @param compoundTypeName {{&apos;j&apos;,&apos;a&apos;,&apos;v&apos;,&apos;a&apos;}, {&apos;l&apos;,&apos;a&apos;,&apos;n&apos;,&apos;g&apos;}}
             */
            public NameEnvironmentAnswer findType(final char[][] compoundTypeName) {
                return findType(join(compoundTypeName));
            }

            public NameEnvironmentAnswer findType(final char[] typeName, final char[][] packageName) {
                return findType(join(packageName) + &quot;.&quot; + new String(typeName));
            }

            /**
             * @param name like `aaa`,`aaa.BBB`,`java.lang`,`java.lang.String`
             */
            private NameEnvironmentAnswer findType(final String name) {
                System.out.println(&quot;### to find the type: &quot; + name);

                // check data dir first
                File file = new File(SOURCES_DIR, name.replace(&apos;.&apos;, &apos;/&apos;) + &quot;.java&quot;);
                if (file.isFile()) {
                    return new NameEnvironmentAnswer(new CompilationUnit(file), null);
                }

                // find by system
                try {
                    InputStream input = this.getClass().getClassLoader().getResourceAsStream(name.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;);
                    if (input != null) {
                        byte[] bytes = IOUtils.toByteArray(input);
                        if (bytes != null) {
                            ClassFileReader classFileReader = new ClassFileReader(bytes, name.toCharArray(), true);
                            return new NameEnvironmentAnswer(classFileReader, null);
                        }
                    }
                } catch (ClassFormatException e) {
                    // Something very very bad
                    throw new RuntimeException(e);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

                System.out.println(&quot;### type not found: &quot; + name);
                return null;
            }

            public boolean isPackage(char[][] parentPackageName, char[] packageName) {
                String name = new String(packageName);
                if (parentPackageName != null) {
                    name = join(parentPackageName) + &quot;.&quot; + name;
                }

                File target = new File(SOURCES_DIR, name.replace(&apos;.&apos;, &apos;/&apos;));

                // only return false if it&apos;s a file
                // return true even if it doesn&apos;t exist
                return !target.isFile();
            }

            public void cleanup() {
            }
        };

        /**
         * Compilation result
         */
        ICompilerRequestor compilerRequestor = new ICompilerRequestor() {

            public void acceptResult(CompilationResult result) {
                // If error
                if (result.hasErrors()) {
                    for (IProblem problem : result.getErrors()) {
                        String className = new String(problem.getOriginatingFileName()).replace(&quot;/&quot;, &quot;.&quot;);
                        className = className.substring(0, className.length() - 5);
                        String message = problem.getMessage();
                        if (problem.getID() == IProblem.CannotImportPackage) {
                            // Non sense !
                            message = problem.getArguments()[0] + &quot; cannot be resolved&quot;;
                        }
                        throw new RuntimeException(className + &quot;:&quot; + message);
                    }
                }

                // Something has been compiled
                ClassFile[] clazzFiles = result.getClassFiles();
                for (int i = 0; i &amp;lt; clazzFiles.length; i++) {
                    String clazzName = join(clazzFiles[i].getCompoundName());

                    // save to disk as .class file
                    File target = new File(BYTECODES_DIR, clazzName.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;);
                    try {
                        FileUtils.writeByteArrayToFile(target, clazzFiles[i].getBytes());
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        };

        IProblemFactory problemFactory = new DefaultProblemFactory(Locale.ENGLISH);
        IErrorHandlingPolicy policy = DefaultErrorHandlingPolicies.exitOnFirstError();

        /**
         * The JDT compiler
         */
        org.eclipse.jdt.internal.compiler.Compiler jdtCompiler = new Compiler(
                nameEnvironment, policy, getCompilerOptions(), compilerRequestor, problemFactory);

        // Go !
        jdtCompiler.compile(new ICompilationUnit[]{new CompilationUnit(new File(SOURCES_DIR, &quot;aaa/BBB.java&quot;))});
    }

    public static CompilerOptions getCompilerOptions() {
        Map&amp;lt;string  , string&amp;gt; settings = new HashMap();
        settings.put(CompilerOptions.OPTION_ReportMissingSerialVersion, CompilerOptions.IGNORE);
        settings.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.GENERATE);
        settings.put(CompilerOptions.OPTION_SourceFileAttribute, CompilerOptions.GENERATE);
        settings.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.IGNORE);
        settings.put(CompilerOptions.OPTION_ReportUnusedImport, CompilerOptions.IGNORE);
        settings.put(CompilerOptions.OPTION_Encoding, &quot;UTF-8&quot;);
        settings.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.GENERATE);
        String javaVersion = CompilerOptions.VERSION_1_5;
        if (System.getProperty(&quot;java.version&quot;).startsWith(&quot;1.6&quot;)) {
            javaVersion = CompilerOptions.VERSION_1_6;
        } else if (System.getProperty(&quot;java.version&quot;).startsWith(&quot;1.7&quot;)) {
            javaVersion = CompilerOptions.VERSION_1_7;
        }
        settings.put(CompilerOptions.OPTION_Source, javaVersion);
        settings.put(CompilerOptions.OPTION_TargetPlatform, javaVersion);
        settings.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.PRESERVE);
        settings.put(CompilerOptions.OPTION_Compliance, javaVersion);
        return new CompilerOptions(settings);
    }

    private static class CompilationUnit implements ICompilationUnit {

        private File file;

        public CompilationUnit(File file) {
            this.file = file;
        }

        @Override
        public char[] getContents() {
            try {
                return FileUtils.readFileToString(file).toCharArray();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public char[] getMainTypeName() {
            return file.getName().replace(&quot;.java&quot;, &quot;&quot;).toCharArray();
        }

        @Override
        public char[][] getPackageName() {
            String fullPkgName = this.file.getParentFile().getAbsolutePath().replace(SOURCES_DIR.getAbsolutePath(), &quot;&quot;);
            fullPkgName = fullPkgName.replace(&quot;/&quot;, &quot;.&quot;).replace(&quot;\\&quot;, &quot;.&quot;);

            if (fullPkgName.startsWith(&quot;.&quot;)) fullPkgName = fullPkgName.substring(1);

            String[] items = fullPkgName.split(&quot;[.]&quot;);
            char[][] pkgName = new char[items.length][];
            for (int i = 0; i &amp;lt; items.length; i++) {
                pkgName[i] = items[i].toCharArray();
            }
            return pkgName;
        }

        @Override
        public boolean ignoreOptionalProblems() {
            return false;
        }

        @Override
        public char[] getFileName() {
            return this.file.getName().toCharArray();
        }
    }

    private static String join(char[][] chars) {
        StringBuilder sb = new StringBuilder();
        for (char[] item : chars) {
            if (sb.length() &amp;gt; 0) {
                sb.append(&quot;.&quot;);
            }
            sb.append(item);
        }
        return sb.toString();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我在代码中，要求它编译sources目录下的aaa包下的BBB.java文件。它们的源代码如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aaa/BBB.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package aaa;

public class BBB {
    public static void main(String[] args) {
        new CCC().hello(&quot;JDT&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;aaa/CCC.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package aaa;

public class CCC {

    public void hello(String name) {
        System.out.println(&quot;Hello, &quot; + name);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行成功后，将会成功的在bytecodes目录下，生成BBB.class和CCC.class文件。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play1.2.x源代码阅读之 enhancers</title>
                <link>http://freewind.in/posts/2089-source-reading-play1-enhancers</link>
                <pubDate>Mon, 25 Mar 2013 16:35:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2089</guid>
                <description><![CDATA[&lt;p&gt;Play中的代码增强是play的魔力之源。Play自己控制java源代码的编译与载入，所以有机会在载入到jvm之前，调用各种enhancer对字节码进行增强，从而获得超强的功能。&lt;/p&gt;
&lt;p&gt;Play的代码增强都是基于javassist这个超级强大又易用的字节码工具库。&lt;/p&gt;
&lt;h2&gt;play.classloading.enhancers.Enhancer&lt;/h2&gt;
&lt;p&gt;Enhancer是一个abstract的基类，为其它enhancer做了一些准备工作，提供了一些工具方法。它创建了一个javassist.ClassPool实例，并把自定义的ApplicationClassLoader所使用的classpath、以及当前项目中的java源代码路径都传了进去，以保证javassist可以找到所有需要的源代码。&lt;/p&gt;
&lt;p&gt;Play中通常使用Annotation作为增强的标记，所以它提供了很多与之相关的工具方法，供子类使用，如hasAnnotation/createAnnotation等。&lt;/p&gt;
&lt;p&gt;最关键的方法是一个虚方法：enhanceThisClass(ApplicationClass applicationClass)，子类需要实现该方法。传入的ApplicationClass实例相当于一个java源文件，它保存了源文件，原始字节码等信息，在子类中可使用javassist相关方法对原始子节码进行操作，并把增强后的字节码赋给applicationClass.enhancedByteCode&lt;/p&gt;
&lt;h2&gt;play.classloading.enhancers.PropertiesEnhancer&lt;/h2&gt;
&lt;p&gt;Play已经内置了一些enhancer。首先是这个PropertiesEnhancer，它可以让我们用字段来实现Property。&lt;/p&gt;
&lt;p&gt;在play中，我们可以这样定义类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    public String name;
    public String email;
}

同时在其它类中，也可以直接访问这些字段：

User user = new User();
System.out.println(user.name);

这种方式，让我们的代码看起来简单很多，因为我们不需要再定义一大堆的getter和setter，也不需要在赋值时使用user.setName(&quot;)这种复杂的方式。

这样会让我们有些疑问，因为很多库如hibernate，会对getter/setter进行增强，插入它们自己的代码。而我们这样写，会不会跟他们产生矛盾？

Play通过javassist的强大功能，解决了这个问题。首先是为User类添加getter/setter：如果某个字段是public的，并且没有找到对应的getter/setter，则创建。然后，把项目中包括其它java类对这些字段的所有访问，全部替换为相应的getter/setter。

这样我们看到且操作的是字段，由实际上都被转换为getter/setter，所以不会与其它的库产生冲突。

## play.classloading.enhancers.LVEnhancer

LV是指LocalVariable，这个类在Play1.2.5及之前的版本中不叫这个名字，我fork的是play1.3.x。

它的作用是为类中为每一个方法添加一个字段，记录其参数名称。因为play自己调用了eclipse的jdt进行编译，并且在编译时保留了参数名称，所以它可以得到正确的参数名称。这样做比较有用，你还记得我们在定义action时，可以直接定义一些参数，就能拿到同名的request param吗？

public static void login(String username, String password) {
    // 直接使用username和password，它们对应reuqest.params.get(&quot;username&quot;)和get(&quot;password&quot;)
}

要是在别的框架中，最起码也要这么写：

public static void login(@Param(&quot;username&quot;) String username, 
                         @Param(&quot;password&quot;) String password) {
}

这就是因为play已经事先把login方法对应的参数名记录下来了。

另外，play还会将局部变量的名字也保存起来，比如我可以在action中这么写：

public static void hello() {
    String name = &quot;world&quot;;
    render(name);
}

Play将会把name这个名字与它的值保存在一个栈中，之后可以通过值找到相应的名字。

如果在其它的框架中，就得写成这样：

public static void hello() {
    String name = &quot;world&quot;;
    Map&amp;lt;string object ,&amp;gt; data = new HashMap();
    data.put(&quot;name&quot;, name);
    render(data);
}

Play让我们的代码尽可能的简洁。

具体实现细节以后补充。

## play.classloading.enhancers.SigEnhancer

该类会计算某一个类的特征，比如类名，各字段、方法相关的类型和名称，static初始化代码等，把它们保存applicationClass的sigChecksum字段中。

当Play执行detectChanges时，会在每次enhance一个类前后对比该值，如果发现变化了，则抛出异常。但我还不太明白为什么要这么做，留待以后。

## play.classloading.enhancers.ControllersEnhancer

该类对controller进行增强。

我们在action中，可以直接调用一些static字段，如request.getXxx(), params.get(“xxx”)。在调用时，我们知道它们是“线程安全”的，但是，为什么？要知道它们是static的，是可以被多线程同时访问的。

原来ControllersEnhancer对它们进行的替换。当我们调用&quot;params&quot;&apos;、 &quot;request&quot;、 &quot;response&quot;、 &quot;session&quot;、 &quot;params&quot;、 &quot;renderArgs&quot;、 &quot;routeArgs&quot;、 &quot;validation&quot;、 &quot;inbound&quot;、 &quot;outbound&quot;、 &quot;flash&quot; 这些参数时，它们都会被替换为：

Xxx.current()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的形式，从而从ThreadLocal中获取当前线程绑定的值。&lt;/p&gt;
&lt;p&gt;该类还进行了其它增强，比如当一个action被调用时要进行判断，是当作一个普通的方法调用，还是返回一个redirect的response给客户端。&lt;/p&gt;
&lt;p&gt;另外，play中render()等方法，会以抛出异常的方式判断模板层，为了保证该异常不会被其它类捕获，在这里也进行了检查和屏蔽。&lt;/p&gt;
&lt;h2&gt;play.classloading.enhancers.MailerEnhancer&lt;/h2&gt;
&lt;p&gt;该类向Mailer相关的controller中插入了一些保护性代码，具体作用不明。&lt;/p&gt;
&lt;h2&gt;play.classloading.enhancers.ContinuationEnhancer&lt;/h2&gt;
&lt;p&gt;该类可让我们的controller支持如continuation，以支持像ajax聊天室那样的功能。即当我们的代码需要等待一些数据（如IO操作，新的聊天信息的到来）时，在保持http连接不断开的同时，腾出当前线程做别的事情。当需要的数据到达时，再恢复线程继续刚才的事情。这样就不会有线程处于无谓的等待状态，可处理更多的请求。&lt;/p&gt;
&lt;p&gt;Play使用了commons-javaflow这个库来实现该功能。当我们的代码调用了controller中的await方法时，则会使用org.apache.commons.javaflow.bytecode.transformation.asm.AsmClassTransformer这个类，来增强当前类。&lt;/p&gt;
&lt;p&gt;细节之处待以后研究。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play1.2.x源代码阅读之 classloading</title>
                <link>http://freewind.in/posts/2088-source-reading-play1-classloading</link>
                <pubDate>Mon, 25 Mar 2013 14:56:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2088</guid>
                <description><![CDATA[&lt;h2&gt;play.classloading.ApplicationClasses&lt;/h2&gt;
&lt;p&gt;这是一个重要的容器，它内部有一个cache，保存项目中java源文件及字节码相关的内容。它在内部定义了一个类ApplicationClass，Play把从项目中扫描java文件，根据其文件、源代码、编译后的字节码、增强后的字节码等数据，生成一个个ApplicationClass实例，放在cache中。同时，ApplicationClass还提供了compile, enhance等方法，可将java源代码编译为字节码，再调用Play的各插件及enhancer，对字节码进一步增强。&lt;/p&gt;
&lt;p&gt;为了将java源代码编译为字节码，它还持有一个ApplicationCompiler的实例，用于将java源代码编译为二进制的字节码。&lt;/p&gt;
&lt;h2&gt;play.classloading.ApplicationCompiler&lt;/h2&gt;
&lt;p&gt;play为了得到更快的编译速度，以及对编译过程进行更多的控制，没有使用jdk中自带的javac，而采用了eclipse的jdt。&lt;/p&gt;
&lt;p&gt;而这个ApplicationCompiler类，就是用于封装jdt相关的api。调用JDT时，我们需要向它传入一些编译参数和回调，在回调中可根据jdt传来的类名包名等，返回正确的源代码或源文件。&lt;/p&gt;
&lt;p&gt;Play的采用的编译参数如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;org.eclipse.jdt.core.compiler.debug.lineNumber GENERATE2.  debug.sourceFile GENERATE3.  debug.localVariable GENERATE4.  codegen.unusedLocal PRESERVE&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并忽略以下警告：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;problem.missingSerialVersion2.  problem.deprecation3.  problem.unusedImport&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前面的几个设置很重要，因为play的很多魔术都要依赖它们，必须在生成的字节码中尽量保持源代码中的信息（如参数名，变量名，行号等）。&lt;/p&gt;
&lt;h2&gt;play.classloading.ApplicationClassloader&lt;/h2&gt;
&lt;p&gt;该类是play框架中的核心类之一，继承于ClassLoader，负责play应用中类的导入。它的方法有一部分返回List&lt;ApplicationClass&gt;，即ApplicationClasses中定义的那个ApplicationClass，持有项目中java文件、源代码、字节码等数据，另一部分返回List&lt;Class&gt;，即ApplicationClass中相应的java字节码导入到jvm后返回的类。&lt;/p&gt;
&lt;p&gt;在play的总管类play.Play中持有ApplicationClassloader的实例(play.Play#classLoader)。当某处代码需要载入类时，可直接通过Play.classLoader进行载入。ApplicationClassloader会首先判断是不是项目中的java类，如果是的话，则进行编译、增强，并放入缓存中；否则的话，交给上级classloader，即由jvm自己来处理载入。&lt;/p&gt;
&lt;p&gt;ApplicationClassloader有一个ApplicationClassloaderState的对象，它可以看作一个自增id，用来标识ApplicationClassloader的当前状态。它定义了一个detectChanges方法，可用于检查项目中的java源代码是否增删改，以及引入的插件是否有变化（插件可对java进行增强，所以也需要考虑）。如果发现了变化，则会生成一个新的ApplicationClassloaderState，可让别人知道classloader的状态发生了变化。然后，ApplicationClassloader会尝试以hotswap的方式导入修改的类（轻量，很快），失败的话，会重新载入整个应用（等于重新启动play，比较慢）。&lt;/p&gt;
&lt;h2&gt;play.classloading.ApplicationClassloaderState&lt;/h2&gt;
&lt;p&gt;用于标识ApplicationClassloader的状态类。它内部有一个static的AtomicLong的generator，和一个实例字段currentStateValue。每次生成一个新对象，都会取generator的下一个值赋给currentStateValue。由于AtomicLong保证了原子操作，所以ApplicationClassloaderState的每一个实例的currentStateValue值都不同。通过检查ApplicationClassloader中持有的ApplicationClassloaderState的实例，可以知道classloader状态是否发生了变化。&lt;/p&gt;
&lt;p&gt;对于这个类，我有点小小疑问：直接在ApplicationClassloader中使用一个AtomicLong就可以了，为什么要专门定义一个这样的类呢？&lt;/p&gt;
&lt;h2&gt;play.classloading.BytecodeCache&lt;/h2&gt;
&lt;p&gt;这是一个Cache工具类，它可以把每个java源代码及相应的字节码保存在项目的tmp/bytecode/目录下的某一个文件中，方便使用。在保存时，并不保存完整的源代码，而是将play的版本号、项目引用的插件名和源代码一起做一个md5运算，得到摘要，并保证每个字节的值都不为0，写在文件的前部；然后写一个byte 0作为分隔，然后把字节码写在后面。&lt;/p&gt;
&lt;p&gt;这样在检查某一个java源代码是否有效时，实际上还要考虑其它可能影响最终字节码的因素。&lt;/p&gt;
&lt;h2&gt;play.classloading.HotswapAgent&lt;/h2&gt;
&lt;p&gt;这是一个代码很少但不太好理解的类。它实现了类的hotswap，在内部它使用了jdk中提供的Instrumentation，对代码进行重载。以后将专门研究一下这个。&lt;/p&gt;
&lt;p&gt;在ApplicationClassloader中发现java源代码发生了变化需要重新载入时，会首先调用该类尝试重载变化的类，失败后才会重载整个应用。&lt;/p&gt;
&lt;p&gt;如果JRebel是免费的话，这里应该可以调用JRebel以实现更有效的重载。&lt;/p&gt;
&lt;h2&gt;play.classloading.hash.ClassStateHashCreator&lt;/h2&gt;
&lt;p&gt;ClassStateHashCreator是一个工具类，它的作用是给定若干路径后，去搜索里面所有的java源文件，然后通过正则表达式去找到所有形如: class X 这样的类定义，然后把它们组合成一个字符串。这样Play就可以快速检测到用户定义的java类是否发生了变化。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用ng-grid实现可配置的表格</title>
                <link>http://freewind.in/posts/2080-use-ng-grid-to-implement-configurable-table</link>
                <pubDate>Wed, 06 Feb 2013 16:27:45 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2080</guid>
                <description><![CDATA[&lt;p&gt;使用Angularjs在带来方便的同时，也有一些遗憾：很多基于jquery或其它的组件，在angularjs中需要集成一下才能用得流畅。但是一些比较复杂的组件，集成起来的工作量相当大，比如说grid。&lt;/p&gt;
&lt;p&gt;大多数情况下，使用angularjs可以方便地实现简单的表格，甚至点击修改这样的功能也很容易。但是如果还希望增加更多的功能，比如拖动改变列的前后顺序，点击表头排序，拖动列宽度，隐藏某些列时，就不那么容易了。如果还想加上分组的功能，那就十分麻烦了。这时候我们就需要一个与angularjs配合很好的grid组件。&lt;/p&gt;
&lt;p&gt;这几天我试用了&lt;a href=&quot;http://angular-ui.github.com/ng-grid/&quot;&gt;http://angular-ui.github.com/ng-grid/&lt;/a&gt;，它完全是基于angularjs写的，所以可以使用angularjs的思路与它交互。使用感觉还不错，基本功能齐全，与之交互实现需要的效果也很顺畅。我用它简单地实现了一个表格设计器，在这里演示一下。&lt;/p&gt;
&lt;p&gt;我实现的功能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指定数据源后，可打开表格设计器，定制每一列的表头，添加删除列，调整列顺序等2.  可取出调整后的参数，保存在服务器中3.  在正式使用的表格中，可读取之前设计好的参数，直接使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为该项目的文档和示例写得比较好，而且当前还在紧张改进之中，所以我在这里不详细介绍如何使用，主要来演示效果。想使用的朋友可以上项目主页看，有问题在issues里提，作者回复很快很热心。&lt;/p&gt;
&lt;h2&gt;首先看成品效果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2080-1.png&quot;&gt;&lt;img src=&quot;/user_images/2080-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的按钮是我自己加的，下面的表格是由ng-grid提供的。可以看到它的外观跟普通的grid差不多，可单选（或多选），可调整宽度及列顺序，点击表头可排序，右上角有个小三角还有一些高级功能：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2080-3.png&quot;&gt;&lt;img src=&quot;/user_images/2080-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可在这里搜索（针对所有列），可以显示或者隐藏某列，右边那些小图标点击后会分组：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2080-5.png&quot;&gt;&lt;img src=&quot;/user_images/2080-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;设计器效果&lt;/h2&gt;
&lt;p&gt;在上面有一个“配置表格”的按钮，点击后将会出现设计器窗口：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2080-7.png&quot;&gt;&lt;img src=&quot;/user_images/2080-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个简单的设计器，它主要用来添加、删除列，改列头，以及调整顺序。左下角是当前已经使用的列，左边是field，对于json数据中某个key，右边是显示在列头的自定义名称；点击每行右边的[-]后，将删除该列；点击左下角的[+]，将会新增一列。&lt;/p&gt;
&lt;p&gt;左上角显示的是数据源中的json数据里存在但未被使用的key。点击旁边的[+]后，它就会移到下方。从下方删除后，就会回到上方。&lt;/p&gt;
&lt;p&gt;右边是表格预览，我们可以调整列宽以及前后顺序。&lt;/p&gt;
&lt;p&gt;可以看出这里调整的都是一些比较基本但又重要的参数，更详细的设置（比如为某列单元格自定义显示模板，配置列排序函数等），还得手动写代码实现。&lt;/p&gt;
&lt;p&gt;当调整完成后，下方还有一个“保存”按钮（没在截图上显示），点击后，就会把当前的配置提交到服务器保存起来供使用。&lt;/p&gt;
&lt;h2&gt;相关代码&lt;/h2&gt;
&lt;p&gt;代码写得比较粗糙，因为只是为了检验是否能满足需求，还未细化，仅供参考。&lt;/p&gt;
&lt;h3&gt;为设计器定义的directive&lt;/h3&gt;
&lt;p&gt;在js中定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// http://angular-ui.github.com/ng-grid/#/api
admin.directive(&apos;configureGrid&apos;, [ &apos;JsRoutes&apos;, function (JsRoutes) {
    return {
        restrict: &quot;A&quot;,
        controller: function ($scope, $element, $attrs, $transclude) {
            var params = $scope.$parent.$eval($attrs[&quot;configureGrid&quot;]);
            $scope.gridId = params.id;
            var dataName = params.dataName;

            JsRoutes.Directives.getGridOptions.get({
                id: $scope.gridId
            }, function (options) {
                if (options &amp;amp;&amp;amp; options.columns) {
                    $scope.columnDefs = options.columns;
                }
            })

            $scope.gridColumns = [];
            $scope.configureGridModalShown = false;
            $scope.$parent.configureGrid = function () {
                $scope.configureGridModalShown = true;
            }

            $scope.$watch(&apos;gridWidth&apos;, function (newV) {
                $scope.layoutPlugin1.updateGridLayout();
            });
            $scope.layoutPlugin1 = new ngGridLayoutPlugin();

            $scope.columnDefs = [ ];

            $scope.gridOptions = {
                data: dataName,
                columnDefs: &apos;columnDefs&apos;,
                plugins: [$scope.layoutPlugin1]
            }

            $scope.$on(&apos;ngGridEventColumns&apos;, function (newColumns) {
                var columns = newColumns.targetScope.columns;
                columns = columns.filter(function (col) {
                    return col.field !== &apos;✔&apos;;
                })
                $scope.gridColumns = columns.map(function (col) {
                    return {
                        field: col.field,
                        displayName: col.displayName,
                        width: col.width
                    }
                });
                var total = 0;
                $scope.gridColumns.forEach(function (col) {
                    total += col.width;
                });
                $scope.gridWidth = total;
            });
            $scope.gridWidth = 500;

            $scope.$on(&apos;&apos;)

            $scope.getFields = function () {
                var data = $scope.$parent[dataName];
                if (data &amp;amp;&amp;amp; data.length &amp;gt; 0) {
                    var keys = _.keys(data[0]);
                    return _.reject(keys, function (key) {
                        return _.find($scope.columnDefs, function (col) {
                            return col.field === key;
                        });
                    });
                }
                return [];
            }

            $scope.addColumn = function (field) {
                $scope.columnDefs.push({
                    field: field,
                    displayName: field,
                    width: 100
                });
            }
            $scope.removeColumn = function (col) {
                $scope.columnDefs = _.reject($scope.columnDefs, function (c) {
                    return c.field == col.field;
                });
            }

            $scope.$watch(dataName, function (data) {
                if (data.length &amp;gt; 0 &amp;amp;&amp;amp; $scope.columnDefs.length == 0) {
                    $scope.getFields().forEach(function (f) {
                        $scope.addColumn(f);
                    });
                }
            })

            $scope.saveGridOptions = function () {
                JsRoutes.Directives.saveGridOptions.post({
                    id: $scope.gridId,
                    columns: $scope.gridColumns
                }, function () {
                    $scope.configureGridModalShown = false;
                }, null, {
                    postType: &apos;json&apos;
                });
            }

        },
        scope: true,
        templateUrl: JsRoutes.Directives.configureGrid.link({format: &apos;html&apos;})
    }
}])

对应的html代码：

&amp;lt;div id=&quot;configure-modal&quot;&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        #configure-modal .modal {
            position: fixed;
            margin-left: -45%;
            margin-top: 30px;
            width: 90%;
        }        #configure-modal .modal-body {
            max-height: none;
        }        #configure-modal .fade.in {
            top: 30px;
        }    &amp;lt;/style&amp;gt;
    &amp;lt;div ui-modal class=&quot;fade configure-modal&quot; ng-model=&quot;configureGridModalShown&quot;&amp;gt;
    #{debug /}
        &amp;lt;div class=&quot;modal-header&quot;&amp;gt;&amp;lt;h3&amp;gt;定制表格 [{{gridId}}]&amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;modal-body&quot;&amp;gt;
            &amp;lt;table class=&quot;table-as-layout&quot;&amp;gt;
                &amp;lt;tr&amp;gt;
                    &amp;lt;td ui-fixed-width=&quot;300&quot;&amp;gt;
                        &amp;lt;ul&amp;gt;
                            &amp;lt;li ng-repeat=&quot;field in getFields()&quot;&amp;gt;{{field}}
                                &amp;lt;a ng-click=&quot;addColumn(field)&quot;&amp;gt;[+]&amp;lt;/a&amp;gt;
                            &amp;lt;/li&amp;gt;
                        &amp;lt;/ul&amp;gt;
                        &amp;lt;hr/&amp;gt;
                        &amp;lt;ul&amp;gt;
                            &amp;lt;li ng-repeat=&quot;col in columnDefs&quot;&amp;gt;
                                &amp;lt;div&amp;gt;
                                    &amp;lt;span ng-click=&quot;details=!details&quot; style=&quot;cursor: pointer&quot;&amp;gt;
                                    &amp;lt;input type=&quot;text&quot; class=&quot;input input-small&quot; ng-model=&quot;col.field&quot; ng-model-onblur/&amp;gt;
                                    - &amp;lt;input type=&quot;text&quot; class=&quot;input input-small&quot; ng-model=&quot;col.displayName&quot; ng-model-onblur/&amp;gt;
                                    &amp;lt;/span&amp;gt;
                                    &amp;lt;a ng-click=&quot;removeColumn(col)&quot;&amp;gt;[-]&amp;lt;/a&amp;gt;
                                &amp;lt;/div&amp;gt;
                            &amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a ng-click=&quot;addColumn(&apos;todo&apos;)&quot;&amp;gt;[+]&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                        &amp;lt;/ul&amp;gt;
                    &amp;lt;/td&amp;gt;
                    &amp;lt;td width=&quot;100%&quot;&amp;gt;
                        &amp;lt;div class=&quot;gridStyle&quot; style=&quot;width:{{gridWidth}}px;height:600px&quot; ng-grid=&quot;gridOptions&quot;&amp;gt;&amp;lt;/div&amp;gt;
                    &amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;
            &amp;lt;/table&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;modal-footer&quot;&amp;gt;
            &amp;lt;a class=&quot;btn btn-primary&quot; data-dismiss=&quot;modal&quot; ng-click=&quot;saveGridOptions()&quot;&amp;gt;保存&amp;lt;/a&amp;gt;
            &amp;lt;a class=&quot;btn&quot; data-dismiss=&quot;modal&quot;&amp;gt;关闭&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

调用该设计器的代码：

&amp;lt;button class=&quot;btn&quot; ng-click=&quot;configureGrid()&quot;&amp;gt;
    &amp;lt;i class=&quot;icon-table&quot;&amp;gt; &amp;lt;/i&amp;gt; 配置表格
&amp;lt;/button&amp;gt;
&amp;lt;div configure-grid=&quot;{id:gridId, dataName: gridDataName}&quot;&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    function Ctrl($scope, JsRoutes, Commons) {
        $scope.users = [];
        $scope.gridId = &apos;402880843CAE4701013CAE594B390001&apos;;
        $scope.gridDataName = &apos;users&apos;;
        $scope.columnDefs = [];
        $scope.gridOptions = {
            data: $scope.gridDataName,
            columnDefs: &apos;columnDefs&apos;,
            beforeSelectionChange: function (event) {
                event.entity.checked = !event.selected;
                return true;
            }
        }
    }
&amp;lt;/script&amp;gt;


在页面中使用保存的参数显示表格

Html代码：

&amp;lt;div ng-grid=&quot;gridOptions&quot; style=&quot;width: 100%;height: 500px&quot;&amp;gt;&amp;lt;/div&amp;gt;

Js代码：

$scope.users = [];
$scope.gridId = &apos;402880843CAE4701013CAE594B390001&apos;;
$scope.gridDataName = &apos;users&apos;;
$scope.columnDefs = [];
$scope.gridOptions = {
    data: $scope.gridDataName,
    columnDefs: &apos;columnDefs&apos;,
    beforeSelectionChange: function (event) {
        event.entity.checked = !event.selected;
        return true;
    }
}
JsRoutes.Directives.getGridOptions.get({
    id: $scope.gridId
}, function (options) {
    console.log(options);
    if (options &amp;amp;&amp;amp; options.columns) {
        $scope.columnDefs = options.columns;
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，以上代码仅供参考思路，里面缺了东西，不能直接运行。另外，ng-grid的代码改得比较快，请注意它的最新文档。&lt;/p&gt;
&lt;h2&gt;动态演示&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2080-9.gif&quot;&gt;&lt;img src=&quot;/user_images/2080-9.gif&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>00. Scala入群题目</title>
                <link>http://freewind.in/posts/2066-scala-group-entry-problem</link>
                <pubDate>Tue, 05 Feb 2013 19:17:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2066</guid>
                <description><![CDATA[&lt;p&gt;Scala热情交流群（132569382）从2013年2月5日起采取答题入群制，在加入本群时，请写出下题的scala代码，要求长度在50个字符以内（因为QQ群的验证框长度限制为50），作为入群的密码。&lt;/p&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;计算出从1到100之间所有奇数的平方之和&lt;/p&gt;
&lt;h2&gt;提示&lt;/h2&gt;
&lt;p&gt;即1&lt;em&gt;1+3&lt;/em&gt;3+5&lt;em&gt;5+ &amp;hellip; + 99&lt;/em&gt;99，结果为166650&lt;/p&gt;
&lt;h3&gt;要求&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;scala代码的长度&lt;font color=&quot;#ff0000&quot;&gt;不超过50个字符&lt;/font&gt;，代码越简洁易读越好&lt;/li&gt;
&lt;li&gt;在群内应该严格遵守&lt;a href=&quot;/posts/scala-group-rule&quot;&gt;scala群规&lt;/a&gt;，警告无效者T&lt;/li&gt;
&lt;li&gt;本群努力营造出一个良好的scala交流环境，需要你的支持&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在playframework中集成livereload</title>
                <link>http://freewind.in/posts/2065-how-to-integration-livereload-in-playframework1</link>
                <pubDate>Sun, 03 Feb 2013 18:18:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2065</guid>
                <description><![CDATA[&lt;p&gt;Livereload是一个非常贴心的功能，可以让我们修改项目中的文件时，浏览器自动刷新取得新代码，省了手动切换刷新。在&lt;a href=&quot;http://freewind.me/blog/20121226/1167.html&quot;&gt;我的web开发最强组合：Play1+angularjs+bootstrap ++ (idea + livereload)&lt;/a&gt;一文中，有gif动画来演示效果。然而稍嫌麻烦的是，我们需要安装python/easy_install/python-livereload等工具，并且每次使用时都得开一个shell，定位到工作目录，输入&lt;code&gt;livereload&lt;/code&gt;命令才行。&lt;/p&gt;
&lt;p&gt;如果能在playframework中集成livereload功能，每次输入play run时就自动提供livereload服务，就太好了。经过一翻折腾，终于实现。&lt;/p&gt;
&lt;p&gt;实现这种功能，有三种可行的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在java代码中调用外部命令（即python库livereload）2.  集成一个java实现的livereload库3.  集成一个python实现的livereload库&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三种方式各有利弊，我开始选择的是第2种，并找到一个可用的项目：&lt;a href=&quot;https://github.com/davidB/livereload-jvm&quot;&gt;https://github.com/davidB/livereload-jvm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个项目实现了livereload的协议，我们可以把它拿过来改改，使用play内置的websocket功能替代原有的基于jetty的库。但它有一个很大的问题：为了能高效地知道哪些文件的状态发生了变化（修改、删除），必须使用jdk7中提供的一些类。也就是说，要使用它，我们必须使用jdk7。这是一个比较大的限制。&lt;/p&gt;
&lt;p&gt;后来突然想到，play1本身使用python2.6来启动，能不能直接把python-livereload库集成进去?比如，当我们输入play run的时候，让它同时启动livereload功能？经过一翻尝试，终于实现。&lt;/p&gt;
&lt;h2&gt;在play的python中安装livereload库&lt;/h2&gt;
&lt;p&gt;一般在python中安装第三方库，都是使用如easy_install/pip这些库管理工具，但我们也可以直接通过源代码安装。&lt;/p&gt;
&lt;p&gt;在每个python的库中，都可以找到一个setup.py的文件，只需要执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python setup.py install

即可。

需要注意的是，由于我们要把库安装到play的python里去，这里要指明python的路径，比如：

E:\play\python\python.exe setup.py install

### setuptools

首先要安装setuptools这个库，进入其主页[http://pypi.python.org/pypi/setuptools#downloads](http://pypi.python.org/pypi/setuptools#downloads)下载。注意要选用源代码打的包（以.tar.gz）结尾的那个。

下载后解压，并安装：

cd setuptools-0.6c11
E:\play\python\python.exe setup.py install

安装成功后，它会有提示。

### python-livereload

然后安装python-livereload，到github上下载其源代码：[https://github.com/lepture/python-livereload](https://github.com/lepture/python-livereload)

通过git clone或者直接下载zip文件的方式下载到本地后，解压并安装：

cd python-livereload
E:\play\python\python.exe setup.py install

它会自动安装python-livereload引用的其它库，如果没有错误，则会提示安装成功。

这时打开play目录下的python目录，可以看到里面多了一个`Scripts`目录，并且里面有`livereload.exe`等文件。

## 修改play脚本

现在将要修改play的脚本，以调用livereload库。

找到`play\framework\pym\play\commands\base.py`文件，它定义了play的常用命令，如`play run`，`play clean`等。

首先添加一个与def run平级的函数livereload，它的代码是我从livereload-script.py中copy过来的：

def livereload():
    __requires__ = &apos;livereload==0.11&apos;
    import sys
    from pkg_resources import load_entry_point
    sys.exit(
        load_entry_point(&apos;livereload==0.11&apos;, &apos;console_scripts&apos;, &apos;livereload&apos;)()
    )

我们需要在run()函数中调用这个函数，但要注意的是，我们不能直接用它，因为它是阻塞的，一旦运行就会阻塞当前线程，后面的代码就没机会执行了，所以得为它新开个线程。

将下面的代码添加到def run()函数中，在`java_cmd = app.java_cmd(args)`之前：

import thread
thread.start_new_thread(livereload, ())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就大功告成了。现在可以在运行play run的同时另起一个线程执行livereload功能，而不需要额外操作。可以直接使用浏览器端的livereload插件进行自动刷新了。&lt;/p&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2065-1.gif&quot;&gt;&lt;img src=&quot;/user_images/2065-1.gif&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;观看时注意“新建”按钮上文字的变化。当我修改了html中的“新建”的内容并保存后后，右上方浏览器中的“新建”会自动变化。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>刘松的node-webkit体验</title>
                <link>http://freewind.in/posts/2062-the-node-webkit-expirement-from-liusong</link>
                <pubDate>Fri, 01 Feb 2013 11:19:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2062</guid>
                <description><![CDATA[&lt;p&gt;（以下为Javascript热情交流群中刘松关于node-webkit的聊天记录。）&lt;/p&gt;
&lt;p&gt;我在考虑用node-webkit做一个小客户端程序。同时也有web版的。&lt;/p&gt;
&lt;p&gt;所以在找node的RPC库。找来找去发现都不合适，都好久没更新，就一个dnode看起来不错，装在我的苹果系统上出现库不兼容的问题。&lt;/p&gt;
&lt;p&gt;dnode是基于socket.io的，我想了一下，其实直接用socket.io当RPC库用就可以。&lt;/p&gt;
&lt;p&gt;我们要做的功能是，解析本地或服务器上的一个或多个sqlite文件，展现在前台界面上，提供查询、过滤、报表等功能。&lt;/p&gt;
&lt;p&gt;除了sqlite文件是放在本地还是服务器这点差别外，其它逻辑（解析sqlite，执行sql，前端界面渲染）都是一样的。&lt;/p&gt;
&lt;p&gt;理想情况下，用node-webkit对这个应用打包，就成为本地应用（桌面程序）。或者作为服务器端程序跑。&lt;/p&gt;
&lt;p&gt;node-webkit最近发展不错，topcube可以放弃了&lt;/p&gt;
&lt;p&gt;看 github上的wiki部分，文档也还好&lt;/p&gt;
&lt;p&gt;就是 浏览器的进程和nodejs的进程如何融合，要做的事很多。它主要复杂在这里。&lt;/p&gt;
&lt;p&gt;node-webkit做nodejs和浏览器进程的共存处理，不需要开发者关心。但这个工作比较复杂，比如console对象，在nodejs里和浏览器里是不一样的&lt;/p&gt;
&lt;p&gt;show一下我刚玩的东西&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2062-1.png&quot;&gt;&lt;img src=&quot;/user_images/2062-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2062-3.png&quot;&gt;&lt;img src=&quot;/user_images/2062-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2062-5.png&quot;&gt;&lt;img src=&quot;/user_images/2062-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;node-webkit结合angularjs、sqlite3&lt;/p&gt;
&lt;p&gt;node-webkit要求，如果你依赖了native的库，要用一个叫 nw-gyp的工具编译。可是我在mac上编译时生成的东西没好使，因为我是64位系统。最终参考这个里面的第一个回复解决了：
&lt;br  /&gt;&lt;a href=&quot;https://github.com/rogerwang/node-webkit/issues/296&quot;&gt;https://github.com/rogerwang/node-webkit/issues/296&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;能打包成绿色可执行程序&lt;/p&gt;
&lt;p&gt;总结一下今晚试node-webkit的收获：能结合d3、angularjs前端库，能用sqlite3后端库（需nw-gpy自己编译），能用nodejs官方的net、child_process库，不需要自己编译，直接require就能用。sqlite3的each回调是在下次队列时执行，因为结合angularjs时需要手工调$scope.$digest()，稍有不爽。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在PlayFramework中实现点击页面上某处直接在Idea中打开对应代码</title>
                <link>http://freewind.in/posts/2044-click-on-an-element-on-page-will-open-the-code-inside-idea</link>
                <pubDate>Tue, 29 Jan 2013 18:25:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2044</guid>
                <description><![CDATA[&lt;p&gt;当项目中文件多了以后，定位文件很不方便，特别是在一个长长的HTML中找到某个按钮、链接，能把眼睛看瞎。今天我有一个想法，能不能在页面上点击某个元素后，直接在编辑器中打开相应代码吗？这样的话，我们可以在浏览页面的同时，发现问题随时编辑，大大提高开发效率。&lt;/p&gt;
&lt;p&gt;经过几个小时的试验，基本上达到了我的要求，目前可以做到这样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Play的模板中某些位置加入一些&lt;code&gt;#{debug /}&lt;/code&gt;标签，它们将以button的形式显示在最终的html中2.  在浏览器中浏览页面时，默认情况下这些button是不可见的，所以不会破坏页面结构3.  当按下ctrl键时，标签对应的button显示出来4.  点击离想编辑的地方最近的button，将在idea中直接打开对应源文件并定位到对应的#{debug/}处&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我最开始希望的是在页面上点击任意元素，都能定位到编辑器中，但看起来似乎难以做到，因为这需要模板引擎在解析模板时，记录下每一个html标签所在的行信息，一般模板引擎都不会这么做。所以只能退而求其次，能定位到哪些点也是好的。毕竟在一个长长的html中，在每个页面块处加上一个#{debug/}，就能方便的定位，还是很值得的。&lt;/p&gt;
&lt;h2&gt;Idea的RemoteCall插件&lt;/h2&gt;
&lt;p&gt;在Idea中有一个RemoteCall插件，可以让我们访问一个url时，Idea能根据传入的信息打开相应的文件。这是很关键的一个插件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://plugins.jetbrains.net/plugin?pr=webide&amp;amp;pluginId=6027&quot;&gt;http://plugins.jetbrains.net/plugin?pr=webide&amp;amp;pluginId=6027&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;github上源代码：&lt;a href=&quot;https://github.com/Zolotov/RemoteCall&quot;&gt;https://github.com/Zolotov/RemoteCall&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你使用其它的编辑器，可能不需要这样的插件，因为有的编辑器支持打开特定的url，只要构造一个符合的url即可。另外，Firefox也可以通过设置，当点击某种类型的url时，调用外部编辑器打开。&lt;/p&gt;
&lt;p&gt;当我们安装好RemoteCall以后，它会自动监听8091端口，只要我们访问一个这样的url:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8091/?message=admins/index.html:11:2&quot;&gt;http://localhost:8091/?message=admins/index.html:11:2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它就会寻找最匹配的admins/index.html文件，并定位到11行第2列。其中行与列信息是可选的。&lt;/p&gt;
&lt;h2&gt;Play中创建一个debug标签&lt;/h2&gt;
&lt;p&gt;这个debug标签一定得是FastTag，这样才能拿到行数。幸亏play有这样的功能，否则就没法做了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyFastTags extends FastTags {
    public static void _debug(Map&amp;lt;?, ?&amp;gt; args, Closure body, PrintWriter out, GroovyTemplate.ExecutableTemplate template, int fromLine) {
        // e.g. {module:wind_articles}/app/views/wind_articles/Categories/index.html
        String filePath = template.template.getName();
        if (filePath.contains(&quot;}&quot;)) {
            filePath = StringUtils.substringAfterLast(filePath, &quot;}&quot;);
        }
        String content = &quot;&amp;lt;span class=&apos;debug debug-hide&apos;&amp;gt;\n&quot;
                         + &quot;&amp;lt;button class=&apos;btn btn-warning&apos; data-file=&apos;&quot;
                         + filePath
                         + &quot;&apos; data-line=&apos;&quot;
                         + fromLine
                         + &quot;&apos;&amp;gt;edit&amp;lt;/button&amp;gt;\n&quot;
                         + &quot;&amp;lt;/span&amp;gt;&quot;;
        out.print(content);
    }
}

注意在上面的代码中，我们拿到了文件路径和行数，把它们加在一个button的属性中。

然后我们可在模板中某些重要位置，写上#{debug /}：

&amp;lt;td&amp;gt;
#{debug /}
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;btn-group&quot;&amp;gt;

它将会在页面中显示为一个button：

[![image](/user_images/2044-1.png &quot;image&quot;)](/user_images/2044-1.png)

点击后，则会自动在Idea中打开相应文件，并定位到相应的#{debug /}处。

## #{debug/}的样式

在通常情况下，我们不希望这个debug按钮显示出来，因为它会破坏我们的页面。所以给它定义了一些css样式，让它默认不可见。

.debug {
    display: inline-block;
}
.debug-hide {
    display: none;
}

在生成的button里，它同时使用了这两个css，所以不会显示。

## jQuery中的处理

我们需要做到，当按下ctrl键的时候，把这些按钮显示出来。首先我们需要监听keydown事件，判断是否按下了ctrl键：

jQuery(&quot;body&quot;).keydown(function (event) {
    // ctrl
    if (event.which == 17) {
        jQuery(&quot;body&quot;).find(&quot;.debug&quot;).toggleClass(&quot;debug-hide&quot;);
    }
});

另外还要给那些按钮们加上onclick事件，根据button属性上的文件和行数信息，拼出正确的url，及使用ajax处理（以防止打开新页面）：

jQuery(&quot;body&quot;).find(&quot;.debug button&quot;).click(function (event) {
    var $button = jQuery(event.target);
    var file = $button.attr(&quot;data-file&quot;);
    var line = $button.attr(&quot;data-line&quot;);
    jQuery.get(&apos;[http://localhost:8091/?message=&apos;](http://localhost:8091/?message=) + file + &quot;:&quot; + line);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就大功告成了。下面是截屏，大家看看效果如何。&lt;/p&gt;
&lt;h2&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2044-3.gif&quot;&gt;&lt;img src=&quot;/user_images/2044-3.gif&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;其它编辑器及其它框架中怎么做&lt;/h2&gt;
&lt;p&gt;这里面关键的有两点，一是可以通过某种方式让编辑打开某文件及相应行，二是框架里可以取得行数。&lt;/p&gt;
&lt;p&gt;关于第一个，很多轻量级编辑器都支持通过某种特定格式的url直接打开某文件，或者写个插件支持。&lt;/p&gt;
&lt;p&gt;关于后者，如果你的web框架支持，则很好，否则的话你可以考虑用另一种方法，不定位到行数，而是让编辑器打开文件后自动查找并定位到某个特殊的唯一的字符串。&lt;/p&gt;
&lt;p&gt;这样我们在调用#{debug/}（或类似的自定义标签时），可以手动生成一个uuid作为唯一字符串：&lt;/p&gt;
&lt;h1&gt;{debug &apos;dd10d46c35558468fbf206d8130cce0fd&apos; /}&lt;/h1&gt;
&lt;p&gt;然后修改编辑器插件，让它找到文件后，能过搜索该字符串找到行数。&lt;/p&gt;
&lt;p&gt;很多编辑器都有uuid插件可生成并插入一个uuid，所以这操作起来也不是很麻烦。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;green&lt;/h3&gt;
&lt;p&gt;谢谢风老大的分享，我也在rythm上做了些增强，现在也支持这个功能了：http://www.screenr.com/fJr7&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用Typescript来写javascript (目前相关工具不够成熟)</title>
                <link>http://freewind.in/posts/2034-use-typescript-to-write-javascript</link>
                <pubDate>Mon, 28 Jan 2013 14:07:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2034</guid>
                <description><![CDATA[&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;800&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;161&quot;&gt;2013-01-28&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;639&quot;&gt;初稿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;161&quot;&gt;2013-01-30&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;639&quot;&gt;增加目前工具不够成熟的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;前几天尝试使用haxejs来写javascript，以获得静态类型带来的益处。虽然成功了，但很快发现&lt;a href=&quot;http://freewind.me/blog/20130126/2022.html&quot;&gt;将它与angularjs一起使用，有一些不太顺畅的地方&lt;/a&gt;，导致开发效率没有提升，反而下降了。虽然我认为使用haxejs来写普通的js（或者与jquery相关的js）没有问题，但不适合与angularjs这样与HTML侵入较大的js框架配合。&lt;/p&gt;
&lt;p&gt;昨天偶然发现idea居然支持typescript了，于是打算尝试一下typescript，目前的感觉还不错，相比haxejs，它与angularjs之间的配合要流畅得多。&lt;/p&gt;
&lt;h2&gt;与coffeescript的比较&lt;/h2&gt;
&lt;p&gt;Typescript与Coffeescript都是对javascript的改进，但两者走的是不同路线。Coffeescript是从语法的角度，通过提供类似于python/ruby的语法，让代码写起来更加简洁，可读性更好。并且它提供的一些控制结构，可以避开Javascript中的问题，比如&lt;code&gt;for ... in ...&lt;/code&gt;，使用coffeescript可以让多层嵌套看起来不那么痛苦：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;coffee&quot;&gt;self.validate json, (err, json) -&amp;gt;
  if err then cb(err)
  else self.mapFiles json, (err, json) -&amp;gt;
    if err then cb(err)
    else self.addFields json, (err, json) -&amp;gt;
      if err then cb(err)
      else self.store.create json, cb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回调的参数放在右边，看起来就像是把前面函数的返回值放在了右边供调用，读起来比较轻松。习惯于python/ruby的开发者可能会比较喜欢coffeescript，我也觉得它在这方面很好。&lt;/p&gt;
&lt;p&gt;而Typescript走的是另一条路，通过增加静态类型，提高程序的可靠性，并没有从语法层面进行大的改进。&lt;/p&gt;
&lt;p&gt;我觉得它们两者是互补的，如果能把两者结合起来，既提供静态类型，又增强语法就太好了，不过这可能在很久以后才有可能出现。&lt;/p&gt;
&lt;h2&gt;编辑器支持&lt;/h2&gt;
&lt;p&gt;Idea并没有声明已经支持typescript，没有看到相关插件，在建项目时也没有任何提示，只有在创建一个以.ts结尾的文件时，它可以识别出来，说明这还是一个实验性的功能，没有完全完成。不过经过我的试用，基本功能都有了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码高亮、格式化2.  代码提示3.  错误检查&lt;/p&gt;
&lt;p&gt;其中编译为js文件的功能似乎有点问题，另外module()函数的检验有时候也不太对，不过这并不影响我们的使用。尽管还是一个开发中的功能，但已经跟idea对haxe的支持不相上下了。&lt;/p&gt;
&lt;p&gt;另外，你还可以使用VS2012+typescript插件，这是官方推荐的。另外喜欢用sublime text2的同学，可到这里下载：&lt;a href=&quot;https://github.com/raph-amiard/sublime-typescript&quot;&gt;https://github.com/raph-amiard/sublime-typescript&lt;/a&gt;。另外vim/emacs也有相关的插件也有，eclipse这里似乎还没有动静。&lt;/p&gt;
&lt;p&gt;据说typescript提供了一些服务性质的api，可以让IDE实现功能（如代码提示等）更加容易。&lt;/p&gt;
&lt;h2&gt;下载地址&lt;/h2&gt;
&lt;p&gt;官方地址：&lt;a href=&quot;http://www.typescriptlang.org&quot;&gt;http://www.typescriptlang.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先到nodejs网站下载并安装nodejs，然后运行以下命令：&lt;/p&gt;
&lt;p&gt;npm install -g typescript&lt;/p&gt;
&lt;p&gt;其中npm是由nodejs提供的包管理工具，安装nodejs后就直接可用了。&lt;/p&gt;
&lt;h2&gt;相关资料&lt;/h2&gt;
&lt;p&gt;Typescript相关的资料不多，目前官网上仅有一些示例和简单的文档，我收集的有以下这些链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;http://www.typescriptlang.org/&quot;&gt;http://www.typescriptlang.org/&lt;/a&gt;[[示例]](http://www.typescriptlang.org/)[[在线尝试]](http://www.typescriptlang.org/Playground/)[[官方例子源代码]](http://typescript.codeplex.com/SourceControl/changeset/view/258e00903a9e#samples/greeter/README.txt)2.  语言规范：&lt;a href=&quot;http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf&quot;&gt;http://www.typescriptlang.org/Content/TypeScript%20Language%20Specification.pdf&lt;/a&gt;，可用来参考，很难看懂&lt;/p&gt;
&lt;h2&gt;语言特性&lt;/h2&gt;
&lt;p&gt;Typescript官方的文档很简单，只给出了一个简单的例子，没有详细的文档来讲解各功能，所以对于初学者入门还是稍有难度，我花了不少时间才基本会用，比我预想的时间多了很多。&lt;/p&gt;
&lt;p&gt;难度不是在语言特性上，而是在代码的组织和示例上，实在太少。比如如何调用声明文件，如何按module来组织代码等，对于初次接触typescript的人还需要一些时间理解。&lt;/p&gt;
&lt;p&gt;我对Typescript的印象，可总结为以下几点：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Typescript的思路还是Javascript，只是对它进行了增强2.  Typescript可以看作是Javascript的超集，所有javascript代码可以直接写在typescript中，这一点对于Javascript程序员来说很方便3.  Typescript中增加了静态系统，提供了class/interface/method的支持。类型系统可以让我们在编译期验证代码是否有笔误，也可以获得编辑器的提示4.  Typescript以module方式来组织代码，既支持commonjs的方式，又支持amd的方式5.  Typescript中的文件可分为实现文件和声明文件，有点像c++中的.cpp和.h的关系。6.  Typescript即可用来写后台代码，也可以用来写前台代码，初步感觉似乎更偏后台一些&lt;/p&gt;
&lt;h3&gt;Class/Interface/Method&lt;/h3&gt;
&lt;p&gt;Typescript中提供了class、interface关键字，可将代码以类的方式组织在一起。构造函数为constructor，静态方法前要加static。在实例方法中调用静态方法时，必须在前面加上类名。这块看起来比较普通，很好理解。&lt;/p&gt;
&lt;p&gt;class User {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constructor(name:string, age:number) {
}
hello() {
    alert(&quot;hell, &quot; + name);
    User.test(age);
}
static test(n:number) {
    console.log(&quot;this is a static method, argument: &quot; + n);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;module&lt;/h3&gt;
&lt;p&gt;这块对于非Javascript程序员来说，有点不太好理解。我之前虽然学习了一段时间的nodejs，但现在已经快忘光了，这几天拾起来的时候，还是很痛苦的，资料很少。现在只能算是有所了解，讲的可能不全对。&lt;/p&gt;
&lt;p&gt;Javascript在语言层面没有提供模块机制，当代码多了以后，很难组织起来。比如在服务器端，将不同的功能分在不同的文件中以复用，或者在浏览器端，想把一个大文件分成多个，按需下载。但文件之间依赖关系、如何向外暴露对象供使用等，都没有规定。所以人们做了很多尝试，制定了一些规范来解决这个问题，其中比较有名的有两个名词，一个commonjs，一个是amd。&lt;/p&gt;
&lt;p&gt;关于它们的介绍和相互关系，可以看这篇文章，说得很好：&lt;a href=&quot;http://www.udpwork.com/item/3978.html&quot;&gt;http://www.udpwork.com/item/3978.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单地说，commonjs是一套规范，它定义了如何将代码组织为模块，如何向外暴露对象，如果依赖。在导入模块时，又可以分为同步和异步，一般可认为commonjs代表同步，AMD代表异步。服务器端代码更需要同步，浏览器那边更需要异步，在typescript的编译器中同时支持这两种方式。但commonjs是默认的，所以我前面说感觉它更偏向后端。&lt;/p&gt;
&lt;p&gt;当我们在代码中使用了module()函数时，Typescript可以把它们编译为commonjs或amd方式的调用。比如：&lt;/p&gt;
&lt;p&gt;/// &lt;reference path=&quot;. /libs/underscore.d.ts&quot;/&gt;
&lt;br  /&gt;import _ = module(&amp;ldquo;underscore&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;当我们这样编译时：&lt;/p&gt;
&lt;p&gt;tsc test.ts&lt;/p&gt;
&lt;p&gt;它会生成这样的js代码：&lt;/p&gt;
&lt;p&gt;var _ = require(&amp;ldquo;underscore&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;当我们指定为amd时：&lt;/p&gt;
&lt;p&gt;tsc &amp;ndash;module amd test.ts&lt;/p&gt;
&lt;p&gt;它会生成这样的代码：&lt;/p&gt;
&lt;p&gt;define([&amp;ldquo;require&amp;rdquo;, &amp;ldquo;exports&amp;rdquo;, &amp;ldquo;underscore&amp;rdquo;], function(require, exports, &lt;strong&gt;&lt;/strong&gt;_) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var _ = _____;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;在服务器端我们一般用前者，在浏览器端一般使用后者（或者完全不用module）。&lt;/p&gt;
&lt;h3&gt;不使用Module&lt;/h3&gt;
&lt;p&gt;如果我们在typescript使用了module函数，则生成的代码在浏览器端执行时，需要有一些script loader的支持。对于浏览器端代码，我们一般生成amd风格的代码，所以需要找一个支持amd的库放在前端。这样的库有很多，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RequireJS2.  Nodules3.  JSLocalnet4.  curl.js&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可根据自己的需要使用。我尝试了&lt;a href=&quot;http://requirejs.org&quot;&gt;RequireJS&lt;/a&gt;，不喜欢它的网站风格，写了那么多，但总是没说重点。比如关于它的配置，我们需要面对的第一个问题，可是它就是没给一个示例出来，让我在网上到处找别人写的例子。要想用好它，可能得先好好读它的文档，再到网上找别人的代码看。&lt;/p&gt;
&lt;p&gt;所以最后我还是按照传统的方式来组织代码，在typescript中完全不使用module函数，而用了全局声明的方式：&lt;/p&gt;
&lt;p&gt;/// &lt;reference path=&quot;.. /../libs/underscore.browser.d.ts&quot;/&gt;
&lt;br  /&gt;declare var _:UnderscoreStatic;&lt;/p&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;p&gt;/// &lt;reference path=&quot;.. /../libs/underscore.browser.d.ts&quot;/&gt;
&lt;br  /&gt;import _ = module(&amp;ldquo;underscore&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;declare var&lt;/code&gt;来声明某变量时，即假设它已经在全局中可用，后面的&lt;code&gt;UnderscoreStatic&lt;/code&gt;则是在&lt;code&gt;underscore.browser.d.ts&lt;/code&gt;这个文件中定义的，关于underscore提供的所有方法的接口描述。&lt;/p&gt;
&lt;p&gt;使用这种方式时，我们保证这段js在浏览器端运行时，已经导入了underscore.js。我们可以按照传统的方式来引用js文件：&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;... /jquery.js&quot;&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script src=&quot;... /underscore.js&quot;&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script src=&quot;... /myapp.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3&gt;Headjs&lt;/h3&gt;
&lt;p&gt;如果你既不想用requirejs等库，又想异步下载js文件，可以考虑这个库：&lt;a href=&quot;http://headjs.com/&quot;&gt;http://headjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;headjs不支持commonjs/amd，它有自己的异步下载的api，十分简洁好用。配合我上面的declare var方式，很好用。&lt;/p&gt;
&lt;p&gt;这里给出一个简单的例子（headjs+jquery+underscore+angularjs+本站js）：&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot; /public/javascripts/head-0.99.min.js&quot;&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script type=&quot;text /javascript&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head.js(&apos;/public/libs/jquery-ui-1.8.24/js/jquery-1.8.2.min.js&apos;,
        &apos;/public/libs/jquery-ui-1.8.24/js/jquery-ui-1.8.24.custom.min.js&apos;,
        &apos;/public/libs/underscore/1.4.3/underscore.min.js&apos;,
        &apos;/public/libs/bootstrap-2.1.1/js/bootstrap.min.js&apos;,
        &apos;/public/libs/angular-1.0.2/angular.min.js&apos;,
        &apos;/public/libs/angular-ui-0.3.2/angular-ui.min.js&apos;,
        &apos;/public/libs/marked.js&apos;,
        &apos;/public/libs/slickswitch/js/jquery.slickswitch.js&apos;,
        &apos;/public/libs/html5.js&apos;,
        &apos;/public/libs/flot/0.7/jquery.flot.js&apos;,
        &apos;/jsRoutes.js&apos;,
        &apos;/public/libs/moment/1.7.2/moment.min.js&apos;,
        &apos;/public/javascripts/angular-config.js&apos;,
        &apos;/public/javascripts/app.js&apos;);
head.ready(function () {
    app.value(&quot;AdminCommonData&quot;, {
        &quot;menuTree&quot;: [],
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;head.js()&lt;/code&gt;方法中，可传入多个js路径，它们并行下载，但按照声明顺序依次执行。可以把一个head.js()分开写成多个。&lt;code&gt;head.ready()&lt;/code&gt;方法将会在所有js下载完成后执行里面的回调函数。&lt;/p&gt;
&lt;p&gt;headjs有一个非常好用的特性，即可以把head.js()放在head.ready()的后面：&lt;/p&gt;
&lt;p&gt;head.js(&amp;ldquo;&amp;hellip;/a.js&amp;rdquo;);
&lt;br  /&gt;head.ready(function() { console.log(&apos;I&apos;m ready&apos;)});
&lt;br  /&gt;head.js(&amp;ldquo;&amp;hellip;/b.js&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;其中的head.ready()函数，虽然写在&quot;b.js&quot;前面，但还是会等到b.js下载并执行完后，才会执行。&lt;/p&gt;
&lt;p&gt;如果我们的模板引擎使用了继承关系，则该特性很有用。比如在play中有一个layout.html文件和内页main.html，我们可以这样组织代码。&lt;/p&gt;
&lt;p&gt;layout.html&lt;/p&gt;
&lt;p&gt;&lt;html&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;/public/javascripts/head-0.99.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  head.js(&apos;/public/libs/jquery-ui-1.8.24/js/jquery-1.8.2.min.js&apos;
          // 所有全局通用的js放在这里);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#{doLayout /}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;
&lt;br  /&gt;&lt;script&gt;
&lt;br  /&gt;head.ready(function() {
&lt;br  /&gt;// 最后执行的启动代码放在最后
&lt;br  /&gt;});
&lt;br  /&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;main.html&lt;/p&gt;
&lt;h1&gt;{extends &amp;ldquo;layout.html&amp;rdquo; /}&lt;/h1&gt;
&lt;p&gt;&lt;script&gt;
&lt;br  /&gt;head.js(&amp;ldquo;&amp;hellip;/main.js&amp;rdquo;,
&lt;br  /&gt;// 仅在本页中使用的js文件)
&lt;br  /&gt;&lt;/script&gt;&lt;/p&gt;
&lt;div&gt;
...
&lt;/div&gt;
&lt;p&gt;&lt;script&gt;
&lt;br  /&gt;head.ready(function() {
&lt;br  /&gt;// 可以在这里为layout.html最后的函数调用准备数据
&lt;br  /&gt;});
&lt;br  /&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;在这里要补充一句，如果你使用angularjs+headjs的话，不能在&lt;html&gt;上声明ng-app=&amp;ldquo;xxx&amp;rdquo;，而应该在layout.html中最后的函数中调用：&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text /javascript&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head.ready(function () {
    angular.bootstrap(document, [&quot;MyModule&quot;, &quot;MyAnother&quot;]);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;注意一定要把&lt;html&gt;上的ng-app去掉。我之前尝试把它们两个结合使用总是失败，这次终于找到原因。&lt;/p&gt;
&lt;h3&gt;声明文件&lt;/h3&gt;
&lt;p&gt;如果你仔细看了前面的例子，会发现有一些以三个斜杠开头的代码，如：&lt;/p&gt;
&lt;p&gt;/// &lt;reference path=&quot;.. /../libs/underscore.browser.d.ts&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它是一种注释，告诉typescript编译器，当前文件使用了哪些声明文件，以帮助编辑器提示信息，及编译器检查类型。这种注释很重要，如果后面的路径不对，则编译会失败。&lt;/p&gt;
&lt;p&gt;引用的文件以&lt;code&gt;.d.ts&lt;/code&gt;结尾，它们是一种声明文件，就像是c语言中的header文件，只包含了类或函数的签名，而没有实际内容，用于编辑器提示和编译器验证。它们的内容形如：&lt;/p&gt;
&lt;p&gt;declare interface UnderscoreVoidListIterator {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(element : any, index : number, list : any[]) : void;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;declare interface UnderscoreMemoListIterator {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(memo : any, element : any, index : number, list : any[]) : any;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;declare interface UnderscoreListIterator {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(element : any, index : number, list : any[]) : any;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这种文件很重要，因为我们要想使用第三方的js库，一般都需要手动做出这样的声明文件，才能在typesafe的环境中使用它们。只需要以注释的方式写上即可，不需要在实际代码中声明或引用什么。&lt;/p&gt;
&lt;p&gt;现在在idea中，这些引用还得手动去写，不太方便，我想tsc或者编辑器应该会对它进行增强。&lt;/p&gt;
&lt;h4&gt;下载第三方js库的声明文件&lt;/h4&gt;
&lt;p&gt;现在有很多优秀的第三方js库，我们要在typescript中使用它们，难道要一一手动创建这些文件吗？这个工作量可不小。&lt;/p&gt;
&lt;p&gt;好在已经有人这么做并把成果开源出来了，我们可以直接下载它们，放在自己的项目中，再加上引用注释即可。&lt;/p&gt;
&lt;p&gt;包含几乎全部的：&lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped&quot; title=&quot;https://github.com/borisyankov/DefinitelyTyped&quot;&gt;https://github.com/borisyankov/DefinitelyTyped&lt;/a&gt;，你应该把它clone到本地。&lt;/p&gt;
&lt;p&gt;使用方法：把它们clone到本地，放在某个地方（比如工具目录中），然后在我们自己的typescript中添加以一个引用即可：&lt;/p&gt;
&lt;p&gt;/// &lt;reference path=&quot;.. /../libs/AngularTS.module.d.ts&quot;/&gt;
&lt;br  /&gt;/// &lt;reference path=&quot;.. /../libs/underscore.browser.d.ts&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;创建自己的声明文件&lt;/h4&gt;
&lt;p&gt;如果我们用typescript写了一些模块，想让别人调用，除了把整个代码复制给他以外，还可以生成一个声明文件(&lt;code&gt;.d.ts&lt;/code&gt;)，让他使用该声明文件即可。tsc提供了选项让我们生成.d.ts:&lt;/p&gt;
&lt;p&gt;tsc &amp;ndash;declaration my.ts&lt;/p&gt;
&lt;p&gt;如果一切正常，将会在当前目录下产生一个&lt;code&gt;my.d.ts&lt;/code&gt;文件，里面包含了my.ts中定义的代码的接口声明。&lt;/p&gt;
&lt;h3&gt;类型&lt;/h3&gt;
&lt;p&gt;Typescript在javascript的基础上提供了类型系统，但它同时也支持动态类型。如果我们把一个变量或者返回值声明为&lt;code&gt;any&lt;/code&gt;，则它表示“动态类型”，编译器不会检查它的类型信息，但我们也得不到编辑器的提示信息。&lt;/p&gt;
&lt;h4&gt;any&lt;/h4&gt;
&lt;p&gt;function(obj: any) {
&lt;br  /&gt;obj.non_exist_method();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;如代码中所示，obj被声明为any，虽然内部调用了一个不存在的方法，编译器也不会提示有误，只有在运行期才知道。&lt;/p&gt;
&lt;h4&gt;推断&lt;/h4&gt;
&lt;p&gt;虽然typescript支持静态类型，但我们并不需要像java那样，在每个地方都要声明类型，因为typescript可以推断：&lt;/p&gt;
&lt;p&gt;var name = &amp;ldquo;Freewind&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;则name会被认为是string类型.&lt;/p&gt;
&lt;p&gt;function myname(name:string) {
&lt;br  /&gt;return name;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;则myname函数的返回值被认为是string类型。&lt;/p&gt;
&lt;p&gt;但我们在声明的地方，最好还是加上类型，以后看起来会比较清楚。&lt;/p&gt;
&lt;h4&gt;常用类型&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;800&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;any&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;可表示动态类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;string&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;number&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;bool&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;true或false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;null&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;undefined&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;void&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;string[]&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;字符串数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;{a;b;}&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;等于{a:any; b:any;}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;{ a:string, b: number; }&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;{ a:string, ()=&gt;number; }&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;后面那个是函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;() =&gt; void&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;表示形如 function() {} 这样的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;(string) =&gt; number&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;表示形如 function(name:string) { return 10; } 这样的函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;256&quot;&gt;{ [string]: number; }&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;544&quot;&gt;表示一个object，它的key为string，值为数学，形如：

{ &quot;aaa&quot;: 111, &quot;bbb&quot;: 222}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;语法糖&lt;/h2&gt;
&lt;p&gt;this.filter((todo: Todo) =&gt; todo.get(&apos;done&apos;));&lt;/p&gt;
&lt;h2&gt;使用grunt自动编译typescript&lt;/h2&gt;
&lt;p&gt;如果你使用的编辑器还不支持自动编译typescript，可以使用grunt来编译，还可以进行更多的任务，如对产生的js进和合并、压缩等工作，十分方便。&lt;/p&gt;
&lt;p&gt;具体可参看这篇文章：&lt;a href=&quot;http://freewind.me/blog/20130127/2027.html&quot;&gt;在Java项目中拥抱Nodejs — 使用gruntjs编译typescript，并将生成的js合并、压缩&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Typescript待实现的特性&lt;/h2&gt;
&lt;p&gt;仅以目前的typescript来说，虽然在类型方面做的不错，但是语言本身还有很多可以改进的地方。比如简化语法，提供更好用的控制结构，对异步进行更好的支持等。如果可以在语言层面改进javascript那些容易出错、不方便的地方，我想会有更多人采用typescript。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://typescript.codeplex.com/workitem/list/basic?field=Votes&amp;amp;direction=Descending&amp;amp;issuesToDisplay=Open&amp;amp;keywords=&amp;amp;emailSubscribedItemsOnly=false&quot;&gt;从这里的issue列表中&lt;/a&gt;，可以看到呼声较高的特性有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持泛型2.  实现await关键字：可以让异步调用变得简单3.  for &amp;hellip; of：js内置的for(x in y)对于数组来说，容易产生问题，但我们又需要经常遍历数组，所以提供for of代替4.  内置压缩js的功能5.  protected关键字6.  生成xml格式的文档7.  extension methods：可以让我们的函数调用更加流畅，比如underscore的那些方法 ，就可以写成 array.filter(function(item) {return ..})8.  allow module.exports9.  string interpolatio and block strings10.  support for abstract classes11.  macros：利用macro，可以扩展语言本身&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中我对2,3,6,10,11这几项很感兴趣，如果它们实现了，则typescript的吸引力会大大增强。&lt;/p&gt;
&lt;h2&gt;TypeScript展望&lt;/h2&gt;
&lt;p&gt;对于Typescript的未来，我还是比较看好的，因为对于服务器端的编程，类型系统是很重要的，可以让我们的代码质量变得更高，让不同版本之间的库的兼容性也更好。&lt;/p&gt;
&lt;p&gt;我之前使用nodejs感觉很郁闷的一点是，某一个库升级了（如改变了api接口），则相关的库都出错了，而想要找出问题很难，只能通过单元测试找到问题，再查看文档解决。而这样的问题在java中出现的就比较少，因为有类型系统的保证，如果接口改变了，直接编译都会出错。&lt;/p&gt;
&lt;p&gt;使用typescript后，让nodejs代码也具有的这样的能力，对于社区的前进是很有帮助的。而且对于java/c#程序员来说，这是很有吸引力的。&lt;/p&gt;
&lt;p&gt;随着以后typescript相关编辑器、工具的成熟，可以预见它将和coffeescript一样，成为javascript开发人员的标准备选，也许会有一些库和工具直接支持typescript，那样的话就会有更多人来使用typescript了。&lt;/p&gt;
&lt;p&gt;如果你对typescript也感兴趣，欢迎加入QQ群：Typescript热情交流群（250299804）&lt;/p&gt;
&lt;h2&gt;相关工具还不够成熟&lt;/h2&gt;
&lt;p&gt;经过几天的试用，发现现在使用它也还是不够方便。主要有几下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Idea的编辑器支持typescript的高亮、格式化及代码提示，但还不能像java那样，实时显示错误，所以只能借助第三方工具（比如gruntjs）来编译并显示错误。这种方式对于一个静态类型的语言来说，不是很方便，因为类型方面的错误很容易犯，如果分成两步走，来回切换工具会让定位很麻烦。&lt;/li&gt;
&lt;li&gt;我使用的是gruntjs，它基于nodejs，有typescript插件可以编译typescript文件。但是由于nodejs在windows平台上的有一个bug导致无法全面取得错误信息，当ts文件有错误时，只能取到第一行（错误行号），而拿不到具体信息。有时候怎么看那一行都不知道错在哪儿，只好又另开一个cmd，调用tsc命令去编译，很麻烦。&lt;/li&gt;
&lt;li&gt;更麻烦的事情来了。在gruntjs中编译提示有误，但我手动调用tsc编译又没错，调试很久都不找不到原因。gruntjs就没法用了。&lt;/li&gt;
&lt;li&gt;Typescript不支持将多个ts文件合并生成一个js并压缩，所以我只能借助gruntjs工具实现，但gruntjs又有点问题。&lt;/li&gt;
&lt;li&gt;Typescript语言本身还存在一些问题。比如array明明有length属性，但不能被识别，导致明明与它匹配的接口会编译出错。另外，一个any[]类型的数组，应该可以包含各种对象，但放入一个string和一个函数后，提示有误，必须在string前加一个&lt;any&gt;（可能是因为Typescript目前还不支持泛型，导致推断有误）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上所述，目前使用typescript进行前端开发，问题还比较多，各种小问题都会影响开发效率。所以看样子，只能老老实实地使用javascript（或者coffeescript?），等到typescript成熟一些后再用它。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在Java项目中拥抱Nodejs — 使用gruntjs编译typescript，并将生成的js合并、压缩</title>
                <link>http://freewind.in/posts/2027-use-nodejs-in-java-project-use-grauntjs-to-compile-typescript-package-compress-js</link>
                <pubDate>Mon, 28 Jan 2013 00:18:11 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2027</guid>
                <description><![CDATA[&lt;p&gt;作为一个Java程序员，做的是Java项目，为什么需要了解Nodejs，并且还要拥抱它？&lt;/p&gt;
&lt;p&gt;这里的Java项目，特指java web项目。如果是纯java项目，并不是很需要它，但如果是有很js/css/coffeescript/typescript/less/sass这样的文件的项目时，也许你就需要Nodejs了。&lt;/p&gt;
&lt;p&gt;Nodejs是一个平台，可以让我们写服务器端的代码，它内部使用了google开发的v8引擎，执行js代码速度很快。我们学习它并不是为了写js代码，而是为了把它当工具使用，更好地处理我们的js/css等文件。&lt;/p&gt;
&lt;p&gt;Nodejs的启动速度很快，并且第三方模块很多，而这些模块很多都跟js相关。其中有一些很好用的工具，可以简化我们的工作。虽然学习它需要花一些时间，但是带来的回报更大。&lt;/p&gt;
&lt;p&gt;这里我将使用它来管理我的js代码，要求实现以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将我的typescript编译为js代码2.  将多个js文件合并为一个3.  将合并后的js文件进行精简操作(min)，减少文件体积4.  当我修改了typescript/js代码，自动重复以上操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Playframework中，可以内置或通过插件，将coffeescript自动转为javascript并精简压缩。但是当我们需要更多更灵活的功能时，就比较麻烦，因为play的插件不是那么好写的。我今天在play1中，编写java代码来处理typescript的编译操作，但是发现效率很低，当文件多的时候，修改typescript文件刷新后，需要好几秒才能编译成新的，难以接受。另外，由于typescript现在不支持将多个ts文件合并为一个js文件，我想去合并、精简时生成的多个js文件时，觉得太麻烦没做，只好将就着。&lt;/p&gt;
&lt;p&gt;后来实在受不了了，发现了gruntjs这个工具，它是基于nodejs的。原来用它实现这些任务竟然如此简单，只需要简单的配置即可，编译速度还很快。另外，除了这些任务，我还发现了nodejs上的livereload插件，这样就可以替代以前使用的那个python的livereload了。&lt;/p&gt;
&lt;p&gt;这些经验不仅仅对现在的项目有用，以后做其它涉及到js的项目时，也同样可用。所以学习它很值得。&lt;/p&gt;
&lt;h2&gt;Nodejs&lt;/h2&gt;
&lt;p&gt;Nodejs现在发展势头良好，正在紧张开发之中，每隔几天就看到一个新版本，让人眼花缭乱，当前最新版是v0.8.18。它的官方地址是&lt;a href=&quot;http://nodejs.org/&quot;&gt;http://nodejs.org/&lt;/a&gt;，可以在windows/linux/unix上安装。&lt;/p&gt;
&lt;p&gt;打开主页后，网站会根据操作系统自动提供相应的安装包，下载后安装即可。我是win7 x64，安装完成后，在cmd中输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node -v


会提示

C:\Users\Freewind&amp;gt;node -v
v0.8.11


我是之前安装的，那时候的版本还是0.8.11

来个hello world。直接输入node，就会出现交互运行环境：

C:\Users\Freewind&amp;gt;node
&amp;gt; console.log(&apos;hello, world&apos;)
hello, world
undefined
&amp;gt;


如果想执行某个js文件，可以输入：

node test.js


## npm

npm是nodejs中内置的包管理系统，类似于ubuntu上的apt-get，或者centos上的yum，或者ruby上的gem。

我们安装完nodejs后，它就可以使用了。我们可在命令行中输入：

npm


就可以看到一些提示信息。它提供的命令很多，可用来安装、卸载某些第三方的库。npm中的库有很多，可到这里查看：[https://npmjs.org/](https://npmjs.org/)，当前显示有20000多个。

### package.json

npm的配置放在名为package.json的文件中，它的内容是一个json字符串，基本内容如下：

{
  &quot;author&quot;: {
    &quot;name&quot;: &quot;Freewind&quot;
  },
  &quot;name&quot;: &quot;mytest&quot;,
  &quot;version&quot;:&quot;0.0.1&quot;,
  &quot;dependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.3.17&quot;,
    &quot;grunt-typescript&quot;: &quot;0.0.8&quot;
  }
}


其中name和version是基本信息，必须有。不过通常比较关注的是&quot;dependencies&quot;信息，它表示所在项目依赖于哪些第三方库。

首先要讲一下npm是怎么来查找路径的。当我们执行一个npm命令时，比如`npm install typescript`，它会首先查当前目录下有没有`package.json`文件或者`node_modules`目录。如果有则直接使用，没有的话，到上级目录中寻找，直到根目录。这个特性可以让我们在一个项目的子目录中执行npm命令，十分方便。如果所有的上级目录都没有的话，则会以当前目录作为工作目录，创建一个node_modules目录，把安装的库放到里面。

如果在当前或者上级某个目录中，有package.json文件，并且里面已经定义了一些依赖，我们可以直接使用这个命令，自动安装：

npm install


后面没有加参数，表示按package.json的要求来安装。

还有一个参数比较重要:

npm install somelib --save


后面的`--save`可用来告诉nodejs，安装完指定库后，把该依赖信息写到package.json文件中（如果有的话）。

更多的常用命令：

&amp;lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;800&quot;&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm install somelib
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        将somelib这个库安装在当前或上级某目录下
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm install somelib -g
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        将somelib这个库安装为全局库，一些工具通常使用这种方式安装，比如typescript。安装完后就可以在命令行中直接使用库中的命令了，比如tsc（typescript的编译命令）
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm remove somelib
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        从当前或上级目录下移除somelib
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm remove somelib -g
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        从全局库中移除somelib
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm install somelib -save
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        在当前或上级目录中安装somelib，并将它添加到package.json中的依赖项里，十分方便
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm install
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        根据当前或上级目录中的package.json，自动安装缺失库
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;201&quot;&amp;gt;
        npm list
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;599&quot;&amp;gt;
        显示当前或上级目录中已经安装的nodejs库
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;

## Typescript

实际上此时并不需要安装typescript的编译器，但是由于肯定会用到，所以一起装了。

Typescript的编译器是以nodejs库的方式发布的。我们只需要使用该命令：

npm install typescript -g


即可。安装成功后，在命令行中输入：

tsc


它就会提示一些帮助信息。

常用用法如下

&amp;lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;800&quot;&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;249&quot;&amp;gt;
        tsc test.ts
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;551&quot;&amp;gt;
        编译一个test.ts文件
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;249&quot;&amp;gt;
        tsc -declaration test.ts
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;551&quot;&amp;gt;
        为test.ts生成它对应的声明文件，产生的文件为test.d.ts
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;249&quot;&amp;gt;
        tsc -out dist.js test.ts 
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;551&quot;&amp;gt;
        将test.ts编译为dist.js文件
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;249&quot;&amp;gt;
        tsc -out dist test.js
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;551&quot;&amp;gt;
        将test.ts编译成dist目录下，如果test.ts依赖其它文件，则把它们也编译到dist目录中
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;249&quot;&amp;gt;
        tsc -module commonjs
      &amp;lt;/td&amp;gt;
&amp;lt;td valign=&quot;top&quot; width=&quot;551&quot;&amp;gt;
        使用commonjs方式生成js（默认），还可以使用amd
      &amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;

关于typescript的更多内容，参看我另一篇博文。

## gruntjs

gruntjs是一个构建系统，有点像java中的ant，但是感觉要简单很多，而且很多任务都是跟js相关的。它现在有380个插件，可在其主页[http://gruntjs.com/](http://gruntjs.com/)上查询。

安装：

npm install -g grunt-cli


这里安装的是`grunt-cli`，它是一个全局的命令行工具，可以让不同的项目使用不同版本的grunt来编译，解决兼容问题。而`grunt`，则要以本地方式安装到我们的某个工作目录中。

进入某个工作目录，输入以下命令：

npm install grunt


则会在本地安装grunt，之后我们才能使用grunt命令来进行一些操作。

如果你是windows系统，一定要注意，安装完后，你有两个grunt命令可用，一个是grunt，一个是grunt.cmd，它们是两个不同的文件。其中前者是grunt库本身的命令，后者是用来执行你定义的任务的命令。请记住必须要用`grunt.cmd`，否则你会奇怪，为什么我的任务没执行等等。这个坑爹的问题花了我很多时间才解决。

要生成它的配置文件，需要安装`grunt-init`工具：

npm install grunt-init -g
git clone https://github.com/gruntjs/grunt-init-gruntfile.git ~/.grunt-init/gruntfile


然后运行：

grunt-init gruntfile


它会问一些配置方面的问题，然后生成一个默认的`Gruntfile.js`文件。

将会在当前或上级目录（按nodejs的方式来定位工作目录），产生一个grunt.js文件，里面的内容如下：

/*global module:false*/
module.exports = function(grunt) {

  // Project configuration.
  grunt.initConfig({
    // Metadata.
    pkg: grunt.file.readJSON(&apos;package.json&apos;),
    banner: &apos;/*! &amp;lt;%= pkg.title || pkg.name %&amp;gt; - v&amp;lt;%= pkg.version %&amp;gt; - &apos; +
      &apos;&amp;lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&amp;gt;\n&apos; +
      &apos;&amp;lt;%= pkg.homepage ? &quot;* &quot; + pkg.homepage + &quot;\\n&quot; : &quot;&quot; %&amp;gt;&apos; +
      &apos;* Copyright (c) &amp;lt;%= grunt.template.today(&quot;yyyy&quot;) %&amp;gt; &amp;lt;%= pkg.author.name %&amp;gt;;&apos; +
      &apos; Licensed &amp;lt;%= _.pluck(pkg.licenses, &quot;type&quot;).join(&quot;, &quot;) %&amp;gt; */\n&apos;,
    // Task configuration.
    concat: {
      options: {
        banner: &apos;&amp;lt;%= banner %&amp;gt;&apos;,
        stripBanners: true
      },
      dist: {
        src: [&apos;lib/&amp;lt;%= pkg.name %&amp;gt;.js&apos;],
        dest: &apos;dist/&amp;lt;%= pkg.name %&amp;gt;.js&apos;
      }
    },
    uglify: {
      options: {
        banner: &apos;&amp;lt;%= banner %&amp;gt;&apos;
      },
      dist: {
        src: &apos;&amp;lt;%= concat.dist.dest %&amp;gt;&apos;,
        dest: &apos;dist/&amp;lt;%= pkg.name %&amp;gt;.min.js&apos;
      }
    },
    jshint: {
      options: {
        curly: true,
        eqeqeq: true,
        immed: true,
        latedef: true,
        newcap: true,
        noarg: true,
        sub: true,
        undef: true,
        unused: true,
        boss: true,
        eqnull: true,
        globals: {
          jQuery: true
        }
      },
      gruntfile: {
        src: &apos;Gruntfile.js&apos;
      },
      lib_test: {
        src: [&apos;lib/**/*.js&apos;, &apos;test/**/*.js&apos;]
      }
    },
    nodeunit: {
      files: [&apos;test/**/*_test.js&apos;]
    },
    watch: {
      gruntfile: {
        files: &apos;&amp;lt;%= jshint.gruntfile.src %&amp;gt;&apos;,
        tasks: [&apos;jshint:gruntfile&apos;]
      },
      lib_test: {
        files: &apos;&amp;lt;%= jshint.lib_test.src %&amp;gt;&apos;,
        tasks: [&apos;jshint:lib_test&apos;, &apos;nodeunit&apos;]
      }
    }
  });

  // These plugins provide necessary tasks.
  grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-nodeunit&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);
  grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);

  // Default task.
  grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;nodeunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]);

};


可以看到它里面定义了很多任务，比如使用jslint检查js文件，合并，压缩，执行单元测试，监视文件变化等。注意里面的文件路径都是空的，需要根据自己的情况添加。

要执行某个任务，可在命令行中输入：

grunt.cmd qunit


如果只输入：

grunt.cmd


则表示执行默认任务。此时表示&apos;lint qunit concat min&apos;。

其中的`watch`任务非常有用，它可以监视某些文件和目录，当它们发现变化时，自动执行指定的某些任务。我们将可以使用该功能监视typescript文件，当修改后，自动把它编译为js，浏览器那边就能看到最新的代码了。

注意，使用此任务时，最好在后面加上-force参数，即：

grunt.cmd watch --force


这样当构建过程中出现错误时，它会跳过并继续监视，否则就直接退出了。

## grunt-typescript

最后是安装grunt-typescript插件，它可以在grunt中增加编译typescript的任务：

npm install grunt-typescript --save


然后[按照其文档](https://npmjs.org/package/grunt-typescript)往grunt.js里添加一些配置即可。我这里的成品是这样的：

/*global module:false*/
module.exports = function (grunt) {

    grunt.loadNpmTasks(&apos;grunt-typescript&apos;);

    // Project configuration.
    grunt.initConfig({
        concat: {
            WindBase: {
                src: [&apos;tmp/typescripts/controllers/**/*.js&apos;,
                    &apos;&apos;],
                dest: &apos;public/javascripts/app.js&apos;
            },
            wind_articles: {
                src: [&apos;../wind_articles/tmp/typescripts/**/*.js&apos;],
                dest: &apos;../wind_articles/public/javascripts/module.js&apos;
            }
        },
        min: {
            WindBase: {
                src: [&apos;public/javascripts/app.js&apos;],
                dest: &apos;public/javascripts/app.min.js&apos;
            },
            wind_articles: {
                src: [&apos;../wind_articles/tmp/typescripts/module.js&apos;],
                dest: &apos;../wind_articles/public/javascripts/module.min.js&apos;
            }
        },
        watch: {
            files: [&apos;typescripts/**/*.ts&apos;, &quot;../wind_articles/typescripts/src/**/*.ts&quot;],
            tasks: &apos;typescript concat min&apos;
        },
        typescript: {
            WindBase: {
                src: [&apos;typescripts/src/**/*.ts&apos;],
                dest: &apos;tmp/typescripts&apos;,
                options: {
                    module: &apos;amd&apos;, //or commonjs
                    target: &apos;es5&apos;, //or es3
                    base_path: &apos;typescripts/src&apos;,
                    sourcemap: false,
                    declaration: false
                }
            },
            wind_articles: {
                src: [&apos;../wind_articles/typescripts/src/**/*.ts&apos;],
                dest: &apos;../wind_articles/tmp/typescripts&apos;,
                options: {
                    module: &apos;amd&apos;, //or commonjs
                    target: &apos;es5&apos;, //or es3
                    base_path: &apos;../wind_articles/typescripts/src&apos;,
                    sourcemap: false,
                    declaration: false
                }
            }
        }
    });

    // Default task.
    grunt.registerTask(&apos;default&apos;, &apos;typescript concat min&apos;);

};


注意其中的&quot;typescript&quot;和&quot;concat&quot;任务，可以设置多个子任务，名字（这里是WindBase和wind_articles）任选，只要里面的配置写对即可。你可以参照它修改。

另外把package.json也贴上：

{
  &quot;name&quot;: &quot;mytest&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;dependencies&quot;: {
    &quot;typescript&quot;: &quot;~0.8.2&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;完成效果&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/2027-1.gif&quot;&gt;&lt;img src=&quot;/user_images/2027-1.gif&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Haxejs不适合与Angularjs一起使用</title>
                <link>http://freewind.in/posts/2022-haxejs-is-not-proper-to-use-with-angularjs</link>
                <pubDate>Sun, 27 Jan 2013 00:02:27 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2022</guid>
                <description><![CDATA[&lt;p&gt;前些天成功地将Haxejs与Angularjs结合起来使用，并把之前用javascript写的几个angularjs的controller改成了haxejs，非常振奋。因为可以在一种typesafe的环境中写代码，是一件让人安心的事情。有以下几点让人感觉特别好：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽可能利用静态类型，在编译期就能找到各种笔误，并且编辑器的代码提示功能基本可用2.  可直接使用Haxejs提供的基本方法，如对String的操作、数组的操作等，不需要学习额外的js库3.  最后生成一个非常精简的js文件，去掉了所有没用上的代码，体积小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但随着使用的深入，一些不方便的地方慢慢显露出来，这主要是跟Angularjs的特性相关。&lt;/p&gt;
&lt;h2&gt;不断在两种语言中切换思路&lt;/h2&gt;
&lt;p&gt;Angularjs跟其它的前端mvc框架有很大的不同，比如它的很多代码是放在HTML标签上，直接引用$scope对象上的数据或方法，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;
&amp;lt;li ng-repeat=&quot;name in names&quot;&amp;gt;{{name}}&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

这里的names就是定义在$scope对象上的一个数组。因为我现在用haxejs来写controller，对于像这样的数据，都是在haxe中操作的，并且使用的是haxe的数据结构。虽然它们会被替换为javascript中相应的数据结构，但并不是一一对等的。比如这个names，我在haxe中使用的是Array&amp;lt;String&amp;gt;，它可近似地看作是javasript中的[]，但并不是完全对等。

在上面的例子中，这段代码运行正常，但下面这个就不对：

&amp;lt;div ng-show=&quot;names&quot;&amp;gt;
todo
&amp;lt;/div&amp;gt;

如果names是null或undefined或[]，这个层应该会隐藏起来。但是如果它是由haxe中的空数组转过来的，则还是会显示！因为names实际上是一个在js中定义的Array function的对象，而不是[]。正确的写法应该是：

&amp;lt;div ng-show=&quot;names!=null &amp;amp;&amp;amp; names.length&amp;gt;0&quot;&amp;gt;
todo
&amp;lt;/div&amp;gt;

这样的例子还有很多，所以在用haxe写angularjs代码时，并不能完全脱离javascript，反而等时刻在两种差别很大的语言中切换思路，经常要考虑：这个对象转成js后，能不能被angularjs识别，会不会出问题等等，让人感觉特别累。

如果使用其它的框架，比如jquery等，则没有这样的问题。因为在haxe中，往往是通过一些代码得出最后的文本，然后替换掉html页面中的某个div。在这个过程中，不需要其它js的参与，基本可以用haxe的思路来处理整个流程，所以不会累。

## Haxe的变量名中不能有$

Haxe是一门可以编译为多种语言的语言，因为有些语言不允许在变量名、方法名中出现$，所以haxe也不允许变量、方法名中出现$。然而Anguarljs却大量使用$，比如$scope, $http, $scope.$on, $scope.$watch等等，都是以$开名，用来表示这是由Anguarljs提供的供我们使用的对象。

在haxe中，为了使用这些方法，我的代码需要写在：

Reflect.field(scope, &quot;$on&quot;)(&quot;myevent&quot;, function() {});

而在js中只需要写成：

$scope.$on(&quot;myevent&quot;, function(){});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只是一两处还好说，但是当我看angularjs代码满眼的$时，有种欲哭无泪的感觉。&lt;/p&gt;
&lt;p&gt;如果使用其它的库，则不会出现这样的问题。因为jQuery使用了$，但仅仅使用它作为jQuery对象的别名，在haxe中可以直接使用jQuery这个名字即可，在方法的调用过程中，很少有$。而其它的库，都会避开与jQuery的冲突，也很少使用$。&lt;/p&gt;
&lt;p&gt;综上所述，虽然使用haxejs可以让我们的代码享受到静态类型的便利，但在与Angularjs的结合中，付出的代价也很大，甚至超过了这种便利。在使用haxejs来写angularjs的controller类的这两天，感觉很烦燥，开发效率很低。&lt;/p&gt;
&lt;p&gt;所以我觉得如果用Angularjs的话，最好使用一种采用javascript思路的语言（如coffeescript/typescript等），或者直接采用javascript本身。如果想用haxejs的话，最好使用一些较简单、对HTML侵入性较低的框架，如jQuery等。&lt;/p&gt;
&lt;p&gt;这篇文章主要表达的是haxejs与angularjs（或其它对HTML侵入较多的js框架）之间不太合适，但haxejs本身产生js的能力还是很强的。在其它需要手写很多js代码、逻辑复杂的情况下，使用haxejs，还是很合适的，可以大幅提高开发效率并提高代码质量，例如后端代码（nodejs开发）可以考虑。因为你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态类型的保护及编辑器的提示&lt;em&gt;   Extension Method，可以让函数调用更加流畅&lt;/em&gt;   haxe强大的宏功能，可以让代码更简洁*   可生成单个js文件，包含所有js代码，且去掉所有不需要的&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>我为什么选择haxejs，而不是dart/typescript</title>
                <link>http://freewind.in/posts/2019-why-i-choose-haxejs-not-dart-typescript</link>
                <pubDate>Wed, 23 Jan 2013 00:00:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2019</guid>
                <description><![CDATA[&lt;p&gt;我在js群里向大家介绍haxejs时，有同学问它与dart/typescript相比，有什么好处，为什么不用dart/typescript？&lt;/p&gt;
&lt;p&gt;三者都有各自的优点和不足，我在这里列出来，大家自行参考：&lt;/p&gt;
&lt;h2&gt;Dart&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Google开发，研发实力雄厚，由v8引擎的开发者主导，阵容强大2.  有很多不错的语言特性，如静态类型仅对IDE起提示作用，所以我们可以给任意一个对象设为任意一个类型，既能得到编辑器的提示，又不影响生成的代码，非常灵活。3.  有一个叫&lt;a href=&quot;https://github.com/dart-lang/web-ui&quot;&gt;dart-web-ui&lt;/a&gt;的项目，跟angularjs很像，但增加了web-components的支持，前途光明4.  eclipse和idea都提供不错的支持5.  思路是Dart的，这样不论是在后台运行，还是生成js，都可直接按dart的思路走，不需要过多考虑js的语法问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目前还不够成熟，还在不断添加语言特性，感觉很谨慎2.  着眼于未来，所以不太在意低版本浏览器的支持。如果你要支持IE6/7/8，请多多测试3.  生成的js优化不够，如果你引用的dart第三方库多了，生成的js会很大。这将导致你在使用dart时有很多顾虑。4.  因为思路是Dart的，并不支持js语法。如果你需要使用很多js库，需要多做一些工作&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;TypeScript&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微软开发。微软对nodejs也在大力支持，可以看出微软将在这方面投入很多。2.  思路还是Javascript的，兼容js语法，仅仅提供了一些基本而必要的面向对象的结构3.  相当于静态类型版的coffeescript，对于js人员来说，学习成本很低4.  微软提供了基于vs的编辑器插件，据说功能不错5.  Js兼容性比较好&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其它编辑器（如eclipse等）的支持还没跟上，对于非微软系的同学，安装VS心理阻力有点大2.  如果你本身不喜欢js的语法，则用typescript时，也会有类似的感觉3.  功能由第三方js库提供，根据项目需要，可能要引入多个第三方js库4.  语言本身提供的功能较少、较弱&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Haxejs&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成js代码时，可以完全去除不需要的代码，生成的js文件体积很小。这意味着你可以随心所欲地使用各种haxe库，不用担心最终的文件大小。2.  语言功能很强，比如macro，可以实现一些常规手段很难实现的功能3.  有一些比较好用的功能，比如extension method等，可以实现流畅的代码调用4.  成熟，已经七年了，简单的bug早就死光了5.  Js兼容性比较好。检查了生成的js，都是一些很常规的用法6.  使用Haxe的思路，对于常用功能，基本上不用考虑js。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有大公司支持，都是开源社区及爱好者们支持。2.  产品化做的不好，文档简单（甚至过时），资料少，不容易系统学习，有时候非常简单的功能也要去问3.  需要看源代码学习。但因为haxe还支持编译为php/neko/flash/c++/java/c#等代码，所以它的源代码中经常有各种编译开关，看着很乱。4.  一些第三方库使用的haxe版本不同，并不是拿来就能用，可能会有编译错误，需要手动修改5.  编辑器的支持不够好，虽然基本功能有了，但还不贴心6.  对于java/c#/js转过去的同学，有一些语言特性还需要学习和理解，有一定的学习曲线7.  大部分用haxe的人，是为了开发跨平台的手机游戏（使用nme库），单纯为了js的人比较少&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;我为什么选择HaxeJS&lt;/h2&gt;
&lt;p&gt;通过上面列出来的优缺点，可以看出，对于大多数人来说，haxejs并不适合。但对于我来说，它却是这三个中最适合的一个。因为它的优点都是我需要的，而它的缺点在这几天的学习过程中，已经克服掉了。&lt;/p&gt;
&lt;p&gt;我今天把我前段时间写的js代码全部转换成了haxe代码，并且运行完全正常，这给了我极大的信心。在转换过程中，发现haxe的语法跟js语法还是很像的，拷过来的代码只需要改少数几个地方（如增加类型）就行了，比较方便。&lt;/p&gt;
&lt;p&gt;我打算以后就用HaxeJs来写js代码，不过对于我来说，大部分功能还是在后端用java实现。我觉得用nodejs的人，更应该考虑一下这种静态解决方案，不论是HaxeJs或者TypeScript，都可以一试。毕竟服务端的代码往往比较多，需要经常重构，如果没有类型系统和编辑器的支持，会让人无从下手。&lt;/p&gt;
&lt;p&gt;最后再次强调，请根据自己的情况和需求选择合适的语言和技术。我的选择只适合我的情况，所以仅供参考。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;zjcqoo&lt;/h3&gt;
&lt;p&gt;Typescript的编译器居然也是用Typescript写的。。。编译速度实在受不了&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>发布了一个Haxe的小项目：HaxeAngularSupport</title>
                <link>http://freewind.in/posts/2016-my-hax-project-haxe-angular-support</link>
                <pubDate>Tue, 22 Jan 2013 21:35:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2016</guid>
                <description><![CDATA[&lt;p&gt;经过几天的奋斗，终于把这个小项目做出来了：&lt;a href=&quot;https://github.com/freewind/HaxeAngularSupport&quot;&gt;https://github.com/freewind/HaxeAngularSupport&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个东西是一个haxe的宏，它的作用是在编译时期改变我们的代码结构，自动生成一些手写麻烦的代码，让我们写起来简单一些。这个项目的代码之前不是这个样子的，但由于一个关于宏的bug还未修复，之前的想法无法实现。好在今天发现了另一种简单的办法，绕开了那个问题，终于成功。&lt;/p&gt;
&lt;p&gt;现在haxe官方发布的稳定版是2.10，近期将要发布3.0版。其中有关宏的api正在大幅增强，所以有bug是难免的，期待3.0的发布。&lt;/p&gt;
&lt;p&gt;下面讲讲这个AngularSupport的宏的作用。之前我们用haxe写angularjs的代码，使用的是传统方式（也是angularjs推荐的方式）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyCtrl implements Public {
    public static function __init__() {
        js.Lib.eval(&quot;MyCtrl.$inject = [&apos;$scope&apos;, &apos;$http&apos;];&quot;);
    }
    function new(scope:Scope, http:Dynamic) {
        scope.name = &quot;Freewind&quot;;
        scope.hello = function() {
            js.Lib.alert(scope.name);
        }
    }
}
private typedef Scope = {
    name:String,
    hello: Void -&amp;gt; Void
}

这种结构对于javascript来说是比较理想的，因为完全没有&quot;this&quot;的调用，减少了混乱，所有的操作都是针对scope来进行的。但是放在haxe中，则有点不太好：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们需要在最下面另外定义一个typedef，指明Scope所有可用的字段和方法，以获得静态类型的检验和编辑器的提示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有利用到class结构中的字段与方法，所有的操作都是在构造函数中完成的。这样我们无法在编辑器的“大纲”视图中看到类结构，以及快速定位到某字段或方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每次增加一个字段或方法，都需要修改两处&lt;/p&gt;
&lt;p&gt;我希望按普通的方式来写：&lt;/p&gt;
&lt;p&gt;class MyCtrl implements Public, implements AngularSupport {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@AngularSupport({inject:[&apos;$scope&apos;, &apos;$http&apos;], scope:&apos;$scope&apos;})
function new(scope:Dynamic, http:Dynamic) {
    this.http = http;
    // don&apos;t need to assign &quot;scope&quot; to anything
}
var http:Dynamic;
var name = &quot;Freewind&quot;;
function hello() {
    js.Lib.alert(name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以看到，以前放在scope上的东西，现在全都以field/method的方式放在class中了。我们对数据进行操作时，都指向this，而不必像之前那样，必须写个&quot;scope.xxx&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;最大的好处是结构更加清楚了，当代码多起来的时候，感觉就会比较明显了。&lt;/p&gt;
&lt;p&gt;这段代码实现了接口&quot;AngularSupport&amp;rdquo;，所有实现该接口的类，都会在编译期得到增强。&lt;/p&gt;
&lt;p&gt;由于它使用了最新的macro api，所以在稳定版的2.10 haxe上用不了，需要下载最新的nightly-build。对于遗留项目有风险，所以最好等到3.0正式发布后再在生产项目中使用，尝鲜的话无所谓了。&lt;/p&gt;
&lt;p&gt;具体要求和用法，请参考项目的README：&lt;a href=&quot;https://github.com/freewind/HaxeAngularSupport&quot;&gt;https://github.com/freewind/HaxeAngularSupport&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(更多理论上的内容，可参考：http://blog.csdn.net/rocks_lee/article/details/9129319)&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用haxejs进行typesafe的javascript开发</title>
                <link>http://freewind.in/posts/2014-use-haxejs-to-write-javascript-in-typesafe-manner</link>
                <pubDate>Mon, 21 Jan 2013 23:27:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">2014</guid>
                <description><![CDATA[&lt;p&gt;我使用angularjs写网页，当逻辑复杂的时候，需要写很多js代码。我对js一直比较怕，因为有这几个问题困扰着我：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Javascript在语言层面有很多陷阱，很容易犯错&lt;/li&gt;
&lt;li&gt;有时候笔误写错了什么，没有运行到它的时候发现不了&lt;/li&gt;
&lt;li&gt;当代码比较多的时候，想重构难以下手&lt;/li&gt;
&lt;li&gt;核心中提供的常用方法比较少，需要引入很多第三方库来实现功能，增加了文件体积&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我一直想找一种语言可以代替js，动静态都行，但要能有效解决上面的几个问题。&lt;/p&gt;
&lt;p&gt;我考察了以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dartlang.org&quot;&gt;Dart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.typescriptlang.org&quot;&gt;Typescript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coffeescript.org/&quot;&gt;Coffeescript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.haxejs.org&quot;&gt;haxejs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/clojure/clojurescript&quot;&gt;clojurescript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们都是可以生成js代码在浏览器端运行的。&lt;/p&gt;
&lt;p&gt;最终我的选择是Haxejs，这里讲一下选择的原因以及一些示例供参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉并且喜欢clojure的，不妨直接上clojurescript。写的是clojure代码，但能生成javascript。群里的老猪同学用它，感觉还不错。&lt;/li&gt;
&lt;li&gt;Coffeescript是很有名的。它的思路还是Javascript，但通过自己的语法规避了不少js的陷阱。喜欢ruby又不追求静态类型的同学可以用它。对于多层嵌套的代码，利用它简化的语法，可以让嵌套不再那么痛苦。&lt;/li&gt;
&lt;li&gt;Dart, Typescript, Haxejs都是动静态类型的，语法及Javascript/Java都有点像。想使用类结构来组织javascript代码的，可使用它们中的任何一种。微软系的同学可能会用Typescript，它的思路也是javascript，只是变了种写法。Dart的思路是dart，它会产生比较大的额外js代码实现自己的基础类库，介意的同学需要考虑一下。Haxejs的思路是Haxe，它虽然定义了自己的数据结构，但在生成js代码时，可以去掉用不到的，生成的js代码极小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于Haxe，对于普通的使用者我并不是很推荐，因为它现在有以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;产品化比较差，官网上的文档少，资料少，严重依赖看源码。对于英语不好的同学来说，入门不易&lt;/li&gt;
&lt;li&gt;同时它可以生成七八种语言的代码，所以源代码看起来有点头晕，到处是#if #end这样的编译开关&lt;/li&gt;
&lt;li&gt;编辑器的支持也不够好，处于“能用”状态&lt;/li&gt;
&lt;li&gt;使用haxe的人大多是被它的一个很强的nme跨平台框架吸引，使用它的js功能的人倒不是很多。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但这并不能掩盖Haxe的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它是动静态类型的，我们可以利用编辑器与编译器的类型检查，写代码比较放心&lt;/li&gt;
&lt;li&gt;我试过的各语言中，只有它能完全去除用不上的js代码，产生的文件极小。这意味着我们可以在代码中无所顾忌地使用各种第三方haxe库&lt;/li&gt;
&lt;li&gt;它有强大的macro功能，可以让我们按自己的想法改变代码的写法。比如&lt;a href=&quot;https://github.com/freewind/HaxeAngularSupport&quot;&gt;我实现的一个宏可用于减少angularjs的写法&lt;/a&gt;，或者杨博的&lt;a href=&quot;https://github.com/Atry/haxe-continuation&quot;&gt;一个库&lt;/a&gt;可以让我们以同步的方式写代码，却生成callback多层嵌套的js代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过检查haxe生成的js代码，可以看出使用了最常用的js用法，所以兼容性不是问题。同时它也内置了对jquery的支持，生成的是jquery的调用，也可以做到浏览器的兼容。&lt;/p&gt;
&lt;p&gt;其实我以前就曾经试过Haxe，但当时感觉比较失望，因为相比dart，似乎并没有太多吸引人的地方。但是我看到了杨博的一篇文章：&lt;a href=&quot;http://www.ac.net.blog.163.com/blog/static/13649056201210243595589/&quot;&gt;Haxe+Node.js+continuation打造高性能高开发效率服务器架构（下）&lt;/a&gt;后，改变了自己的看法，因为如果能掌握haxe的macro，就有可能实现出以前做不到的功能。比如杨博的那个库，就是我以前研究nodejs时很想要的一个东西。&lt;/p&gt;
&lt;p&gt;所以真正让我想用haxe的，也是因为haxe的macro，然后才发现了更多的优点（以及不爽之处）。因为Angularjs特殊的流程，使得它无法很好利用类结构带来的优势。比如这段代码，可以看作是angularjs的标准Controller写法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function Ctrl($scope) {
    $scope.name = &quot;Freewind&quot;;
    $scope.hello = function() {
       alert($scope.name);
    }
    $scope.method1 = function() {}
    $scope.method2 = function() {}
    $scope.method3 = function() {}
    $scope.method4 = function() {}
    $scope.method5 = function() {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于Angularjs来说，这个Ctrl函数，仅仅是用来在调用一次后，对传入的$scope进行改变，比如增加属性和方法等，然后Ctrl和$scope就没关系了。如果想用引入类，大约是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;haxe&quot;&gt;class Ctrl {
   public function new(scope:Scope) {
      scope.name = &quot;Freewind&quot;;
      scope.hello = function() {
         alert(scope.name);
      }
      scope.method1 = function() {}
      scope.method2 = function() {}
      scope.method3 = function() {}
      scope.method4 = function() {}
      scope.method5 = function() {}
   }
}
typedef Scope = {
    name:String,
    hello:Void-&amp;gt;Void,
    method1: Void-&amp;gt;Void,
    method2: Void-&amp;gt;Void,
    method3: Void-&amp;gt;Void,
    method4: Void-&amp;gt;Void,
    method5: Void-&amp;gt;Void
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出来，这段代码跟前面的差不多，虽然引入了class，但却没有办法利用上class的字段、方法等结构，还是全部在一个new函数里操作。同时为了利用编译器的检查，还要另外为scope定义一个type hint，既繁琐又不好看。（虽然看起来有点繁琐，但对于很长的javascript代码，这样做还是有莫大的好处。因为毕竟只有少数代码是用来定义类型的，大部分代码可以受益）&lt;/p&gt;
&lt;p&gt;如果我们的目的仅仅是这样，那么使用dart/typescript/haxe中的任意一种，都可以做到。但我希望可以写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;haxe&quot;&gt;class Scope {
    public var name:String = &quot;Freewind&quot;;
    public function hello() { alert(this.name); }
    public function method1() {}
    public function method2() {}
    public function method3() {}
    public function method4() {}
    public function method5() {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来清楚多了，但问题是，无法实现。&lt;/p&gt;
&lt;p&gt;这时候我想到haxe的宏(macro)不知道能不能派上用场。因为在杨博的例子中，可以看出macro的威力是巨大的，它可以把平行的代码变成嵌套的，这个改变相当的大，而不是局部优化。我能不能也写一个宏，但这个Scope类上定义的字段和方法，统统转移给传入的那个scope变量呢？这样我们写出来的是具有类结构的haxe代码，而产生的是angularjs需要的代码，皆大欢喜。&lt;/p&gt;
&lt;p&gt;于是我开始了我痛苦而又有挑战性的macro之旅。此处省略三天废寝忘食的描述，并且对back2dos和simon等多位国际友人及haxe前辈表达深深的谢意，没有你们的帮助，我简直寸步难行。&lt;/p&gt;
&lt;p&gt;最后的结果是，我差一点点就实现了这个功能。因为在此期间，发现了haxe编译器的一个bug：&lt;a href=&quot;http://code.google.com/p/haxe/issues/detail?id=1401&quot;&gt;http://code.google.com/p/haxe/issues/detail?id=1401&lt;/a&gt;，也正是这个bug，让我的功能没法实现。因为在编译期haxe对于类型的推断有问题，导致在改变代码结构的时候，无法正确的推断出某些方法的类型，编译不通过或者生成的js代码有误。&lt;/p&gt;
&lt;p&gt;我的代码放在：&lt;a href=&quot;https://github.com/freewind/HaxeMacroQkdny&quot; title=&quot;https://github.com/freewind/HaxeMacroQkdny&quot;&gt;https://github.com/freewind/HaxeMacroQkdny&lt;/a&gt;，有兴趣的同学可关注。我现在只能等待官方修正了这个bug后，才能继续尝试。&lt;/p&gt;
&lt;p&gt;如果这个功能实现了，我们就可以实现这样的效果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;haxe代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;haxe&quot;&gt;@AngularScope(&quot;$scope&quot;)
class Ctrl {
    @Inject(&quot;$http&quot;) private var http;
    public var name = &quot;freewind&quot;;
    public function hello() {
        trace(name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Js代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function Ctrl($scope, $http) {
    $scope.name = &quot;freewind&quot;;
    $scope.hello = function() {
        console.log($scope.name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在所能做的，只有等待了。如果这个功能实现的话，使用haxejs来开发angularjs就很爽了。&lt;/p&gt;
&lt;h2&gt;更新&lt;/h2&gt;
&lt;p&gt;这个功能已经实现了，使用了一种与这里描述的不一样的方式，绕开了那个bug。&lt;/p&gt;
&lt;p&gt;参看：&lt;a href=&quot;http://freewind.me/blog/20130122/2016.html&quot;&gt;发布了一个Haxe的小项目：HaxeAngularSupport&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>7.1 关系及其性质 50 ~ 57</title>
                <link>http://freewind.in/posts/1984-7-1-relationship-50</link>
                <pubDate>Tue, 08 Jan 2013 21:02:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1984</guid>
                <description><![CDATA[&lt;h2&gt;题目 50&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1984-1.png&quot;&gt;&lt;img src=&quot;/user_images/1984-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 50&lt;/h2&gt;
&lt;p&gt;由“反对称”的定义可知，题目只是“反对称”的定义的另一种表达方式&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 51&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1975-1.png&quot;&gt;&lt;img src=&quot;/user_images/1975-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 51&lt;/h2&gt;
&lt;p&gt;如果R是自反的，则对于A的所有元素x，都有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;。由于&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;{R^{ - 1}}&quot; /&gt;是R的逆关系，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;(x,x) \in {R^{ - 1}}&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;{R^{ - 1}}&quot; /&gt;是自反的。&lt;/p&gt;
&lt;p&gt;如果&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;{R^{ - 1}}&quot; /&gt;是自反的，则对于A的所有元素x，都有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;(x,x) \in {R^{ - 1}}&quot; /&gt;。由于R是&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;{R^{ - 1}}&quot; /&gt;的逆关系，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;，所以R是自反的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 52&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1978-1.png&quot;&gt;&lt;img src=&quot;/user_images/1978-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 52&lt;/h2&gt;
&lt;p&gt;因为R是集合A上的自反关系，所以对于A中的每一个元素x都有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;。由于&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Coverline%20R%20&quot; alt=&quot;\overline R &quot; /&gt;是R的补关系，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cnotin%20%5Coverline%20R%20&quot; alt=&quot;(x,x) \notin \overline R &quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Coverline%20R%20&quot; alt=&quot;\overline R &quot; /&gt;是反自反的。&lt;/p&gt;
&lt;p&gt;反过来，因为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Coverline%20R%20&quot; alt=&quot;\overline R &quot; /&gt;是反自反的，所以对于A中的每一个元素x都有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cnotin%20%5Coverline%20R%20&quot; alt=&quot;(x,x) \notin \overline R &quot; /&gt;。由于R是&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Coverline%20R%20&quot; alt=&quot;\overline R &quot; /&gt;的补关系，所以有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;，所以R是自反的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 53&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1981-1.png&quot;&gt;&lt;img src=&quot;/user_images/1981-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 53&lt;/h2&gt;
&lt;p&gt;使用数学归纳法。&lt;/p&gt;
&lt;p&gt;当n=1时，有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E1%7D%7B%5Crm%7B%20%3D%20%7D%7DR&quot; alt=&quot;{R^1}{\rm{ = }}R&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;对于任意正整数，因为R是传递的，由定理1，可知&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7Bn%20%2B%201%7D%7D%20%5Csubseteq%20R&quot; alt=&quot;{R^{n + 1}} \subseteq R&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;要证&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Csubseteq%20%7BR%5E%7Bn%20%2B%201%7D%7D&quot; alt=&quot;R \subseteq {R^{n + 1}}&quot; /&gt;。由归纳假设&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5En%7D%7B%5Crm%7B%20%3D%20%7D%7DR&quot; alt=&quot;{R^n}{\rm{ = }}R&quot; /&gt;，可知&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7Bn%20%2B%201%7D%7D%20%3D%20%7BR%5En%7D%20%5Ccirc%20R%20%3D%20R%20%5Ccirc%20R&quot; alt=&quot;{R^{n + 1}} = {R^n} \circ R = R \circ R&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;取&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20R&quot; alt=&quot;(a,b) \in R&quot; /&gt;，因为R是自反的，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28b%2Cb%29%20%5Cin%20R&quot; alt=&quot;(b,b) \in R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20R%20%5Ccirc%20R&quot; alt=&quot;(a,b) \in R \circ R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20%7BR%5E%7Bn%20%2B%201%7D%7D&quot; alt=&quot;(a,b) \in {R^{n + 1}}&quot; /&gt;，从而&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Csubseteq%20%7BR%5E%7Bn%20%2B%201%7D%7D&quot; alt=&quot;R \subseteq {R^{n + 1}}&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%3D%20%7BR%5E%7Bn%20%2B%201%7D%7D&quot; alt=&quot;R = {R^{n + 1}}&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;综上所述，对于所有的正整数，都有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5En%7D%7B%5Crm%7B%20%3D%20%7D%7DR&quot; alt=&quot;{R^n}{\rm{ = }}R&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 54&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1987-1.png&quot;&gt;&lt;img src=&quot;/user_images/1987-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 54&lt;/h2&gt;
&lt;p&gt;设题目中的集合为A&lt;/p&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;除了(2,3)和(4,5)，包含&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;中所有其它元素。&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;包含&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;中全部元素&lt;/p&gt;
&lt;h3&gt;c)&lt;/h3&gt;
&lt;p&gt;包含&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;中全部元素&lt;/p&gt;
&lt;h3&gt;d)&lt;/h3&gt;
&lt;p&gt;包含&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;中全部元素&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 55&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1990-1.png&quot;&gt;&lt;img src=&quot;/user_images/1990-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 55&lt;/h2&gt;
&lt;p&gt;用数学归纳法来证明。&lt;/p&gt;
&lt;p&gt;当n=1时，有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E1%7D%20%3D%20R&quot; alt=&quot;{R^1} = R&quot; /&gt;，显然成立。&lt;/p&gt;
&lt;p&gt;假设&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5En%7D&quot; alt=&quot;{R^n}&quot; /&gt;是自反的，则对于所有的&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=a%20%5Cin%20R&quot; alt=&quot;a \in R&quot; /&gt;都有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Ca%29%20%5Cin%20%7BR%5En%7D&quot; alt=&quot;(a,a) \in {R^n}&quot; /&gt;且&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Ca%29%20%5Cin%20R&quot; alt=&quot;(a,a) \in R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Ca%29%20%5Cin%20%7BR%5En%7D%20%5Ccirc%20R%20%3D%20%7BR%5E%7Bn%20%2B%201%7D%7D&quot; alt=&quot;(a,a) \in {R^n} \circ R = {R^{n + 1}}&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;所以对所有的正整数，&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5En%7D&quot; alt=&quot;{R^n}&quot; /&gt;都是自反的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 56&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1996-1.png&quot;&gt;&lt;img src=&quot;/user_images/1996-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;答案 56&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1996-3.png&quot;&gt;&lt;img src=&quot;/user_images/1996-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 56&lt;/h2&gt;
&lt;p&gt;此题留着以后证。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 57&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1993-1.png&quot;&gt;&lt;img src=&quot;/user_images/1993-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 57&lt;/h2&gt;
&lt;p&gt;不一定是。&lt;/p&gt;
&lt;p&gt;假设集合A={1,3}，关系R={(3,1),(1,3)}，显然它是反自反的，但&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;={(1,1),(3,3)}是自反的&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>7.1 关系及其性质 40 ~ 49</title>
                <link>http://freewind.in/posts/1920-7-1-relationship-40-42</link>
                <pubDate>Mon, 07 Jan 2013 22:23:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1920</guid>
                <description><![CDATA[&lt;h2&gt;题目 40-42&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1920-1.png&quot;&gt;&lt;img src=&quot;/user_images/1920-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1920-3.png&quot;&gt;&lt;img src=&quot;/user_images/1920-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1920-5.png&quot;&gt;&lt;img src=&quot;/user_images/1920-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 40-42&lt;/h2&gt;
&lt;h3&gt;40&lt;/h3&gt;
&lt;p&gt;A = { 0, 1 }&lt;/p&gt;
&lt;p&gt;则 A x A = { (0,0), (0,1), (1,0), (1,1) }&lt;/p&gt;
&lt;p&gt;共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E4%7D&quot; alt=&quot;{2^4}&quot; /&gt;共16种不同的关系：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Cemptyset%20&quot; alt=&quot;\emptyset &quot; /&gt;&lt;/li&gt;
&lt;li&gt;{ (0,0) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (0,1) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (1,0) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (0,1), (1,0) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (0,1), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (1,0), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (0,0), (0,1), (1,0), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (0,1) }&lt;/li&gt;
&lt;li&gt;{ (0,1), (1,0) }&lt;/li&gt;
&lt;li&gt;{ (0,1), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (0,1), (1,0), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (1,0) }&lt;/li&gt;
&lt;li&gt;{ (1,0), (1,1) }&lt;/li&gt;
&lt;li&gt;{ (1,1) }&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;41&lt;/h3&gt;
&lt;p&gt;8个。

### 42

自反的：5, 7, 8, 9

反自反的：1,10, 11, 14

对称的：1,2,5,6,9,11,13,16

反对称的：1,2,3,4,5,7,8,10,12,14,15,16

非对称的：1,10,14

传递的：1,2,3,4,5,7,8,9,10,12,14,15,16
&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 43&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1928-1.png&quot;&gt;&lt;img src=&quot;/user_images/1928-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 43&lt;/h2&gt;
&lt;p&gt;a) 共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7B4%5E2%7D%7D%7D&quot; alt=&quot;{2^{{4^2}}}&quot; /&gt;=65536个&lt;/p&gt;
&lt;p&gt;b) 共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7B4%5E2%7D%20-%201%7D%7D%20%3D%20%7B2%5E%7B15%7D%7D&quot; alt=&quot;{2^{{4^2} - 1}} = {2^{15}}&quot; /&gt;=32768个&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 44&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1933-1.png&quot;&gt;&lt;img src=&quot;/user_images/1933-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 44&lt;/h2&gt;
&lt;p&gt;a) S上共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%7D%7D&quot; alt=&quot;{2^{{n^2}}}&quot; /&gt;个关系。因为对于S上的关系来说，(a,b)有一半的机会出现，所以包含(a,b)的关系共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%20-%201%7D%7D&quot; alt=&quot;{2^{{n^2} - 1}}&quot; /&gt;个。&lt;/p&gt;
&lt;p&gt;b) 同上，共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%20-%201%7D%7D&quot; alt=&quot;{2^{{n^2} - 1}}&quot; /&gt;个&lt;/p&gt;
&lt;p&gt;c) 满足题意的关系，可看作是&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28S%20-%20%5C%7B%20a%5C%7D%20%29%20%5Ctimes%20S&quot; alt=&quot;(S - \{ a\} ) \times S&quot; /&gt;，故共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%28n%20-%201%29n%7D%7D&quot; alt=&quot;{2^{(n - 1)n}}&quot; /&gt;个关系&lt;/p&gt;
&lt;p&gt;d) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%7D%7D%20-%20%7B2%5E%7B%28n%20-%201%29n%7D%7D&quot; alt=&quot;{2^{{n^2}}} - {2^{(n - 1)n}}&quot; /&gt;个&lt;/p&gt;
&lt;p&gt;e) 满足题意的关系，可看作是&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28S%20-%20%5C%7B%20a%5C%7D%20%29%20%5Ctimes%20%28S%20-%20%5C%7B%20b%5C%7D%20%29&quot; alt=&quot;(S - \{ a\} ) \times (S - \{ b\} )&quot; /&gt;，故共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7B%7B%28n%20-%201%29%7D%5E2%7D%7D%7D&quot; alt=&quot;{2^{{{(n - 1)}^2}}}&quot; /&gt;个关系&lt;/p&gt;
&lt;p&gt;f) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%7D%7D%20-%20%7B2%5E%7B%7B%7B%28n%20-%201%29%7D%5E2%7D%7D%7D&quot; alt=&quot;{2^{{n^2}}} - {2^{{{(n - 1)}^2}}}&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 45&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1937-1.png&quot;&gt;&lt;img src=&quot;/user_images/1937-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 45&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;在一个对称的集合中，(a,b)和(b,a)总是成对出现，所以我们可以把它们当成一类，只考虑(a,b)出现的次数。&lt;/p&gt;
&lt;p&gt;设集合为A，则&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;中的元素共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7Bn%5E2%7D&quot; alt=&quot;{n^2}&quot; /&gt;个。其中(a,a)这样的有n个，(a,b)且a不等于b这样的元素有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7Bn%5E2%7D%20-%20n&quot; alt=&quot;{n^2} - n&quot; /&gt;个。因为对于每一个(a,b)，&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;都有一个(b,a)，如果我们只考虑其中一种，则有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28%7Bn%5E2%7D%20-%20n%29%2F2&quot; alt=&quot;({n^2} - n)/2&quot; /&gt;个。再加上(a,a)这样的，一共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28%7Bn%5E2%7D%20-%20n%29%2F2%20%2B%20n&quot; alt=&quot;({n^2} - n)/2 + n&quot; /&gt;个元素需要考虑。&lt;/p&gt;
&lt;p&gt;所以在A上，对称的关系的总个数为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%28%7Bn%5E2%7D%20-%20n%29%2F2%20%2B%20n%7D%7D&quot; alt=&quot;{2^{({n^2} - n)/2 + n}}&quot; /&gt;个。&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;将&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=A%20%5Ctimes%20A&quot; alt=&quot;A \times A&quot; /&gt;中的元素分为两类考虑，一类是全等关系&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BI_A%7D&quot; alt=&quot;{I_A}&quot; /&gt;中的元素，一类是(a,b)和(b,a)，其中a不等于b。&lt;/p&gt;
&lt;p&gt;对于&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BI_A%7D&quot; alt=&quot;{I_A}&quot; /&gt;，它可以出现，可以不出现，所以有两种情况。&lt;/p&gt;
&lt;p&gt;对于每对(a,b)与(b,a)，它们至多出现一个，所以有三种情况。&lt;/p&gt;
&lt;p&gt;综合起来，一共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5En%7D%7B3%5E%7B%28%7Bn%5E2%7D%20-%20n%29%2F2%7D%7D&quot; alt=&quot;{2^n}{3^{({n^2} - n)/2}}&quot; /&gt;个。&lt;/p&gt;
&lt;h3&gt;c)&lt;/h3&gt;
&lt;p&gt;非对称中不能出现(a,a)这样的元素，所以可考虑的元素个数为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28%7Bn%5E2%7D%20-%20n%29&quot; alt=&quot;({n^2} - n)&quot; /&gt;个。其中每对(a,b)与(b,a)中，每次至多只能出现其中一个，所以有3种情况。这样就有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B3%5E%7B%28%7Bn%5E2%7D%20-%20n%29%2F2%7D%7D&quot; alt=&quot;{3^{({n^2} - n)/2}}&quot; /&gt;个&lt;/p&gt;
&lt;h3&gt;d)&lt;/h3&gt;
&lt;p&gt;反自反关系中，不能出现(a,a)这样的元素，所以需考虑的元素个数为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7Bn%5E2%7D%20-%20n&quot; alt=&quot;{n^2} - n&quot; /&gt;个，关系总个数为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%20-%20n%7D%7D&quot; alt=&quot;{2^{{n^2} - n}}&quot; /&gt;个&lt;/p&gt;
&lt;h3&gt;e)&lt;/h3&gt;
&lt;p&gt;先不考虑(a,a)这样的元素，剩下的每两个(a,b)与(b,a)看作一组，则有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28%7Bn%5E2%7D%20-%20n%29%2F2&quot; alt=&quot;({n^2} - n)/2&quot; /&gt;个元素需要考虑。它们的关系总个数为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B_%7B%28%7Bn%5E2%7D%20-%20n%29%2F2%7D%7D%7D&quot; alt=&quot;{2^{_{({n^2} - n)/2}}}&quot; /&gt;个。然后在每个关系里加上&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BI_A%7D&quot; alt=&quot;{I_A}&quot; /&gt;，即满足要求。所以共&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B_%7B%28%7Bn%5E2%7D%20-%20n%29%2F2%7D%7D%7D&quot; alt=&quot;{2^{_{({n^2} - n)/2}}}&quot; /&gt;个。&lt;/p&gt;
&lt;h3&gt;f)&lt;/h3&gt;
&lt;p&gt;先不考虑&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BI_A%7D&quot; alt=&quot;{I_A}&quot; /&gt;，则元素个数为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7Bn%5E2%7D%20-%20n&quot; alt=&quot;{n^2} - n&quot; /&gt;个，关系个数为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%20-%20n%7D%7D&quot; alt=&quot;{2^{{n^2} - n}}&quot; /&gt;个。然后再考虑&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BI_A%7D&quot; alt=&quot;{I_A}&quot; /&gt;中的元素，除去全选和全不选的情况，配合前面的关系，就能满足题意。所以共有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7B2%5E%7B%7Bn%5E2%7D%20-%20n%7D%7D%20%5Ctimes%20%28%7B2%5En%7D%20-%202%29%7B%5Crm%7B%20%3D%20%7D%7D%7B%7B%5Crm%7B2%7D%7D%5E%7B%7Bn%5E2%7D%7D%7D%20-%20%7B2%5E%7B%7Bn%5E2%7D%20-%20n%20%2B%201%7D%7D&quot; alt=&quot;{2^{{n^2} - n}} \times ({2^n} - 2){\rm{ = }}{{\rm{2}}^{{n^2}}} - {2^{{n^2} - n + 1}}&quot; /&gt;个关系。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 46&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1944-1.png&quot;&gt;&lt;img src=&quot;/user_images/1944-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 46&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;当n=1时，集合上的关系总数为2个：空集和{{1,1}}，这两个都是传递的，所以有2个传递关系&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;用图的方式说明方便一些。一个图上有两个点a和b，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1944-3.png&quot;&gt;&lt;img src=&quot;/user_images/1944-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以分为三种情况考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A与B之间没有边。此时不论A与B上有没有环，都是传递的，所以4种2.  A与B之间有单边。从A到B或者从B到A，不论A与B上有没有环，都是传递的，所以有2&amp;#215;4=8种。3.  A与B之间有双边。此时只有A与B都有环，才是传递的，有1种。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;共有13种。&lt;/p&gt;
&lt;h3&gt;c)&lt;/h3&gt;
&lt;p&gt;如下图，有三个点A,B,C：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1944-5.png&quot;&gt;&lt;img src=&quot;/user_images/1944-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分多种情况考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有任何边。此时不论这三点上有没有环，都是传递的，所以有2x2x2共8种。      2.  有一条单边。共有6种单边，此时不论三点有没有环，都是传递的，有6&amp;#215;8=48种。3.  有一条双边。有3种双边。当两点间有双边时，此两点上都必须有环，另一点上有没有环都行。所以共有3&amp;#215;2=6种。4.  有两条单边。共有12种情况。其中有6种情况类似于(a,b),(b,c)，这时不论点上有没有环，都不是传递的。另外6种情况，不论点上有没有环，都是传递的。所以共有6&amp;#215;8=48种。5.  有两边双边。此时不论点上有没有环，都不是传递的。6.  有一条单边一条双边。此时不可能传递。&lt;/li&gt;
&lt;li&gt;有三条单边。共有8种情况。回路有2种，此时不是传递的。其它情况有6种，不论点上有没有环，都是传递的。所以共有6&amp;#215;8=48种。8.  有三条双边。此时只有三点上都有环，才是传递的，共有1种情况。9.  有一条单边，两条双边。都不是传递的。&lt;/li&gt;
&lt;li&gt;有一条双边，两条单边。分12种情况。其中当两条单边顺次相连（如(a,b),(b,c)），不论点上有没有环，都不是传递的，少了一半。其它6情况，双边的两点必须有环，另一点有没有环都一样传递。所以共6&amp;#215;2=12种。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，共有171种。&lt;/p&gt;
&lt;p&gt;不用程序来做会死人。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 47&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1947-1.png&quot;&gt;&lt;img src=&quot;/user_images/1947-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 47&lt;/h2&gt;
&lt;p&gt;有问题的地方在于这一句“取元素&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=b%20%5Cin%20A&quot; alt=&quot;b \in A&quot; /&gt;，使得&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20R&quot; alt=&quot;(a,b) \in R&quot; /&gt;”。因为对于A上的任意一个点，可能并不存在一个b使&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20R&quot; alt=&quot;(a,b) \in R&quot; /&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 48&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1950-1.png&quot;&gt;&lt;img src=&quot;/user_images/1950-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 48&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因为R是A上的自反关系，所以R包含了所有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Ccup%20S&quot; alt=&quot;R \cup S&quot; /&gt;包含了所有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;，所以它是自反的。&lt;/li&gt;
&lt;li&gt;因为R和S都是A上的自反关系，所以R和S都包含了所有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Ccap%20S&quot; alt=&quot;R \cap S&quot; /&gt;是自反的&lt;/li&gt;
&lt;li&gt;因为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Coplus%20S&quot; alt=&quot;R \oplus S&quot; /&gt;不包含它们的交集，所以不包含(x,x)，所以它是反自反的。&lt;/li&gt;
&lt;li&gt;因为R-S不包含它们的交集，所以不包含(x,x)，所以它是反自反的。&lt;/li&gt;
&lt;li&gt;因为R和S都是A上的自反关系，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=S%20%5Ccirc%20R&quot; alt=&quot;S \circ R&quot; /&gt;也包含所有的&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,x) \in R&quot; /&gt;，所以它也是自反的。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 49&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1971-1.png&quot;&gt;&lt;img src=&quot;/user_images/1971-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 49&lt;/h2&gt;
&lt;p&gt;若R是对称的，则对于&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20R&quot; alt=&quot;(a,b) \in R&quot; /&gt;，有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28b%2Ca%29%20%5Cin%20R&quot; alt=&quot;(b,a) \in R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;(a,b) \in {R^{ - 1}}&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Csubseteq%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;R \subseteq {R^{ - 1}}&quot; /&gt;。类似的，由于R是对称的，则&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;{R^{ - 1}}&quot; /&gt;也是对称的，可以求出&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D%20%5Csubseteq%20R&quot; alt=&quot;{R^{ - 1}} \subseteq R&quot; /&gt;，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%3D%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;R = {R^{ - 1}}&quot; /&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20R&quot; alt=&quot;(a,b) \in R&quot; /&gt;，有&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28b%2Ca%29%20%5Cin%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;(b,a) \in {R^{ - 1}}&quot; /&gt;。如果&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%3D%20%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;R = {R^{ - 1}}&quot; /&gt;，则&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28b%2Ca%29%20%5Cin%20R&quot; alt=&quot;(b,a) \in R&quot; /&gt;。所以R是对称的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>7.1 关系及其性质 31 ~ 39</title>
                <link>http://freewind.in/posts/1885-7-1-relationship-31</link>
                <pubDate>Mon, 07 Jan 2013 21:16:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1885</guid>
                <description><![CDATA[&lt;h2&gt;问题 31&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1885-1.png&quot;&gt;&lt;img src=&quot;/user_images/1885-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 31&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=S%20%5Ccirc%20R&quot; alt=&quot;S \circ R&quot; /&gt;&lt;/p&gt;
&lt;p&gt;{ (a,b) | a是b的父母，且b有一个兄弟姐妹 }&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=R%20%5Ccirc%20S&quot; alt=&quot;R \circ S&quot; /&gt;&lt;/p&gt;
&lt;p&gt;{ (a,b) |  a是b的姑姑舅舅 }&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 32&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1890-1.png&quot;&gt;&lt;img src=&quot;/user_images/1890-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1890-3.png&quot;&gt;&lt;img src=&quot;/user_images/1890-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 32&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a) R6&lt;/li&gt;
&lt;li&gt;b) R2&lt;/li&gt;
&lt;li&gt;c) R5&lt;em&gt;   d) 空集&lt;/em&gt;   e) 空集&lt;em&gt;   f) R5&lt;/em&gt;   g) R6*   h) R6&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 33&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1896-0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1896-2.png&quot;&gt;&lt;img src=&quot;/user_images/1896-2.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 33&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;b) R6&lt;/li&gt;
&lt;li&gt;c) R3&lt;/li&gt;
&lt;li&gt;d) R3&lt;/li&gt;
&lt;li&gt;e) 空集*   f) R1&lt;/li&gt;
&lt;li&gt;g) R4&lt;/li&gt;
&lt;li&gt;h) R4&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 34&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1893-0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1893-2.png&quot;&gt;&lt;img src=&quot;/user_images/1893-2.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 34&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a) R1&lt;em&gt;   b) R1&lt;/em&gt;   c) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;*   d) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;e) R1&lt;/li&gt;
&lt;li&gt;f) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;g) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;h) R3&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 35&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1899-0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1899-2.png&quot;&gt;&lt;img src=&quot;/user_images/1899-2.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 35&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a) R1&lt;/li&gt;
&lt;li&gt;b) R2&lt;/li&gt;
&lt;li&gt;c) R3&lt;/li&gt;
&lt;li&gt;d) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;e) R3&lt;/li&gt;
&lt;li&gt;f) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;g) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;li&gt;h) &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 36&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1902-1.png&quot;&gt;&lt;img src=&quot;/user_images/1902-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：双亲关系是指，a是b的父母&lt;/p&gt;
&lt;p&gt;中文题目有问题，英文为：&lt;/p&gt;
&lt;p&gt;Let R be the parent relation on the set of all people (see Example 21). When is an ordered pair in the relation &lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E3%7D&quot; alt=&quot;{R^3}&quot; /&gt; ?&lt;/p&gt;
&lt;p&gt;最后应该问：在什么情况下，&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E3%7D&quot; alt=&quot;{R^3}&quot; /&gt;里有有序对？&lt;/p&gt;
&lt;h2&gt;解答 36&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E3%7D&quot; alt=&quot;{R^3}&quot; /&gt;，三次双亲关系。我们要找一个人a，它有子女b，b有子女c，c有子女d，则(a,d)属于&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E3%7D&quot; alt=&quot;{R^3}&quot; /&gt;，d应该叫a祖爷爷、祖奶奶了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 37&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1905-1.png&quot;&gt;&lt;img src=&quot;/user_images/1905-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 37&lt;/h2&gt;
&lt;p&gt;若(a,b)在&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;中，则存在一个&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=c%20%5Cin%20R&quot; alt=&quot;c \in R&quot; /&gt;，使用a是c的导师，且c是b的导师。&lt;/p&gt;
&lt;p&gt;若(a,b)在&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5En%7D&quot; alt=&quot;{R^n}&quot; /&gt;中，则存在一个n+1的序列，其头为a，尾为b，其中每一个都是下一个的导师&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 38&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1911-1.png&quot;&gt;&lt;img src=&quot;/user_images/1911-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 38&lt;/h2&gt;
&lt;p&gt;注意是在正整数集上，所以不用考虑0的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a) {(a,b) | a整除b或者b整除a }&lt;/li&gt;
&lt;li&gt;b) {(a,a) | a=b }注：原答案为&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=a%20%3D%20%20%5Cpm%20b&quot; alt=&quot;a =  \pm b&quot; /&gt;或a不等于0。由于是在正整数集上，所以可简化为我的答案。&lt;/li&gt;
&lt;li&gt;c) {(a,b) | a整除b，但a不等于b }&lt;/li&gt;
&lt;li&gt;d) {(a,b) | a是b的倍数，但a不等于b}*   e) {(a,b) | a整除b或者b整除a，且a不等于b }&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 39&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1917-1.png&quot;&gt;&lt;img src=&quot;/user_images/1917-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 39&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a) a与b是模3同余或模4同余&lt;/li&gt;
&lt;li&gt;b) a与b模12同余&lt;/li&gt;
&lt;li&gt;c) a与b模3同余但不模12同余&lt;/li&gt;
&lt;li&gt;d) a与b模4同余但不模12同余&lt;/li&gt;
&lt;li&gt;e) a与b模3同余或模4同余，但不模12同余&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在博客上手写复杂数学公式? （MathJax）</title>
                <link>http://freewind.in/posts/1788-use-mathjax-to-write-complex-math-formulas-on-blog</link>
                <pubDate>Mon, 07 Jan 2013 15:47:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1788</guid>
                <description><![CDATA[&lt;p&gt;在伟大的&lt;a href=&quot;http://math.stackoverflow.com&quot;&gt;http://math.stackoverflow.com&lt;/a&gt;上提问的时候，发现人们使用一种奇怪的语法来写数学符号和公式，比如这句：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1788-1.png&quot;&gt;&lt;img src=&quot;/user_images/1788-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于我们来说，写那个“大于等于”和“属于”符号，是一件很困难的事。他们是怎么做的呢？看下源代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Relation $R$ is $xy\ge1$, and $x\in \mathbb{Z}$ and $y\in\mathbb{Z}$, is $R$ reflexive?

注意里面有很多以`$`包围起来的符号，以及用斜线开头的词，如`\in`。而显示的时候，它们就自动变成了美观的数学符号，这是怎么做的？

## MathJax和LaTeX

在[http://math.stackexchange.com/faq](http://math.stackexchange.com/faq)介绍了做法，原来使用了一个叫[MathJax](http://www.mathjax.org/)的js库来渲染，语法是一个类似于[LaTeX](http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm)的语法：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MathJax: &lt;a href=&quot;http://www.mathjax.org/&quot; title=&quot;http://www.mathjax.org/&quot;&gt;http://www.mathjax.org/&lt;/a&gt;*   LaTeX-like syntax: &lt;a href=&quot;http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm&quot; title=&quot;http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm&quot;&gt;http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了这两样，我们可以直接在文章中写公式，而不需要借助其它的工具。之前我用MathType，想把上面的公式弄到博客上，只能截图。又换了一种可以可以输入数学符号的输入法，但是要不断切换输入法，非常麻烦。Math.stackoverflow.com的这种方式非常好。&lt;/p&gt;
&lt;h2&gt;在博客上安装MathJax&lt;/h2&gt;
&lt;p&gt;如何在自己的博客上安装MathJax呢？过程比较简单。首先在下面的网址下载需要的js库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mathjax.org/download/&quot;&gt;http://www.mathjax.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大约为17.6M，有点大。它里面包含了很多东西，比如不同的语法，各种兼容什么的。解压后大得夸张，居然有133M，里面有3万多个文件！&lt;/p&gt;
&lt;p&gt;虽然不知道哪些要用哪些不需要，但为了保险，我还是把它们整个都传上去了。传3万多个文件太慢，所以我把整个压缩包上传上去，在服务端端解压，这样快了一下。&lt;/p&gt;
&lt;p&gt;这种方式对于很多人的博客不适用，毕竟133M太大了，可能博客空间也就两三百M。这时可使用由MathJax提供的另一种方式，直接使用它们的CDN，这样就不需要上传了，只在网页中增加一个js的引用即可，引用cdn中的文件。&lt;/p&gt;
&lt;p&gt;具体详情可参见：&lt;a href=&quot;http://docs.mathjax.org/en/latest/configuration.html&quot;&gt;http://docs.mathjax.org/en/latest/configuration.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;上传方式安装&lt;/h3&gt;
&lt;p&gt;如果选择的是上传到博客的方式来安装，可以这么做。&lt;/p&gt;
&lt;p&gt;首先把MathJax的zip上传到博客空间，通过服务端解压，把它们解压到自己的博客目录中，记下位置。&lt;/p&gt;
&lt;p&gt;然后在博客源代码中，添加以下代码（可添加在body的最后）：&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text /x-mathjax-config&quot;&gt;
&lt;br  /&gt;MathJax.Hub.Config({
&lt;br  /&gt;tex2jax: {inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\(&apos;,&apos;\)&apos;]]}
&lt;br  /&gt;});
&lt;br  /&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script type=&quot;text /javascript&quot; src=&quot;path-to-MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;注意，如果你想让它能解析以&lt;code&gt;$&lt;/code&gt;包起来的数学代码，则需要加上&lt;code&gt;Config&lt;/code&gt;那段。&lt;/p&gt;
&lt;h3&gt;CDN方式安装&lt;/h3&gt;
&lt;p&gt;不需要上传MathJax，只添加引用即可。&lt;/p&gt;
&lt;p&gt;&lt;script type=&quot;text /x-mathjax-config&quot;&gt;
&lt;br  /&gt;MathJax.Hub.Config({
&lt;br  /&gt;tex2jax: {inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&apos;\(&apos;,&apos;\)&apos;]]}
&lt;br  /&gt;});
&lt;br  /&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script type=&quot;text /javascript&quot;
&lt;br /&gt;src=&amp;ldquo;&lt;a href=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&quot;&gt;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;rdquo;&lt;/a&gt;&gt;
&lt;br  /&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;在博客中写上下面的代码，它表示&quot;q属于集合R&amp;rdquo;&lt;/p&gt;
&lt;p&gt;$ q \in R $&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一切正常，它会显示成：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1788-3.png&quot;&gt;&lt;img src=&quot;/user_images/1788-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面这个是截的图片，再来一个真实版：&lt;/p&gt;
&lt;p&gt;$ q \in R $&lt;/p&gt;
&lt;h2&gt;LaTeX语法&lt;/h2&gt;
&lt;p&gt;详细文档在这里：&lt;a href=&quot;http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm&quot;&gt;http://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我把常用的一些总结在这里&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;533&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;图片&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;MathJax效果&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-5.png &quot;image&quot;)](/user_images/1788-5.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\emptyset$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\emptyset`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-7.png &quot;image&quot;)](/user_images/1788-7.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$q \in R$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`q \in R`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-9.png &quot;image&quot;)](/user_images/1788-9.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$q \notin R$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`q \notin R`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-11.png &quot;image&quot;)](/user_images/1788-11.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$A \subseteq B$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`A \subseteq B`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-13.png &quot;image&quot;)](/user_images/1788-13.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$A \subset B$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`A \subset B`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-15.png &quot;image&quot;)](/user_images/1788-15.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-17.png &quot;image&quot;)](/user_images/1788-17.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-19.png &quot;image&quot;)](/user_images/1788-19.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-21.png &quot;image&quot;)](/user_images/1788-21.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-23.png &quot;image&quot;)](/user_images/1788-23.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-25.png &quot;image&quot;)](/user_images/1788-25.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-27.png &quot;image&quot;)](/user_images/1788-27.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\{x | x\in\Bbb Z\}$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\{x | x\in\Bbb Z\}`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-29.png &quot;image&quot;)](/user_images/1788-29.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\forall x$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\forall x`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-31.png &quot;image&quot;)](/user_images/1788-31.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\exists$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\exists`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-33.png &quot;image&quot;)](/user_images/1788-33.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\gt$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\gt`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\ge$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\ge`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\geq$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\geq`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\geqq$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\geqq`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-35.png &quot;image&quot;)](/user_images/1788-35.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\lnot$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;`\lnot`&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-37.png &quot;image&quot;)](/user_images/1788-37.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\lor$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;&lt;var&gt;`&lt;var&gt;\lor&lt;/var&gt;`&lt;/var&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;116&quot;&gt;[![image](/user_images/1788-39.png &quot;image&quot;)](/user_images/1788-39.png)&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;177&quot;&gt;$\land$&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;238&quot;&gt;&lt;var&gt;`&lt;var&gt;\land&lt;/var&gt;`&lt;/var&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;经过多次使用后，发现MathJax对于某些公式的显示有问题，比如&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E2%7D&quot; alt=&quot;{R^2}&quot; /&gt;，会显示得乱七八糟。看了一下math.stackoverflow.com，发现它修改了MathJax的代码以解决这些问题。但我拿不到这些代码，自己也不知道怎么修正，所以只能暂时不再使用这种方式。&lt;/p&gt;
&lt;p&gt;现在的做法是，使用最新的MathType 6.8，它支持把公式拖到Live writer，感觉还不错。唯一有点担心的是，它利用了google的chart api来产生图形，这个服务在国内不稳定（你懂的）。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>我在“自反”概念上栽了两个跟头</title>
                <link>http://freewind.in/posts/1778-my-mistakes-on-reflexive</link>
                <pubDate>Mon, 07 Jan 2013 13:10:14 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1778</guid>
                <description><![CDATA[&lt;p&gt;“自反”是关系中的第一个性质，应该也算是最简单的一个。没想到在做题的过程中，发现自己对它的理解出现了几处偏差，好在math.stackoverflow.com上得到了网友的大力帮助，终于明白了。特记录下来，以备后用。&lt;/p&gt;
&lt;h2&gt;自反的概念&lt;/h2&gt;
&lt;p&gt;英文：A relation R on a set A is called reflexive if (a, a) ∈ R for every element a ∈ A.&lt;/p&gt;
&lt;p&gt;中文：如果对每个元素a∈A有(a,a)∈R，那么集合A上的关系叫做自反的。&lt;/p&gt;
&lt;h3&gt;需要判断A中的每一个元素&lt;/h3&gt;
&lt;p&gt;不知怎么，我做题做着就把“A中的每一个元素”记成了“关系R的域中的每一个元素了”。&lt;/p&gt;
&lt;p&gt;比如这个题目：关系R是整数集上的关系，xy≥1是不是自反的？&lt;/p&gt;
&lt;p&gt;直接按定义来，可以看出(0,0)不满足R，但0却又是整数集中的一个元素，所以R不是自反的。&lt;/p&gt;
&lt;p&gt;但我开始只考虑关系R的域，则0不属于该域。而对于属于该域的元素x，(x,x)都属于R，所以我以为它是自反的。&lt;/p&gt;
&lt;p&gt;这个题目可参考我的提问：&lt;a href=&quot;http://math.stackexchange.com/questions/271638/relation-r-is-xy-ge1-and-x-in-mathbbz-and-y-in-mathbbz-is-r-ref&quot;&gt;http://math.stackexchange.com/questions/271638/relation-r-is-xy-ge1-and-x-in-mathbbz-and-y-in-mathbbz-is-r-ref&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;复杂的情况&lt;/h3&gt;
&lt;p&gt;关系R是所有网页组成的集合上的关系，如果所有访问过网页a的人也访问过网页b，则(a,b)∈R。问R是不是自反的。

显然如果一个网页a被人访问过，则访问过网页a的人自然也访问过a，所以(a,a)∈R。但是考虑另外一种情况：某个网页a从来没有被人访问过，那么(a,a)是否属于R呢？

把R用谓词表示出来：R={(x,y)|∀p(F(p,x)→F(p,y))}, 其中p∈P，P表示所有的人；而F(p,x)表示&quot;p访问过x&quot;

如果一个网页x从来没有被人访问过，则F(p,x)始终为假。由于前件为假，所以F(p,x)→F(p,y)始终为真，则(x,任意y)都属于R。这的确有点违反直觉。

所以对于任意网页x，不论它是否被访问过，(x,x)都属于R。所以这个关系是自反的。

我的提问：[http://math.stackexchange.com/questions/271923/is-it-reflexive-everyone-who-has-visited-web-page-a-has-also-visited-web-page-b](http://math.stackexchange.com/questions/271923/is-it-reflexive-everyone-who-has-visited-web-page-a-has-also-visited-web-page-b)

没想到这一个小小的自反概念，让我栽了两次跟头，概念一定要理解得深入彻底才行。数学在这里体现出了它的严谨性，一个定义，对于各种边界情况，它都能自圆其说，始终如一。
&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用graphviz画关系图</title>
                <link>http://freewind.in/posts/1745-use-graphviz-to-draw-relationship</link>
                <pubDate>Sun, 06 Jan 2013 13:48:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1745</guid>
                <description><![CDATA[&lt;p&gt;在学习离散数学“关系”一章时，需要画一个关系图，放到博客中。手画太麻烦，在群友致远的帮助下，找到了这个软件：graphviz，它可以用命令行的方式，生成美观的关系图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;官网：&lt;a href=&quot;http://www.graphviz.org&quot;&gt;http://www.graphviz.org&lt;/a&gt;&lt;em&gt;   下载：&lt;a href=&quot;http://www.graphviz.org/Download_windows.php&quot;&gt;http://www.graphviz.org/Download_windows.php&lt;/a&gt;，大约57.6M&lt;/em&gt;   一些文档&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.openfoundry.org/tw/foss-programs/8820-graphviz-&quot;&gt;http://www.openfoundry.org/tw/foss-programs/8820-graphviz-&lt;/a&gt;&lt;em&gt;   &lt;a href=&quot;http://blog.163.com/prevBlogPerma.do?host=lockriver&amp;amp;srl=487232242010101761749383&amp;amp;mode=prev&quot;&gt;http://blog.163.com/prevBlogPerma.do?host=lockriver&amp;amp;srl=487232242010101761749383&amp;amp;mode=prev&lt;/a&gt;&lt;/em&gt;   &lt;a href=&quot;http://hi.baidu.com/yc0576/item/5ccdb10da5bd2ece9157186c&quot;&gt;http://hi.baidu.com/yc0576/item/5ccdb10da5bd2ece9157186c&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;dot&lt;/h2&gt;
&lt;p&gt;graphviz中包含一种名为&lt;code&gt;dot&lt;/code&gt;的语言，专门用来定义关系。我们必须先在某个文件中写上代码，最后调用命令行生成。没有找到可边写边改的集成环境。&lt;/p&gt;
&lt;p&gt;关于dot的具体语法参看官方文档，这里就不多说。这里仅用来入门。&lt;/p&gt;
&lt;h2&gt;简单例子&lt;/h2&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;从集合A到集合B的关系，代码如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;digraph G {
    {a b c} -&amp;gt; {d e f}
}

保存在simple.gr文件中（文件名任选）。

### 生成图片

命令行

dot -Tpng -o simple.png simple.gr

读取simple.gr文件，以png格式将生成的图像保存到simple.png文件中

### 效果图

[![image](/user_images/1745-1.png &quot;image&quot;)](/user_images/1745-1.png)

## 带中文的复杂例子

graphviz默认情况下对中文支持不好，如果代码中有中文，则必须使用UTF-8的格式保存文件，并且在代码中指定字体。

### 代码

把下列代码保存在`1.txt`文件中。

digraph G {
         edge[fontname = &quot;STHUPO&quot;];
         node[peripheries= 2 , fontname = &quot;STHUPO&quot;]
         size= &quot;16,16&quot;;
         main[shape = box]; //标记 
         main[label = &quot;从这里开始&quot;]
         main-&amp;gt; parse [weight = 8] 
         parse-&amp;gt; execute;
         main-&amp;gt; init [style = dotted];
         main-&amp;gt; cleanup;
         execute-&amp;gt; {make_string;printf;}
         edge[color = red];
         init-&amp;gt; make_string[label = &quot;1000次的感动&quot;];
         main-&amp;gt; printf[label = &quot;make a \n string&quot;];

         node[shape = box,style = filled, color = &quot;.7 .3 1.0&quot;];
         execute-&amp;gt; compare;
}

注意一定要保存为`UTF-8`的格式，否则里面的中文会变成乱码！

还要注意里面有一行用来指定字体名，否则也无法正常显示中文：

node[peripheries= 2 , fontname = &quot;STHUPO&quot;] 

### 生成图片

命令行：

dot -Tpng -o 1.png 1.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表示使用文件&lt;code&gt;1.txt&lt;/code&gt;中的指令，以&lt;code&gt;png&lt;/code&gt;格式，把生成的图像写到&lt;code&gt;1.png&lt;/code&gt;这个文件中。&lt;/p&gt;
&lt;h3&gt;效果&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1745-3.png&quot;&gt;&lt;img src=&quot;/user_images/1745-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里的中文有点难看，下面修正它。&lt;/p&gt;
&lt;h2&gt;Windows中的字体&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新細明體：PMingLiU&lt;em&gt;   細明體：MingLiU&lt;/em&gt;   標楷體：DFKai-SB&lt;em&gt;   黑体：SimHei&lt;/em&gt;   宋体：SimSun&lt;em&gt;   新宋体：NSimSun&lt;/em&gt;   仿宋：FangSong&lt;em&gt;   楷体：KaiTi&lt;/em&gt;   仿宋_GB2312：FangSong_GB2312&lt;em&gt;   楷体_GB2312：KaiTi_GB2312&lt;/em&gt;   微軟正黑體：Microsoft JhengHei*   微软雅黑体：Microsoft YaHei&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;换个字体试试&lt;/h3&gt;
&lt;p&gt;将上例中的字体换一个，比如微软雅黑，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1745-5.png&quot;&gt;&lt;img src=&quot;/user_images/1745-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然不一样了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在Idea中编辑Play2的模板，有很多无用的错误提示，怎么回事？</title>
                <link>http://freewind.in/posts/1738-why-there-are-many-useless-error-hints-when-editing-play2-templates-with-idea</link>
                <pubDate>Sun, 06 Jan 2013 11:46:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1738</guid>
                <description><![CDATA[&lt;h2&gt;老高问&lt;/h2&gt;
&lt;p&gt;你在IDEA下面编辑Play2的模板，会遇到很多无用的错误提示吗？因为不是合法的HTML。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1738-1.png&quot;&gt;&lt;img src=&quot;/user_images/1738-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么 &lt;!DOCTYPE html&gt; 也提示 Unexpected tokens 呢。&lt;/p&gt;
&lt;h2&gt;老高答&lt;/h2&gt;
&lt;p&gt;原来我Windows下面没装play2插件，只有idea自带的playframework support。idea自带的playframework support只支持play1，而在play1中,@符号有特殊的作用（用于产生url），编辑器会做特别的检查，所以才会提示Unexpected tokens。&lt;/p&gt;
&lt;p&gt;装上play2的插件就解决了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何解决Windows下 IDEA 中文字体显示为方框的问题的</title>
                <link>http://freewind.in/posts/1733-solve-the-problem-that-idea-show-strange-square-instead-of-chinese-character-on-windows</link>
                <pubDate>Sun, 06 Jan 2013 11:29:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1733</guid>
                <description><![CDATA[&lt;h2&gt;老高问&lt;/h2&gt;
&lt;p&gt;请教下大家是怎么解决Windows下 IDEA 中文字体显示为方框的问题的？（先声明：我对Windows下的宋体完全无爱）&lt;/p&gt;
&lt;p&gt;默认情况下代码编辑器内可以正常显示中文，但某些窗口，比如Message，Make，比如“配置对话框”，中文显示为方框。我试过改Console Font，也试过在IDEA用的&lt;code&gt;jre/lib/fonts&lt;/code&gt;下增加fallback，都没效果。&lt;/p&gt;
&lt;p&gt;Make输出后来想了想可能是javac返回给IDEA的，所以通过Compiler Properties增加参数 &lt;code&gt;-Duser.language=en -Duser.country=US -Duser.variant=US -Duser.region=US&lt;/code&gt; 搞定了（改成输出英文）。但界面上其他中文显示为方框的问题，常规途径似乎无效。&lt;/p&gt;
&lt;h2&gt;老高答&lt;/h2&gt;
&lt;p&gt;搞定了。一定要 &lt;code&gt;override default fonts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1733-1.png&quot;&gt;&lt;img src=&quot;/user_images/1733-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里才是全局，一开始这些都是方块。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>7.1 关系及其性质 21 ~ 30</title>
                <link>http://freewind.in/posts/1727-7-1-relationship-21</link>
                <pubDate>Sat, 05 Jan 2013 22:54:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1727</guid>
                <description><![CDATA[&lt;h2&gt;问题 21&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1727-1.png&quot;&gt;&lt;img src=&quot;/user_images/1727-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 21&lt;/h2&gt;
&lt;p&gt;$ \forall x \forall y((x,y) \in R \to (y,x) \notin R) $&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 22&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1724-1.png&quot;&gt;&lt;img src=&quot;/user_images/1724-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 22&lt;/h2&gt;
&lt;p&gt;一般用于比较的关系，如“A比B高”，“A比B跑得快”等，满足非自反关系。注意，比较中不可以包含“相等”关系，“A比B高或者跟B一般高”不是非对称。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 23&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1721-1.png&quot;&gt;&lt;img src=&quot;/user_images/1721-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 23&lt;/h2&gt;
&lt;p&gt;$A \times B$产生的集合中，共有 m*n 个元素。使用这些元素中的任意个组成的集合，都是满足题意的关系，所以一共有 ${2^{mn}}$个不同的关系。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 24&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1855-1.png&quot;&gt;&lt;img src=&quot;/user_images/1855-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 24&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D%20%3D%20%5C%7B%20%28a%2Cb%29%7C%28b%2Ca%29%20%5Cin%20R%5C%7D%20%20%3D%20%5C%7B%20%28a%2Cb%29%7Ca%20%3E%20b%5C%7D%20&quot; alt=&quot;{R^{ - 1}} = \{ (a,b)|(b,a) \in R\}  = \{ (a,b)|a &amp;gt; b\} &quot; /&gt;&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Cbar%20R%20%3D%20%5C%7B%20%28a%2Cb%29%7C%28b%2Ca%29%20%5Cnotin%20R%5C%7D%20%20%3D%20%5C%7B%20%28a%2Cb%29%7Ca%20%5Cge%20b%5C%7D%20&quot; alt=&quot;\bar R = \{ (a,b)|(b,a) \notin R\}  = \{ (a,b)|a \ge b\} &quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 25&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1859-1.png&quot;&gt;&lt;img src=&quot;/user_images/1859-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;答案 25&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;{ (a,b) | b整除a }&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;{ (a,b) | a不能整除b}&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 26&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1863-1.png&quot;&gt;&lt;img src=&quot;/user_images/1863-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;答案 26&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;因为R显然是对称的，所以&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR%5E%7B%20-%201%7D%7D&quot; alt=&quot;{R^{ - 1}}&quot; /&gt;=R&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;若&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cin%20%5Coverline%20R%20&quot; alt=&quot;(a,b) \in \overline R &quot; /&gt;，则&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28a%2Cb%29%20%5Cnotin%20R&quot; alt=&quot;(a,b) \notin R&quot; /&gt;，即a与b不相邻&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 27&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1867-1.png&quot;&gt;&lt;img src=&quot;/user_images/1867-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 27&lt;/h2&gt;
&lt;p&gt;没有学函数，暂时不回答&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 28&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1870-1.png&quot;&gt;&lt;img src=&quot;/user_images/1870-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 28&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR_1%7D%20%5Ccup%20%7BR_2%7D%20%3D%20%7BR_2%7D&quot; alt=&quot;{R_1} \cup {R_2} = {R_2}&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%7BR_1%7D%20%5Ccap%20%7BR_2%7D%20%3D%20%7BR_1%7D&quot; alt=&quot;{R_1} \cap {R_2} = {R_1}&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;c)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Cemptyset%20&quot; alt=&quot;\emptyset &quot; /&gt;&lt;/p&gt;
&lt;h3&gt;d)&lt;/h3&gt;
&lt;p&gt;{(1,1), (2,1), (2,2), (3,1), (3,2), (3,3)}&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 29&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1878-1.png&quot;&gt;&lt;img src=&quot;/user_images/1878-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 29&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;a)  { (a,b) | 学生a需要或已经读过书b}&lt;/li&gt;
&lt;li&gt;b) { (a,b) | 学生a需要并且读过书b}&lt;/li&gt;
&lt;li&gt;c) { (a,b) | 学生a需要书b但没读过，或者读过书b但不需要}&lt;/li&gt;
&lt;li&gt;d) { (a,b) | 学生a需要书b但没读过}&lt;/li&gt;
&lt;li&gt;e) { (a,b) | 学生a读过书b，但不需要 }&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 30&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1882-1.png&quot;&gt;&lt;img src=&quot;/user_images/1882-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 30&lt;/h2&gt;
&lt;p&gt;{ (1,1), (1,2), (2,1), (2,2) }&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>7.1 关系及其性质 13 ~ 20</title>
                <link>http://freewind.in/posts/1707-7-1-relationship-13</link>
                <pubDate>Sat, 05 Jan 2013 22:50:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1707</guid>
                <description><![CDATA[&lt;h2&gt;问题 13&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1707-1.png&quot;&gt;&lt;img src=&quot;/user_images/1707-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 13&lt;/h2&gt;
&lt;p&gt;可能，比如对于集合A={1,2}，则关系R={(1,1)}，即不是自反的，也不是反自反的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 14&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1730-1.png&quot;&gt;&lt;img src=&quot;/user_images/1730-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 14&lt;/h2&gt;
&lt;h3&gt;反自反的定义&lt;/h3&gt;
&lt;p&gt;如果对于每个$a \in R$，有$(a,a) \notin R$，那么集合A上的关系R是反自反的，即如果没有A中的元素与自己有关系，关系R就是反自反的。&lt;/p&gt;
&lt;h3&gt;量词&lt;/h3&gt;
&lt;p&gt;$ \forall x ((x,x) \notin R)$&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 15&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1710-1.png&quot;&gt;&lt;img src=&quot;/user_images/1710-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 15&lt;/h2&gt;
&lt;p&gt;一般用于比较的关系，如“A比B高”，“A比B跑得快”等，满足反自反关系。另外，比较中可以包含“相等”关系，“A比B高或者跟B一般高”。&lt;/p&gt;
&lt;h2&gt;问题 16 ~ 19&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1715-1.png&quot;&gt;&lt;img src=&quot;/user_images/1715-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1715-3.png&quot;&gt;&lt;img src=&quot;/user_images/1715-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 16 ~ 19&lt;/h2&gt;
&lt;p&gt;“非对称(&lt;strong&gt;asymmetric&lt;/strong&gt;)”与“反对称(&lt;strong&gt;irreflexive&lt;/strong&gt;)”有区别。“反对称”中可以存在(x,x)，但非对称中不能。&lt;/p&gt;
&lt;h3&gt;16.&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1715-5.png&quot;&gt;&lt;img src=&quot;/user_images/1715-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只有d是非对称的&lt;/p&gt;
&lt;h3&gt;17.&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1715-7.png&quot;&gt;&lt;img src=&quot;/user_images/1715-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只有a是非对称的&lt;/p&gt;
&lt;h3&gt;18.&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1715-9.png&quot;&gt;&lt;img src=&quot;/user_images/1715-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四个都不是非对称。&lt;/p&gt;
&lt;p&gt;b中，如果网页a上没有链接，则(a,a)没有公共链接，属于R。所以不是“非对称”&lt;/p&gt;
&lt;h3&gt;19.&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1715-11.png&quot;&gt;&lt;img src=&quot;/user_images/1715-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全都不是“非对称”。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 20&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1718-1.png&quot;&gt;&lt;img src=&quot;/user_images/1718-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 20&lt;/h2&gt;
&lt;p&gt;非对称的关系一定是反对称的。反对称的关系不一定是非对称的。&lt;/p&gt;
&lt;p&gt;非对称的定义：&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Cforall%20x%5Cforall%20y%28%28x%2Cy%29%20%5Cin%20R%20%5Cto%20%28y%2Cx%29%20%5Cnotin%20R%29&quot; alt=&quot;\forall x\forall y((x,y) \in R \to (y,x) \notin R)&quot; /&gt;&lt;/p&gt;
&lt;p&gt;反对称的定义：&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%5Cforall%20x%5Cforall%20y%28%28x%2Cy%29%20%5Cin%20R%20%5Cwedge%20%28y%2Cx%29%20%5Cin%20R%20%5Cto%20x%20%3D%20y%29&quot; alt=&quot;\forall x\forall y((x,y) \in R \wedge (y,x) \in R \to x = y)&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果一个关系是非对称的，则&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cy%29%20%5Cin%20R%20%5Cwedge%20%28y%2Cx%29%20%5Cin%20R&quot; alt=&quot;(x,y) \in R \wedge (y,x) \in R&quot; /&gt;为false。则&lt;img src=&quot;http://chart.apis.google.com/chart?cht=tx&amp;amp;chs=1x0&amp;amp;chf=bg,s,FFFFFF00&amp;amp;chco=000000&amp;amp;chl=%28x%2Cy%29%20%5Cin%20R%20%5Cwedge%20%28y%2Cx%29%20%5Cin%20R%20%5Cto%20x%20%3D%20y&quot; alt=&quot;(x,y) \in R \wedge (y,x) \in R \to x = y&quot; /&gt;的前件为假，故命题为真。所以它也是“反对称的”。&lt;/p&gt;
&lt;p&gt;但反过来，一个关系是反对称的，则(x,x)可以存在关系中，而它不满足非对称的定义，所以不是非对称的。实际上，一个关系是非对称时，当且仅当它即是反对称又是反自反。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>7.1 关系及其性质 01 ~ 12</title>
                <link>http://freewind.in/posts/1678-7-1-relationship-01</link>
                <pubDate>Sat, 05 Jan 2013 22:43:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1678</guid>
                <description><![CDATA[&lt;h2&gt;题目 01&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1678-1.png&quot;&gt;&lt;img src=&quot;/user_images/1678-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 01&lt;/h2&gt;
&lt;h3&gt;a) a等于b&lt;/h3&gt;
&lt;p&gt;{ (0,0), (1,1), (2,2), (3,3) }&lt;/p&gt;
&lt;h3&gt;b) a与b的和为4&lt;/h3&gt;
&lt;p&gt;{ (1,3), (2,2), (3,1), (4,0) }&lt;/p&gt;
&lt;h3&gt;c) a大于b&lt;/h3&gt;
&lt;p&gt;{ (1,0), (2,0), (2,1), (3,0), (3,1), (3,2), (4,0), (4,1), (4,2), (4,3) }&lt;/p&gt;
&lt;h3&gt;d) a整除b&lt;/h3&gt;
&lt;p&gt;a不可为0，b可为0.&lt;/p&gt;
&lt;p&gt;{ (1,0), (1,1), (1,2), (1,3), (2,0), (2,2), (3,0), (4,0) }&lt;/p&gt;
&lt;h3&gt;e) a与b的最大公约数为1&lt;/h3&gt;
&lt;p&gt;gcd: greatest common divisor，最大公约数&lt;/p&gt;
&lt;p&gt;定义：如果有一个自然数a能被自然数b整除，则称a为b的倍数，b为a的约数。几个自然数公有的约数，叫做这几个自然数的公约数。公约数中最大的一个公约数，称为这几个自然数的最大公约数。&lt;/p&gt;
&lt;p&gt;在离散数学中，“自然数”包括0和正整数。&lt;/p&gt;
&lt;p&gt;0与1的最大公约数为1。因为1的最大约数为1，它又能整除0。&lt;/p&gt;
&lt;p&gt;{ (0,1), (1,0), (1,1), (1,2), (1,3), (2,1), (2,3), (3,1), (3,2), (4,1), (4,3) }&lt;/p&gt;
&lt;h3&gt;f) a与b的最小公倍数为2&lt;/h3&gt;
&lt;p&gt;lcm: Least Common Multiple，最小公倍数&lt;/p&gt;
&lt;p&gt;{ (1,2), (2,1), (2,2) }&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 02&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1681-1.png&quot;&gt;&lt;img src=&quot;/user_images/1681-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;例4是什么样的&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1681-3.png&quot;&gt;&lt;img src=&quot;/user_images/1681-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 02&lt;/h2&gt;
&lt;h3&gt;a) 集合表示法&lt;/h3&gt;
&lt;p&gt;{ (1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (2,2), (2,4), (2,6), (3,3), (3,6), (4,4), (5,5), (6,6)  }&lt;/p&gt;
&lt;h3&gt;b) 图表示法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1681-5.png&quot;&gt;&lt;img src=&quot;/user_images/1681-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;c) 矩阵&lt;/h3&gt;
&lt;p&gt;&lt;p&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;350&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;R&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&quot;middle&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 03&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1684-1.png&quot;&gt;&lt;img src=&quot;/user_images/1684-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 03&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自反&lt;/strong&gt;&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;：有(2,4)，没有(4,2)&lt;/em&gt;   不是&lt;strong&gt;反对称&lt;/strong&gt;：因为存在对称点(2,3),(3,2)&lt;em&gt;   &lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自反&lt;/strong&gt;&lt;em&gt;   &lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;strong&gt;   不是&lt;/strong&gt;反对称*&lt;em&gt;:因为存在对称点(1,2)与(2,1)&lt;/em&gt;   &lt;strong&gt;传递&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;c)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不是&lt;strong&gt;自反&lt;/strong&gt;:缺少(1,1),(2,2),(3,3)和(4.4)&lt;em&gt;   &lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;strong&gt;   不是&lt;/strong&gt;反对称*&lt;em&gt;:因为存在对称点(2,4)和(4,2)&lt;/em&gt;   不是&lt;strong&gt;传递&lt;/strong&gt;:存在(2,4)和(4,2)，但不存在(2,2)及(4,4)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;d)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不是&lt;strong&gt;自反&lt;/strong&gt;:缺少(1,1),(2,2),(3,3),(4,4)&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;:有(1,2)，但没有(2,1)&lt;/em&gt;   &lt;strong&gt;反对称&lt;/strong&gt;&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*:有(1,2)和(2,3)，但没有(1,3)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;e)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自反&lt;/strong&gt;&lt;em&gt;   &lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;strong&gt;   &lt;/strong&gt;反对称*&lt;strong&gt;   &lt;/strong&gt;传递**&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;f)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不是&lt;strong&gt;自反&lt;/strong&gt;:缺少(1,1)、(2,2)、(3,3)、(4,4)&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;:有(1,4)，但没有(4,1)&lt;/em&gt;   不是&lt;strong&gt;反对称&lt;/strong&gt;:存在对称点(1,3)和(3,1)&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*:有(1,3)和(3,1)，但没有(1,1)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 04&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1687-1.png&quot;&gt;&lt;img src=&quot;/user_images/1687-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 04&lt;/h2&gt;
&lt;h3&gt;a) a比b高&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是“反对称”，“传递”*   不是“自反”，“对称”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;b) a和b生在同一天&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是“自反”，“对称”，“传递”*   不是“反对称”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;c) a和b同名&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是“自反”，“对称”，“传递”*   不是“反对称”&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;d) a和b有共同的祖父母&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是“自反”，“对称”，“传递”*   不是“反对称”&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 05&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1690-1.png&quot;&gt;&lt;img src=&quot;/user_images/1690-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 05&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;关键在于“每个”两字，可以理解为“所有”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是&lt;strong&gt;自反&lt;/strong&gt;的，因为访问了a的人也同时访问了a&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;的，因为不是每一个访问了b的人，都会访问a&lt;/em&gt;   不是&lt;strong&gt;反对称&lt;/strong&gt;的，因为访问了(a,b)的人，有可能访问(b,a)，也有可能不访问(b,a)&lt;em&gt;   是&lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*的，因为如果所有访问了a的人都访问了b，所有访问了b的人都访问了c，则所有访问了a的人都访问了c&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#000000&quot;&gt;不是&lt;strong&gt;自反&lt;/strong&gt;的，因为如果一个网页a上有链接，则a与a有公共链接，显然(a,a)不属于R&lt;/font&gt;&lt;em&gt;   是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;的，因为a与b没有公共链接的话，则b与a必然没有公共链接&lt;/em&gt;   不是&lt;strong&gt;反对称&lt;/strong&gt;的&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*的，因为(a,b)没有公共链接，(b,a)也没有公共链接，但是(a,a)有公共链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;c)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;strike&gt;是&lt;strong&gt;自反&lt;/strong&gt;的，因为若a与b上至少有一条公共链接，则a与b上都至少有一条链接。a与a之间，也至少有一条公共链接，属于R &lt;/strike&gt;如果某个网页a上没有链接，则“a与a至少有一条公共链接”不成立，则(a,a)不属于R，所以不是自反的。我之前误解了“自反”的概念。&lt;/font&gt;&lt;em&gt;   是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;的，若a与b上至少有一条公共链接，则b与a上至少有一条公共链接&lt;/em&gt;   不是&lt;strong&gt;反对称&lt;/strong&gt;的&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*的，若(a,b)和(b,c)都属于R，但a与b的公共链接跟b与c的公共链接不相同，(a,c)有可能不属于R&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;d)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strike&gt;&lt;font color=&quot;#000000&quot;&gt;是&lt;strong&gt;自反&lt;/strong&gt;的，若存在一个网页包含了到a与b的链接，则该网页包含到a与a的链接，即(a,a)属于R&lt;/font&gt;&lt;/strike&gt;对于“所有网页来说”，对于某一个网页a来说，可能不存在一个网页包含了到它的链接，则(a,a)不存于R，所以不是自反的。我之前理解错了“自反”的定义。&lt;em&gt;   是&lt;/em&gt;&lt;em&gt;对称&lt;/em&gt;&lt;em&gt;的，若存在一个网页包含了到a与b的链接，则必然包含了到b与a的链接，即(b,a)属于R&lt;/em&gt;   不是&lt;strong&gt;反对称&lt;/strong&gt;的&lt;em&gt;   不是&lt;/em&gt;&lt;em&gt;传递&lt;/em&gt;*的，可能有一个网页包含了到a与b的链接，另一个网页包含了到b与c的链接，但没有网页包含到a与c的链接。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;问题 06&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1693-1.png&quot;&gt;&lt;img src=&quot;/user_images/1693-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 06&lt;/h2&gt;
&lt;h3&gt;a) x+y=0&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1,1)∉R，所以不是自反的&lt;em&gt;   因为x+y=0，所以y+x=0，即(y,x)∈R，所以是对称的&lt;/em&gt;   因为存在对称点(x,y)，且x≠y，所以R不是反对称的*   因为(1,-1)∈R，(-1,1)∈R，但(1,1)∉R，所以不是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;b) x=±y&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为(x,x)满足x=±y，所以是自反的&lt;em&gt;   因为x=±y，所以y=±x，所以(y,x)∈R，所以是对称的&lt;/em&gt;   因为存在对称点(x,y)，且x≠y，所以R不是反对称的*   若(x,y)∈R且(y,z)∈R，因为x=±y=±z，所以(x,z)∈R，所以是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;c) x-y是有理数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为x-x=0是有理数，所以(x,x)∈R，所以R是自反的&lt;em&gt;   如果x-y是有理数，则y-x=-(x-y)也是有理数，所以是对称的&lt;/em&gt;   因为存在对称点(x,y)，且x≠y，所以R不是反对称的*   如果(x,y)∈R且(y,z)∈R，则x-y和y-z都是有理数，则它们的和(x-y+y-z)=x-z也是有理数，所以是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;d) x=2y&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1,1)∉R，所以不是自反的&lt;em&gt;   因为(4,2)∈R，但(2,4)∉R，所以不是对称的&lt;/em&gt;   若(x,y)∈R，则x=2y，则y=x/2。如果要让(y,x)∈R，则x/2=2x，只能x=0，则y=x=0。所以不是反对称的*   若(x,y)∈R且(y,z)∈R，则x=2y=4z，所以(x,z)∉R。所以不是传递的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;e) xy≥0&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为x&lt;em&gt;x≥0，所以(x,x)∈R，所以是自反的&lt;/em&gt;   若(x,y)∈R，则yx=xy≥0，所以是对称的&lt;em&gt;   因为(2,3)和(3,2)都属于R，所以R不是反对称的&lt;/em&gt;   因为(2,0)和(0,-1)属于R，但(2,-1)不属于R，所以不是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;f) xy=0&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(1,1)不属于R，所以不是自反的&lt;em&gt;   若(x,y)属于R，即xy=0，则yx=0，即(y,x)也属于R，所以是对称的&lt;/em&gt;   因为(4,0)和(0,4)都属于R，所以不是反对称的*   因为(4,0)和(0,4)都属于R，但(4,4)不属于R，所以R不是传递的&lt;/p&gt;
&lt;h3&gt;g) x=1&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(2,2)不属于R，所以不是自反的&lt;em&gt;   (1,2)属于R，但(2,1)不属于R，所以不是对称的&lt;/em&gt;   若(x,y)和(y,x)都属于R，则x=y=1，所以是反对称的*   若(x,y)和(y,z)都属于R，则x=y=z=1，所以R是传递的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;h) x=1或y=1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(2,2)不属于R，所以不是自反的&lt;em&gt;   若(x,y)属于R，则x=1，所以(y,x)属于R，所以是对称的&lt;/em&gt;   因为(1,2)和(2,1)都属于R，所以不是反对称的*   因为(3,1)和(1,2)都属于R，但(3,2)不属于R，所以不是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 07&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1696-1.png&quot;&gt;&lt;img src=&quot;/user_images/1696-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 08&lt;/h2&gt;
&lt;h3&gt;a) x≠y&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1,1)∉R，所以不是自反的&lt;em&gt;   则x不等于y，则y不等于x，所以是对称的&lt;/em&gt;   因为(2,3)和(3,2)都属于R，所以不是反对称的*   因为(2,3)和(3,2)都属于R，但(2,2)不属于R，所以不是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;b) xy≥1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#000000&quot;&gt;&lt;strike&gt;显然R的域中不包含0，则x&lt;em&gt;x大于等于1，则(x,x)属于R，所以是自反的&lt;/strike&gt;0是整数，但(0,0)不满足xy≥1，所以(0,0)∈R，所以不是自反的&lt;/font&gt;&lt;/em&gt;   若xy大于等于1，则yx大于等于1，所以是对称的&lt;em&gt;   因为(1,2)和(2,1)都属于R，所以不是反对称的&lt;/em&gt;   若xy大于等于1，且x,y都为整数，则x和y同号并且绝对值最小为1。若(x,y)和(y,z)都属于R，则x与y同号，y与z同号，所以x和z同号且最小值为1，所以x*z大于等于1，所以(x,z)也属于R。所以是传递的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在做这个题的时候，我开始认为它是自反的，怎么都想不明白。后来在stackoverflow上网友的帮助下，才明白我对自反的概念理解错了。&lt;/p&gt;
&lt;p&gt;自反的概念：A relation R on a set A is called reflexive if (a, a) ∈ R for every element a ∈ A，即对集合中&lt;strong&gt;所有的元素&lt;/strong&gt;都有(a,a)属于R。&lt;/p&gt;
&lt;p&gt;我之前理解成了，对于属于R的域中的每一个元素a都有(a,a)属于R。&lt;/p&gt;
&lt;p&gt;这是提问：&lt;a href=&quot;http://math.stackexchange.com/questions/271638/reloation-r-is-xy1-and-xz-and-yz-is-r-reflexive&quot;&gt;http://math.stackexchange.com/questions/271638/reloation-r-is-xy1-and-xz-and-yz-is-r-reflexive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从提问到得到答案只花了2分钟，太靠谱了！&lt;/p&gt;
&lt;h3&gt;c) x=y+1或x=y-1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(1,1)不属于R，所以不是自反的&lt;em&gt;   若(x,y)属于R，则x=y+1或y-1。则y=x-1或x+1，所以(y,x)也属于R。所以是对称的&lt;/em&gt;   因为(2,1)和(1,2)都属于R，所以不是反自反的*   因为(2,1)和(1,2)都属于R，但(2,2)不属于R，所以不是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;d) x≡y(mod 7)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为x与x模7同余，所以是自反的&lt;em&gt;   因为x与y模7同余，所以y与x模7同余，所以是对称的&lt;/em&gt;   因为(0,7)和(7,0)属于R，所以不是反对称的*   若(x,y)和(y,z)都属于R，则x=7k+y,y=7m+z，所以x=7(k+m)+z，所以x与z模7同余，所以是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;e) x是y的倍数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为x是x的倍数，所以是自反的&lt;em&gt;   因为(2,1)属于R，但(1,2)不属于R，所以不是对称的&lt;/em&gt;   因为(1,-1)和(-1,1)都属于R，所以不是反自反的&lt;em&gt;   若(x,y)和(y,z)都属于R，则x=k&lt;/em&gt;y,y=m&lt;em&gt;z，所以x=k&lt;/em&gt;m*z，所以(x,z)也属于R，所以是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;f) x与y都是负的，或者都是非负的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;显然(x,x)属于R，所以是自反的&lt;em&gt;   如果(x,y)属于R，则x与y都是负数，或者都是非负数，所以yx也满足R，所以是对称的&lt;/em&gt;   因为(2,3)和(3,2)满足R，所以不是反对称的*   若(x,y)和(y,z)都属于R，则x、y、z都是负数，或者都是非负数，所以xz也满足R，所以是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;g) x=y^2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(4,4)不属于R，所以不是自反的&lt;em&gt;   (4,2)属于R，但(2,4)不属于R，所以不是对称的&lt;/em&gt;   若x是y的平方，且y是x的平方，则只能是x=y，所以是反对称的*   (8,4)与(4,2)都属于R，但(8,2)不属于R，所以不是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;h) x≥y^2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(4,4)不属于R，所以不是自反的&lt;em&gt;   (4,2)属于R，但(2,4)不属于R，所以不是对称的&lt;/em&gt;   若(x,y)和(y,x)都属于R，则x≥y&lt;em&gt;y≥x&lt;/em&gt;x&lt;em&gt;x&lt;/em&gt;x，又因为x为整数，所以x=0或1，则y=x。所以是反对称的&lt;em&gt;   若(x,y)和(y,z)都属于R，则x≥y&lt;/em&gt;y≥z&lt;em&gt;z&lt;/em&gt;z&lt;em&gt;z≥z&lt;/em&gt;z，所以(x,z)也属于R，所以是传递的&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 08&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1701-1.png&quot;&gt;&lt;img src=&quot;/user_images/1701-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 08&lt;/h2&gt;
&lt;h3&gt;a)&lt;/h3&gt;
&lt;p&gt;如果一个关系既是对称的，又是反对称的，只有一种可能：如果有对称点，则对称点在矩阵的主对角线上。&lt;/p&gt;
&lt;p&gt;假设集合A为{1,2,3,4}，则{(1,1),(2,2),(3,3),(4,4)}的任一子集都是对称和反对称的。&lt;/p&gt;
&lt;h3&gt;b)&lt;/h3&gt;
&lt;p&gt;关系中既包含不相等的对称点，又包含没有对称点的点。&lt;/p&gt;
&lt;p&gt;假设集合A为{1,2,3,4}，则{(1,1),(2,1),(1,2),(2,3)}，既不是对称的，也不是反对称的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;题目 09 ~ 12&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1704-1.png&quot;&gt;&lt;img src=&quot;/user_images/1704-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1704-3.png&quot;&gt;&lt;img src=&quot;/user_images/1704-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;解答 09 ~ 12&lt;/h2&gt;
&lt;p&gt;反自反比较好判断。只有当矩阵主对角线上全部为假时，即关系中不存在(a,a)这样的元素时，关系才是反自反的。&lt;/p&gt;
&lt;h3&gt;9.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1704-4.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中，c、d、f是反自反的。&lt;/p&gt;
&lt;h3&gt;10&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1704-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中，a是反自反的。&lt;/p&gt;
&lt;h3&gt;11&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1704-6.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;四个都不是反自反的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a) 因为访问了某个网页a的人，当然也访问了网页a。所以不是反自反的。&lt;/li&gt;
&lt;li&gt;b) 若网页a上没有链接，则a与a上没有公共链接，属于R。所以不是反自反的。&lt;/li&gt;
&lt;li&gt;c) 如果网页a上有链接，则a和a上至少有一条公共链接，属于R。所以不是反自反的。&lt;/li&gt;
&lt;li&gt;d) 如果存在一个Web包含了到a的链接，则它包含了到a和a的链接，(a,a)属于R。所以不是反自反的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;12&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/1704-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;全部都不是反自反的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为(0,0)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(0,0)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(0,0)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(0,0)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(0,0)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(0,0)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(1,1)属于R，所以不是反自反的&lt;/li&gt;
&lt;li&gt;因为(1,1)属于R，所以不是反自反的&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Windows中，如何检查快捷键被哪个程序占用了？</title>
                <link>http://freewind.in/posts/1675-how-to-check-which-program-the-keyshort-is-used-by-on-windows</link>
                <pubDate>Sat, 05 Jan 2013 19:17:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1675</guid>
                <description><![CDATA[&lt;p&gt;有时候快捷键不知被哪个程序占用了，怎么检查都查不出来，怎么办？&lt;/p&gt;
&lt;p&gt;这时候你可以试试这个免费软件：&lt;a href=&quot;http://hkcmdr.anymania.com/hkexplr_inst.exe&quot;&gt;Windows Hotkey Explorer&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一图胜千言：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1675-1.png&quot;&gt;&lt;img src=&quot;/user_images/1675-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://hkcmdr.anymania.com/hkexplr_inst.exe&quot; title=&quot;http://hkcmdr.anymania.com/hkexplr_inst.exe&quot;&gt;http://hkcmdr.anymania.com/hkexplr_inst.exe&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>学习prolog对学习离散数学是否有帮助？</title>
                <link>http://freewind.in/posts/1664-is-it-helpful-to-learn-prolog-for-discrete-math</link>
                <pubDate>Fri, 04 Jan 2013 22:09:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1664</guid>
                <description><![CDATA[&lt;p&gt;在“离散数学及其应用”这本书里，提到了prolog这门语言。它是一种逻辑推理语言，跟我们平时使用的“命令式”语言差别很大，在人工智能等方面用得很广泛。&lt;/p&gt;
&lt;p&gt;我看了一些关于它的介绍，也写了简单的hello world，感觉它跟离散数学有关系。比如这样的一个简单的程序：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1664-1.png&quot;&gt;&lt;img src=&quot;/user_images/1664-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们写的代码，都是一些事物及规则，对应离散数学中的“谓词”。然后，就可以向prolog询问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wallace和cheese是不是朋友啊&lt;/li&gt;
&lt;li&gt;wallace和他自己是不是朋友啊&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prolog就会回答：Yes, No。&lt;/p&gt;
&lt;p&gt;这的确很神奇，而且可以看出它的确使用了离散数学里的那些逻辑推理的知识。使用prolog，可以用很短的代码就可以解出“八皇后问题”，“数独”，“排序”等麻烦的问题，关键我们还不用写算法！只要我们准确地描述出规则，Prolog就会自动推理，得出我们想要的结论。让人觉得无比神奇。&lt;/p&gt;
&lt;p&gt;但我感觉好像对我学习离散数学帮助不大。因为它的推理都是自动的，只告诉我结果。就算我学会了Prolog，我编程的时候：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按Prolog的语法规则，把题目输进去&lt;/li&gt;
&lt;li&gt;查询，得到答案&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这好像跟我直接翻书后的答案差不多。关键是中间的推理过程，我看不到。&lt;/p&gt;
&lt;p&gt;所以我觉得学习Prolog对离散帮助有限，似乎应该反过来：学习离散数学后，才能很好的掌握Prolog，才能正确地使用它去解决某些领域的问题。&lt;/p&gt;
&lt;p&gt;（因为我对离散数学学得很浅，对Prolog也只是hello world了一下，如果理解不对，欢迎指正。我在网上找不到这方面的经验，只好写篇文章，希望得到您的意见）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>madmanahong答“程序员学习数学的困惑”</title>
                <link>http://freewind.in/posts/1652-the-answer-of-puzzles-of-programmers-learning-math-from-madmanahong</link>
                <pubDate>Fri, 04 Jan 2013 21:48:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1652</guid>
                <description><![CDATA[&lt;p&gt;在CSDN里看到一个老帖子，有&lt;a href=&quot;http://bbs.csdn.net/topics/190141850&quot;&gt;程序员问学习数学的困惑&lt;/a&gt;，问题如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;我很喜欢程序语言，很喜欢并且还学的可以。但是听很多人说，作为程序员一定的数学好。但是我数学不好，可怕的是我不喜欢数学，对数学不感兴趣。但是我又对程序语言很感兴趣，很矛盾。我不喜欢数学，但是当我碰到程序中的数学问题时，往往是根据程序去学数学，不喜欢先学数学再根据数学去解决程序问题，往往是根据程序算法问题，再去学数学。因为我觉得这样学起来更加有效率，单纯得学数学我觉得太枯燥了。&lt;/p&gt;
&lt;p&gt;我该怎么办？很多人都说：如果碰到问题再去学数学，那样太迟了。我情愿先学程序，再学数学。面对这样得矛盾，我真的不知道该怎么办了？我不只一次得问自己，我适合做程序员吗？但是我的兴趣告诉我，我很爱程序。对语言又疯狂得痴迷。但是很多人说数学会是我的瓶颈，但是我觉得我通过程序算法，再去学数学很实用。专门得去学数学，我觉得太枯燥。并且和很多得实际问题不挂钩，都是太多得理论问题。很多人都说理论才是根本。&lt;/p&gt;
&lt;p&gt;说到数学只能说不感兴趣，还不敢说讨厌。学起来嘛，只能说凑合。&lt;/p&gt;
&lt;p&gt;既然我这么爱程序语言，听从了一些人的建议我要好好学数学。我想听听那位高手说说该怎么学数学，该去攻克那学数学课程。注重那些数学课程的学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中一位叫“madmanahong”的同学的回答，让我觉得相当好，也解决了我的一些困惑，所以记录在这里。如下：&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;忍不住上来发一个帖子。&lt;/p&gt;
&lt;p&gt;我是赞成要学习数学的，这是我多年程序的体验。当然，具体学不学要看你所在的领域和感兴趣的话题，
&lt;br  /&gt;我不否则你不会数学也可以挣到月薪20K。不讨论学习数学对事业的帮助，对薪水的帮助，因为也许很多人啥也不会，
&lt;br  /&gt;但是他们出行都用BWM7系！&lt;/p&gt;
&lt;p&gt;我觉得不支持数学的程序员往往是应用级程序员。譬如你可以做一个程序界面，可以封装一些简单的程序接口，或者修改注册表，访问数据库，如果熟悉设计模式，那么你的代码可以在公司内受到好评。如果熟悉架构和网络编程，你甚至也可以做一个游戏服务器，或者类似BT或者emule的p2p文件共享平台。&lt;/p&gt;
&lt;p&gt;所有这些都没有问题，但总有一天，你会发现其中的局限性。&lt;/p&gt;
&lt;p&gt;譬如让你写字符串子串查找功能的时候，在ttesttstglkjwerj串中查找lkj子串，你也许只会用普通线性查找。却将KMP算法忽略了。&lt;/p&gt;
&lt;p&gt;譬如让你写一个对5G的文本数据进行排序的时候，你一直擅长的qsort或者std::sort或许无所能及。这时你只能依靠败者树。&lt;/p&gt;
&lt;p&gt;又或者，现在让你写一个3D的凹凸影射(Bump Mapping), 实时阴影(ShadowVolume), 或者更高深的3D渲染效果的时候，抱歉我当时也是浅尝则止。你只能重新打开工程数学，来看矩阵的操作。&lt;/p&gt;
&lt;p&gt;同样，如果要你实现一个数据库，你只能看B树或者其他算法，当然，我曾经也是认为有了MySQL，谁还会自己去做数据库，但是我现在的公司确实在使用自己开发的数据库，还好面试我的时候我说出了B树的大概原理。&lt;/p&gt;
&lt;p&gt;搜索引擎不用说了，里面的数学知识大家都应该清楚，尽管分词操作大量依靠于词典，但是很多算法你依然逃脱不了，譬如文本文类有KNN，SVM，K临近。文本抽词，给你一篇文本，让你抽出其中的关键词或者让你使用程序自动抽出这篇文章的摘要，听起来神奇，但是使用什么数学，什么马尔可夫模型，这一切都变成了事实。&lt;/p&gt;
&lt;p&gt;还有还有，你可能下载了几个电影，你会发现为什么电影文件体积这么小，但是播放的影片确还是接近DVD效果，深入研究，你发现这就是很流行h264/AVC，同时作为程序员你想探究原理的话，那么恭喜你，你将不得不拿出大学的高等数学，同时翻开概率与数理统计，更甚至你要学习数字信号处理(DSP)这门计算机专业没学过的课程，还没有完呢，你还必须学习信息论这种抽象的学科，从中了解香农（shannon）这个伟大的人物，了解熵这个很古怪的名词。等等&lt;/p&gt;
&lt;p&gt;如果你要说我忽悠你。我还会告诉你在无损压缩领域，如果利用数学证明最小的信息熵，同时否则了哈夫曼编码的地位(huffman)，因为哈夫曼编码中，最小的信息，你至少要用1个bit表示。你想过用0.1个bit来表示一个信息吗？如果没有，那么赶紧去看看神奇的算术编码。&lt;/p&gt;
&lt;p&gt;看到这里，如果你已经不耐烦了，想破口大骂，那就骂吧，我也想骂，因为我大脑中能想到的维度只有3维，那就是x-y-z坐标系，可是为了实现有损压缩的最高境界，为了去除信息的相关性，离散余弦变换（DCT）这种在N维空间中表示一个信息的想法差点让我脑力衰竭！！&lt;/p&gt;
&lt;p&gt;写到这里，想想这么多，我前两天帮朋友做的那个用程序自动把歪的图片调正还算是比较简单的，因为霍夫(hough)变换这个东西包括理论才几页而已。&lt;/p&gt;
&lt;p&gt;其实我写到这里，人工智能(AI)不愿意了：“为什么不提我？为什么不提专家系统？？”。&lt;/p&gt;
&lt;p&gt;我说算了吧，程序中用到的数学太多了，都提出来，可能就字符限制了，还是套用展堂的话：“我能给你说三天三夜不带重样的！”&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;差点忘了补充一点，BT和EMULE中的DHT其实也是用到数学的，譬如KAD网络就用到一种特殊的查找算法。&lt;/p&gt;
&lt;p&gt;同时我要声明，我觉得没有贬低任何人之意。&lt;/p&gt;
&lt;p&gt;我只是阐述自己的观点：数学很重要。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我觉得你举的那两个例子都和数学没关系，数学讨论的是严谨性，讨论的是原理。&lt;/p&gt;
&lt;p&gt;很多东西我们不了解数学，也是可以解决的，就像你说的那两个例子。&lt;/p&gt;
&lt;p&gt;但是数学绝对不是禁锢。利用数学你才能计算出随机事件，或者计算出我们无法模拟的情况。&lt;/p&gt;
&lt;p&gt;假设你第一个例子中的灯泡是漏水的，或者你没有水源，又或者不满足理想状态的时候，你又怎么办呢？&lt;/p&gt;
&lt;p&gt;同时我觉得这个例子完全是不真实的，如果这个人精通数学，那么让他去计算灯泡的体积，和放入水中测试的速度应该是一样快的！&lt;/p&gt;
&lt;p&gt;同时你的第二个例子我觉得也是不真实的，这种东西主要的目的是让人打破禁锢，但针对的角度绝对不是数学。&lt;/p&gt;
&lt;p&gt;这种例子应该放到成功学或者策划讨论大会山，但我想如果真的放到数学家的案桌上，会被耻笑的。&lt;/p&gt;
&lt;p&gt;======================&lt;/p&gt;
&lt;p&gt;我觉得你应该举一个更简单真实的例子，譬如说测量长度的例子，&lt;/p&gt;
&lt;p&gt;如果你想测试房屋的高度，那么很简单，你可以利用尺子或者绳子，但是如果你要测试赤道的长度，你怎么办？&lt;/p&gt;
&lt;p&gt;同时假设让你测量月球到太阳的距离，你又怎么办？？？？！！！！&lt;/p&gt;
&lt;p&gt;======================&lt;/p&gt;
&lt;p&gt;不是说使用数学的方法就是禁锢，熟悉数学的人可以在两难中选择取舍，譬如在H264中，大师们懂得利用近似运算来取代精确的DCT，&lt;/p&gt;
&lt;p&gt;大师们知道利用分块的方法来弥补每个象素的运动补偿。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我觉得在国内，很多人轻视数学是因为鄙视国内的数学教育，但是我觉得，如果你因为鄙视国内的数学教育而不去学习数学的话，&lt;/p&gt;
&lt;p&gt;那实际上是悲哀的。&lt;/p&gt;
&lt;p&gt;数学交给了我们一种解决问题的方法，尽管在生活中，你不必每件事情都使用数学，我看到楼上有人说：买个菜还要用一元二次方程？&lt;/p&gt;
&lt;p&gt;我就晕，不要把所有不沾边的联想到一起，难道你学过了唐诗宋词，就一定要在买菜讨价还价的时候用？？&lt;/p&gt;
&lt;p&gt;同时试想，如果没有数学，买菜的时候，只好一斤一斤买，买10个鸡蛋付10次钱！！！&lt;/p&gt;
&lt;p&gt;==========================&lt;/p&gt;
&lt;p&gt;不要把所有的缺点和禁锢都归于数学，不要把国内一些迂腐的死背分子作出来的事情归结于数学的过错。&lt;/p&gt;
&lt;p&gt;这都是你们自己想出来的，而不是像爱因斯坦那种伟大的数学家（也算吧）做出来的事情。&lt;/p&gt;
&lt;p&gt;同时，你说的：只拿&quot;数学模型&quot;去解决问题是很可笑的。。&lt;/p&gt;
&lt;p&gt;是的，我们没有只拿数学去解决问题，我们这里谈论的是数学的重要性，没有说只用数学，数学家自己也觉得只用数学很可笑，&lt;/p&gt;
&lt;p&gt;所以，他们往往把数学和哲学或者心理学结合到一起……&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这位madmanahong同学才是真正的牛人，向他学习。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play1中play.classloading.hash.ClassStateHashCreator.computePathHash()返回的int有什么用？</title>
                <link>http://freewind.in/posts/1646-play1-int-from-computepathhash</link>
                <pubDate>Fri, 04 Jan 2013 16:55:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1646</guid>
                <description><![CDATA[&lt;p&gt;这是Play热情交流群中肥包同学的提问：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;问问大家一个比较深层次的问题： play.classloading.hash.ClassStateHashCreator.computePathHash() 有谁知道这个方法返回的int用来做啥？貌似框架对这个返回值没有怎么处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;研究了一下，写在这里，有不对之处请指出。&lt;/p&gt;
&lt;h2&gt;一、相关代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;public synchronized int computePathHash(List&amp;lt;VirtualFile&amp;gt; paths) {
    StringBuffer buf = new StringBuffer();
    for (VirtualFile virtualFile : paths) {
        scan(buf, virtualFile);
    }
    // TODO: should use better hashing-algorithm.. MD5? SHA1?
    // I think hashCode() has too many collisions..
    return buf.toString().hashCode();
}

可以看到，方法中遍历了一组路径，并把某些信息放入一个StringBuffer，然后返回该字符串的HashCode。

要想知道它使用了路径的哪些信息，需要看使用到的scan方法：

private void scan(StringBuffer buf, VirtualFile current) {
    if (!current.isDirectory()) {
        if (current.getName().endsWith(&quot;.java&quot;)) {
            buf.append(getClassDefsForFile(current));
        }
    } else if (!current.getName().startsWith(&quot;.&quot;)) {
        // TODO: we could later optimizie it further if we check if the entire folder is unchanged
        for (VirtualFile virtualFile : current.list()) {
            scan(buf, virtualFile);
        }
    }
}
private String getClassDefsForFile(VirtualFile current) {
    File realFile = current.getRealFile();
    // first we look in cache
    FileWithClassDefs fileWithClassDefs = classDefsInFileCache.get(realFile);
    if (fileWithClassDefs != null &amp;amp;&amp;amp; fileWithClassDefs.fileNotChanges()) {
        // found the file in cache and it has not changed on disk
        return fileWithClassDefs.getClassDefs();
    }    // didn&apos;t find it or it has changed on disk
    // we must re-parse it    StringBuilder buf = new StringBuilder();
    Matcher matcher = classDefFinderPattern.matcher(current.contentAsString());
    buf.append(current.getName());
    buf.append(&quot;(&quot;);
    while (matcher.find()) {
        buf.append(matcher.group(1));
        buf.append(&quot;,&quot;);
    }
    buf.append(&quot;)&quot;);
    String classDefs = buf.toString();    // store it in cache
    classDefsInFileCache.put(realFile, new FileWithClassDefs(realFile, classDefs));
    return classDefs;
}

其中后一个方法用到了一个正则表达式：

private final Pattern classDefFinderPattern = Pattern.compile(&quot;\\s+class\\s([a-zA-Z0-9_]+)\\s+&quot;);

从上面两个函数可以看到，它将遍历所有目录（忽略以.开头的），找到每一个java文件，并通过正则找出里面每一个class的名字，然后组成一个大的字符串返回。其中为了性能考虑，使用了缓存。

## 二、scan方法有什么用

通过scan方法，我们可以大概了解到某个目录下有多少java文件，每个文件中定义了哪些类，得到一个摘要消息。通过这个字符串，我们就可以快速知道某个目录下定义了哪些所有java类。如果把这个消息记录下来，就可以知道源代码中定义的java类是否发生了变化。

我们知道Play的一个重要特性就是，当源代码发生了变化时，刷新浏览器就能使用修改后的代码。Play需要知道修改的程度，以便采用不同的处理。比如如果添加或者删除了类，就需要更新Play.classes.classes集合中的内容；如果修改了方法，就不需要这个操作。

在每次请求时，Play通过对app目录进行scan操作，就知道有没有java类发生了变化。

查看代码，在ApplicationClassloader.java中：

int pathHash = 0;

int computePathHash() {
    return classStateHashCreator.computePathHash(Play.javaPath);
}

/**
 * Detect Java changes
 */
public void detectChanges() {
    // ...    

    // Now check if there is new classes or removed classes
    int hash = computePathHash();
    if (hash != this.pathHash) {
        // Remove class for deleted files !!
        for (ApplicationClass applicationClass : Play.classes.all()) {
            // ...
        }
        throw new RuntimeException(&quot;Path has changed&quot;);
    }
}

方法中调用了computePathHash()来判断java类是否发生了变化，如果变化了，则抛出异常。

如果想再深究一下，可以看到在Invoker.java中，在非prod模式下，每当有新请求时来时，都会调用detectChanges()检测。如果有代码改变了，则根据情况重启play。

## 三、为什么要计算HashCode

前面看到，直接使用返回的string就可以判断，为什么要用hashcode呢？

HashCode运用很广，在java的Object类中就定义了hashCode()方法，返回一个32位的integer。它可以用来给一个对象分配一个数字，在某些情况下，用来区分不同的对象。比如在HashMap中，将会根据放入的key的hashCode值，把它分配在不同的内部区，以提高性能。

一个对象在没有发生变化的时候，返回的hash code总是相同的。不同的对象有不同的hashCode实现，比如String.hashCode()用到了以下的算法：

[![image](/user_images/1646-1.png &quot;image&quot;)](/user_images/1646-1.png)

好的算法可以使不同的字符串得到的hashcode尽可能不同，当然也有可能，比如以下两个字符串得到的hashcode都是1279794159:

what the heck?
?☻§◄
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但这并不影响hashcode的使用，因为我们并不以hashcode作为区分两个对象的依据。使用一个int来比较，比比较两个长长的String更方便。&lt;/p&gt;
&lt;p&gt;在Play中，使用摘要字符串的hashcode来比较是可以接受的，因为两个长长的不同的字符串得到同一个hashcode的概率很小，可以忽略。&lt;/p&gt;
&lt;p&gt;如果有疑问或指正，请留言说明。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>05. 增加站内推荐</title>
                <link>http://freewind.in/posts/1619-programmer-write-blogs-5-add-site-recommends</link>
                <pubDate>Thu, 03 Jan 2013 22:41:34 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1619</guid>
                <description><![CDATA[&lt;p&gt;站长统计(&lt;a href=&quot;http://www.cnzz.com&quot;&gt;www.cnzz.com&lt;/a&gt;)里有一个工具叫“云推荐(&lt;a href=&quot;http://tui.cnzz.com&quot;&gt;http://tui.cnzz.com&lt;/a&gt;)”，可以根据当前文章的内容，找到站内相关的文章展示出来，吸引用户眼球。觉得还挺有用的，于是把它加在我的博客里。&lt;/p&gt;
&lt;p&gt;它提供了两种方式展示，一种是固定在页面中的某个位置，一种是悬浮在浏览器的某个边上。&lt;/p&gt;
&lt;p&gt;可以设置样式、推荐文章时从哪个域名下寻找内容，优先推荐哪些等，比较细致，配置起来也很方便。最后会得到一段代码，插入到博客的源代码中即可。&lt;/p&gt;
&lt;p&gt;我的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1619-1.png&quot;&gt;&lt;img src=&quot;/user_images/1619-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉还不错。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>离散数学步步笔记</title>
                <link>http://freewind.in/posts/1614-notes-of-discrete-math-in-steps</link>
                <pubDate>Thu, 03 Jan 2013 18:56:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1614</guid>
                <description><![CDATA[&lt;p&gt;离散数学里有无数的定义、概念、性质，在学习的过程中，就是看书、背公式、做题，很难知道为什么会有这些公式，它们能用在哪里。问别人的时候，他们往往也不知道，“只要记住就行了”，“想那么多干什么”。&lt;/p&gt;
&lt;p&gt;也许自己坚持学完，以后用上的时候，才会明白每个概念和公式出现的理由，但是在学习的过程中，如同在迷雾中摸索，不知道路在何方，真担心自己什么时候就会迷路放弃。&lt;/p&gt;
&lt;p&gt;我认为某个概念的出现一定是有意义的，每一个章节与前面的知识都是有联系的。所以我边学习边记录下自己的思考，虽然可能不正确，但这没关系，等以后想明白的时候再补上。也希望大家可以纠正我的错误。&lt;/p&gt;
&lt;p&gt;我使用的教材是“离散数学”耿素云，屈婉玲编著的那本：&lt;a href=&quot;http://book.douban.com/subject/1231190/&quot;&gt;http://book.douban.com/subject/1231190/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全书分为四章，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数理逻辑2.  集合论3.  代数结构4.  图论&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我现在看完了数理逻辑，正在看集合论，进展比较慢。&lt;/p&gt;
&lt;p&gt;数学是不断抽象的过程，一层层的抽象，不断提高思考层次。这个过程如同盖楼，在不同的层次，考虑的东西也不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一层：原子、分子。考虑化学反应、物理特性2.  第二层：沙子、泥土、水泥、钢铁、木材。考虑材料性质、硬度、粘性、脆度、热胀冷缩，原料来源、价格、成本等3.  第三层：砖、瓦、板、钢筋。考虑形状、颜色、尺寸，能否批量生产，是否满足标准4.  第四层：房屋、公路、铁路、桥、广场。考虑要实现的功能、风格，建筑力学，抗震、防火，成本、价格。5.  第五层：城市规划、社区、商圈、公园。考虑交通、经济、人口、政策、未来发展等6.  第六层：&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在每一层，需要考虑的东西都是独特的，各不相同。但它们都要依赖低一层的基础，借用其研究成果。如果低一层的特性改变了，高一层能实现的目标和表现形式也会不同。&lt;/p&gt;
&lt;p&gt;离散数学也是一样，一层一层累积起来。&lt;/p&gt;
&lt;h2&gt;一、命题与联结符&lt;/h2&gt;
&lt;p&gt;首先是数理逻辑中关于“命题与联结符”，它们就是原子、分子，是后面的基础。命题是可以判断出真假的陈述句，可分为前提和结论。仅仅五个联结符“&lt;a href=&quot;/user_images/1614-1.png&quot;&gt;&lt;img src=&quot;/user_images/1614-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;”就描述了各个前提与结论之间的关系。此时每个前提都是独立的，有自己的真或假，彼此之间互不依赖，只能通过联结符运算提出结论是真是假。&lt;/p&gt;
&lt;p&gt;为什么会选择这五个联结符？为什么不是四个或者六个？为什么是这五个而不是别的五个呢？我想之所有选择这几个，是因为它们很符合我们的日常表达习惯：并且，或者，不是，因为所以，还有一个不常用但比较重要的“当且仅当”。&lt;/p&gt;
&lt;p&gt;通过“联结词的完备集”那一章，我们可以看到，要实现这五个联结词要表达的内容，实际上只需要其中的几个就可以了，剩下的都可以推出来：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1614-3.png&quot;&gt;&lt;img src=&quot;/user_images/1614-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但这样的话，虽然理论上可以表达，但与我们直觉及语言习惯相差太远，或者表达不方便，增大了学习和表达的难度。选择这五个“&lt;a href=&quot;/user_images/1614-5.png&quot;&gt;&lt;img src=&quot;/user_images/1614-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;”应该是综合了多种考虑之后的最优选。&lt;/p&gt;
&lt;p&gt;但这五个联结论，也并不是完全与语言中的“并且，或者，不是，因为所以”完全对应的。因为语言是很灵活的，在不同的语境及习惯用语中，使用的是同一个词，而实际上要表达的意思却对应了不同的联结词。所以，在把语言化的命题用符号表示时，需要根据每一个联结词的定义，重新组织语句，让他们可以对应起来。同时，为了让这几个联结词有着明确和精确的定义，使用了真值表，使得它们的表达没有任何歧义。&lt;/p&gt;
&lt;p&gt;这几个联结词中，蕴含符&lt;a href=&quot;/user_images/1614-7.png&quot;&gt;&lt;img src=&quot;/user_images/1614-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;让我想的不太明白。它对应了语言中的“因为，所以”，“如果，则”，但实际上并不完全相同。在生活中，“因为”与“所以”之间表达的内容，是有联系的，比如“因为我饿了，所以我去吃饭了”，但在命题逻辑中，前件与后件间可以没有任何关系，比如“我饿了&lt;a href=&quot;/user_images/1614-9.png&quot;&gt;&lt;img src=&quot;/user_images/1614-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;下雪了”。命题逻辑中，每个前提、结论之间都是独立的，它们之间没关系。命题是真是假，仅仅由每个前提与结论的真假和它们之间的联结符确定。你可以把它们看作一张张没有感情的真值表，每一个前提都变成了冰冷的0和1，各联结符如同一个个开关，拨来拨去，最后灯亮或者灯灭。&lt;/p&gt;
&lt;p&gt;还有，&lt;a href=&quot;/user_images/1614-11.png&quot;&gt;&lt;img src=&quot;/user_images/1614-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;这个命题，当p为假时，不管q如何，命题为真。这个让我一开始很难想明白，因为在生活中，当我说“因为”什么，或者“如果”什么，当这个前提不成立的时候，结果应该不成立才对，但为什么命题是真呢？&lt;/p&gt;
&lt;p&gt;这是因为混淆了“命题为真”和“结论为真”。当p为假时，命题为真，但并没有说结论q是真是假。实际上在生活中很多时候，我们很少考虑前提为假的情况，大都考虑的是前提为真时，结论是否成立。但在命题逻辑中，结论、前提之间是独立的，考虑的也是整个命题的真值。把&lt;a href=&quot;/user_images/1614-13.png&quot;&gt;&lt;img src=&quot;/user_images/1614-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;定义为“p为假时，命题为真”是有意义的，因为在后面的一阶逻辑中，这种定义，可以让表达很符合我们的直觉。这点在后面说。&lt;/p&gt;
&lt;p&gt;从上面可以看到，命题逻辑既和生活的逻辑有关系，但又不一样，它更加准确、考虑的范围更小、更确定。可以说是“源于生活，高于生活”。它与计算机对应得很好，因为计算机仅有0和1这两个状态，而命题逻辑研究的也只有“假”和“真”这两个状态，门当户对。&lt;/p&gt;
&lt;p&gt;在命题逻辑，事物之间没有关系。如果以生活在地球上的人类来打比方，“命题逻辑”就像在高空中俯视，只能看到一个个的人。实际上人与人之间还有各种关系，比如家庭、朋友等等，但“命题逻辑”是不关心的。&lt;/p&gt;
&lt;p&gt;这显然不够，所以在后面提出了“一阶逻辑”和“谓词”的概念。&lt;/p&gt;
&lt;h2&gt;二、一阶逻辑与谓词&lt;/h2&gt;
&lt;p&gt;从上面的“命题逻辑”可以看出，它研究的都是孤立的事物，不能很好地表达事物的性质和事物间的关系。比如“人都要吃饭，小明是人，所以小明要吃饭”。这样的命题，使用前面的命题逻辑是无法判断结论是否正确。&lt;/p&gt;
&lt;p&gt;为了能推理这样的命题，提出了“谓词”这个概念。谓词表示一个事物怎么样，或者多个事物之间有什么关系。它是很重要的一个词，在后面经常会用到。&lt;/p&gt;
&lt;p&gt;还提出了“量词”的概念，一个是“全部&lt;a href=&quot;/user_images/1614-15.png&quot;&gt;&lt;img src=&quot;/user_images/1614-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;”，一个是“存在&lt;a href=&quot;/user_images/1614-17.png&quot;&gt;&lt;img src=&quot;/user_images/1614-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;”，这样就可以表示上面的命题了。&lt;/p&gt;
&lt;p&gt;设个体域为“全总个体域”，即“宇宙间一切事物”。F(x)表示“x是人”，G(x)表示“x要吃饭”。上面的命题可表示为：&lt;/p&gt;
&lt;p&gt;前提：&lt;a href=&quot;/user_images/1614-19.png&quot;&gt;&lt;img src=&quot;/user_images/1614-19.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结论：&lt;a href=&quot;/user_images/1614-21.png&quot;&gt;&lt;img src=&quot;/user_images/1614-21.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即“对于宇宙间的一切事物，如果它是人，则它要吃饭。因为小明是人，所以小明要吃饭”。&lt;/p&gt;
&lt;p&gt;这里要提到&lt;a href=&quot;/user_images/1614-23.png&quot;&gt;&lt;img src=&quot;/user_images/1614-23.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;的定义了。前面说，&lt;a href=&quot;/user_images/1614-25.png&quot;&gt;&lt;img src=&quot;/user_images/1614-25.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;，当p为假时，命题为真。可以看到，这种定义很适合这里的推理。因为对于宇宙间的一切事物来说，x可能是人，也可能不是人，则F(x)可能为真，也可能为假。当F(x)为真（即x是人时）好处理，直接看G(x)是否为真即可。但当F(x)为假（即x不是人时），应该怎么办呢？简单的办法就是让命题为真，即：F(x)为假时，不应该影响命题的真假。&lt;/p&gt;
&lt;p&gt;一阶逻辑是对命题逻辑的补充，多了两个量词&lt;a href=&quot;/user_images/1614-27.png&quot;&gt;&lt;img src=&quot;/user_images/1614-27.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;和&lt;a href=&quot;/user_images/1614-29.png&quot;&gt;&lt;img src=&quot;/user_images/1614-29.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;。当我们在一阶逻辑上进行运算时，需要利用命题逻辑中的公式，怎么办呢？&lt;/p&gt;
&lt;p&gt;所以需要引入“消去”和“引入”量词的办法：全称量词的消去和引入，存在量词的消去和引入。&lt;/p&gt;
&lt;p&gt;在消去量词时，实际上隐式明确了个体域。在&lt;a href=&quot;/user_images/1614-31.png&quot;&gt;&lt;img src=&quot;/user_images/1614-31.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;的写法中，x的个体域比较大，F(x)可能为真，可能为假。如果我们假设在当前的题意中，可以认为个体域中的所有值，都能使F(x)为真，则上式可以写为这样：&lt;a href=&quot;/user_images/1614-33.png&quot;&gt;&lt;img src=&quot;/user_images/1614-33.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;此时式子里没有量词了，可以当作命题逻辑进行运算。这就是量词消去和引入的意义。&lt;/p&gt;
&lt;p&gt;一阶逻辑中，通过“谓词”可以表示“两个或多个事物之间有关系”，但并不细究它们之间的关系。在“一阶逻辑”的眼里，这生活在地球上的人类，并不是孤立的，他们之间已经有了一定的关系。但仅仅知道有“关系”，到底是什么样的关系，一阶逻辑是不关心的。&lt;/p&gt;
&lt;p&gt;为了研究“关系”，后面又有了集合论。&lt;/p&gt;
&lt;p&gt;（除了一阶逻辑，还有二阶逻辑，不过那个就比较难了，我也说不清是做什么的，对于我们来说用不到，先把一阶逻辑学好再说。）&lt;/p&gt;
&lt;h2&gt;三、集合论与关系&lt;/h2&gt;
&lt;p&gt;集合论的主要目的是研究关系。“集合”是为了研究关系而定义的基础概念，然后又定义了“二元关系”的概念和运算，毕竟二元关系是最简单的关系。&lt;/p&gt;
&lt;p&gt;关系有很多种，也有很多种性质，在集合论中，选择了以下几种性质进行研究：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自反，反自反&lt;/li&gt;
&lt;li&gt;对称，反对称&lt;/li&gt;
&lt;li&gt;传递&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里还没细看，不过刚才搜索了一下，看到了一些比较好的比喻。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“自反”：域中的每一个元素都“自恋”；“反自反”：域中的每一个元素都不“自恋”&lt;/li&gt;
&lt;li&gt;“对称”：域中的每一个元素都“自恋”，或者与其它元素是“朋友”的关系；“反对称”：域中的每一个元素，要么“自恋”，要么都是单方面的认识，就算是追星，你认识明星，明星不认识你。&lt;/li&gt;
&lt;li&gt;“传递”：朋友的朋友，也是朋友&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;集合论刚看到这里，先写到这里。总之，这一章就是研究“关系”的。&lt;/p&gt;
&lt;p&gt;(待续)&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>04. 增加分享与关注按钮</title>
                <link>http://freewind.in/posts/1577-programmer-write-blogs-4-add-share-buttons</link>
                <pubDate>Thu, 03 Jan 2013 14:26:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1577</guid>
                <description><![CDATA[&lt;p&gt;在博客的推广上有点发愁，怎么才能让更多人来看我的博客呢？不想专门花钱来做这个事。看到很多博客上都有“分享”与“关注”按钮，觉得这是个好办法，于是把它们加到我的博客上。&lt;/p&gt;
&lt;h2&gt;百度分享&lt;/h2&gt;
&lt;p&gt;首先发现了“百度分享”(&lt;a href=&quot;http://share.baidu.com&quot;&gt;http://share.baidu.com&lt;/a&gt;)这个工具，使用起来相当简单，直接点击“那个大大的免费获取代码”按钮：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1577-1.png&quot;&gt;&lt;img src=&quot;/user_images/1577-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就可以生成全部所需的HTML代码了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1577-3.png&quot;&gt;&lt;img src=&quot;/user_images/1577-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意顶部有效果预览。&lt;/p&gt;
&lt;p&gt;将这段代码拷到博客的源代码中即可，当然位置需要自己选好，我放在了右边栏处。&lt;/p&gt;
&lt;p&gt;然后使用其中的“一键分享”的功能，把几篇写得比较好的博客，发到我的腾讯和新浪微博中。&lt;/p&gt;
&lt;p&gt;百度分享这个工具的确又简单又好用，赞一个。&lt;/p&gt;
&lt;h2&gt;腾讯微博收听按钮&lt;/h2&gt;
&lt;p&gt;打开这个网址：&lt;a href=&quot;http://dev.t.qq.com/websites/followcomp/&quot;&gt;http://dev.t.qq.com/websites/followcomp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录后，输入“网站名称”和“网站地址”，并选择下方的样式，就能看到效果。我选择的是“收听文字链”这种最简洁的方式。然后点击“获取代码”按钮即可得到一些html，把它们插入到博客的源代码中即可。&lt;/p&gt;
&lt;p&gt;注意如果想修改按钮信息或者样式，点击上方“我的应用”，在“我的组件”中即可看到刚刚创建的收听组件。&lt;/p&gt;
&lt;p&gt;此时获得的是初级权限，可填写身份信息并提交审核，可得到更多的权限。&lt;/p&gt;
&lt;p&gt;我的效果如下图（你可以直接点击并收听）：&lt;/p&gt;
&lt;p&gt;&lt;iframe height=&quot;26&quot; marginheight=&quot;0&quot; src=&quot;http: //follow.v.t.qq.com/index.php?c=follow&amp;a=quick&amp;name=nowind_lee&amp;style=3&amp;t=1357193311233&amp;f=1&quot; frameborder=&quot;0&quot; width=&quot;128&quot; allowtransparency=&quot;allowtransparency&quot; marginwidth=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;新浪微博关注按钮&lt;/h2&gt;
&lt;p&gt;新浪微博的关注按钮跟腾讯很像，打开这个网页：&lt;a href=&quot;http://open.weibo.com/widget/followbutton.php&quot;&gt;http://open.weibo.com/widget/followbutton.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录后，填写信息并调整样式即可。不过它的代码比较麻烦，需要向页面中不同的地方，插入三段代码。&lt;/p&gt;
&lt;p&gt;按提示加到博客的源代码后，我的效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;wb:follow-button height=&quot;26&quot; width=&quot;136&quot; type=&quot;red_2&quot; uid=&quot;1800562633&quot;&gt;&lt;/wb:follow-button&gt;&lt;/p&gt;
&lt;p&gt;由于它的样式在chrome下显示有点不正常（换行了），我还需要专门定制了一下它的样式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.WB_follow_ex {
    display: inline-block;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天先做这么多，下次再继续。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>03. 使用google站长工具检查错误</title>
                <link>http://freewind.in/posts/1570-programmer-write-blogs-3-use-google-webmaster-to-check-errors</link>
                <pubDate>Wed, 02 Jan 2013 20:32:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1570</guid>
                <description><![CDATA[&lt;p&gt;google提供了一个叫webmaster tools的网站，可以检查网站中的问题，十分权威。所以先使用它检查一下。&lt;/p&gt;
&lt;p&gt;网址是：&lt;a href=&quot;https://www.google.com/webmasters/tools/home&quot; title=&quot;https://www.google.com/webmasters/tools/home&quot;&gt;https://www.google.com/webmasters/tools/home&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;添加网站&lt;/h2&gt;
&lt;p&gt;登录后，要先添加网站&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1570-1.png&quot;&gt;&lt;img src=&quot;/user_images/1570-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加时要验证域名，有多种验证方式，如在域名管理面板中，对域名增加一个什么记录，或者上传一个html文件，或者在首页的html代码中增加一个meta标签。由于我的博客是php的，并且本地已经下载了源代码，同步方便，所以选择了最后一种方式。&lt;/p&gt;
&lt;p&gt;根据提示，在&lt;head&gt;中添加如下由网站提供的代码：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;

    &lt;meta name=&quot;google-site-verification&quot; content=&quot;qNVyu-4_lc1gyZd0mIzV3Sss_teYJo-xxxxxxxxxx_w&quot; /&gt;
    &lt;/div&gt;
&lt;pre&gt;&lt;code&gt;然后点击下面的Verify按钮即可，验证通过。

## HTML改进

## 

进去后，发现在左侧“优化”-“HTML改进”处，有一些问题可供改进，如下：

[![image](/user_images/1570-3.png &quot;image&quot;)](/user_images/1570-3.png)

可以看到有三个地方可改进，一是“重复的元说明”，二是“短的元说明”，三是“重复的标题标记”

## 重复的元说明

点开“重复的元说明”，显示以下内容：

[![image](/user_images/1570-5.png &quot;image&quot;)](/user_images/1570-5.png)

先看第一个，竟然有两个博客内容一样，打开一看，果然。应该是当时提交博客时，提交了两次，删除一个即可。

再看第二个，居然有98个一样的。它们的特点是都是tag，可能博客处没有设置好，应该以Tag名作为标题等信息。

检查了一下博客里的设置，没发现问题，可能是使用的主题里面改了，检查代码后发现，对于非文章，都是以博客描述作为description和keywords：

&amp;lt;meta name=&quot;description&quot; content=&quot;&amp;lt;?php bloginfo(&apos;description&apos;); ?&amp;gt;&quot;/&amp;gt;
&amp;lt;meta name=&quot;keywords&quot; content=&quot;&amp;lt;?php bloginfo(&apos;description&apos;); ?&amp;gt;&quot; /&amp;gt;
&amp;lt;p&amp;gt;对应的html是这样的：

[![image](/user_images/1570-7.png &quot;image&quot;)](/user_images/1570-7.png)

我对wordpress了解不多，所以只好用tag名替换它们，先试试再说。

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
&amp;lt;meta name=&quot;description&quot; content=&quot;&amp;lt;?php wp_title(&apos;&apos;); ?&amp;gt;&quot;/&amp;gt;
&amp;lt;meta name=&quot;keywords&quot; content=&quot;&amp;lt;?php wp_title(&apos;&apos;); ?&amp;gt;&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;这样显示就正常了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1570-9.png&quot;&gt;&lt;img src=&quot;/user_images/1570-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;短的元说明&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1570-11.png&quot;&gt;&lt;img src=&quot;/user_images/1570-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样的页面有276条，每个页面的说明只有一行，几个字，的确有点太少。&lt;/p&gt;
&lt;p&gt;看了一下我的wordpress，估计那主题已经被改得面目全非，有插件也不一定能用，所以只好先这样，等晚点再修改。(TODO)&lt;/p&gt;
&lt;h2&gt;重复的标题标记&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1570-13.png&quot;&gt;&lt;img src=&quot;/user_images/1570-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细一看，原来是一些Tag和一些文章的标题相同，这样就会有多个页面有相同的title。解决这个问题，我需要把那些文章的标题修改一下即可。&lt;/p&gt;
&lt;p&gt;今天到此为止。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>02. 使用在线检查工具检查博客</title>
                <link>http://freewind.in/posts/1548-programmer-write-blogs-2-use-online-tools-to-check-blog</link>
                <pubDate>Wed, 02 Jan 2013 19:15:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1548</guid>
                <description><![CDATA[&lt;p&gt;有一些在线工具，可以检查网站的状况，找出其中问题所在，给出建议。&lt;/p&gt;
&lt;p&gt;我搜了一下，看到不少，不过只有一个能用。名字我就不写在这里了，因为它只提供了一次简单试用，然后似乎记录下了我的ip，再使用就要注册了，还要信用卡号。&lt;/p&gt;
&lt;p&gt;如果你有好用的工具，不妨留言给我，我再试下。&lt;/p&gt;
&lt;p&gt;刚才那个网站的检查结果页已经被我关了，没法截图，这里只能凭记忆写下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;域名注册的时间太短2.  内容太少3.  外链太少&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;域名续费&lt;/h2&gt;
&lt;p&gt;看了一下这个域名，再过半年就到期了，所以先renew一下它。这个.me的域名是在name.com上买的，价格不便宜，一年要$18.99，所以只好先续一年，等有优惠码的时候再多续一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1548-1.png&quot;&gt;&lt;img src=&quot;/user_images/1548-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容太少没办法，不想为了增加内容弄一些垃圾文章进来。外链太少，似乎也不是短期能搞定的，不过&amp;hellip;&lt;/p&gt;
&lt;h2&gt;增加外链&lt;/h2&gt;
&lt;p&gt;突然想到我给学校做过一个网站，现在还是由我维护，于是在网站的页脚，增加一个到本博客的链接，毕竟我是名正言顺的维护者嘛。马上动手搞定，这个就不写在这里了：）&lt;/p&gt;
&lt;p&gt;如果你觉得本站不错，而且你也有技术网站或博客，不妨给我留个言，我们交换下链接。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>01. 序</title>
                <link>http://freewind.in/posts/1545-programmer-write-blogs-1-startup</link>
                <pubDate>Wed, 02 Jan 2013 18:43:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1545</guid>
                <description><![CDATA[&lt;p&gt;我的博客已经搭了一年多了，虽然写了不少文章，但一直仅当作自己记录笔记之用，以及针对群友提出的问题进行总结后分享。查看了一下访问量，每天大约只有100多的PV，相当可怜。&lt;/p&gt;
&lt;p&gt;我自己喜欢写博客，因为发现在写的过程中，可以对思路进行总结，是一个思考的过程。为了准确，常常需要找到一些出处及链接，这些东西记录下来，以后用时就方便了。另外，有一些记录性的文章（如在linux上安装postgresql）等，真是相当有用，每次需要安装时直接翻出博客，照着做就可以了。&lt;/p&gt;
&lt;p&gt;之前曾经想做一些网站，折腾几次最后都不了了之，而博客却是我一直坚持下来的东西。所以我想，不如把那些折腾的时间放到博客上，好好做做它，既能为群友和网友带来一些好处，又能学习如何进行网络宣传与推广。&lt;/p&gt;
&lt;p&gt;虽然有这个打算，但是我还是想坚持我的原则，一是原创，二是为自己而写。看到很多一些教程，都是说当前什么热门就写什么，但那样的话，就失去了我写博客的意义了。&lt;/p&gt;
&lt;p&gt;为了记录下这件事情，所以我在优化的过程中，一步步记录下我所进行的操作，看看每一步的效果，仅自己和大家参考。&lt;/p&gt;
&lt;p&gt;我主要打算做的事情有以下几件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让博客美观、好用&lt;/li&gt;
&lt;li&gt;丰富内容&lt;/li&gt;
&lt;li&gt;组织好内容，让人们浏览方便&lt;/li&gt;
&lt;li&gt;根据一些工具的提示，解决网站中存在的问题&lt;/li&gt;
&lt;li&gt;增加分享&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我会定期把结果记录下来，看看有没有改进。&lt;/p&gt;
&lt;p&gt;先贴上当前的状态：&lt;/p&gt;
&lt;p&gt;日期：2013-01-02&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1545-1.png&quot;&gt;&lt;img src=&quot;/user_images/1545-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1545-3.png&quot;&gt;&lt;img src=&quot;/user_images/1545-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1545-5.png&quot;&gt;&lt;img src=&quot;/user_images/1545-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看出，任重而道远。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>01. Scala群规</title>
                <link>http://freewind.in/posts/1493-scala-group-rule</link>
                <pubDate>Wed, 02 Jan 2013 13:54:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1493</guid>
                <description><![CDATA[&lt;p&gt;此群规用于以下QQ群：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scala热情交流群 132569382&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;话题范围&lt;/h3&gt;
&lt;p&gt;本群是一个偏严肃的技术交流群，“热情”两字表现为技术讨论交流上的“热情”，而不是无原则的热闹。大家时间都很宝贵，没时间浪费在闲聊上。如果想要灌水，你一定能在别处找到很多满意的灌水群。&lt;/p&gt;
&lt;p&gt;鼓励：与Scala/Java等技术相关的讨论、交流、分享、疑问，或程序员相关行业的有价值的新闻与话题&lt;/p&gt;
&lt;p&gt;禁止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯娱乐、政治相关话题2.  纯广告3.  无聊发泄（如当前生活状态、加班辛苦、国内外程序员生活及待遇）、灌水刷屏等4.  转发与技术无关的内容（如“中国人顶起来”之类）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于主观性很强、易引起争吵的话题，如编辑器之争、框架之争、行业现状之争等，请尽量避免，最好点到即止。&lt;/p&gt;
&lt;h3&gt;讨论氛围&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;谦虚、热情，不带脏字脏话，不攻击他人2.  对于自己不了解的东西不武断发表意见3.  有问题先到google上查询一下再问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有缘千里进一群，大家都是朋友，希望能保持友好积极的讨论氛围。&lt;/p&gt;
&lt;h3&gt;字体、字号与颜色&lt;/h3&gt;
&lt;p&gt;使用默认的最好。&lt;/p&gt;
&lt;p&gt;如果想要调整，按以下原则：字号为10或11，使用宋体或其它端正的字体，去掉粗斜体和下划线，使用深色（不要使用红黄绿等显眼的亮色，或灰色等看不清的暗色）。&lt;/p&gt;
&lt;h5&gt;问：10号字太小了，我看不清怎么办&lt;/h5&gt;
&lt;p&gt;答：通常10号字还是比较清楚的，但如果你习惯了大字体，可以右键点击发言区，如下图调整显示比例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1493-1.png&quot;&gt;&lt;img src=&quot;/user_images/1493-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;问：我想让自己的字体与众不同，这样好分清哪句话是谁说的&lt;/h5&gt;
&lt;p&gt;答：通常“与众不同”的意思，是让自己的文字更显眼，所以会选用大字、粗体、鲜艳的颜色和怪异的字体。但这样做会给其它人带来困扰，因为这就像是在公共场合大声喧哗，发出怪声以引起他人注意。本群是技术交流群，我们需要的是有内容的文字，如果你的内容让人印象深刻，你不需要任何刻意的装饰，有你的名字就够了。&lt;/p&gt;
&lt;h3&gt;昵称&lt;/h3&gt;
&lt;p&gt;昵称中不可有空格、火星文、表情符号，或者娱乐性太强的名字。起个技术点普通点的名字就好。&lt;/p&gt;
&lt;h3&gt;贴代码及大段文字&lt;/h3&gt;
&lt;p&gt;贴代码时容易夹带一些表情符号，按下面方式设置：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1493-3.png&quot;&gt;&lt;img src=&quot;/user_images/1493-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把“使用表情快捷键”前面的勾去掉。&lt;/p&gt;
&lt;p&gt;大段代码请发布在第三方网站上，然后在群里发个链接即可。可发到以下网站：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://gist.github.com/&quot;&gt;http://gist.github.com&lt;/a&gt;2.  &lt;a href=&quot;http://pastebin.com/&quot;&gt;http://pastebin.com&lt;/a&gt;3.  &lt;a href=&quot;http://pastie.org/&quot;&gt;http://pastie.org&lt;/a&gt;4.  &lt;a href=&quot;http://codepad.org/&quot;&gt;http://codepad.org&lt;/a&gt;5.  &lt;a href=&quot;http://paste.ideaslabs.com/&quot;&gt;http://paste.ideaslabs.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;警告、T人及清理&lt;/h3&gt;
&lt;p&gt;对于违反以上群规的群友，视情况提醒或警告。警告无效后T人。&lt;/p&gt;
&lt;p&gt;不定时清理长期不发言的群友。欢迎在需要的时候再加回来。&lt;/p&gt;
&lt;h3&gt;加群密码&lt;/h3&gt;
&lt;p&gt;请打开该以下链接，做出要求的题目，将scala代码作为加群密码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://freewind.me/blog/20130205/2066.html&quot;&gt;http://freewind.me/blog/20130205/2066.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您不赞同本群规，请谨慎加群。&lt;/p&gt;
&lt;p&gt;如果赞同的话，请检查您的字体，本群对字体及颜色的要求比较严格。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>01. PlayFramework群规</title>
                <link>http://freewind.in/posts/1492-playframework-group-rule</link>
                <pubDate>Wed, 02 Jan 2013 13:53:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1492</guid>
                <description><![CDATA[&lt;p&gt;此群规用于以下QQ群：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Playframework热情交流群 168013302&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;话题范围&lt;/h3&gt;
&lt;p&gt;本群是一个偏严肃的技术交流群，“热情”两字表现为技术讨论交流上的“热情”，而不是无原则的热闹。大家时间都很宝贵，没时间浪费在闲聊上。如果想要灌水，你一定能在别处找到很多满意的灌水群。&lt;/p&gt;
&lt;p&gt;鼓励：与PlayFramework/Java等技术相关的讨论、交流、分享、疑问，或程序员相关行业的有价值的新闻与话题。&lt;/p&gt;
&lt;p&gt;如果你要交流play2-scala，请加Scala群（132569382）。&lt;/p&gt;
&lt;p&gt;禁止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯娱乐、政治相关话题2.  纯广告3.  无聊发泄（如当前生活状态、加班辛苦、国内外程序员生活及待遇）、灌水刷屏等4.  转发与技术无关的内容（如“中国人顶起来”之类）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于主观性很强、易引起争吵的话题，如编辑器之争、框架之争、行业现状之争等，请尽量避免，最好点到即止。&lt;/p&gt;
&lt;h3&gt;讨论氛围&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;谦虚、热情，不带脏字脏话，不攻击他人2.  对于自己不了解的东西不武断发表意见3.  有问题先到google上查询一下再问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有缘千里进一群，大家都是朋友，希望能保持友好积极的讨论氛围。&lt;/p&gt;
&lt;h3&gt;字体、字号与颜色&lt;/h3&gt;
&lt;p&gt;使用默认的最好。&lt;/p&gt;
&lt;p&gt;如果想要调整，按以下原则：字号为10或11，使用宋体或其它端正的字体，去掉粗斜体和下划线，使用深色（不要使用红黄绿等显眼的亮色，或灰色等看不清的暗色）。&lt;/p&gt;
&lt;h5&gt;问：10号字太小了，我看不清怎么办&lt;/h5&gt;
&lt;p&gt;答：通常10号字还是比较清楚的，但如果你习惯了大字体，可以右键点击发言区，如下图调整显示比例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1492-1.png&quot;&gt;&lt;img src=&quot;/user_images/1492-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;问：我想让自己的字体与众不同，这样好分清哪句话是谁说的&lt;/h5&gt;
&lt;p&gt;答：通常“与众不同”的意思，是让自己的文字更显眼，所以会选用大字、粗体、鲜艳的颜色和怪异的字体。但这样做会给其它人带来困扰，因为这就像是在公共场合大声喧哗，发出怪声以引起他人注意。本群是技术交流群，我们需要的是有内容的文字，如果你的内容让人印象深刻，你不需要任何刻意的装饰，有你的名字就够了。&lt;/p&gt;
&lt;h3&gt;昵称&lt;/h3&gt;
&lt;p&gt;昵称中不可有空格、火星文、表情符号，或者娱乐性太强的名字。起个技术点普通点的名字就好。&lt;/p&gt;
&lt;h3&gt;贴代码及大段文字&lt;/h3&gt;
&lt;p&gt;贴代码时容易夹带一些表情符号，按下面方式设置：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1492-3.png&quot;&gt;&lt;img src=&quot;/user_images/1492-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把“使用表情快捷键”前面的勾去掉。&lt;/p&gt;
&lt;p&gt;大段代码请发布在第三方网站上，然后在群里发个链接即可。可发到以下网站：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://gist.github.com/&quot;&gt;http://gist.github.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pastebin.com/&quot;&gt;http://pastebin.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pastie.org/&quot;&gt;http://pastie.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://codepad.org/&quot;&gt;http://codepad.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://paste.ideaslabs.com/&quot;&gt;http://paste.ideaslabs.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;警告、T人及清理&lt;/h3&gt;
&lt;p&gt;对于违反以上群规的群友，视情况提醒或警告。警告无效后T人。&lt;/p&gt;
&lt;p&gt;不定时清理长期不发言的群友。欢迎在需要的时候再加回来。&lt;/p&gt;
&lt;h3&gt;加群密码&lt;/h3&gt;
&lt;p&gt;加群时请输入以下内容(黄底红字部分)：&lt;font style=&quot;background-color: #ffff00&quot; color=&quot;#ff0000&quot;&gt;我已阅读并将严格遵守PlayFramework群规&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;如果您不赞同本群规，请谨慎加群。&lt;/p&gt;
&lt;p&gt;如果赞同的话，请检查您的字体，本群对字体及颜色的要求比较严格。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Javascript群规</title>
                <link>http://freewind.in/posts/1491-javascript-group-rule</link>
                <pubDate>Wed, 02 Jan 2013 13:51:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1491</guid>
                <description><![CDATA[&lt;p&gt;此群规用于以下QQ群：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Javascript热情交流群 168013483&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;话题范围&lt;/h3&gt;
&lt;p&gt;本群是一个偏严肃的技术交流群，“热情”两字表现为技术讨论交流上的“热情”，而不是无原则的热闹。大家时间都很宝贵，没时间浪费在闲聊上。如果想要灌水，你一定能在别处找到很多满意的灌水群。&lt;/p&gt;
&lt;p&gt;鼓励：与JavaScript、前端、nodejs等相关技术讨论、交流、分享、疑问，或程序员相关行业的有价值的新闻与话题&lt;/p&gt;
&lt;p&gt;禁止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯娱乐、政治相关话题2.  纯广告3.  无聊发泄（如当前生活状态、加班辛苦、国内外程序员生活及待遇）、灌水刷屏等4.  转发与技术无关的内容（如“中国人顶起来”之类）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于主观性很强、易引起争吵的话题，如编辑器之争、框架之争、行业现状之争等，请尽量避免，最好点到即止。&lt;/p&gt;
&lt;h3&gt;讨论氛围&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;谦虚、热情，不带脏字脏话，不攻击他人2.  对于自己不了解的东西不武断发表意见3.  有问题先到google上查询一下再问&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有缘千里进一群，大家都是朋友，希望能保持友好积极的讨论氛围。&lt;/p&gt;
&lt;h3&gt;字体、字号与颜色&lt;/h3&gt;
&lt;p&gt;使用默认的最好。&lt;/p&gt;
&lt;p&gt;如果想要调整，按以下原则：字号为10或11，使用宋体或其它端正的字体，去掉粗斜体和下划线，使用深色（不要使用红黄绿等显眼的亮色，或灰色等看不清的暗色）。&lt;/p&gt;
&lt;h5&gt;问：10号字太小了，我看不清怎么办&lt;/h5&gt;
&lt;p&gt;答：通常10号字还是比较清楚的，但如果你习惯了大字体，可以右键点击发言区，如下图调整显示比例。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1491-1.png&quot;&gt;&lt;img src=&quot;/user_images/1491-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;问：我想让自己的字体与众不同，这样好分清哪句话是谁说的&lt;/h5&gt;
&lt;p&gt;答：通常“与众不同”的意思，是让自己的文字更显眼，所以会选用大字、粗体、鲜艳的颜色和怪异的字体。但这样做会给其它人带来困扰，因为这就像是在公共场合大声喧哗，发出怪声以引起他人注意。本群是技术交流群，我们需要的是有内容的文字，如果你的内容让人印象深刻，你不需要任何刻意的装饰，有你的名字就够了。&lt;/p&gt;
&lt;h3&gt;昵称&lt;/h3&gt;
&lt;p&gt;昵称中不可有空格、火星文、表情符号，或者娱乐性太强的名字。起个技术点普通点的名字就好。&lt;/p&gt;
&lt;h3&gt;贴代码及大段文字&lt;/h3&gt;
&lt;p&gt;贴代码时容易夹带一些表情符号，按下面方式设置：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1491-3.png&quot;&gt;&lt;img src=&quot;/user_images/1491-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把“使用表情快捷键”前面的勾去掉。&lt;/p&gt;
&lt;p&gt;大段代码请发布在第三方网站上，然后在群里发个链接即可。&lt;/p&gt;
&lt;p&gt;贴可实时看到效果的js/css/html代码，请使用以下网站：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://jsfiddle.net/&quot;&gt;http://jsfiddle.net&lt;/a&gt;2.  &lt;a href=&quot;http://jsbin.com/&quot;&gt;http://jsbin.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;格式化javascript/json代码，使用以下网站：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://jsbeautifier.org/&quot;&gt;http://jsbeautifier.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;普通的可发到以下网站：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://gist.github.com/&quot;&gt;http://gist.github.com&lt;/a&gt;2.  &lt;a href=&quot;http://pastebin.com/&quot;&gt;http://pastebin.com&lt;/a&gt;3.  &lt;a href=&quot;http://pastie.org/&quot;&gt;http://pastie.org&lt;/a&gt;4.  &lt;a href=&quot;http://codepad.org/&quot;&gt;http://codepad.org&lt;/a&gt;5.  &lt;a href=&quot;http://paste.ideaslabs.com/&quot;&gt;http://paste.ideaslabs.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;警告、T人及清理&lt;/h3&gt;
&lt;p&gt;对于违反以上群规的群友，视情况提醒或警告。警告无效后T人。&lt;/p&gt;
&lt;p&gt;不定时清理长期不发言的群友。欢迎在需要的时候再加回来。&lt;/p&gt;
&lt;h3&gt;加群密码&lt;/h3&gt;
&lt;p&gt;加群时请输入以下内容(黄底红字部分)：&lt;font style=&quot;background-color: #ffff00&quot; color=&quot;#ff0000&quot;&gt;我已阅读并将严格遵守JavaScript群规&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#ff0000&quot; size=&quot;5&quot;&gt;&lt;strong&gt;注意，如果您不赞同本群规（尤其是字体及颜色方面的要求），请不要加群。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>修改LiveWriter插件WintyCodeArea，生成google-code-prettify适用的代码块</title>
                <link>http://freewind.in/posts/1367-modify-wintycodearea-plugin-of-livewrite-to-insert-code-block</link>
                <pubDate>Tue, 01 Jan 2013 20:30:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1367</guid>
                <description><![CDATA[&lt;h2&gt;开源就是好！&lt;/h2&gt;
&lt;p&gt;一直觉得LiveWriter中插入源代码不方便，使用了几个插件都不好用，因为基本上向代码中插入很多style，嵌入到文档中，无法与google-code-prettify很好的结合起来。&lt;/p&gt;
&lt;p&gt;今天看到了一个WintyCodeArea的插件：&lt;a href=&quot;http://www.blogjava.net/wintys/archive/2009/10/05/dotNET_WindowLiveWriter_WintyCodeArea.html&quot;&gt;http://www.blogjava.net/wintys/archive/2009/10/05/dotNET_WindowLiveWriter_WintyCodeArea.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它的功能比较简单，可以把选中的代码外面包一个&lt;code&gt;&amp;lt;div class=&quot;mycode&quot;&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;，虽然不太符合我的需求，但是由于作者开放了源代码，我照猫画虎，做出了自己想要的功能。&lt;/p&gt;
&lt;p&gt;源代码我已经发布在github上：&lt;a href=&quot;https://github.com/freewind/WintyCodeArea&quot;&gt;https://github.com/freewind/WintyCodeArea&lt;/a&gt;，感谢原作者的代码。因为有原作者的劳动成果，我才能在C#还未入门的情况下，做出自己需要的效果。&lt;/p&gt;
&lt;p&gt;所做的主要修改在WintyCodeArea类中，这一段：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;

    if (m_settings.RemoveBr)
          content += originalContent
          .Replace(&quot;&lt;P&gt;&quot;, &quot;&quot;).Replace(&quot;&lt;/P&gt;&quot;, &quot;&quot;)
          .Replace(&quot;\r\n&quot;, &quot;&quot;).Replace(&quot;\n&quot;, &quot;&quot;)
          .Replace(&quot;&lt;BR&gt;&quot;, &quot;\n&quot;)
          .Replace(&quot;&amp;nbsp;&quot;, &quot; &quot;);
    &lt;/div&gt;
&lt;pre&gt;&lt;code&gt;我增加了一个配置选项：`RemoveBr`，用来表示是否去除代码中的`&amp;lt;br&amp;gt;`标签。

当我们把代码直接拷贝到live writer后，live writer为了正确显示其格式，会把换行符`\n`变为`&amp;lt;BR&amp;gt;`，同时把多于一个的空格换成`&amp;amp;nbsp;`。如果我们直接在它们外面包上`&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;`，显然是不行的，因为google-code-prettify需要的是纯文本格式的代码，里面不能含有html代码。我们需要在代码中，把`&amp;lt;BR&amp;gt;`换成换行符`\n`，把`&amp;amp;nbsp;`换成空格。

另外，我们得到的`content`字符串（即选中的内容）会莫名多出一些换行符，必须先把它们去掉，不然最后生成的代码，格式是乱的。

另外，在选择时，有可能把代码块外面包着的`&amp;lt;p&amp;gt;`也选中，不需要它，所以把它也去掉。

这样对选中代码进行处理后，再在外面套上`&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;`，就是一个满足google-code-prettify要求的代码块了。

## 配置Visual Studio

这里记录一下Visual Studio的操作，以免以后需要的时候忘了。其实四个月前我还学习一段时间的C#和VS，基本算入门了，但四个月之后，已经记不清了，花了不少时间去配置VS，才让项目跑起来。

我用的是Visual Studio 2012，系统是win7 x64.

添加LiveWriter的dll

源代码项目中没有包含live writer的dll，我们必须先安装好live writer，然后将它目录下的WindowsLive.Writer.Api.dll引入到项目中。该dll就是让人们写live writer插件用的，里面提供了一些类可供使用。

[![image](/user_images/1367-1.png &quot;image&quot;)](/user_images/1367-1.png)

在浏览页，选择live writer中的WindowsLive.Writer.Api.dll，确定即可，此时如图：

[![image](/user_images/1367-3.png &quot;image&quot;)](/user_images/1367-3.png)

添加之后，按F6，重新生成一下解决方案。

如果你是x64的系统，此时可能会提示错误，因为live writer是32位，我们必须手动把项目的编译类型改为x86。

右键点“解决方案”－“配置属性”－“配置”，右上角“配置管理器”。

出来如下的对话框，点“活动解决方案平台”，选“新建...”

[![image](/user_images/1367-5.png &quot;image&quot;)](/user_images/1367-5.png)

弹出如下的对话框，选择x86:

[![image](/user_images/1367-7.png &quot;image&quot;)](/user_images/1367-7.png)

确定后，回到前面的页面，确定这里是x86:

[![image](/user_images/1367-9.png &quot;image&quot;)](/user_images/1367-9.png)

然后再重新生成解决方案，如果没有提示代码错误，表明环境和代码都正确。

此时可能会出现这样的一个错误：

[![image](/user_images/1367-11.png &quot;image&quot;)](/user_images/1367-11.png)

这是说把生成的WintyCodeArea.dll拷贝到Live writer的Plugins目录下出错。如果出了这个错，可以手动把WintyCodeArea.dll拷贝过去。

这个WintyCodeArea.dll就是这个项目生成的库文件，直接把它放在Live writer的Plugins目录下，再重新打开Live writer即可。如果没有错误，你可以在其插件列表中看到WintyCodeArea这个插件名：

[![image](/user_images/1367-13.png &quot;image&quot;)](/user_images/1367-13.png)

## 配置WintyCodeArea

确定如下：

[![image](/user_images/1367-15.png &quot;image&quot;)](/user_images/1367-15.png)

## 将插件添加到“快速访问工具栏”

因为live writer不支持自定义快捷键，我也没有找到在插件中设置快捷键的办法，每次使用时都需要切换工具面板，十分不便。所以把加到“快速访问工具栏”中，使用方便一些。

[![image](/user_images/1367-17.png &quot;image&quot;)](/user_images/1367-17.png)

以后使用时，只需要点这里就行了。

[![image](/user_images/1367-19.png &quot;image&quot;)](/user_images/1367-19.png)

这样live writer这块就搞定了。

## 博客端

由于wordpress不支持google-code-prettify，所以我们还需要修改wordpress代码，让它可以给代码块着色。

首先到[http://code.google.com/p/google-code-prettify/](http://code.google.com/p/google-code-prettify/)下载所需要的js文件，拿到prettify.min.js文件，加到博客的header中。

然后在页面的最下面加上：

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
$(function() {
  $(&quot;pre&quot;).addClass(&quot;prettyprint&quot;);
  prettyPrint();
});
&amp;lt;/script&amp;gt;
&amp;lt;/div&amp;gt;

它会给所有的&amp;lt;pre&amp;gt;标签加上prettyprint这个css class供google-code-prettify定位，然后调用google-code-prettify中的方法prettyPrint，给代码块着色。

再设置css:

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
pre {
    margin: 0px 0px 20px;
    padding: 10px;
    border: 1px solid #CCC;
    _height: 1%;
    white-space: pre-wrap;
    display: block;
    font-size: 12.025px;
    line-height: 18px;
    word-break: break-all;
    word-wrap: break-word;
    white-space: pre-wrap;
    background-color: whiteSmoke;
    border: 1px solid rgba(0, 0, 0, 0.15);
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
}pre code {
    color: #333;
    font-size: 14px;
    border: 0px;
    background-color: transparent;
    margin: 0px;
    padding: 0px;
}code {
    font-family: Consolas, Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, serif;
    background-color: #eeeeee;
    border: 1px solid rgba(0, 0, 0, 0.15);
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
    border-radius: 4px;
    color: #871b15;
    margin: 0px 3px;
    padding: 3px 6px;
}/* prettify */
.com {
    color: #93a1a1;
}.lit {
    color: #195f91;
}.pun, .opn, .clo {
    color: #93a1a1;
}.fun {
    color: #dc322f;
}.str, .atv {
    color: #D14;
}.kwd, .linenums .tag {
    color: #1e347b;
}.typ, .atn, .dec, .var {
    color: teal;
}.pln {
    color: #48484c;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;这样，代码就可以显示出这样的效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1367-21.png&quot;&gt;&lt;img src=&quot;/user_images/1367-21.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Scala资源</title>
                <link>http://freewind.in/posts/1343-scala-resources</link>
                <pubDate>Tue, 01 Jan 2013 17:28:50 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1343</guid>
                <description><![CDATA[&lt;h3&gt;资料与网站&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://scala-lang.org/&quot;&gt;Scala官网&lt;/a&gt;: &lt;a href=&quot;http://www.scala-lang.org/downloads&quot;&gt;下载&lt;/a&gt;,&lt;a href=&quot;http://www.scala-lang.org/api/current/index.html&quot;&gt;文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://typesafe.com/&quot;&gt;Typesafe官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.scala-lang.org/display/SW/Tools+and+Libraries#ToolsandLibraries-Messaging&quot;&gt;Scala项目收集&lt;/a&gt; scala官方网站上的，比较权威&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;学习资料&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://daily-scala.blogspot.com/&quot;&gt;Daily Scala&lt;/a&gt; 非常好的scala学习网站，虽然已经有两年未更新，但对于初学者依然有极大的参考价值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/tags/scala/info&quot;&gt;Stackoverflow&lt;/a&gt;: 涉及到Scala各方面的问题的总汇&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://james-iry.blogspot.com/2007/09/monads-are-elephants-part-1.html&quot;&gt;Manods are elephants&lt;/a&gt;: 学习Manod必读&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hongjiang.info/scala&quot;&gt;宏江博客&lt;/a&gt;: scala类型系统、manod等文章写得很好&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/&quot;&gt;Type level programming&lt;/a&gt;: 深入学习scala类型系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://danielwestheide.com/scala/neophytes.html&quot;&gt;The Neophyte&apos;s Guide to Scala&lt;/a&gt;: 深入讲解了scala中的一些主题&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;教学类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.simplyscala.com/&quot;&gt;Simply Scala&lt;/a&gt;: 实时互动的scala学习网站，可以直接输入代码运行&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://twitter.github.com/scala_school/index.html&quot;&gt;twitter的scala school&lt;/a&gt; 由twitter推出的scala教程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;中文&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://qiujj.com/static/Scala-Handbook.htm&quot;&gt;Scala速查手册&lt;/a&gt; JamesQiu的Scala学习笔记与速查手册&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scala.wisdomfish.org/&quot;&gt;Scala鱼&lt;/a&gt;：台湾网友创建的scala教学网站&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://caterpillar.onlyfun.net/Gossip/Scala/index.html&quot;&gt;Scala学习笔记&lt;/a&gt;: 台湾网友的scala教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://developer.51cto.com/art/200906/127830.htm&quot;&gt;51cto上的scala专题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oschina.net/search?scope=blog&amp;amp;q=scala&quot;&gt;oschina上的scala文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/search/csass/search/?q=scala&amp;amp;co=us&amp;amp;lo=zh-simplified&amp;amp;ibm-submit.x=8&amp;amp;ibm-submit.y=18&amp;amp;sn=&amp;amp;lang=en&amp;amp;cc=US&amp;amp;en=utf&amp;amp;hpp=&quot;&gt;ibm上的scala中文文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;国内scala社区收集&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scalacn.com/&quot;&gt;scalacn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baomomo.com/&quot;&gt;baomomo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;开源项目&lt;/h3&gt;
&lt;h4&gt;web框架及相关&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://playframework.org/&quot;&gt;playframework&lt;/a&gt;: typesafe官方推荐&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://liftweb.net/&quot;&gt;liftweb&lt;/a&gt;: 老牌，view-first&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scalatra.org/&quot;&gt;scalatra&lt;/a&gt;: 简洁&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://circumflex.ru/&quot;&gt;circumflex&lt;/a&gt;: 传统mvc，还提供了ORM&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://unfiltered.databinder.net/Unfiltered.html&quot;&gt;unfiltered&lt;/a&gt;: 干净&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://spray.cc/&quot;&gt;Spray&lt;/a&gt; 构建于akka这上的轻量级rest库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/typesafehub/play2-mini/&quot;&gt;Play2-mini&lt;/a&gt;: 构建于playframework之上的轻量级rest库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://scalate.fusesource.org/&quot;&gt;scalate&lt;/a&gt;: 基于scala的模板引擎，提供了多种语法，一定有你喜欢的风格&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;并发&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://akka.io/&quot;&gt;Akka&lt;/a&gt;: typesafe官方推出的并发库。&lt;a href=&quot;http://akka.io/docs/&quot;&gt;英文文档&lt;/a&gt;，&lt;a href=&quot;http://www.gtan.com/akka_doc/intro/what-is-akka.html&quot;&gt;老猪翻译的文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据库&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;scalaquery&lt;/li&gt;
&lt;li&gt;squeryl&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;序列化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/novus/salat&quot;&gt;salat&lt;/a&gt;: Salat is a simple serialization library for case classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;JSON&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/codahale/jerkson/&quot;&gt;jerkson&lt;/a&gt;: 在强大好用的jackson上包装了一层&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lift/lift/tree/master/framework/lift-base/lift-json/&quot;&gt;lift-json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;构建工具&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/harrah/xsbt/wiki&quot;&gt;sbt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;测试&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.scalatest.org/&quot;&gt;scalatest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://etorreborre.github.com/specs2/&quot;&gt;specs2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;其它&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://parboiled.org/&quot;&gt;parboiled&lt;/a&gt;: 简洁的解析器，可以解析自定义的语法和格式。与scala自带的combinator.Parsers类似，但功能更为强大一些。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;国产&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bitbucket.org/centaur/scalaconsole/wiki/Home&quot;&gt;scalaconsole&lt;/a&gt;: 可执行scala代码的GUI界面，比纯命令行方便多了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;书籍&lt;/h3&gt;
&lt;h4&gt;有中文版的&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/4909629/&quot;&gt;Scala程序设计：Java虚拟机多核编程实战&lt;/a&gt; 薄薄一本，适合java程序员快速入门&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/5377415/&quot;&gt;Scala编程&lt;/a&gt; 学习scala必备，系统讲述了scala的各知识点，讲得不深，适合初学者&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;正在翻译的&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;《Scala for the Impatient》老高已翻译，预计下个月面市，scala语言教程。&lt;/li&gt;
&lt;li&gt;《scala in depth》魔头大哥在翻（期待中），scala语言教程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;其它&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;《Programming in Scala, 2nd Edition》2011年, scala语言教程 英文版&lt;/li&gt;
&lt;li&gt;《beginning scala》2009年, scala语言教程 英文版&lt;/li&gt;
&lt;li&gt;《Programming Scala》2009年, scala语言教程&lt;/li&gt;
&lt;li&gt;《scala in action》&lt;/li&gt;
&lt;li&gt;《Steps in Scala》2010年&lt;/li&gt;
&lt;li&gt;《Manning.Lift.in.Action.Nov.2011.》lift web 框架&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;开发工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Emacs + ensime + sbt&lt;/li&gt;
&lt;li&gt;Eclipse + &lt;a href=&quot;http://scala-ide.org/&quot;&gt;Scala-IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jetbrains.com/idea/&quot;&gt;intellij idea&lt;/a&gt; + &lt;a href=&quot;http://confluence.jetbrains.net/display/SCA/Scala+Plugin+for+IntelliJ+IDEA&quot;&gt;scala插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vim&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://code.google.com/p/scala-edit/&quot;&gt;ScalaEdit&lt;/a&gt; A text editor for Scala programmers&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Scala商业应用&lt;/h3&gt;
&lt;h4&gt;国内&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;星畅 &lt;a href=&quot;http://www.starworking.com/star-one-site/oa_video.html&quot;&gt;http://www.starworking.com/star-one-site/oa_video.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;广谈 &lt;a href=&quot;http://www.gtan.com/&quot;&gt;http://www.gtan.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;云壤 &lt;a href=&quot;http://www.yunrang.com/&quot;&gt;http://www.yunrang.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;国外&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;typesafe: &lt;a href=&quot;http://typesafe.com/&quot;&gt;http://typesafe.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;twitter: &lt;a href=&quot;http://twitter.com/&quot;&gt;http://twitter.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Javascript MVC 资源</title>
                <link>http://freewind.in/posts/1342-javascript-mvc-resources</link>
                <pubDate>Tue, 01 Jan 2013 17:27:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1342</guid>
                <description><![CDATA[&lt;h3&gt;网站与资料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://todomvc.com/&quot;&gt;todomvc&lt;/a&gt; 使用各种MVC框架来实现一个TodoList的程序，可看效果及源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;前端MV*框架&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://angularjs.org/&quot;&gt;angularjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://documentcloud.github.com/backbone&quot;&gt;backbone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://knockoutjs.com/&quot;&gt;knockout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://emberjs.com/&quot;&gt;Ember.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sammyjs.org/&quot;&gt;sammy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cappuccino.org/&quot;&gt;Cappuccino&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://javascriptmvc.com/&quot;&gt;JavascriptMVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://batmanjs.org/&quot;&gt;batman.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优秀开源库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore&lt;/a&gt; 提供了很多好用的函数，以减化我们的js代码，必备。*   &lt;a href=&quot;https://github.com/chjj/marked&quot;&gt;marked&lt;/a&gt; 非常高效的markdown解析库，性能极好。还实现了github推荐的&lt;a href=&quot;http://github.github.com/github-flavored-markdown/&quot;&gt;markdown改进语法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Javascript资源</title>
                <link>http://freewind.in/posts/1341-javascript-resources</link>
                <pubDate>Tue, 01 Jan 2013 17:27:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1341</guid>
                <description><![CDATA[&lt;h3&gt;优秀库&lt;/h3&gt;
&lt;h4&gt;常用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://momentjs.com/&quot;&gt;moment&lt;/a&gt; 一个轻量级的解析和格式化日期的类，即可用于nodejs，也可用于浏览器端。&lt;a href=&quot;http://momentjs.com/docs/&quot;&gt;文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;图像&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://d3js.org/&quot;&gt;d3&lt;/a&gt; 数据驱动，利用HTML、SVG和CSS生成多种复杂漂亮图表的库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基于JavaScript的新语言&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt; 借鉴了Ruby,Python等语法，代码直接转换为JavaScript源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JavaScript增强&lt;/h3&gt;
&lt;h4&gt;静态类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://roy.brianmckenna.org/&quot;&gt;Roy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; 静态类型的函数式语言，直接编译为HTML/CSS/JavaScript。&lt;a href=&quot;http://elm-lang.org/edit/examples/Intermediate/Clock.elm&quot;&gt;时钟&lt;/a&gt;，&lt;a href=&quot;http://elm-lang.org/edit/examples/Reactive/Transforms.elm&quot;&gt;交互&lt;/a&gt;，&lt;a href=&quot;http://elm-lang.org/edit/Examples.elm&quot;&gt;复杂页面&lt;/a&gt;，&lt;a href=&quot;http://elm-lang.org/Examples.elm&quot;&gt;更多实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Haskell资源</title>
                <link>http://freewind.in/posts/1340-haskell-resources</link>
                <pubDate>Tue, 01 Jan 2013 17:26:50 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1340</guid>
                <description><![CDATA[&lt;h3&gt;书籍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;Learn You a Haskell for Great Good&lt;/a&gt; 评价很高的一本Hashell书籍，免费提供在线版。&lt;a href=&quot;http://learnyouahaskell-zh-tw.csie.org/&quot;&gt;繁体中文版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Flex资源</title>
                <link>http://freewind.in/posts/1339-flex-resources</link>
                <pubDate>Tue, 01 Jan 2013 17:26:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1339</guid>
                <description><![CDATA[&lt;h3&gt;教学资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-02-2009/jw-02-actionscript1.html?page=1&quot;&gt;ActionScript for Java developers1&lt;/a&gt;, &lt;a href=&quot;http://www.javaworld.com/javaworld/jw-03-2009/jw-03-actionscript2.html&quot;&gt;2&lt;/a&gt; Java程序员必看&lt;em&gt;   &lt;a href=&quot;http://www.flexafterdark.com/&quot;&gt;FlexAfterDark&lt;/a&gt; 非常好的教学文档，清晰简洁&lt;/em&gt;   &lt;a href=&quot;http://understandingflex.com/&quot;&gt;Understanding Flex&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;示例与源代码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.adobe.com/devnet/flex/tourdeflex.html&quot;&gt;Tour de Flex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dlgsoftware.com/dataExplorer/dataExplorer.html&quot;&gt;World Data Explorer&lt;/a&gt;: &lt;a href=&quot;http://www.dlgsoftware.com/dataExplorer/srcview/index.html&quot;&gt;Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dlgsoftware.com/ftt/ftt.html&quot;&gt;Flex3 Tips and Traps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dlgsoftware.com/fttdatabrowser/fttdatabrowser.html&quot;&gt;FTT Data Browser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dlgsoftware.com/flexex/FlexEx.html&quot;&gt;Flex Explorations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dlgsoftware.com/flexexrenderers/FlexExrenderers.html&quot;&gt;Flex Data Presentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;皮肤相关&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://help.adobe.com/en_US/flex/using/WSA95C9644-B650-4783-B5C0-D2C7F95A23E3.html&quot;&gt;Skinning Spark components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart 可选类型 (Optional Types in Dart)</title>
                <link>http://freewind.in/posts/1337-dart-optional-types</link>
                <pubDate>Tue, 01 Jan 2013 17:24:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1337</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是唐古拉山itang 2012-07-27)&lt;/p&gt;
&lt;p&gt;http://www.dartlang.org/articles/&lt;/p&gt;
&lt;p&gt;作者 Gilad Bracha&lt;/p&gt;
&lt;p&gt;2011 十月 &lt;a href=&quot;http://www.dartlang.org/articles/optional-types/&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dart最大的创新之一是对可选类型（optional type）的使用。这篇文档旨在诠释可选类型是怎么工作的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;内容&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://shuzu.org:9000/dart/books/articles-and-tutorials/articles/5011364fe4b0d1017825aad7#Overview&quot;&gt;概貌&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://shuzu.org:9000/dart/books/articles-and-tutorials/articles/5011364fe4b0d1017825aad7#section2&quot;&gt;静态检查器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://shuzu.org:9000/dart/books/articles-and-tutorials/articles/5011364fe4b0d1017825aad7#section3&quot;&gt;类型Dynamic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://shuzu.org:9000/dart/books/articles-and-tutorials/articles/5011364fe4b0d1017825aad7#section4&quot;&gt;范型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://shuzu.org:9000/dart/books/articles-and-tutorials/articles/5011364fe4b0d1017825aad7#section5&quot;&gt;受检模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://shuzu.org:9000/dart/books/articles-and-tutorials/articles/5011364fe4b0d1017825aad7#section6&quot;&gt;使用类型&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;概貌&lt;/h5&gt;
&lt;p&gt;Dart语言是动态类型的。你可以写没有任何类型标注的程序，然后运行之， 跟在JavaScript里一样。&lt;/p&gt;
&lt;p&gt;你也可以选择添加类型标注到你的程序里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加类型不会阻止你的程序编译和运行 - 甚至你标注的是不完整的或者完全错的。*   你的程序将有一样准确的语义， 不管你加不加类型标注&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;增加类型标注到代码里还是有益处的。类型提供了一下的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给人准备了文档。如果合理的放置类型标注，让人更容易阅读你的代码。&lt;em&gt;   给机器准备了文档。工具能够在各种方式下利用好类型标注。尤其是他们能帮忙完成一些漂亮的功能，如IDE下的代码自动完成和改进导航。&lt;/em&gt;   早期的错误检测。Dart提供了一个静态检查器，它能就潜在的问题给出警告， 不会阻止你前行。另外，在开发模式下，Dart自动转换类型标注为辅助调试的运行时断言检查。*   有时，在编译为JavaScript时类型能帮助改进性能。这个我们待会再详细说说。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;静态检查器&lt;/h5&gt;
&lt;p&gt;静态检查器扮演的角色跟C语言的lint很像。编译时给出关于潜在问题的警告信息。很多警告是跟类型相关的。静态检查器_不会_产生错误，就是说你能一直编译和运行你的代码，而不用管检查器给出的结果如何。&lt;/p&gt;
&lt;p&gt;这个检查器对每种可能的类型违反都不会如邻大敌。它不是一个类型检查器(typechecker)， Dart使用类型的方式跟传统的类型系统就不一样。检查器只会抱怨可能真的会出现的问题， 但是不会让你为了满足这个narrow-minded类型系统而让你赴汤蹈火。&lt;/p&gt;
&lt;p&gt;例如， 考虑以下下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String s1 = &apos;9&apos;;
String s2 = &apos;1&apos;;
...
int n = s1 + s2;  // 译者注(1)
print(n);

这里存在一个明显的问题。静态检查器在这种情况下也会发出一个警告。该注意的是这段代码能照常运行(译者注：受检模式下将抛出异常），将`n`设置`‘91’`和打印出`91`。

然而，还有不像一个典型的强制类型系统的，代码如下：

Object lookup(String key) {...} // a lookup method in a heterogenous table
String s = lookup(&apos;Frankenstein&apos;);

以上代码的问题检查器是熟试无睹的。这是因为，尽管缺少类型信息，这段代码（译注：运行逻辑上）极有可能是正确的。像我们作为程序员，经常是具备一些语义方面的认识， 但是类型检查器不会。你知道通过&apos;Frankenstein&apos; 查存储的表所得的值是一个字符串，就算lookup方法申明返回的是`Object`。

##### 类型Dynamic

当不提供类型时Dart如何避免抱怨？这里的关键就是类型`Dynamic`，它是程序员没有显示指明类型时的默认类型。使用类型``Dynamic`让检查器不会再多管闲事。

有时，你会希望明确的使用`Dynamic`。

Map&amp;lt;String, Dynamic&amp;gt; m = {
  &apos;one&apos;: new Partridge(),
  &apos;two&apos;: new TurtleDove(),
  ...,
  &apos;twelve&apos;: new Drummer()
};

此处，我们也可以为`m`变量声明`Map&amp;lt;String, Object&amp;gt;`类型， 但是， 当我们去访问m的内容时，它具有了静态类型`Object`, 这样暴露给我们的东西很少了。这是因为map的内容只有通过`Object`的接口， 所以我们可能更倾向用`Dynamic`。如果我们试图调用map值的方法， 如下所示：

pearTree = m[&apos;one&apos;].container();

如果&apos;one&apos;对应的值是Object类型，那么将得到警告信息，因为`Object`不支持container方法。 如果使用类型`Dynamic`, 警告就自动消除了。

##### 泛型

Dart支持物化泛型。就是说，泛型类型的对象们在运行时持有它们的类型参数。将类型参数传给泛型类型的构造器是一个运行时操作。那么泛型跟声称的类型可选如何共存呢？

好吧，如果你对类型想都不想去想， 泛型也不会强迫你什么。你能泛型类的实例而不用提供类型参数。例如：

new List();

工作得也好。当然，你可以这样写：

new List&amp;lt;String&amp;gt;();

如你所想。而

new List();

是以下这个的简写形式

new List&amp;lt;Dynamic&amp;gt;();

在构造器中，类型参数充当运行时角色。他们实际上是在运行时传递的，所以当你做动态类型判定时你能使用他们。

new List&amp;lt;String&amp;gt;() is List&amp;lt;Object&amp;gt; // true: 所有的字符串都是对象
new List&amp;lt;Object&amp;gt;() is List&amp;lt;String&amp;gt; // false: 不是所有的对象都是字符串

在Dart里，泛型是符合程序员直觉的。这里有一些更有趣的示例：

new List&amp;lt;String&amp;gt;() is List&amp;lt;Int&amp;gt; // false
new List&amp;lt;String&amp;gt;() is List      // true
new List&amp;lt;String&amp;gt;() is List&amp;lt;Dynamic&amp;gt; // 跟上面一样
new List() is List&amp;lt;Dynamic&amp;gt;     // true, 他们是完全一样的

相比之下，类型标注（例如,类型添加到变量的声明， 或者作为函数和方法的返回类型）扮演的是非运行时角色，而且不会影响程序语义。还有一个示例值得学习：

new List() is List&amp;lt;String&amp;gt;      // 也是true

你可能写程序不带类型，但是你经常将数据传递到的是带类型的库里。避免类型带来的干扰， 泛型不带类型参数的被视为相应的任意泛型版本的子类型。

##### 受检模式

在开发阶段， Dart程序可以以受检模式（Checked mode）运行。

如果在受检模式下运行程序，系统将自动执行某种类型检查，诸如在传递参数时，返回结果时，执行赋值时。如果检查失败， 执行将在那个点停止，并给出清晰的错误信息。所以，

String s = new Object();

将停止代码的继续执行， 因为`Object`不是`String`的子类型。然而

Object foo(){ return &quot;x&quot;; }
String s = foo();

工作得却很好， 因为foo实际返回的对象类型在运行时类型就是`String`, 虽然foo的类型签名说返回的是一个`Object`。当一个对象分配给一个变量时, Dart会检查对象的运行时类型是不是变量声明（静态）类型的子类型。

本质上， 受检模式就像在带有观察点的调试器下运行你的程序，它会在每次赋值，返回值等情况下进行子类型的检查。看下面更多的例子：

&amp;lt;int&amp;gt;[0,1,1][2] = new Object(); // 受检模式下失败

bar(int n) { return n * 2; }
...
bar(3.2); //产品模式下返回6.4, 受检模式下失败

在受检模式下，每次当一个参数传给一个函数， 参数的类型会被检查，看它是否是形参声明的类型的子类型。我们能轻松的写出正确的代码：

bar(num n) { return n * 2; }
...
bar(3.2); // 工作正常

int i_bar(num n) { return n * 2; }
...
i_bar(3.2); // 受检模式下失败， 因为返回的值不是一个整形int

注意最后一行。类型检查在返回值那一刻起作用， 就算函数的返回值没有分配给任意变量。

让我们再回到老朋友Frankenstein那里。

Object lookup(String key) {...} // 查表
String s = lookup(&apos;Frankenstein&apos;);

如果正如我们预想的那样，lookup方法返回一个字符串，受检模式将顺利的执行下去。如果我们错了， 它会捕获错误抛给我们。 在产品模式下， 这份代码正常运行，没有异样。假定lookup实际上是返回类`Frankenstein`的一个实例， 不是一个字符串，这是变量s仍然持有这个实例。Dart不会在任何情况下试图用魔法将它转换为一个字符串。如果它这样做了，那意味着类型标注改变了我们程序的行为，而且类型不在是可选的了。

当然， 如果你根本就没用类型，受检模式也不会当你的路。

my_add(s1, s2) { return s1 + s2; }

my_add(3, 4); // 7
my_add(&quot;3&quot;, &quot;4&quot;); // &quot;34&quot;

所有这些检查造成可观的性能损失， 所以在生产环境下这是一种不可接受的负担。 这些检查带来的好处是可以跟踪动态类型错误，帮助更好的调试中存在的问题。这些问题中的大部分通过各种测试可以侦测到， 但是受检模式帮助定位他们。

##### 使用类型

怎么用类型取决于你自己。如果你讨厌类型，你根本不需要用它们。你也不会得到任何类型警告， 并且你能在这种开发方式下获得跟其他动态语言下那种舒服的感觉。你也可以从类型中受益， 因为Dart库有类型签名， 能告诉它们所需要的和所返回的。如果你在受检模式下运行，给库传递了错误的参数， 受检模式能侦测你犯错误的点。

如果你喜欢类型，你可以在任何地方使用它们，这就像在静态类型语言中一样。然而，尽管你获取不到同静态类型检查一样的级别。Dart的规则更宽松。我们预期里会提供一些额外的工具来，让解释类型变得跟严格， 满足喜欢它们的人的口味。

我们不推荐走极端化。在合适的地方使用类型。你能做的最有价值的事情是在你的库的公开成员上面加上类型。再下一步，在私有成员上做同样的事情。就算没专人维护的代码，你会发现当你留下一堆代码，几周或几个月之后你再反过头来看它们的时候，就能知道它带来的帮助。在这两种情况下， 你不一定必须将类型添加到方法体或函数体里。 类型签名总能给库的使用者带来价值， 即使他们不是100％准确。

在函数体里面，可能不需要过于关于类型标注的声明。有时， 代码本来就很简单，类型不是真正的问题所在， 反而像来搅局的。

通常的， 你应该专注设计， 不让它受类型方面的考虑所影响。例如， 在需要传函数名字符串的地方用传函数代替 这使你的代码更有效更方便类型检查。Dart不鼓励无节制的使用反射。然而， 当真正需要反射的时候， 你应该毫不豫犹的用它。

###### 译者注：

1、 Dart is removing support for concatenating strings with the + operator， 此段代码可以改写如下：

int n = “${s1}${s2}&quot;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart资源</title>
                <link>http://freewind.in/posts/1336-dart-resources</link>
                <pubDate>Tue, 01 Jan 2013 17:23:43 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1336</guid>
                <description><![CDATA[&lt;h3&gt;开源项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://rikulo.org/&quot;&gt;rikulo&lt;/a&gt; Rikulo is a free and open source framework for creating incredible cross-platform web and native mobile applications in Dart &amp;amp; HTML5.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;网站与资源&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dartlang.org/&quot;&gt;dart官网&lt;/a&gt; &lt;a href=&quot;http://www.dartlang.org/downloads.html&quot;&gt;下载&lt;/a&gt;, &lt;a href=&quot;http://www.dartlang.org/docs/spec/&quot;&gt;语言规范&lt;/a&gt;, &lt;a href=&quot;http://www.dartlang.org/docs/editor/&quot;&gt;编辑器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.dartwatch.com/&quot;&gt;dart-watch&lt;/a&gt; 有名的与dart相关的新闻与文章网站*   &lt;a href=&quot;http://c.dart-examples.com/learn&quot;&gt;dart教程&lt;/a&gt; dart教程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优秀项目&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dartlang.org/docs/pub-package-manager&quot;&gt;pub&lt;/a&gt; dart官方实现的包管理器*   &lt;a href=&quot;https://github.com/bp74/dartflash&quot;&gt;dartflash&lt;/a&gt; 用dart和html5来实现了Flash的API&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dartflash.com/apps/escape/escape.html&quot;&gt;Escape游戏&lt;/a&gt; 使用dartflash实现的一个游戏。本来是用flash写的，但在6个小时内就改成了html5版本，并且速度到达60fps，这是在flash中是不可想像的&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>推荐一个能解析github风格代码块的javascript markdown库</title>
                <link>http://freewind.in/posts/1335-javascript-markdown-lib-github-style</link>
                <pubDate>Tue, 01 Jan 2013 17:23:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1335</guid>
                <description><![CDATA[&lt;p&gt;Markdown的标准语法中，对于代码块，使用“在每行行首添加4个空格”的方式来表示。&lt;/p&gt;
&lt;p&gt;但这种方式对于长的代码块不太方便，因为我们常常需要手动调整缩进。而如果使用以下方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
my code
```

则会方便很多。

推荐：

[https://github.com/chjj/marked](https://github.com/chjj/marked)

可同时用于服务器端和浏览器端。

浏览器端使用方法如下：

下载[https://github.com/chjj/marked/raw/master/lib/marked.js放入本地并导入到html中，然后：](https://github.com/chjj/marked/raw/master/lib/marked.js%E6%94%BE%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%B9%B6%E5%AF%BC%E5%85%A5%E5%88%B0html%E4%B8%AD%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%9A)

var html = marked.parser(marked.lexer(input));
alert(html);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;weakish&lt;/h3&gt;
&lt;p&gt;var html = marked.parser(marked.lexer(input));&lt;/p&gt;
&lt;p&gt;好像直接marked(input)就可以&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>6 .权限控制</title>
                <link>http://freewind.in/posts/1334-play1-guide-6-secure-module</link>
                <pubDate>Tue, 01 Jan 2013 17:22:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1334</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是胡波)&lt;/p&gt;
&lt;h3&gt;权限控制&lt;/h3&gt;
&lt;p&gt;有了管理员模块后，我们需要对其进行权限控制。幸运的是，Play已经有个现成的Module——那就是Secure。&lt;/p&gt;
&lt;h4&gt;启用Secure module&lt;/h4&gt;
&lt;p&gt;要想启用Secure module，编辑配置文件 &lt;strong&gt;yabe/conf/application.conf&lt;/strong&gt; 并重启应用程序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Import the secure module
module.secure=${play.path}/modules/secure

重启之后，Play应该会自动加载此Module。

Secure module的配置文件实际上就是Play的配置文件**yabe/conf/routes**，默认配置如下 (当然我们也可以自定义规则):

# Import Secure routes
*       /                                       module:secure

#### 有权限的访问Admin Module

Secure Module提供了一个Secure Controller的基类，继承它的子类都可以设置有权限的访问。但是Java只允许单重继承，如果你还想继承其他父类就比较麻烦。

出了继承以为，Secure还提供了一个标注@With来限定哪些Controller在调用时触发相应的安全机制，请看下述代码：

package controllers;

import play.*;
import play.mvc.*;

@With(Secure.class)
public class Posts extends CRUD {    
}

对于Comment，User以及Tag的Controller，我们都可以这样设置。

现在，如果你直接访问Admin，会自动跳转到一个登录界面：

[![image](/user_images/1334-1.png &quot;image&quot;)](/user_images/1334-1.png)

实际，你现在可以输入任何用户名和密码，后台暂时没有任何验证。

#### 自定义验证处理

Play有内置的验证类Secure.Security类，继承后即可自定义验证处理。接下来我们就来创建自己的验证类来判断用户名和密码是否正确。

创建 **yabe/app/controllers/Security.java** 文件，并且覆盖父类的authenticated() 方法：

package controllers;

import models.*;

public class Security extends Secure.Security {

    static boolean authenticate(String username, String password) {
        return true;
    }

}

因为之前我们已经有了User类，很容易就可以实现这个方法：

static boolean authenticate(String username, String password) {
    return User.connect(username, password) != null;
}

先注销当前会话 [http://localhost:9000/logout](http://localhost:9000/logout) ，让后用先前inital-data.yml导入的测试数据中随便选一个用来测试，这里我用的是 bob@gmail.com/secret.

#### 重构Admin部分

最初的Admin部分用的是现成的CRUD Module, 但是它的UI不能很好的融合到我们的Blog中。因此，我们要开发一个新的Admin模块，允许每个作者管理自己发的帖子，而超级用户则可以进行任何操作（**注意：以下都是基于用户登录成功后的操作**）。

现在先来创建一个Admin Controller:

package controllers;

import play.*;
import play.mvc.*;

import java.util.*;

import models.*;

@With(Secure.class)
public class Admin extends Controller {

    @Before
    static void setConnectedUser() {
        if(Security.isConnected()) {
            User user = User.find(&quot;byEmail&quot;, Security.connected()).first();
            renderArgs.put(&quot;user&quot;, user.fullname);
        }
    }

    public static void index() {
        render();
    }

}

接下来，修改 **yabe/conf/routes** 文件：

# Administration
GET     /admin/?                                Admin.index
*       /admin                                  module:crud

注意routes文件中的URL顺序。第一行是用来匹配HTTP的GET请求，同时也表示映射到Admin Controller的请求第一行的优先级高于第二行。这样的话/admin/?下的所以请求都得经过Admin.index, 而/admin则用的是CRUD.index.

修改模板 **yabe/app/views/main.html**, 增加超链接&apos;Log in to write something&apos;：

…
&amp;lt;ul id=&quot;tools&quot;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;a href=&quot;@{Admin.index()}&quot;&amp;gt;Log in to write something&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
…

最后一步就是创建新的模板 **yabe/app/views/Admin/index.html**, 来显示登录成功后的信息：

Welcome ${user}!

现在回到blog的主页，点击&apos;Log in to write something&apos;, 你就可以看到下面的欢迎页：

[![image](/user_images/1334-3.png &quot;image&quot;)](/user_images/1334-3.png)

看到了吗？ 好样的。但是因为我们的Admin模块会有很多新的页面，我们需要一个admin的layout模板，马上来创建**yabe/app/views/admin.html** 文件：

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;Administration&amp;lt;/title&amp;gt;        
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&amp;gt;
        #{get &apos;moreStyles&apos; /}    
        &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; 
                href=&quot;@{&apos;/public/stylesheets/main.css&apos;}&quot; /&amp;gt;
        &amp;lt;link rel=&quot;shortcut icon&quot; type=&quot;image/png&quot; 
                href=&quot;@{&apos;/public/images/favicon.png&apos;}&quot; /&amp;gt;
        &amp;lt;script src=&quot;@{&apos;/public/javascripts/jquery-1.4.2.min.js&apos;}&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script src=&quot;@{&apos;/public/javascripts/jquery.tools-1.2.5.toolbox.expose.min.js&apos;}&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body id=&quot;admin&quot;&amp;gt;

        &amp;lt;div id=&quot;header&quot;&amp;gt;
            &amp;lt;div id=&quot;logo&quot;&amp;gt;
                yabe. &amp;lt;span&amp;gt;administration&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;ul id=&quot;tools&quot;&amp;gt;
                &amp;lt;li&amp;gt;
                    &amp;lt;a href=&quot;@{Secure.logout()}&quot;&amp;gt;Log out&amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div id=&quot;main&quot;&amp;gt;
            #{doLayout /} 
        &amp;lt;/div&amp;gt;

        &amp;lt;p id=&quot;footer&quot;&amp;gt;
            Yabe is a (not so) powerful blog engine built with the 
            &amp;lt;a href=&quot;http://www.playframework.org&quot;&amp;gt;Play framework&amp;lt;/a&amp;gt;
            as a tutorial application.
        &amp;lt;/p&amp;gt;

    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

正如你看到，这个模板已经非常接近blog前端所用的模板了。接下来把URL login改成URL logout，注意这里用的是Secure Model的自带logout。

最后修改 **yabe/app/views/Admin/index.html**， 将admin模板套用上：

#{extends &apos;admin.html&apos; /}

Welcome ${user}!

立即刷新！

[![image](/user_images/1334-5.png &quot;image&quot;)](/user_images/1334-5.png)

如果你点击了logout, 浏览器会重新跳转会登录界面：

[![image](/user_images/1334-7.png &quot;image&quot;)](/user_images/1334-7.png)

那个注销是SecureModule默认的处理方式。当然如果想自定义的话，只要覆盖controllers.Security类中的onDisconnected()方法即可：

static void onDisconnected() {
    Application.index();
}
You can do the same for the onAuthenticated() event:

static void onAuthenticated() {
    Admin.index();
}

#### 添加角色

实际上Admin模块有两块：一块是一些简单的编辑用户，另一块则是超级用户了。回过头看看User类，你会发现我们准备了一个叫isAdmin的字段，它可以标示那些用户拥有超级用户的权限。

Secure Model不仅仅提供权限验证，还可以对授权进行管理。这个称之为profiles。如何创建属于Admin的profile呢，只需要覆盖controllers.Security类的check()方法即可：

static boolean check(String profile) {
    if(&quot;admin&quot;.equals(profile)) {
        return User.find(&quot;byEmail&quot;, connected()).&amp;lt;User&amp;gt;first().isAdmin;
    }
    return false;
}

接下来我们修改layout页面**app/views/admin.html**，将Admin的操作菜单保护起来：

...
&amp;lt;div id=&quot;main&quot;&amp;gt;

    &amp;lt;ul id=&quot;adminMenu&quot;&amp;gt;
        &amp;lt;li class=&quot;${request.controller == &apos;Admin&apos; ? &apos;selected&apos; : &apos;&apos;}&quot;&amp;gt;
            &amp;lt;a href=&quot;@{Admin.index()}&quot;&amp;gt;My posts&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        #{secure.check &apos;admin&apos;}
            &amp;lt;li class=&quot;${request.controller == &apos;Posts&apos; ? &apos;selected&apos; : &apos;&apos;}&quot;&amp;gt;
                &amp;lt;a href=&quot;@{Posts.list()}&quot;&amp;gt;Posts&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;${request.controller == &apos;Tags&apos; ? &apos;selected&apos; : &apos;&apos;}&quot;&amp;gt;
                &amp;lt;a href=&quot;@{Tags.list()}&quot;&amp;gt;Tags&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;${request.controller == &apos;Comments&apos; ? &apos;selected&apos; : &apos;&apos;}&quot;&amp;gt;
                &amp;lt;a href=&quot;@{Comments.list()}&quot;&amp;gt;Comments&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;${request.controller == &apos;Users&apos; ? &apos;selected&apos; : &apos;&apos;}&quot;&amp;gt;
                &amp;lt;a href=&quot;@{Users.list()}&quot;&amp;gt;Users&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        #{/secure.check}
    &amp;lt;/ul&amp;gt;

    #{doLayout /} 
&amp;lt;/div&amp;gt;
...

注意上述页面使用了#{secure.check /}来保证只有当拥有Admin权限的用户才可以看到。

[![image](/user_images/1334-9.png &quot;image&quot;)](/user_images/1334-9.png)

回过头看看继承CRUD的Controller，这部分还没有任何验证。如果有人知道URL，就可以直接进入。要保护这些controllers，我们照样可以使用标注@Check，以下就是对Posts controller的修改：

package controllers;

import play.*;
import play.mvc.*;

@Check(&quot;admin&quot;)
@With(Secure.class)
public class Posts extends CRUD {    
}

像Tags, Comments和Users controllers都可以类似处理。现在直接访问URL[http://localhost:9000/admin/users](http://localhost:9000/admin/users) 看看，出现403了，证明验证有效。

[![image](/user_images/1334-11.png &quot;image&quot;)](/user_images/1334-11.png)

#### 自定义 CRUD layout

因为CRUD Model有自带的layout，所以当我们访问继承CRUD的controllers，是无法继承我们编写的admin.html layout。现在我们就来改变这一切。在Play命令行输入：

play crud:ov --layout

系统会生成自动生成 **/yabe/app/views/CRUD/layout.html** 文件. 修改里面的内容，将我们的 admin.html layout 融入其中：

#{extends &apos;admin.html&apos; /}
#{set &apos;moreStyles&apos;}
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; 
        href=&quot;@{&apos;/public/stylesheets/crud.css&apos;}&quot; /&amp;gt;
#{/set}

&amp;lt;div id=&quot;crud&quot;&amp;gt;

    #{if flash.success}
        &amp;lt;div class=&quot;crudFlash flashSuccess&quot;&amp;gt;
            ${flash.success}
        &amp;lt;/div&amp;gt;
    #{/if}
    #{if flash.error || error}
        &amp;lt;div class=&quot;crudFlash flashError&quot;&amp;gt;
            ${error ?: flash.error}
        &amp;lt;/div&amp;gt;
    #{/if}

    &amp;lt;div id=&quot;crudContent&quot;&amp;gt;
        #{doLayout /}
    &amp;lt;/div&amp;gt;

&amp;lt;/div&amp;gt;

这里我们还是复用curd.css样式，不做大的改动。再次访问该页面，会发现已经和我们的admin layout整合在一起了：

[![image](/user_images/1334-13.png &quot;image&quot;)](/user_images/1334-13.png)

[![image](/user_images/1334-15.png &quot;image&quot;)](/user_images/1334-15.png)

#### 修改登录页的样式

Admin模块的样式已经基本一致了。最后我们来完善登录页面的样式。要自定义样式非常简单，用Play在命令行运行：

play secure:ov --css

这里我们不修改生成的 **yabe/public/stylesheets/secure.css** 样式文件，而是将mains.css 导入其中：

@import url(main.css);
…

最后别忘了在资源文件**yabe/conf/messages**中加入新的键值：

secure.username=Your email:
secure.password=Your password:
secure.signin=Log in now
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后刷新看效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1334-17.png&quot;&gt;&lt;img src=&quot;/user_images/1334-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>5. 创建验证码</title>
                <link>http://freewind.in/posts/1315-play1-guide-5-create-captcha</link>
                <pubDate>Tue, 01 Jan 2013 17:17:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1315</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是wersion)&lt;/p&gt;
&lt;h3&gt;创建验证码&lt;/h3&gt;
&lt;p&gt;因为任何人都可以提交一个评论到我们的博客引擎，我们应该稍微保护它避免自动垃圾邮件。保护表单防止这情况的一种简单的方法就是添加一个验证码 图像（captcha image）。&lt;/p&gt;
&lt;h3&gt;生成验证码图像&lt;/h3&gt;
&lt;p&gt;我们将开始看到如何使用Play简单地生成一个验证码图像。基本说来，我们仅仅会使用其他的行为，除了将返回一个二进制流而不是我们目前已经返回的HTML响应之外。 既然Play是一个全堆栈型的web框架，我们尝试把内置构造包含到web应用的大多数典型的需求中；生成验证码就是应用中的一种。我们可以使用&lt;code&gt;play.libs.Images&lt;/code&gt; 辅助包简单地生成一个验证码图像，然后把它写入http响应中。&lt;/p&gt;
&lt;p&gt;如往常一样，我们将从一个简单的实现开始。添加captcha 行为到应用控制器中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void captcha() {
    Images.Captcha captcha = Images.captcha();
    renderBinary(captcha);
}

注意，我们可以直接地传递captcha对象到renderBinary()方法，因为这Images.Captcha类实现了java.io.InputStream。

### 别忘了导入 `play.libs.*`.

现在添加一个新路由到/yabe/conf/routes文件:

GET     /captcha                                Application.captcha

然后通过打开[http://localhost:9000/captcha尝试下这个验证码行为。](http://localhost:9000/captcha尝试下这个验证码行为。)

[![image](/user_images/1315-1.png &quot;image&quot;)](/user_images/1315-1.png)

每次刷新，它将会生成一个随机文本。

### 我们如何管理它的状态？

直到现在它还是简单的，但是最复杂的部分马上就要来了。为了验证这验证码，我们需要把已写入到这个验证码图像某处的随即文本保存起来，然后在表单提交的时候再检查下。

当然，我们仅能在图像生成的时候把文本放入到用户会话中，然后等以后再获取它。但是这种方案有2个污点：

第一，Play 会话作为一个cookie被存储。依据结构体系，它解决了大量的问题，但是它还有很多的意义。写入会话cookie的数据都被签名了（因此用户就不能修改它们）但却没有被加密。假如我们把这个验证码的代码写入这会话中，那么任何人都可以通过读取会话cookie简单地解决它。

第二，记住，Play是一个无状态的框架。我们想在一种纯粹无状态的方式来管理这些事件。一般来说，假如一个用户用不同的验证码图像同时打开了2个不同的博客页面，这将会发生什么？我们对每个表单需要追踪它的验证码代码。

因此，解决这个问题我们需要2件事。我们将会把验证码密钥存储在服务端。因为这是些短暂的数据所以我们可以简单地使用这个play 缓冲数据（Play Cache）。除此之外，因为被缓冲的数据是有限的生命周期，所以它将会被加入多种安全机制（让我们说，一个验证码代码仅仅有效10mn）。接着，解决这代码之后，我们需要生成一个唯一id。这唯一id号将会作为一个隐藏域被添加到每个表单，然后隐式的指定一个已生成的验证码代码。

接着我们优雅地解决我们状态问题。

像这样修改验证码行为：

public static void captcha(String id) {
    Images.Captcha captcha = Images.captcha();
    String code = captcha.getText(&quot;#E4EAFD&quot;);
    Cache.set(id, code, &quot;10mn&quot;);
    renderBinary(captcha);
}

注意，`getText()`方法把任何颜色作为参数。它将会使用这种颜色去绘画文本。 别忘了导入`play.cache.*`。

### 为评论表单添加验证码图像

现在，在显示一个评论表单之前，我们将会生成一个唯一ID。接着，我们将修改html表单通过使用它的id使一个验证码图像完整，然后添加这个ID到另外的隐藏域。 让我们重写这个 `Application.show `行为：

public static void show(Long id) {
    Post post = Post.findById(id);
    String randomID = Codec.UUID();
    render(post, randomID);
}

接着，在`/yable/app/views/Application/show.html`模板的表单：

…
&amp;lt;p&amp;gt;
    &amp;lt;label for=&quot;content&quot;&amp;gt;Your message: &amp;lt;/label&amp;gt;
    &amp;lt;textarea name=&quot;content&quot; id=&quot;content&quot;&amp;gt;${params.content}&amp;lt;/textarea&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;label for=&quot;code&quot;&amp;gt;Please type the code below: &amp;lt;/label&amp;gt;
    &amp;lt;img src=&quot;@{Application.captcha(randomID)}&quot; /&amp;gt;
    &amp;lt;br /&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;code&quot; id=&quot;code&quot; size=&quot;18&quot; value=&quot;&quot; /&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;randomID&quot; value=&quot;${randomID}&quot; /&amp;gt;
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit your comment&quot; /&amp;gt;
&amp;lt;/p&amp;gt;
…

好棒的开始。现在，这个评论表单有了一个验证码图像了。 

[![image](/user_images/1315-3.png &quot;image&quot;)](/user_images/1315-3.png)

### 验证这个验证码

现在，我们仅需要去验证这个验证码。我们需要添加这个随机ID（randomID）作为一个隐藏域，对吗？因此，我们可以在postComment行为上获取它，然后从缓冲中获取有效的代码，最后，再和已提交的代码进行比较。

这并不难。让我们修改这个`postComment`行为：

public static void postComment(
        Long postId, 
        @Required(message=&quot;Author is required&quot;) String author, 
        @Required(message=&quot;A message is required&quot;) String content, 
        @Required(message=&quot;Please type the code&quot;) String code, 
        String randomID) 
{
    Post post = Post.findById(postId);
    validation.equals(
        code, Cache.get(randomID)
    ).message(&quot;Invalid code. Please type it again&quot;);
    if(validation.hasErrors()) {
        render(&quot;Application/show.html&quot;, post, randomID);
    }
    post.addComment(author, content);
    flash.success(&quot;Thanks for posting %s&quot;, author);
    Cache.delete(randomID);
    show(postId);
}

因为现在我们有了更多的错误信息，所以修改下我们在show.html模板上显示的错误方式（为是的话，我们将会显示第一个错误，而这就足够了）：

.. 
#{ifErrors}
    &amp;lt;p class=&quot;error&quot;&amp;gt;
        ${errors[0]}
    &amp;lt;/p&amp;gt;
#{/ifErrors}
…
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般来说，对于更加复杂的表单，错误信息都不会用这种方式进行管理，而是都被实例化到messages 文件并且每个错误别写入到相应的域中。 检验这验证码现在是功能齐全了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1315-5.png&quot;&gt;&lt;img src=&quot;/user_images/1315-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;非常棒！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>3. 构建第一个视图</title>
                <link>http://freewind.in/posts/1308-play1-guide-3-first-view</link>
                <pubDate>Tue, 01 Jan 2013 17:14:44 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1308</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是CQS)&lt;/p&gt;
&lt;h4&gt;构建第一个页面&lt;/h4&gt;
&lt;p&gt;现在我们已经建立了第一个数据模型,是时候去创建第一个应用页面了.这个页面将展示最新发的博文,同时也展示了旧的博文链接列表.&lt;/p&gt;
&lt;p&gt;下面这张图片就是我们要看的页面效果原型:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1308-1.png&quot;&gt;&lt;img src=&quot;/user_images/1308-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;用默认的数据引导程序&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;事实上，在写第一个页面前，我们需要做件事情先.写一个没有测试数据的网页应用是不爽的.你不能对你的应用做任何测试.因为我们不曾创建了博文发布的页面，所以我们不能自己发布博文.&lt;/p&gt;
&lt;p&gt;为了得到数据，我们可以在应用载入的时候,去载入一个fixture文件并读取默认的数据。为了执行这个操作，我们新建一个引导任务（Bootstrap Job）.一个Play任务(Job)即在任何Http 请求外执行一些操作，比如说在应用起始时或者间断性地执行周期任务.&lt;/p&gt;
&lt;p&gt;现在让我们创建&lt;code&gt;/yabe/app/Bootstrap.java&lt;/code&gt;任务去使用&lt;code&gt;Fixtures&lt;/code&gt;载入默认数据.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import play.*;
import play.jobs.*;
import play.test.*;

import models.*;

@OnApplicationStart
public class Bootstrap extends Job {

public void doJob() {
    // Check if the database is empty
        if(User.count() == 0) {
        Fixtures.loadModels(&quot;initial-data.yml&quot;);
        }
    }
}

我们用&amp;lt;code&amp;gt;@OnApplicationStart&amp;lt;/code&amp;gt;去注释这个Job是为了告诉Play在应用启动时并同步的执行这个任务.

&amp;gt; 事实上，Play 任务在DEV 和PROD 模式下是不同的.在Dev模式下，Play会等待第一个请求，才会启动应用.所以这个任务也会在第一次请求是同步执行.这种情况下，如果你的任务执行失败，你将在浏览器得到错误信息。在PROD模式下，这个任务会在应用开始就被执行（和`play run`命令同步）同时Play会在发生错误时阻止应用启动.

你需要在`/yabe/conf`目录下创建一个`initial-data.yml`文件.当然你也可以重新使用我们之前用来测试的数据内容`data.yml`.

现在用`play run`命令启动这个应用吧，在浏览器输入[http://localhost:9000/](http://localhost:9000/)查看页面.

#### 构建博客主页

* * *

这次，我们可是要真开始编写博客主页了.

你还记得第一个页面如何显示的吗？先在routes配置文件中规定`/` URL地址去调用`controller.Application.index()`action方法.然后这个方法会调用`render()`并执行`/yabe/app/views/Application/index.html`模板.

我们将保留这些组件，并填添加代码，让它们载入博文列表并展示.

打开`/yabe/app/controllers/Application.java`这个控制器(controller)文件并修改这个`index()`方法去载入博文列表,如下代码：

package controllers;

import java.util.*;

import play.*;
import play.mvc.*;

import models.*;

public class Application extends Controller {

    public static void index() {
        Post frontPost = Post.find(&quot;order by postedAt desc&quot;).first();
        List&amp;lt;Post&amp;gt; olderPosts = Post.find(
        &quot;order by postedAt desc&quot;
        ).from(1).fetch(10);
        render(frontPost, olderPosts);
    }

}

你看见如何传递对象给`render()`方法了吗？它允许对应的模板文件使用同名去读取对象。就这个例子而言，变量`frontPost`和`olderPosts`即可以在模板中使用.

打开模板`/yabe/app/views/Application/index.html`并修改去展示这些对象.

#{extends &apos;main.html&apos; /}
#{set title:&apos;Home&apos; /}

#{if frontPost}
    &amp;lt;div class=&quot;post&quot;&amp;gt;
    &amp;lt;h2 class=&quot;post-title&quot;&amp;gt;
        &amp;lt;a href=&quot;#&quot;&amp;gt;${frontPost.title}&amp;lt;/a&amp;gt;
    &amp;lt;/h2&amp;gt;
    &amp;lt;div class=&quot;post-metadata&quot;&amp;gt;
        &amp;lt;span class=&quot;post-author&quot;&amp;gt;by ${frontPost.author.fullname}&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;post-date&quot;&amp;gt;${frontPost.postedAt.format(&apos;MMM dd&apos;)}&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;post-comments&quot;&amp;gt;
            &amp;amp;nbsp;|&amp;amp;nbsp; 
            ${frontPost.comments.size() ?: &apos;no&apos;} 
            comment${frontPost.comments.size().pluralize()}
            #{if frontPost.comments}
                , latest by ${frontPost.comments[-1].author}
            #{/if}
        &amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;post-content&quot;&amp;gt;
        ${frontPost.content.nl2br()}
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

#{if olderPosts}
    &amp;lt;div class=&quot;older-posts&quot;&amp;gt;    
        &amp;lt;h3&amp;gt;Older posts &amp;lt;span class=&quot;from&quot;&amp;gt;from this blog&amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt;

        #{list items:olderPosts, as:&apos;oldPost&apos;}
            &amp;lt;div class=&quot;post&quot;&amp;gt;
                &amp;lt;h2 class=&quot;post-title&quot;&amp;gt;
                    &amp;lt;a href=&quot;#&quot;&amp;gt;${oldPost.title}&amp;lt;/a&amp;gt;
                &amp;lt;/h2&amp;gt;
                &amp;lt;div class=&quot;post-metadata&quot;&amp;gt;
                    &amp;lt;span class=&quot;post-author&quot;&amp;gt;
                        by ${oldPost.author.fullname}
                    &amp;lt;/span&amp;gt;
                    &amp;lt;span class=&quot;post-date&quot;&amp;gt;
                        ${oldPost.postedAt.format(&apos;dd MMM yy&apos;)}
                    &amp;lt;/span&amp;gt;
                    &amp;lt;div class=&quot;post-comments&quot;&amp;gt;
                        ${oldPost.comments.size() ?: &apos;no&apos;} 
                        comment${oldPost.comments.size().pluralize()}
                        #{if oldPost.comments}
                            - latest by     ${oldPost.comments[-1].author}
                        #{/if}
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        #{/list}
    &amp;lt;/div&amp;gt;

#{/if}

#{/if}

#{else}
&amp;lt;div class=&quot;empty&quot;&amp;gt;
    There is currently nothing to read here.
&amp;lt;/div&amp;gt;
#{/else}

你可以在Templates章节查看下模板是如何工作的.基本上，它允许你动态读取Java对象.我们使用Groovy驱动模板引擎.大部分简洁的构建正如你所见的如`?:`操作，都是来自Groovy.但是你并不需要去了解如何用Groovy写Play模板.如果你已经对其他模板语言例如JSP（用JSTL驱动)够熟悉的话，你就不用慌，够用了.

好的，现在可以刷新你的博客主页了.

[![image](/user_images/1308-3.png &quot;image&quot;)](/user_images/1308-3.png)

虽不靓，但已跑起.

不爽的是你发现你已经在码重复的代码了.因为我们展示多个形式的展示博文（完整的，完整带评论，博文摘要），我们将创建一个类函数的东西可以被多个模板调用.这个东西做的便是Play tag的职能。

创建一个标签，只需要在`/yabe/app/views/tags/`下创建一个`display.html`文件.标签其实另一种模板.它含有参数(像一个函数).这个`#{display/}`标签有两个参数:一个是要被展示的Post对象，另个是展示的模式(`home`，`teaser`，`full`三者之一).

*{ Display a post in one of these modes: &apos;full&apos;, &apos;home&apos; or &apos;teaser&apos; }*

&amp;lt;div class=&quot;post ${_as == &apos;teaser&apos; ? &apos;teaser&apos; : &apos;&apos;}&quot;&amp;gt;
&amp;lt;h2 class=&quot;post-title&quot;&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;${_post.title}&amp;lt;/a&amp;gt;
&amp;lt;/h2&amp;gt;
&amp;lt;div class=&quot;post-metadata&quot;&amp;gt;
    &amp;lt;span class=&quot;post-author&quot;&amp;gt;by ${_post.author.fullname}&amp;lt;/span&amp;gt;,
    &amp;lt;span class=&quot;post-date&quot;&amp;gt;${_post.postedAt.format(&apos;dd MMM yy&apos;)}&amp;lt;/span&amp;gt;
    #{if _as != &apos;full&apos;}
        &amp;lt;span class=&quot;post-comments&quot;&amp;gt;
            &amp;amp;nbsp;|&amp;amp;nbsp; ${_post.comments.size() ?: &apos;no&apos;} 
            comment${_post.comments.size().pluralize()}
            #{if _post.comments}
                , latest by ${_post.comments[-1].author}
            #{/if}
        &amp;lt;/span&amp;gt;
    #{/if}
&amp;lt;/div&amp;gt;
#{if _as != &apos;teaser&apos;}
    &amp;lt;div class=&quot;post-content&quot;&amp;gt;
        &amp;lt;div class=&quot;about&quot;&amp;gt;Detail: &amp;lt;/div&amp;gt;
        ${_post.content.nl2br()}
    &amp;lt;/div&amp;gt;
#{/if}
&amp;lt;/div&amp;gt;

#{if _as == &apos;full&apos;}
&amp;lt;div class=&quot;comments&quot;&amp;gt;
    &amp;lt;h3&amp;gt;
        ${_post.comments.size() ?: &apos;no&apos;} 
        comment${_post.comments.size().pluralize()}
    &amp;lt;/h3&amp;gt;

    #{list items:_post.comments, as:&apos;comment&apos;}
        &amp;lt;div class=&quot;comment&quot;&amp;gt;
            &amp;lt;div class=&quot;comment-metadata&quot;&amp;gt;
                &amp;lt;span class=&quot;comment-author&quot;&amp;gt;by ${comment.author},&amp;lt;/span&amp;gt;
                &amp;lt;span class=&quot;comment-date&quot;&amp;gt;
                    ${comment.postedAt.format(&apos;dd MMM yy&apos;)}
                &amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;comment-content&quot;&amp;gt;
                &amp;lt;div class=&quot;about&quot;&amp;gt;Detail: &amp;lt;/div&amp;gt;
                ${comment.content.escape().nl2br()}
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    #{/list}

&amp;lt;/div&amp;gt;
#{/if}

现在就可以使用Play标签去重写刚才那带有重复代码的主页了.

#{extends &apos;main.html&apos; /}
#{set title:&apos;Home&apos; /}

#{if frontPost}

#{display post:frontPost, as:&apos;home&apos; /}

#{if olderPosts.size()}

    &amp;lt;div class=&quot;older-posts&quot;&amp;gt;
        &amp;lt;h3&amp;gt;Older posts &amp;lt;span class=&quot;from&quot;&amp;gt;from this blog&amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt;

        #{list items:olderPosts, as:&apos;oldPost&apos;}
            #{display post:oldPost, as:&apos;teaser&apos; /}
        #{/list}
    &amp;lt;/div&amp;gt;

#{/if}

#{/if}

#{else}
&amp;lt;div class=&quot;empty&quot;&amp;gt;
    There is currently nothing to read here.
&amp;lt;/div&amp;gt;
#{/else}

刷新一下页面,页面OK.

#### 改善布局

* * *

正如你所见，`index.html`模板从`main.html`处继承。因为我们要提供一个通用的布局给所有带有博文标题和登录链接的博文页面，我们需要修改`main.html`文件。 编辑这个`/yable/app/views/main.html`文件

&amp;lt;!DOCTYPE html &amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;#{get &apos;title&apos; /}&amp;lt;/title&amp;gt;        
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; 
        href=&quot;@{&apos;/public/stylesheets/main.css&apos;}&quot; /&amp;gt;
    &amp;lt;link rel=&quot;shortcut icon&quot; type=&quot;image/png&quot; 
        href=&quot;@{&apos;/public/images/favicon.png&apos;}&quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;div id=&quot;header&quot;&amp;gt;
        &amp;lt;div id=&quot;logo&quot;&amp;gt;
            yabe.
        &amp;lt;/div&amp;gt;
        &amp;lt;ul id=&quot;tools&quot;&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;Log in to write something&amp;lt;/a&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
        &amp;lt;div id=&quot;title&quot;&amp;gt;
            &amp;lt;span class=&quot;about&quot;&amp;gt;About this blog&amp;lt;/span&amp;gt;
            &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;${blogTitle}&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
            &amp;lt;h2&amp;gt;${blogBaseline}&amp;lt;/h2&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div id=&quot;main&quot;&amp;gt;
        #{doLayout /} 
    &amp;lt;/div&amp;gt;

    &amp;lt;p id=&quot;footer&quot;&amp;gt;
        Yabe is a (not that) powerful blog engine built with the 
        &amp;lt;a href=&quot;http://www.playframework.org&quot;&amp;gt;Play framework&amp;lt;/a&amp;gt;
        as a tutorial application.
    &amp;lt;/p&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

刷新并确认结果.发现这个页面Ok了,除了`blogTitle`和`blogBaseline`这两个变量没有被正确显示。因为我们没有在`render(...)`中传递它们。当然我们可以在`index`action方法中的`render()`中添加.因为`main.html`文件被作为其他所有方法模板的基本模板，我并不乐意在每天调用时都传递这两个变量.

有一种方法可以执行同样的效果，即让contoller文件中的每个action都做同样的操作，只需定义一个`@Before`拦截方法。

我们添加一个`addDefaults()`方法到Application controller文件.

@Before
static void addDefaults() {
    renderArgs.put(&quot;blogTitle&quot;, Play.configuration.getProperty(&quot;blog.title&quot;));
    renderArgs.put(&quot;blogBaseline&quot;, Play.configuration.getProperty(&quot;blog.baseline&quot;));
}
&amp;gt; 你需要在`Application.java`文件中导入`play.Play`.

在`renderArgs`范围中添加的所有变量都可以被模板获取。你会发现这个方法从`Play.configuration`对象中读取这些变量值.而这个对象包含了`/yabe/conf/application.conf`文件中所有配置的键值(key).

在这个配置文件中添加两个键值:

# Blog engine configuration
# ~~~~~
blog.title=Yet another blog
blog.baseline=We will write about nothing

重新载入这个主页，确认它Ok了.

[![image](/user_images/1308-5.png &quot;image&quot;)](/user_images/1308-5.png)

#### 添加一些风格

* * *

现在这个博客主页差不多了，但是它并不美观。我们需要添加一些风格让它更美观些.你会发现这个main 模板文件`main.html`包含了`/public/stylesheets/maim.css`样式表.我们将保留这句话，并在CSS文件中添加样式.

你可以点击[这里](http://shuzu.org:9000/play/books/tutorial/articles/www.playframework.org/documentation/1.2.5/files/main.css)下载，然后复制内容到`/public/stylesheets/main.css`文件下.

刷新这个页面，你就可以看到样式化的页面了.

[![image](/user_images/1308-7.png &quot;image&quot;)](/user_images/1308-7.png)

#### 提交工作

* * *

现在这个主页完成了。和往常一样，我们需要提交这个博客版本到bazaar：

$ bzr st
$ bzr add
$ bzr commit -m &quot;Home page&quot;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>2. 数据模型(Data Model)</title>
                <link>http://freewind.in/posts/1299-play1-guide-2-data-model</link>
                <pubDate>Tue, 01 Jan 2013 17:11:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1299</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是胡波)&lt;/p&gt;
&lt;h3&gt;第一次亲密接触数据模型(Data Model)&lt;/h3&gt;
&lt;p&gt;让我们用model开始我们的blog之旅。&lt;/p&gt;
&lt;h4&gt;JPA概述&lt;/h4&gt;
&lt;p&gt;Model层在Play应用程序中可谓举足轻重，实际上所有细粒度的应用程序设计都是如此。对信息处理的应用程序来说，Model只是对特定领域的一种表述。举例来说，当我们想要创建一个Blog，Model层自然而然的包括诸如 User, Post 以及 Comment 这样的类文件。&lt;/p&gt;
&lt;p&gt;大多数情况下，一旦应用程序重启，内存中的model对象可能就不复存在了。若要想继续使用，必须存储到数据库里。通常选择的是关系型数据库，但Java本身是一门面向对象的编程语言，我们会去用ORM去减少两者之间的阻抗。&lt;/p&gt;
&lt;p&gt;JPA 是Java的持久层规范，它定义了一系列ORM的API接口。Play作为JPA的一个实现，底层实际上用的是闻名遐迩的Hibernate。使用JPA标准接口的一个好处就是，所有的&apos;mapping&apos;直接可以声明在Java对象里。&lt;/p&gt;
&lt;p&gt;如果你以前有用过Hibernate或JPA，你会惊讶Play竟然简化的如此神奇——无任何配置，JPA开箱即用。&lt;/p&gt;
&lt;p&gt;要是一点都不懂JPA的话，还是恶补一下再继续吧。&lt;/p&gt;
&lt;h4&gt;JPA概述&lt;/h4&gt;
&lt;p&gt;我们从创建一个User类开始我们的Blog之旅。文件路径为 &lt;strong&gt;/yabe/app/models/User.java&lt;/strong&gt;, 初次实现代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package models;

import java.util.*;
import javax.persistence.*;

import play.db.jpa.*;

@Entity
public class User extends Model {

    public String email;
    public String password;
    public String fullname;
    public boolean isAdmin;

    public User(String email, String password, String fullname) {
        this.email = email;
        this.password = password;
        this.fullname = fullname;
    }

}

标注 **@Entity** 表示此类为JPA托管的实体，而Play提供的父类Model又封装了一系列开箱即用的给力方法（稍后会说明）。

&amp;gt; 默认情况下，表的名字也是&apos;User&apos;。如果你所使用的数据库&apos;User&apos;是关键字的话（比如SQL Server），通过JPA的标注**@Table(name=“blog_user”)**指定一个新的表名即可。
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;pre&gt;&lt;code&gt;当然不是说非得继承Play的**play.db.jpa.Model**，也使用普通的JPA。不过继承Model有很多激动人心的扩展，能更加方便，容易的使用JPA未尝不是一件好事？

如果以前用过JPA，那么肯定知道每个实体都要求有个标注**@Id**来表示主键。这里我们继承的Model默认采用的是绝大多数适用的数据库自增ID。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里我要重申一下，这个Id字段是非业务性标识符，而只是个技术处理的手段。什么意思呢？我们不应该拿业务对象本身的Id作为主键，应该创建一个新的主键（可能是自增，序列或者哈希）来满足系统。因此，将两者的概念区分开来非常重要。（做过数据迁徙的童鞋，一定深有体会。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果你是一名有过Java开发经验的程序员，肯定会摆出一副不屑一顾，却又嗤之以鼻的姿态，然后开始大谈什么是OO，什么是封装——不要将成员变量公开化，应该通过get/set方法来访问他们。 实际上, Play会自动帮你创建get/set方法，在后面的章节中会谈到它具体怎么工作的。

现在刷新一下浏览器看看首页结果，如果不出意外的话，首页是没有任何变化的——尽管Play后台自动的编译、加载User类，但是对当前应用无任何影响。

#### 开始第一个测试

如何测试刚创建的User类呢？使用JUnit是不错的选择。它用一种渐进式的方法来边开发，边测试，最后确保所有方法都没问题。

想要进行单元测试，得用特殊的方式（测试模式）来启动你的应用程序。先停了当前的应用，在命令行重新输入：

~$ play test

[![image](/user_images/1299-1.png &quot;image&quot;)](/user_images/1299-1.png)

发现了吧，和运行模式差不多，只是多了个可以直接通过浏览器进行测试的模块。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在测试模式下运行，Play会自动切换Framework ID，并且从application.conf中加载对应的配置信息。猛击此处查看更多关于Framework ID的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用浏览器打开 [http://localhost:9000/@tests，看看测试用例。](http://localhost:9000/@tests%EF%BC%8C%E7%9C%8B%E7%9C%8B%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E3%80%82) 选择所有的默认测试用例并运行它们，应该会全亮绿色。实际上，默认的测试用例什么都没有做。

测试应用程序的Model，我们用的是JUnit。正如你所看到的，一个名为BasicTests.java的类文件已经创建好了，我们用下面的路径打开它： **(/yabe/test/BasicTest.java)**:

import org.junit.*;
import play.test.*;
import models.*;

public class BasicTest extends UnitTest {

    @Test
    public void aVeryImportantThingToTest() {
        assertEquals(2, 1 + 1);
    }

}

删掉默认没有意义的** (aVeryImportantThingToTest) **方法，创建一个新的方法来测试创建和读取User的操作：

@Test
public void createAndRetrieveUser() {
    // Create a new user and save it
    new User(&quot;bob@gmail.com&quot;, &quot;secret&quot;, &quot;Bob&quot;).save();

    // Retrieve the user with e-mail address bob@gmail.com
    User bob = User.find(&quot;byEmail&quot;, &quot;bob@gmail.com&quot;).first();

    // Test 
    assertNotNull(bob);
    assertEquals(&quot;Bob&quot;, bob.fullname);
}

看看，父类Model内置的save()和find()方法多给力。

想了解更多Model的内置方法，可以参考Play的JPA章节。

在重新选择 BasicTests.java 进行测试，看看结果是不是都是绿条。

现在我们需要做一个验证用户名和密码是否正确的功能。在User.java中加入新方法 connect():

public static User connect(String email, String password) {
    return find(&quot;byEmailAndPassword&quot;, email, password).first();
}

编写测试用例:

@Test
public void tryConnectAsUser() {
    // Create a new user and save it
    new User(&quot;bob@gmail.com&quot;, &quot;secret&quot;, &quot;Bob&quot;).save();

    // Test 
    assertNotNull(User.connect(&quot;bob@gmail.com&quot;, &quot;secret&quot;));
    assertNull(User.connect(&quot;bob@gmail.com&quot;, &quot;badpassword&quot;));
    assertNull(User.connect(&quot;tom@gmail.com&quot;, &quot;secret&quot;));
}

如果有修改到代码，你可以运行所有的测试用例保证代码没有因为你的改变而遭到破坏。

#### The Post class

Post类用来显示发表的内容，我们先来看看它的第一个实现版本：

package models;

import java.util.*;
import javax.persistence.*;

import play.db.jpa.*;

@Entity
public class Post extends Model {

    public String title;
    public Date postedAt;

    @Lob
    public String content;

    @ManyToOne
    public User author;

    public Post(User author, String title, String content) {
        this.author = author;
        this.title = title;
        this.content = content;
        this.postedAt = new Date();
    }

}

考虑到发表内容可能是大文本，我们使用了标注@Lob来进行存储。因为User和Post的关系是多对一，我们使用标注@ManyToOne进行关联。这样每个Post归属于一个User，一个User可以有多个Post。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最近的几个PostgreSQL版本即使你用了@Lob也不会存储字符串到数据库中。没关系，加上Hibernate的扩展标注&lt;strong&gt;@Type(type = “org.hibernate.type.TextType”).&lt;/strong&gt;就可以搞定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;现在我们来编写一个新的测试来看看Post类是否没问题。在测试之前，我们需要做些准备工作——因为每次的测试都会往数据库里写入新的记录。这对其它类似测试统计记录个数的方法会产生干扰，所以我们在JUnit的setup()方法中先删除整个数据库：

public class BasicTest extends UnitTest {

    @Before
    public void setup() {
        Fixtures.deleteDatabase();
    }

    …
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标注@Before是JUnit的核心概念之一，感兴趣的话可自己去查看JUnit相关资料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Fixtures帮助类是用来处理数据库与单元测试的枢纽。你可以再次运行，确保代码没有问题后，我们开始编写下一个测试：

@Test
public void createPost() {
    // Create a new user and save it
    User bob = new User(&quot;bob@gmail.com&quot;, &quot;secret&quot;, &quot;Bob&quot;).save();

    // Create a new post
    new Post(bob, &quot;My first post&quot;, &quot;Hello world&quot;).save();

    // Test that the post has been created
    assertEquals(1, Post.count());

    // Retrieve all posts created by Bob
    List&amp;lt;Post&amp;gt; bobPosts = Post.find(&quot;byAuthor&quot;, bob).fetch();

    // Tests
    assertEquals(1, bobPosts.size());
    Post firstPost = bobPosts.get(0);
    assertNotNull(firstPost);
    assertEquals(bob, firstPost.author);
    assertEquals(&quot;My first post&quot;, firstPost.title);
    assertEquals(&quot;Hello world&quot;, firstPost.content);
    assertNotNull(firstPost.postedAt);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;记得导入 java.util.List，否则无法通过编译。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 增加评论

最后我们要给我们的Blog增加评论的功能。

那么现在就开始来创建我们的Comment类吧：

package models;

import java.util.*;
import javax.persistence.*;

import play.db.jpa.*;

@Entity
public class Comment extends Model {

    public String author;
    public Date postedAt;

    @Lob
    public String content;

    @ManyToOne
    public Post post;

    public Comment(Post post, String author, String content) {
        this.post = post;
        this.author = author;
        this.content = content;
        this.postedAt = new Date();
    }

}

先速度来一个单元测试：

@Test
public void postComments() {
    // Create a new user and save it
    User bob = new User(&quot;bob@gmail.com&quot;, &quot;secret&quot;, &quot;Bob&quot;).save();

    // Create a new post
    Post bobPost = new Post(bob, &quot;My first post&quot;, &quot;Hello world&quot;).save();

    // Post a first comment
    new Comment(bobPost, &quot;Jeff&quot;, &quot;Nice post&quot;).save();
    new Comment(bobPost, &quot;Tom&quot;, &quot;I knew that !&quot;).save();

    // Retrieve all comments
    List&amp;lt;Comment&amp;gt; bobPostComments = Comment.find(&quot;byPost&quot;, bobPost).fetch();

    // Tests
    assertEquals(2, bobPostComments.size());

    Comment firstComment = bobPostComments.get(0);
    assertNotNull(firstComment);
    assertEquals(&quot;Jeff&quot;, firstComment.author);
    assertEquals(&quot;Nice post&quot;, firstComment.content);
    assertNotNull(firstComment.postedAt);

    Comment secondComment = bobPostComments.get(1);
    assertNotNull(secondComment);
    assertEquals(&quot;Tom&quot;, secondComment.author);
    assertEquals(&quot;I knew that !&quot;, secondComment.content);
    assertNotNull(secondComment.postedAt);
}

在这个测试用例中，我们发现Post和Comment关联关系不是很简单：在给Post加Comment之前，首先要得到所有的Comment对象。不过别急，要想简化的话，我们可以把在Post类中加入新的的关联关系：

给Post类增加新的属性comments，来实现双向关联：

...
@OneToMany(mappedBy=&quot;post&quot;, cascade=CascadeType.ALL)
public List&amp;lt;Comment&amp;gt; comments;

public Post(User author, String title, String content) { 
    this.comments = new ArrayList&amp;lt;Comment&amp;gt;();
    this.author = author;
    this.title = title;
    this.content = content;
    this.postedAt = new Date();
}
...

这里我们还是使用了JPA的标注@OneToMany，其中属性mappedBy表示用Comment类的post属性是控制端，负责关联关系的管理。当你定义了双向关联后，指定哪方来维护关联关系非常重要。在这个例子中，因为每一个Comment都属于一个Post，所以Comment上的post属性表示Comment于Post的反转关系。

我们还定了了级联删除 cascade=CascadeType.ALL。当我们删除Post时，级联下的Comment统统都会跟着一起删除。

有了新定义的关联关系，我们可以添加一个简化后的方法来为Post增加Comment：

public Post addComment(String author, String content) {
    Comment newComment = new Comment(this, author, content).save();
    this.comments.add(newComment);
    this.save();
    return this;
}

在来看看新的单元测试：

@Test
public void useTheCommentsRelation() {
    // Create a new user and save it
    User bob = new User(&quot;bob@gmail.com&quot;, &quot;secret&quot;, &quot;Bob&quot;).save();

    // Create a new post
    Post bobPost = new Post(bob, &quot;My first post&quot;, &quot;Hello world&quot;).save();

    // Post a first comment
    bobPost.addComment(&quot;Jeff&quot;, &quot;Nice post&quot;);
    bobPost.addComment(&quot;Tom&quot;, &quot;I knew that !&quot;);

    // Count things
    assertEquals(1, User.count());
    assertEquals(1, Post.count());
    assertEquals(2, Comment.count());

    // Retrieve Bob&apos;s post
    bobPost = Post.find(&quot;byAuthor&quot;, bob).first();
    assertNotNull(bobPost);

    // Navigate to comments
    assertEquals(2, bobPost.comments.size());
    assertEquals(&quot;Jeff&quot;, bobPost.comments.get(0).author);

    // Delete the post
    bobPost.delete();

    // Check that all comments have been deleted
    assertEquals(1, User.count());
    assertEquals(0, Post.count());
    assertEquals(0, Comment.count());
}

你是不是也全是绿条呢？

[![image](/user_images/1299-3.png &quot;image&quot;)](/user_images/1299-3.png)

#### Using Fixtures to write more complicated tests

When you start to write more complex tests, you often need a set of data to test on. Fixtures let you describe your model in a YAML file and load it at any time before a test.

Edit the **/yabe/test/data.yml** file and start to describe a User:

User(bob):
    email: bob@gmail.com
    password: secret
    fullname: Bob

...

Well, because the data.yml file is a litle big, you can download it here.

Now we create a test case that loads this data and runs some assertions over it:

@Test
public void fullTest() {
    Fixtures.loadModels(&quot;data.yml&quot;);

    // Count things
    assertEquals(2, User.count());
    assertEquals(3, Post.count());
    assertEquals(3, Comment.count());

    // Try to connect as users
    assertNotNull(User.connect(&quot;bob@gmail.com&quot;, &quot;secret&quot;));
    assertNotNull(User.connect(&quot;jeff@gmail.com&quot;, &quot;secret&quot;));
    assertNull(User.connect(&quot;jeff@gmail.com&quot;, &quot;badpassword&quot;));
    assertNull(User.connect(&quot;tom@gmail.com&quot;, &quot;secret&quot;));

    // Find all of Bob&apos;s posts
    List&amp;lt;Post&amp;gt; bobPosts = Post.find(&quot;author.email&quot;, &quot;bob@gmail.com&quot;).fetch();
    assertEquals(2, bobPosts.size());

    // Find all comments related to Bob&apos;s posts
    List&amp;lt;Comment&amp;gt; bobComments = Comment.find(&quot;post.author.email&quot;, &quot;bob@gmail.com&quot;).fetch();
    assertEquals(3, bobComments.size());

    // Find the most recent post
    Post frontPost = Post.find(&quot;order by postedAt desc&quot;).first();
    assertNotNull(frontPost);
    assertEquals(&quot;About the model layer&quot;, frontPost.title);

    // Check that this post has two comments
    assertEquals(2, frontPost.comments.size());

    // Post a new comment
    frontPost.addComment(&quot;Jim&quot;, &quot;Hello guys&quot;);
    assertEquals(3, frontPost.comments.size());
    assertEquals(4, Comment.count());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can read more about Play and YAML in the YAML manual page.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 用Fixtures编写更多复杂测试

在开始复杂的单元测试测试之前，通常需要准备一系列的测试数据。Fixtures 允许你用YAML文件来构建你的测试数据，并且还可以任意次的加载。

编辑文件 **/yabe/test/data.yml**，创建我们的测试数据：

User(bob):
    email: bob@gmail.com
    password: secret
    fullname: Bob

...

该文件比较大，这里已经有编写好的data.yml文件，你也可以直接[点击此处下载](http://www.playframework.org/documentation/1.2.5/files/data.yml)。

现在编写单元测试加载此文件，看看是不是没问题：

@Test
public void fullTest() {
    Fixtures.loadModels(&quot;data.yml&quot;);

    // Count things
    assertEquals(2, User.count());
    assertEquals(3, Post.count());
    assertEquals(3, Comment.count());

    // Try to connect as users
    assertNotNull(User.connect(&quot;bob@gmail.com&quot;, &quot;secret&quot;));
    assertNotNull(User.connect(&quot;jeff@gmail.com&quot;, &quot;secret&quot;));
    assertNull(User.connect(&quot;jeff@gmail.com&quot;, &quot;badpassword&quot;));
    assertNull(User.connect(&quot;tom@gmail.com&quot;, &quot;secret&quot;));

    // Find all of Bob&apos;s posts
    List&amp;lt;Post&amp;gt; bobPosts = Post.find(&quot;author.email&quot;, &quot;bob@gmail.com&quot;).fetch();
    assertEquals(2, bobPosts.size());

    // Find all comments related to Bob&apos;s posts
    List&amp;lt;Comment&amp;gt; bobComments = Comment.find(&quot;post.author.email&quot;, &quot;bob@gmail.com&quot;).fetch();
    assertEquals(3, bobComments.size());

    // Find the most recent post
    Post frontPost = Post.find(&quot;order by postedAt desc&quot;).first();
    assertNotNull(frontPost);
    assertEquals(&quot;About the model layer&quot;, frontPost.title);

    // Check that this post has two comments
    assertEquals(2, frontPost.comments.size());

    // Post a new comment
    frontPost.addComment(&quot;Jim&quot;, &quot;Hello guys&quot;);
    assertEquals(3, frontPost.comments.size());
    assertEquals(4, Comment.count());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想了解更多关于Play+YAML的话，会在后面的章节YAML中详细介绍。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 用Fixtures编写更多复杂测试

在开始复杂的单元测试测试之前，通常需要准备一系列的测试数据。Fixtures 允许你用YAML文件来构建你的测试数据，并且还可以任意次的加载。

编辑文件 **/yabe/test/data.yml**，创建我们的测试数据：

User(bob):
    email: bob@gmail.com
    password: secret
    fullname: Bob

...

该文件比较大，这里已经有编写好的data.yml文件，你也可以直接[点击此处下载](http://www.playframework.org/documentation/1.2.5/files/data.yml)。

现在编写单元测试加载此文件，看看是不是没问题：

@Test
public void fullTest() {
    Fixtures.loadModels(&quot;data.yml&quot;);

    // Count things
    assertEquals(2, User.count());
    assertEquals(3, Post.count());
    assertEquals(3, Comment.count());

    // Try to connect as users
    assertNotNull(User.connect(&quot;bob@gmail.com&quot;, &quot;secret&quot;));
    assertNotNull(User.connect(&quot;jeff@gmail.com&quot;, &quot;secret&quot;));
    assertNull(User.connect(&quot;jeff@gmail.com&quot;, &quot;badpassword&quot;));
    assertNull(User.connect(&quot;tom@gmail.com&quot;, &quot;secret&quot;));

    // Find all of Bob&apos;s posts
    List&amp;lt;Post&amp;gt; bobPosts = Post.find(&quot;author.email&quot;, &quot;bob@gmail.com&quot;).fetch();
    assertEquals(2, bobPosts.size());

    // Find all comments related to Bob&apos;s posts
    List&amp;lt;Comment&amp;gt; bobComments = Comment.find(&quot;post.author.email&quot;, &quot;bob@gmail.com&quot;).fetch();
    assertEquals(3, bobComments.size());

    // Find the most recent post
    Post frontPost = Post.find(&quot;order by postedAt desc&quot;).first();
    assertNotNull(frontPost);
    assertEquals(&quot;About the model layer&quot;, frontPost.title);

    // Check that this post has two comments
    assertEquals(2, frontPost.comments.size());

    // Post a new comment
    frontPost.addComment(&quot;Jim&quot;, &quot;Hello guys&quot;);
    assertEquals(3, frontPost.comments.size());
    assertEquals(4, Comment.count());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想了解更多关于Play+YAML的话，会在后面的章节YAML中详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;保存你的作品&lt;/h4&gt;
&lt;p&gt;到现在为止，我们已经完成了大部分的Blog开发。我们创建了所需的Model，并且对他们进行了单元测试。接下来可以开始Web开发之旅了。&lt;/p&gt;
&lt;p&gt;But before continuing, it’s time to save your work using Bazaar. Open a command line and type bzr st to see the modifications made since the last commit:&lt;/p&gt;
&lt;p&gt;$ bzr st As you can see, some new files are not under version control. The test-result folder doesn’t need to be versioned, so let’s ignore it.&lt;/p&gt;
&lt;p&gt;$ bzr ignore test-result Add all the other files to version control using bzr add.&lt;/p&gt;
&lt;p&gt;$ bzr add You can now commit your project.&lt;/p&gt;
&lt;p&gt;$ bzr commit -m &amp;ldquo;The model layer is ready&amp;rdquo; Go to the Building the first screen.&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>1. 创建工程</title>
                <link>http://freewind.in/posts/1294-play1-guide-1-create-project</link>
                <pubDate>Tue, 01 Jan 2013 17:09:29 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1294</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是CQS)&lt;/p&gt;
&lt;h4&gt;引言&lt;/h4&gt;
&lt;p&gt;通过这个教程，你将学会如何使用Play框架去构建一个实实在在的web 应用。在这个应用中，我们将使用一切实际项目中可能会用到的技术，同时介绍一些好的且有效的Play应用程序开发实践。&lt;/p&gt;
&lt;p&gt;我们把这个教程分成若干个独立的模块。每个模块将介绍不少复杂的Play应用特征，并提供一切实际项目所需的技术需求:如验证，错误处理，完整的安全框架，自动化的测试组件，一个新颖的Web前端，一个管理模块等等&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;教程里的&lt;strong&gt;所有代码&lt;/strong&gt;都可以在你的项目中使用。我们鼓励你复制/粘贴部分代码或者拿走所有你所喜闻乐见的代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h4&gt;关于项目&lt;/h4&gt;
&lt;p&gt;我们选择去创建一个博客引擎.这虽然不是一个极具想象力的应用，但是它却允许我们的开发涵盖了大部分现代Web应用所需要用到的功能。&lt;/p&gt;
&lt;p&gt;为了使这个应用变得有趣一些，我们将管理多个用户并给予不同的角色(可编辑者，管理员)&lt;/p&gt;
&lt;p&gt;我们叫这个博客引擎(项目)为&lt;strong&gt;yabe&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;这个教程同时被分发为一个例子应用。你可以在Play的安装目录的&lt;strong&gt;samples-and-tests/yabe/&lt;/strong&gt;目录下找到完整的代码.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h4&gt;先决条件&lt;/h4&gt;
&lt;p&gt;第一点，你必须确定你有一个可以工作的Java环境。Play需要&lt;strong&gt;JDK5 或之后版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我们可能会较多的使用命令行，建议最好选择使用一个类Unix的操作系统。当然，你如果使用Windows系统，Play一样也能工作的很好;你只需在windows的命令提示符下输入少量的几行Play指令。&lt;/p&gt;
&lt;p&gt;我们假定你已经有Java和web开发(例如HTML,CSS和JavaScript)的经验,但你不需要深入了解Java 企业级开发组件(Java Enterprise Edition)。Play是一个“全栈式”的Java框架，它提供并封装了所有你需要Java API.同时也不需要去知道如何去配置一个JPA 对象管理或部署一个JEE 组件.&lt;/p&gt;
&lt;p&gt;在编码之前，你需要一个编辑器。如果你习惯了使用一个功能齐全的Java IDE，例如Eclipse或NetBeans，毋庸置疑，你可以使用它们进行Play编码。但是如果你更乐意使用一些简单的编辑器例如Textmate,Emacs，VI，由于Play框架可以自己控制编译和部署，在不久后支持这些编辑器.&lt;/p&gt;
&lt;p&gt;在这个教程的后面，我们将使用Lighttpd和Mysql去展示如何部署一个&apos;产品模式&apos;的Play应用.如果你不会装mysql和Lightted，Play同样可以好好的工作，这些都不是问题。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;译者注:Play内置了内存数据库HSQL DB和内置服务器netty&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h4&gt;安装Play框架&lt;/h4&gt;
&lt;p&gt;安装过程非常简单。从下载页下载最新的二进制包，解压到任何路径下。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;如果你使用的是Windows，尽量的避开路径中万恶的空格，如：&lt;strong&gt;c:\play&lt;/strong&gt;优于&lt;strong&gt;c:Documents And Settings\user\play&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了更有效工作，你需要将Play安装目录添加到你的环境变量Path中。这样你只需要在命令提示符中输入&lt;strong&gt;play&lt;/strong&gt;就能时候用Play工具包了。确认你的安装是否正确，只需打开终端，敲入&lt;strong&gt;play&lt;/strong&gt;，正确安装的话，它会展示给你不少的Play的基本使用帮助。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;创建项目&lt;/h4&gt;
&lt;p&gt;好的，现在Play已经正确安装了,是时候创建博客应用了。创建一个Play应用相当容易，由Play命令工具全权控制。这样就能保证所有的Play应有都有标准的项目布局。&lt;/p&gt;
&lt;p&gt;新建命令行，然后输入：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;～$ play new yabe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它会提示你输入应用全名。输入:&lt;strong&gt;Yet Another Blog Engine&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1294-1.png&quot;&gt;&lt;img src=&quot;/user_images/1294-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;play new&lt;/strong&gt; 命令创建了一个目录&lt;strong&gt;yabe/&lt;/strong&gt;，同时生成一系列文件和目录，重要的几个文件如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;app/&lt;/strong&gt; 包含了应用程序的核心，由模型(models)，控制器(controllers)和视图(views) 3个目录组成。当然，这里可包含其他Java包.这里是&lt;strong&gt;.java&lt;/strong&gt;文件正确的放置目录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conf/&lt;/strong&gt; 包含了应用程序的所有配置文件,其中三个特殊的文件，主配置文件&lt;strong&gt;application.conf&lt;/strong&gt;,&lt;strong&gt;routes&lt;/strong&gt;路由定义文件，用于国际化的&lt;strong&gt;messages&lt;/strong&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lib/&lt;/strong&gt;包含了其它Java库(标准&lt;strong&gt;.jar&lt;/strong&gt;包).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public/&lt;/strong&gt;包含了公共可用的资源，例如JavaScript文件，Css文件，图片目录文件等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;test/&lt;/strong&gt;包含了应用测试.测试可能是Java Junit测试 或者Selenium测试.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;由于Play使用&lt;strong&gt;UTF-8&lt;/strong&gt;编码,所以请保证在这些目录中的文件使用了UTF-8编码,确认你的编辑器相应地设置了UTF-8编码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你是一个老练的Java开发人员，你会疑惑.class文件跑哪去了?答案是没有:Play没有使用任何的class文件.它只是直接读取Java源文件.在这种情况下，我们使用Eclipse编译器实时的编译Java源码.&lt;/p&gt;
&lt;p&gt;这样就允许下述的两个重要特性在开发过程中出现。第一,Play将监测源码的变化，并自动将它在运行阶段重新载入.第二,当一个Java异常发生,Play可以创建一个更好的错误报告，并告知你发生错误的源码位置。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;事实上，Play保留一份bytecode缓存在你的&lt;strong&gt;tem/&lt;/strong&gt;目录下,但这仅仅是为了提高在重启大型应用时的速度。如果你需要，你可以使用&lt;strong&gt;play clean&lt;/strong&gt;命令行去清理缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h4&gt;运行程序&lt;/h4&gt;
&lt;p&gt;我们现在测试一下刚才刚创建的Play应用.跳到命令行，进入到刚创建的&lt;strong&gt;yabe/&lt;/strong&gt;目录下，并输入&lt;strong&gt;play run&lt;/strong&gt;。Play将载入这个应用，并启动一个端口为9000的web服务器.&lt;/p&gt;
&lt;p&gt;现在你可以在浏览器中输入&lt;a href=&quot;http://localhost:9000&quot;&gt;http://localhost:9000&lt;/a&gt;查看这个应用.一个新的Play应用会有一个标准的欢迎界面去告诉你，你的应用创建成功了.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1294-3.png&quot;&gt;&lt;img src=&quot;/user_images/1294-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在让我们看看这个新的应用是如何做到展示这个页面的.&lt;/p&gt;
&lt;p&gt;这个应用的主要入口在&lt;strong&gt;conf/routes&lt;/strong&gt;文件中定义，包括了所有可以被访问的URLs.打开这个自动生成的routes文件，你可以看到第一个&apos;route&apos;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET        /            Application.index

这个的意思即当服务器收到一个/ 路径的**GET**请求，则调用**Application.index**这个Java方法.其实，**Application.index**是**controllers.Application.index**的快捷方式，因为**controllers**包是默认的.

当你创建一个独立的Java应用，你可以看到看到程序单一的入口即main函数如：

public static void main(String[] args) {
  ... 
}

一个Play应用有相对于每个URL都有个切入口.我们叫这些方法为**action**方法.Action方法所在类被称为控制器(controllers).

让我们看看**controller.Application**这个控制器里有什么?打开**yabe/app/controllers/Application.java**这个源文件:

package controllers;
import play.mvc.*;

public class Application extends Controller {
    public static void index() {
        render();
    }
}

我们可以发现控制类都继承了**play.mvc.Controller**.这个类提供了许多有用的方法,例如index action中的使用到**render()**方法。

这个index方法被定义为**public static void**,这是一个action方法的标准定义.你可以发现action方法是static的,因为这个控制类永远不会被实例化.同时action方法被标记为public是为了授权play框架去调用(call)它们去相应一个URL请求.通常action方法是返回void.

这个默认的index action相当简单:它调用**render()**方法去告诉Play去渲染一个模板.使用模板是用来生成HTTP响应最通常的方法(当然不是唯一的).

这些模板是在**/app/views**目录下的一些简单文本文件.因为我们没有指定模板，index action的默认模板为:**Application/index.html**.

现在看看模板长的啥样,打开**/yabe/app/views/Application/index.html**文件

#{extends &apos;main.html&apos; /}
#{set title:&apos;Home&apos; /}

#{welcome /}

这个模板内容看上去相当轻量.事实上，你看到都是Play tags.Play tags是和JSP tags相似的.**#{welcome/}** tag就是用来生成你在浏览器看到欢迎信息的.

**#{extends &apos;main.html&apos;/}** tag 告诉Play这个模板继承了一个叫**main.html**的模板.模板继承是一个很强大的感念，它允许你通过重用公用部分,创建一个相当复杂的网页。

打开**/yabe/app/views/main.html**模板:

&amp;lt;!DOCTYPE html&amp;gt;
 &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
       &amp;lt;title&amp;gt;#{get &apos;title&apos; /}&amp;lt;/title&amp;gt;        
       &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&amp;gt;
       &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; 
           href=&quot;@{&apos;/public/stylesheets/main.css&apos;}&quot; /&amp;gt;
       &amp;lt;link rel=&quot;shortcut icon&quot; type=&quot;image/png&quot; 
        href=&quot;@{&apos;/public/images/favicon.png&apos;}&quot; /&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        #{doLayout /} 
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

发现这个**#{doLayout/}** tag没?**Application/index.html**的内容就是插入到这的.

我们现在尝试去编辑这个控制器文件,去探究下Play是如何自动重新载入的.打开**yabe/app/controllers/Application.java**文件，故意去掉**render()**后面的分号.

然后在浏览器中重新刷新页面.你可以发现Play已经检测到变化并重新载入了程序控制器.因为你制造了一个错误，所以你得到一个编译错误.

[![image](/user_images/1294-5.png &quot;image&quot;)](/user_images/1294-5.png)



好，现在我们修正这个错误,做一个真正的修改.

public static void index() {
    System.out.println(&quot;Yop&quot;);
    render();
}

这次，Play正确的重载了控制器,并替代JVM里旧的代码.这样，每次/地址请求都会打印一个&apos;Yop&apos;到控制台.

你可以去掉这行没用的代码,并编辑**yabe/app/views/Application/index.html**文件，替换掉这个欢迎Tag.

#{extends &apos;main.html&apos; /}
#{set title:&apos;Home&apos; /}

&amp;lt;h1&amp;gt;A blog will be there&amp;lt;/h1&amp;gt;

Java代码变化了,只需刷新浏览器就可以看见这个页面的变化了.

&amp;gt; 现在我们开始这个Blog应用的编码.你可以继续使用一个文本编辑器或者在Java IDE中打开这个项目.如果你要设置一个Java IDE环境用于Play编程，请看[Setting-up your preferred IDE](http://play-framework.herokuapp.com/zh/ide).

* * *

#### 设置数据库

在开始编码之前，我们需要为这个Blog引擎设置一个数据库.为了开发方便的目的,Play设置了一个独立的SQL数据库(H2).在切换到其它更为强壮的数据库钱，使用H2是一个很好的方式去起始一个项目.你可以选择一个基于内存的数据库或者为了保存重启应用后仍存在的数据而使用的文件数据库。

在应用的初始，我们将对应用的模型做比较多的测试和更改，所以我们选择了基于内存的数据库，以便于每次都有一个新鲜的数据集.

打开**yabe/conf/application.conf**文件，取消注释这行:

db=men

正如你注释中看到的，你可以很容易的配置任何JDBC兼容的数据库，甚至配置连接池.

现在，我们返回浏览器刷新页面.Play会自动启动这个H2数据库.你会在应用日志中看到这个消息:

INFO  ~ Connected to jdbc:h2:mem:play
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4&gt;Using a version control system to track changes&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt;译者注:由于这里使用了非主流控制系统(Bazaar)进行版本控制，表示不乐意翻译，有兴趣请看英文,谢谢.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When you work on a project, it’s highly recommended to store your source code in a version control system (VCS). It allows you to revert to a previous version if a change breaks something, work with several people and give access to all the successive versions of the application. Of course you can use any VCS to store your project, but here we will use Bazaar as an example. Bazaar is a distributed source version control system.&lt;/p&gt;
&lt;p&gt;Installing Bazaar is beyond the scope of this tutorial but it is very easy on any system. Once you have a working installation of Bazaar, go to the blog directory and init the application versioning by typing:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;$ bzr init&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When storing a Play application in a VCS, it’s important to exclude the tmp/ and logs/ directories.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;$ bzr ignore tmp&lt;/p&gt;
&lt;p&gt;$ bzr ignore logs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now we can commit our first blog engine version:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;$ bzr add&lt;/p&gt;
&lt;p&gt;$ bzr commit -m &amp;ldquo;YABE inital version&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Version 1 is committed and we now have a solid foundation for our project.&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play2中如何实现play1中的Job?</title>
                <link>http://freewind.in/posts/1286-how-to-implement-the-job-of-play1-in-play2</link>
                <pubDate>Tue, 01 Jan 2013 17:04:55 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1286</guid>
                <description><![CDATA[&lt;p&gt;在play1中，我们可以这样定义一些Job，让它们在后台执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@OnApplicationStart
@Every(&quot;1h&quot;)
public class MyJob extends Job {
    public void doJob() {
        println(&quot;Hello world&quot;);
    }
}

以上代码将每小时向控制台输出一次`Hello world`。

但在play2中找不到`OnApplicationStart`和`Every`了，应该怎么实现该功能？

**回答：**

`OnApplicationStart`的功能移到`GlobalSettings`中了。我们需要在根包下建立一个`Global`类继承于它，并覆盖其`onStart`方法。

而`Every`这样的`Job`功能，现在使用Akka来处理了。我们需要向Akka提交一些异步任务。

代码如下：

import akka.actor.ActorSystem;
import akka.actor.Scheduler;
import akka.util.Duration;
import akka.util.FiniteDuration;
import java.util.concurrent.TimeUnit;
import play.Application;
import play.GlobalSettings;
import play.libs.Akka;

class Global extends GlobalSettings {
    public void onStart(Application app) {
        Akka.system().scheduler().schedule(
            Duration.create(0, TimeUnit.MILLISECONDS),
            Duration.create(1, TimeUnit.HOURS),
            new Runnable() {
                public void run() {
                    System.out.println(&quot;Hello world&quot;);
                }
            }
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>11. 使用第三方库整合数据库存取层</title>
                <link>http://freewind.in/posts/1285-play2-11-integrate-3rd-database-lib</link>
                <pubDate>Tue, 01 Jan 2013 17:03:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1285</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h3&gt;Integrating with other database libraries&lt;/h3&gt;
&lt;p&gt;你可以在Play中使用任何第三方&lt;strong&gt;SQL&lt;/strong&gt;数据库存取依赖库, 并且很方便地从&lt;code&gt;play.api.db.DB&lt;/code&gt;工具类中获得&lt;code&gt;Connection&lt;/code&gt;或&lt;code&gt;Datasource&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;整合ScalaQuery&lt;/h4&gt;
&lt;p&gt;这里可以整合任何需要JDBC数据源的数据存取层依赖库，比如整合[[ScalaQuery |&lt;a href=&quot;https://github.com/szeiger/scala-query&quot;&gt;https://github.com/szeiger/scala-query&lt;/a&gt;]]:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import play.api.db._
import play.api.Play.current

import org.scalaquery.ql._
import org.scalaquery.ql.TypeMapper._
import org.scalaquery.ql.extended.{ExtendedTable =&amp;gt; Table}

import org.scalaquery.ql.extended.H2Driver.Implicit._ 

import org.scalaquery.session._

object Task extends Table[(Long, String, Date, Boolean)](&quot;tasks&quot;) {

  lazy val database = Database.forDataSource(DB.getDataSource())

  def id = column[Long](&quot;id&quot;, O PrimaryKey, O AutoInc)
  def name = column[String](&quot;name&quot;, O NotNull)
  def dueDate = column[Date](&quot;due_date&quot;)
  def done = column[Boolean](&quot;done&quot;)
  def * = id ~ name ~ dueDate ~ done

  def findAll = database.withSession { implicit db:Session =&amp;gt;
      (for(t &amp;lt;- this) yield t.id ~ t.name).list
  }

}

#### 通过JNDI暴露数据源

有些库需要从JNDI获取`Datasource`. 你可以通过在`conf/application.conf`添加如下的配置把Play托管的数据源通过JNDI的形式暴露出来

db.default.driver=org.h2.Driver
db.default.url=&quot;jdbc:h2:mem:play&quot;
db.default.jndiName=DefaultDS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaDatabaseOthers&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaDatabaseOthers&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>10. 使用anorm操作数据库</title>
                <link>http://freewind.in/posts/1284-play2-10-use-anorm-to-operate-database</link>
                <pubDate>Tue, 01 Jan 2013 17:03:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1284</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h3&gt;Anorm, simple SQL data access&lt;/h3&gt;
&lt;p&gt;Play包含一个叫&lt;code&gt;Anorm&lt;/code&gt;的数据库存取层。该数据库存取层使用原生SQL与数据库交互,并提供了一组API来解析和转换查询结果集.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anorm不是一个对象关系映射框架&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;我们在接下来的例子中使用MySQL官方提供的样本数据库([[ world sample database ||&lt;a href=&quot;http://dev.mysql.com/doc/world-setup/en/world-setup.html&quot;&gt;http://dev.mysql.com/doc/world-setup/en/world-setup.html&lt;/a&gt;]]) 。请参照这个[[ 文档 | ScalaDatabase ]] 配置好数据源..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;概述&lt;/h4&gt;
&lt;p&gt;改用原生SQL操作数据库可能会让人觉得很奇怪，尤其习惯于ORM框架的java开发者. 虽然我们承认在Java中使用这些工具几乎是有必要的，但我们也认为使用像Scala这种表达能力很强的高级编程语言开发的应用完全没有必要使用这些ORM工具, 使用了反而会产生反效果.&lt;/p&gt;
&lt;h6&gt;提供更好的API减轻使用JDBC的痛苦&lt;/h6&gt;
&lt;p&gt;我们同意,尤其在Java中，直接使用JDBC编程是一件很乏味的事, 因为你不得不处理各种受检查异常(checked exception)， 不得不反复将原始结果集转换成你需要的数据结构。&lt;/p&gt;
&lt;p&gt;我们为JDBC提供了一套简单易用的API。如果你使用Scala语言编写应用，你无需为各种异常处理而烦恼, 使用函数式语言转换数据是十分简单的。事实上，我们希望通过提供一组API让JDBC和Scala之间的数据结构转换变得更有效率。&lt;/p&gt;
&lt;h6&gt;你不需要另一种DSL操作关系型数据库&lt;/h6&gt;
&lt;p&gt;SQL是操作数据库最好的领域特定语言（Domain Specific Language, DSL）。 我们不需要发明一种新的DSL, 而且SQL的语法和数据库特性在不同的供应商之间存在差异。如果你尝试抽象出一种新的DSL，你不得不像Hibernate那样处理几种数据库的方言, 而且使用一些有趣的特性会受到限制。&lt;/p&gt;
&lt;p&gt;Play提供了一些预定义的SQL语句，但目的不是为了隐藏某些操作细节, 只是为一些常用的查询减少编码量。而且你总是可以改回原生SQL.&lt;/p&gt;
&lt;h6&gt;使用类型安全的DSL生成SQL是错误的&lt;/h6&gt;
&lt;p&gt;有些观点认为，使用类型安全的DSL是更好的做法,因为所有的查询都可以经过编译器检查。不幸的是，编译器只基于你编写的对象关系映射的元数据模型定义来检验你的查询。 元数据模型无法保证是正确的。即使查询代码被编译器判定为类型正确，但仍有可能由于不匹配的关系对象映射而导致运行时出错。&lt;/p&gt;
&lt;h6&gt;掌控SQL代码&lt;/h6&gt;
&lt;p&gt;对象关系映射在一般情况下会工作得很好, 但当要处理复杂的schemas或者遗留的数据库，你就得在ORM框架上花大量时间生成你需要的SQL。为Hello world这种简单应用编写原生的SQL查询也许会很乏味，但对于实际应用来说，最终会节省时间并简化代码.&lt;/p&gt;
&lt;h4&gt;执行SQL查询&lt;/h4&gt;
&lt;p&gt;开始之前，你需要知道如何执行SQL查询。&lt;/p&gt;
&lt;p&gt;首先，导入&lt;code&gt;anorm._&lt;/code&gt;，然后使用&lt;code&gt;SQL&lt;/code&gt;对象创建查询。你需要一个&lt;code&gt;Connection&lt;/code&gt;对象运行查询。&lt;code&gt;Connection&lt;/code&gt;对象可以从&lt;code&gt;play.api.db.DB.withConnection&lt;/code&gt;函数取得&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import anorm._ 

DB.withConnection { implicit c =&amp;gt;
  val result: Boolean = SQL(&quot;Select 1&quot;).execute()    
}

`execute()`函数返回一个表示查询是否成功的布尔值。

如果要执行更新查询，使用`executeUpdate()`函数, 这个函数会返回记录被更新的个数

val result: Int = SQL(&quot;delete from City where id = 99&quot;).executeUpdate()

如果向一个拥有`Long`类型的自增主键的表插入数据，使用`executeInsert()`.如果该表有联合主键或主键不是`Long`类型，那么可以向`executeInsert()`传入一个`ResultSetParser`返回正确的主键。

val id: Int = SQL(&quot;insert into City(name, country) values ({name}, {country}&quot;)
              .on(&quot;Cambridge&quot;, &quot;New Zealand&quot;).executeInsert()

由于Scala支持多行文本的写法，因此可以将复杂的SQL表达式写成：

val sqlQuery = SQL(
  &quot;&quot;&quot;
    select * from Country c 
    join CountryLanguage l on l.CountryCode = c.Code 
    where c.code = &apos;FRA&apos;;
  &quot;&quot;&quot;
)

如果SQL查询包含动态参数，可以使用占位符表示，如`{name}`, 然后在使用`on()`函数赋值.

SQL(
  &quot;&quot;&quot;
    select * from Country c 
    join CountryLanguage l on l.CountryCode = c.Code 
    where c.code = {countryCode};
  &quot;&quot;&quot;
).on(&quot;countryCode&quot; -&amp;gt; &quot;FRA&quot;)

#### 使用Stream API获取数据

获取查询结果的第一种方法是使用Stream API. 调用`SQL`表达式对象上的`apply()`方法会返回一个`Stream`集合，`Stream`集合中的每个元素代表一个`Row`实例，每个`Row`实例可以看成一个映射表（dictionary)

// Create an SQL query
val selectCountries = SQL(&quot;Select * from Country&quot;)

// Transform the resulting Stream[Row] to a List[(String,String)]
val countries = selectCountries().map(row =&amp;gt; 
  row[String](&quot;code&quot;) -&amp;gt; row[String](&quot;name&quot;)
).toList

在下面的例子中，我们统计一下`Country`表共有有多少条记录, 因此查询结果只会返回包含一个字段的一条记录.

// First retrieve the first row
val firstRow = SQL(&quot;Select count(*) as c from Country&quot;).apply().head

// Next get the content of the &apos;c&apos; column as Long
val countryCount = firstRow[Long](&quot;c&quot;)

#### 使用模式匹配

可以使用模式匹配的方法从`Row`抽取出所需的内容。在这种情况下，字段名不再重要，只要求顺序和参数类型匹配即可。

下面的例子使用模式匹配的方法将每条记录匹配到合适的Scala类型中：

case class SmallCountry(name:String) 
case class BigCountry(name:String) 
case class France

val countries = SQL(&quot;Select name,population from Country&quot;)().collect {
  case Row(&quot;France&quot;, _) =&amp;gt; France()
  case Row(name:String, pop:Int) if(pop &amp;gt; 1000000) =&amp;gt; BigCountry(name)
  case Row(name:String, _) =&amp;gt; SmallCountry(name)      
}

由于`collect(_)`会忽略偏应用函数没有定义的情况， 因此你可以忽略某些记录。

#### 特殊数据类型

##### Clob类型

可以这样抽取CLOBs/TEXTs类型的值：

SQL(&quot;Select name,summary from Country&quot;)().map {
  case Row(name: String, summary: java.sql.Clob) =&amp;gt; name -&amp;gt; summary
}

这里我们特地使用`map`函数，使得当出现我们非预期的记录时抛出异常。

##### 二进制类型

抽取二进制类型的值也是类似的做法：

SQL(&quot;Select name,image from Country&quot;)().map {
  case Row(name: String, image: Array[Byte]) =&amp;gt; name -&amp;gt; image
}

##### 数据库互操作（Database interoperability）

对于记录的某个字段，不同的数据库引擎会返回不同的数据类型. 比如一个‘smallint’类型字段, org.h2.Driver会返回一个short，org.postgresql.Driver会返回一个Integer. 一个简单的解决办法是为每种数据库编写特定的版本。(比如一个版本用于开发数据库，一个版本用于生产数据库)

#### 处理空值(null)的列

如果列含有空值(`Null`），那么最好处理成`Option`类型。 例如`Country`表的`indepYear`列允许空值,那么使用`Option[Int]`匹配该列:

SQL(&quot;Select name,indepYear from Country&quot;)().collect {
  case Row(name:String, Some(year:Int)) =&amp;gt; name -&amp;gt; year
}

或者用这种写法：

SQL(&quot;Select name,indepYear from Country&quot;)().map { row =&amp;gt;
  row[String](&quot;name&quot;) -&amp;gt; row[Option[Int]](&quot;indepYear&quot;)
}

如果将`indepYear`列直接匹配为`Int`， 那么当遇到null值会抛出`UnexpectedNullableFound(COUNTRY.INDEPYEAR)`异常：

SQL(&quot;Select name,indepYear from Country&quot;)().map { row =&amp;gt;
  row[String](&quot;name&quot;) -&amp;gt; row[Int](&quot;indepYear&quot;)
}

#### 使用parser API

你可以使用parser API创建通用的可重用的解析器解析任意查询结果集。

&amp;gt; **备注:** 这种做法是有用的，因为大部分we应用的查询都返回相似的结果集。例如，你可以定义一个能用于解析`Country`表查询结果集的解析器和一个用于解析`Language`表查询结果集的解析器。然后在用到连接查询的地方将两个解析器组合起来使用。 记得导入`anorm.SqlParser._`

##### 单一结果集

首先你需要一个`RowParser`将一条记录解析成一个Scala对象。下面定义一个将单一列的记录转换成`Long`值对象的记录解析器（row parser)：

val rowParser = scalar[Long]  // row parser that parse a record into scala Long

再将它转换成`ResultSetParser`(结果集解析器):

val rsParser = rowParser.single  // resultset parser that transform the result set into an object.

然后可以使用`rsParser`将`select count`产生的结果集转换成`Long`值对象：

val count: Long = SQL(&quot;select count(*) from Country&quot;).as(scalar[Long].single)

##### 单一可选结果集

假如要根据国家名查找country_id, 但表中可能不存在该国家名（或输入了一个错误的国家名），这种情况下查询会返回一个空值。 这时应该使用`singleOpt`解析器:

val countryId: Option[Long] = SQL(&quot;select country_id from Country C where C.country=&apos;France&apos;&quot;).as(scalar[Long].singleOpt)

##### 更复杂的结果集

下面我们编写一个更复杂的解析器. 首先,`str(&quot;name&quot;) ~ int(&quot;population&quot;)`会创建一个记录解析器。这个解析器能解析一条包含类型为String的`name`字段和类型为Integer的`population`字段的记录。然后在此基础上使用`*`创建结果集解析器（`ResultSetParser`）,

val populations:List[String~Int] = {
  SQL(&quot;select * from Country&quot;).as( str(&quot;name&quot;) ~ int(&quot;population&quot;) * ) 
}

这个查询结果集最终被转换成`List[String~Int]`类型 ———— 一个包含国家名和该国人口数量的列表。

你可以将上面的例子改成:

val result:List[String~Int] = {
  Sql(&quot;select * from Country&quot;).as(get[String](&quot;name&quot;)~get[Int](&quot;population&quot;)*) 
}

可能大家已经注意到`String~Int`这个类型。这是一个**Anorm**类型，但用起来不会很方便， 相信改成`（String, Int)`这样的二元组会更好。你可以在`RowParser`上使用`map`函数将一条记录转换成合适的类型：

str(&quot;name&quot;) ~ int(&quot;population&quot;) map { case n~p =&amp;gt; (n,p) }
&amp;gt; **备注:** 这里我们将一条记录转换成一个二元组`(String,Int)`，你可以换成你想要的类型，比如样本类(case class)

由于将`A~B~C`转换成(A,B,C)是很普遍的, Play提供了一个`flatten`函数实现同样的功能。上面的例子可以改成：

val result:List[(String,Int)] = {
  SQL(&quot;select * from Country&quot;).as(
    str(&quot;name&quot;) ~ int(&quot;population&quot;) map(flatten) *
  ) 
}

##### 更复杂的例子

现在尝试更复杂的例子。如何根据国家代码查出国家名以及该国所使用的所有语言？

select c.name, l.language from Country c 
    join CountryLanguage l on l.CountryCode = c.Code 
    where c.code = &apos;FRA&apos;

我们将查询结果集解析成`List[(String,String)]`(一个包含name和language二元组的列表）

var p: ResultSetParser[List[(String,String)]] = {
  str(&quot;name&quot;) ~ str(&quot;language&quot;) map(flatten) *
}

最后我们会得到这样的结果：

List(
  (&quot;France&quot;, &quot;Arabic&quot;), 
  (&quot;France&quot;, &quot;French&quot;), 
  (&quot;France&quot;, &quot;Italian&quot;), 
  (&quot;France&quot;, &quot;Portuguese&quot;), 
  (&quot;France&quot;, &quot;Spanish&quot;), 
  (&quot;France&quot;, &quot;Turkish&quot;)
)

然后使用scala collection API转换成所需的结果：

case class SpokenLanguages(country:String, languages:Seq[String])

languages.headOption.map { f =&amp;gt;
  SpokenLanguages(f._1, languages.map(_._2))
}

最后整理一下：

case class SpokenLanguages(country:String, languages:Seq[String])

def spokenLanguages(countryCode: String): Option[SpokenLanguages] = {
  val languages: List[(String, String)] = SQL(
    &quot;&quot;&quot;
      select c.name, l.language from Country c 
      join CountryLanguage l on l.CountryCode = c.Code 
      where c.code = {code};
    &quot;&quot;&quot;
  )
  .on(&quot;code&quot; -&amp;gt; countryCode)
  .as(str(&quot;name&quot;) ~ str(&quot;language&quot;) map(flatten) *)

  languages.headOption.map { f =&amp;gt;
    SpokenLanguages(f._1, languages.map(_._2))
  }
}

接下来，将官方语言和其他语言分开：

case class SpokenLanguages(
  country:String, 
  officialLanguage: Option[String], 
  otherLanguages:Seq[String]
)

def spokenLanguages(countryCode: String): Option[SpokenLanguages] = {
  val languages: List[(String, String, Boolean)] =  Sql(
    &quot;&quot;&quot;
      select * from Country c 
      join CountryLanguage l on l.CountryCode = c.Code 
      where c.code = {code};
    &quot;&quot;&quot;
  )
  .on(&quot;code&quot; -&amp;gt; countryCode)
  .as {
    str(&quot;name&quot;) ~ str(&quot;language&quot;) ~ str(&quot;isOfficial&quot;) map {
      case n~l~&quot;T&quot; =&amp;gt; (n,l,true)
      case n~l~&quot;F&quot; =&amp;gt; (n,l,false)
    } *
  }

  languages.headOption.map { f =&amp;gt;
    SpokenLanguages(
      f._1, 
      languages.find(_._3).map(_._2),
      languages.filterNot(_._3).map(_._2)
    )
  }
}

如果在Mysql world sample数据库上运行上述的查询，会得到：

$ spokenLanguages(&quot;FRA&quot;)
&amp;gt; Some(
    SpokenLanguages(France,Some(French),List(
        Arabic, Italian, Portuguese, Spanish, Turkish
    ))
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaAnorm&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaAnorm&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>09. Comet sockets</title>
                <link>http://freewind.in/posts/1283-play2-09-comet-sockets</link>
                <pubDate>Tue, 01 Jan 2013 17:02:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1283</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h3&gt;Comet sockets&lt;/h3&gt;
&lt;h4&gt;使用chunked response创建comet sockets&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;chunked response&lt;/strong&gt;的一个用途就是创建Comet sockets。 一个Comet socket就是一段只包含&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素的&lt;code&gt;text/html&lt;/code&gt;文本。每次浏览器收到这一份chunked resposne后，会执行&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;里的脚本。我们可以利用这种特性向浏览器发送一些实时的事件(event)，或者说服务器能实时通知客户端(浏览器）某些事件已发生，让客户端（浏览器）对此做出响应，比如向服务器发送异步请求或局部刷新页面。&lt;/p&gt;
&lt;p&gt;让我们举一个例子。这个例子使用&lt;code&gt;Enumerator&lt;/code&gt;构造了三个chunked response。每个chuncked response都包含一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标记块，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;块中调用一个Javascript函数&lt;code&gt;console.log()&lt;/code&gt;往浏览器控制台输出一行日志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def comet = Action {
  val events = Enumerator(
     &quot;&quot;&quot;&amp;lt;script&amp;gt;console.log(&apos;kiki&apos;)&amp;lt;/script&amp;gt;&quot;&quot;&quot;,
     &quot;&quot;&quot;&amp;lt;script&amp;gt;console.log(&apos;foo&apos;)&amp;lt;/script&amp;gt;&quot;&quot;&quot;,
     &quot;&quot;&quot;&amp;lt;script&amp;gt;console.log(&apos;bar&apos;)&amp;lt;/script&amp;gt;&quot;&quot;&quot;
  )
  Ok.stream(events &amp;gt;&amp;gt;&amp;gt; Enumerator.eof).as(HTML)
}

浏览器访问这个action，你会在浏览器控台看到三行日志

&amp;gt; **提示:** `events &amp;gt;&amp;gt;&amp;gt; Enumerator.eof`是`events.andThen(Enumerator.eof)`另一个等价的写法。

可以换一种更好的实现方式: 使用`play.api.libs.iteratee.Enumeratee`适配器将`Enumerator[A]`转换成`Enumerator[B]`。将上述的例子重构一下：

import play.api.templates.Html

// Transform a String message into an Html script tag
val toCometMessage = Enumeratee.map[String] { data =&amp;gt; 
    Html(&quot;&quot;&quot;&amp;lt;script&amp;gt;console.log(&apos;&quot;&quot;&quot; + data + &quot;&quot;&quot;&apos;)&amp;lt;/script&amp;gt;&quot;&quot;&quot;)
}

def comet = Action {
  val events = Enumerator(&quot;kiki&quot;, &quot;foo&quot;, &quot;bar&quot;)
  Ok.stream(events &amp;gt;&amp;gt;&amp;gt; Enumerator.eof &amp;amp;&amp;gt; toCometMessage)
}
&amp;gt; **提示:** `events &amp;gt;&amp;gt;&amp;gt; Enumerator.eof &amp;amp;&amp;gt; toCometMessage`是`events.andThen(Enumerator.eof).through(toCometMessage)`另一个中等价写法。

#### 使用`play.api.libs.Comet`工具类

我们提供了一个Comet工具类来处理这些comet chunked streams, 所做的工作跟上述的例子一样。

&amp;gt; **注意:** 实际上这个工具类会为我们完成更多的工作，比如会针对浏览器兼容性将一段初始空白的缓存数据块推送给浏览器， 并且它同时支持JSON和String两种消息。它也可以通过类型类扩展，以支持更多的消息类型。

用它来重写之前的例子：

def comet = Action {
  val events = Enumerator(&quot;kiki&quot;, &quot;foo&quot;, &quot;bar&quot;)
  Ok.stream(events &amp;amp;&amp;gt; Comet(callback = &quot;console.log&quot;))
}
&amp;gt; **提示:** `Enumerator.callbackEnumerator`和`Enumerator.pushEnumerator`是以命令式风格创建灵敏的非阻塞迭代器的两种写法

#### 恒久常新的iframe技术

编写Comet socket的标准做法是，在HTML页面中放置一个iframe子页面。iframe向服务器发起一个Http请求。然后服务器连续不断地向客户端（浏览器）发送chunked comet response。另一方面，在HTML页面上定义一个回调函数。当客户端收到一个chunked comet response后，执行回调函数.

举例：

def comet = Action {
  val events = Enumerator(&quot;kiki&quot;, &quot;foo&quot;, &quot;bar&quot;)
  Ok.stream(events &amp;amp;&amp;gt; Comet(callback = &quot;parent.cometMessage&quot;))
}

以及相应的Html页面：

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  var cometMessage = function(event) {
    console.log(&apos;Received event: &apos; + event)
  }
&amp;lt;/script&amp;gt;

&amp;lt;iframe src=&quot;/comet&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文： &lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaComet&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaComet&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>08. 流式的Http响应</title>
                <link>http://freewind.in/posts/1282-play2-08-streaming-http-response</link>
                <pubDate>Tue, 01 Jan 2013 17:01:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1282</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h3&gt;流式的HTTP响应&lt;/h3&gt;
&lt;h4&gt;Http响应和Content-Length头&lt;/h4&gt;
&lt;p&gt;在Http 1.1里，为了在一条TCP连接上进行多次请求和响应的发送，服务器必须为&lt;code&gt;Content-Length&lt;/code&gt;选择合适的值. 但一般情况下，你无需主动指定&lt;code&gt;Content-Length&lt;/code&gt;的值. 比如发送一段简单的文本，Play能根据文本的长度计算出&lt;code&gt;Content-Length&lt;/code&gt;的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def index = Action {
  Ok(&quot;Hello World&quot;)
}
&amp;gt; **注意: **对于文本响应，`Content-Length`的值除了和字符串的长度有关外，还跟所使用的字符编码有关。`Content-Length`的值表示要传输的字节流大小。

之前我们提到，使用`play.api.libs.iteratee.Enumerator`指定Http响应正文:

def index = Action {
  SimpleResult(
    header = ResponseHeader(200),
    body = Enumerator(&quot;Hello World&quot;)
  )
}

实际上，Play要遍历整个`Enumerator`才能算出`Content-Length`的值，并且必须把`Enumerator`放在内存里

#### 发送大量的数据

如果只是发送少量的数据，采用上述简单的方法是没问题的，但对于要发送大数据量的情形，比如需要向客户端发送一个几兆的文件，就需要用到流式处理

假设我们需要将一个几兆的PDF文件发送给客户端，仍采用`Enumerator[Array[Byte]]`的办法：

val file = new java.io.File(&quot;/tmp/fileToServe.pdf&quot;)
val fileContent: Enumerator[Array[Byte]] = Enumerator.fromFile(file)

def index = Action {

  val file = new java.io.File(&quot;/tmp/fileToServe.pdf&quot;)
  val fileContent: Enumerator[Array[Byte]] = Enumerator.fromFile(file)    

  SimpleResult(
    header = ResponseHeader(200),
    body = fileContent
  )
}

此时，Play会整个PDF文件加载到内存，然后计算`Content-Length`的值。 这在高并发场景下容易造成内存不足。为了避免这个问题，我们需要手动指定`Content-Length`的值。

def index = Action {

  val file = new java.io.File(&quot;/tmp/fileToServe.pdf&quot;)
  val fileContent: Enumerator[Array[Byte]] = Enumerator.fromFile(file)    

  SimpleResult(
    header = ResponseHeader(200, Map(CONTENT_LENGTH -&amp;gt; file.length.toString)),
    body = fileContent
  )
}

这样的话，Play会一边读取PDF文件的内容，一边往Http响应体发送字节流。

#### 文件的服务

针对常见的文件服务场景, Play提供了一些工具函数:

def index = Action {
  // 将/tmp/fileToServe.pdf 发送给客户端
  Ok.sendFile(new java.io.File(&quot;/tmp/fileToServe.pdf&quot;))
}

这个`Ok.sendFile`函数会自动计算`Content-Type`的值，并提供`Content-Disposition`的值告诉浏览器该如何处理这个Http响应。默认的行为是往添加一个`Content-Disposition: attachment; filename=fileToServe.pdf`的Http header, 告诉浏览器下载文件. 使用这些工具函数能提高程序的开发效率.

你可以指定文件下载时使用的名字：

def index = Action {
  Ok.sendFile(
    content = new java.io.File(&quot;/tmp/fileToServe.pdf&quot;),
    fileName = _ =&amp;gt; &quot;termsOfService.pdf&quot;
  )
}

如果你希望浏览器显示文件的内容，而不是下载它，那么可以这样做：

def index = Action {
  Ok.sendFile(
    content = new java.io.File(&quot;/tmp/fileToServe.pdf&quot;),
    inline = true  // 告诉浏览器直接显示文件的内容
  )
}

#### 分块响应（chunked response）

如果无法事先计算响应正文的大小, 就需要使用**分块传输编码（Chunked transfer encoding）**技术。

&amp;gt; **分块传输编码（Chunked transfer encoding）**是Http 1.1引入的一种数据传输方式。使用这种数据传输方式时，服务器需要设置`Transfer-Encoding`响应头，但无需设置`Content-Length`。由于没有指定`Content-Length`，服务器在向客户端（通常是浏览器）开始传输响应数据时，无需知道内容的总长度（可能事先也无法知道）.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;pre&gt;&lt;code&gt;服务器可以不断地向客户端发送动态产生的数据。数据以分块的形式进行传输。在向客户端传输每个数据块之前， 服务器会先告诉客户端该数据块的大小，这样客户端就能知道每次要接收多少字节的信息量。当服务器向客户端传输一个长度为0的数据块时，表明整个传输过程结束，客户端可以关闭Http连接。

关于**分块传输编码（Chunked transfer encoding）**的更多内容，请参阅[[[http://en.wikipedia.org/wiki/Chunked_transfer_encoding](http://en.wikipedia.org/wiki/Chunked_transfer_encoding)]]

这种传输方式的优点是允许我们**实时**传输数据，也就是说只要数据准备就绪（哪怕是一小部分），就可以立即发送。缺点是客户端（或浏览器）无法知道还要接收多少字节信息，因此无法准确显示剩余下载时间。

在下面的例子中，我们假设提供了一个能不断产生数据的输入流`InputStream`的服务. 首先，我们需要从该流构建一个`Enumerator`:

val data = getDataStream
val dataContent: Enumerator[Array[Byte]] = Enumerator.fromStream(data)

然后我们可以使用`ChunkedResult`以流的形式发送数据：

def index = Action {

  val data = getDataStream
  val dataContent: Enumerator[Array[Byte]] = Enumerator.fromStream(data)

  ChunkedResult(
    header = ResponseHeader(200),
    chunks = dataContent
  )
}

和平常一样，Play也为这种场景提供了辅助函数：

def index = Action {

  val data = getDataStream
  val dataContent: Enumerator[Array[Byte]] = Enumerator.fromStream(data)

  Ok.stream(dataContent)
}

当然，我们也可以使用`Enumerator`来创建若干数据块

def index = Action {
  Ok.stream(
    Enumerator(&quot;kiki&quot;, &quot;foo&quot;, &quot;bar&quot;).andThen(Enumerator.eof)
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; &lt;code&gt;Enumerator.callbackEnumerator&lt;/code&gt;和&lt;code&gt;Enumerator.pushEnumerator&lt;/code&gt;是两种以命令式代码风格创建活性非阻塞迭代器(enumerators)的快捷方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你可以使用一些Http剖析工具查看上述例子的Http响应文本：

HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Transfer-Encoding: chunked

4
kiki
3
foo
3
bar
0
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;从剖析的结果来看，服务器向客户端发送了三个数据块,分别是_kiki&lt;em&gt;,&lt;/em&gt;foo_和_bar_,最后发送一个0字节的数据块告诉客户端整个传输过程结束。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaStream&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaStream&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>07. 编写异步的Http应用</title>
                <link>http://freewind.in/posts/1281-play2-07-asynchronous-http-application</link>
                <pubDate>Tue, 01 Jan 2013 17:01:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1281</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h3&gt;处理异步响应&lt;/h3&gt;
&lt;h4&gt;为什么要使用异步处理?&lt;/h4&gt;
&lt;p&gt;目前为止，我们都是采用同步方式处理Http请求。但在某些情况下，比如需要调用一个Web Service或执行一段耗时的运算来生成最终的Http响应结果，同步处理方式会暴露出严重的性能问题，导致Play应用无法响应更多的Http请求。&lt;/p&gt;
&lt;p&gt;正因为如此，action代码块应该能被快速执行，尽量不要出现阻塞操作。但如果无法立即产生最终的结果，比如需要调用一个Web Service或执行一段长时间的运算，那么我们应该如何做呢？答案是，返回一个result的承诺(a promise of result), 即承诺在将来某个时间点产生最终的result。（译者：类似于JDK 5的Future对象)&lt;/p&gt;
&lt;p&gt;Play使用&lt;code&gt;Promise[Result]&lt;/code&gt;来表示一个result的承诺. 让Action返回&lt;code&gt;Promise[Resut]&lt;/code&gt;可以避免因为某些长时间的操作而使程序陷入阻塞。等最终的Result生成后，Play再从&lt;code&gt;Promise[Result]&lt;/code&gt;中找回result。&lt;/p&gt;
&lt;p&gt;虽然在响应结果(result)被产生之前客户端仍要等待，但不会对对服务器造成阻塞，服务器仍能继续响应其他Http请求。&lt;/p&gt;
&lt;h4&gt;如何创建&lt;code&gt;Promise[Result]&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;首先，我们看看&lt;code&gt;play.api.libs.concurrent.Promise[A]&lt;/code&gt;的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val promiseOfPIValue: Promise[Double] = computePIAsynchronously()
val promiseOfResult: Promise[Result] = promiseOfPIValue.map { pi =&amp;gt;
  Ok(&quot;PI value computed: &quot; + pi)    
}

这里我们使用`computePIAsynchronously()`自定义函数计算圆周率(pi)。 为了不阻塞当前线程，`computePIAsynchronously()`函数快速返回一个`Promise[Double]`类型的对象。然后我们再把`Promise[Double]`转换成`Promise[Result]`。 至于`computePIAsynchronously()`的内部实现，可能是创建一个异步的计算任务交给执行器执行。

需要注意的是，所有Play 2.0的异步API都返回`Promise[A]`类型的对象。 比如当你使用`play.api.libs.ws.WS`调用一个Web Service，或者使用`play.api.libs.concurrent.Akka`创建一个异步的任务，API函数都会立即返回一个`Promise`，避免当前执行线程阻塞。只有当尝试从`Promise`取回最终的结果时，才会阻塞当前执行线程。

下面我们看看如何使用`play.api.libs.concurrent.Akka`提供的辅助函数来创建一个异步的任务。

val promiseOfInt: Promise[Int] = Akka.future {
  intensiveComputation()  
}

这里把耗时的计算（`intensiveComputation()`函数）放在另一个线程里执行，也可以使用Akka remote将计算任务放在后端集群服务器上执行。

#### 异步结果

当你创建一个异步的计算任务时，需要向客户端返回一个`AsyncResult`对象来包装`SimpleResult`

def index = Action {
  val promiseOfInt = Akka.future { intensiveComputation() }
  Async {
    promiseOfInt.map(i =&amp;gt; Ok(&quot;Got result: &quot; + i))
  }
}

这里的`Async{ ... }`是一个根据`Promise[Result]`构建`AsyncResult`的辅助函数

#### 超时的处理

提供超时响应是有用的，因为它可以避免因为某些不可预知的错误而导致线程陷入长时间的阻塞或等待。 你可以指定一个超时阀值，当尝试从`Promise`取回最终值时，如果等待时间超过指定的阀值，则返回一个预设的值。


def index = Action {
  val promiseOfInt = play.api.libs.concurrent.Akka.future { intensiveComputation() }
  Async {
    promiseOfInt.orTimeout(&quot;Oops&quot;, 1000).map { eitherIntOrTimeout =&amp;gt;
      eitherIntOrTimeout.fold(
        i =&amp;gt; Ok(&quot;Got result: &quot; + i),
        timeout =&amp;gt; InternalServerError(timeout)
      )    
    }  
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaAsync&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaAsync&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>06. Action 的组合</title>
                <link>http://freewind.in/posts/1280-play2-06-action-composition</link>
                <pubDate>Tue, 01 Jan 2013 17:00:59 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1280</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h3&gt;Action 的组合&lt;/h3&gt;
&lt;p&gt;这章介绍几种定义action功能的方法。&lt;/p&gt;
&lt;h4&gt;基本的Action组合&lt;/h4&gt;
&lt;p&gt;假设我们需要记录每次action的调用，那么首先需要定义一个生成&lt;code&gt;Action&lt;/code&gt;对象的辅助函数, 并且在该函数中记录action的调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def LoggingAction(f: Request[AnyContent] =&amp;gt; Result): Action[AnyContent] = {
  Action { request =&amp;gt;
    Logger.info(&quot;Calling action&quot;)
    f(request)
  }
}

然后使用刚定义的`LoggigAction`

def index = LoggingAction { request =&amp;gt;
  Ok(&quot;Hello World&quot;)    
}

修改一下上述的`LogginAction`，使其能被指定一个正文解析器:

def LoggingAction[A](bp: BodyParser[A])(f: Request[A] =&amp;gt; Result): Action[A] = {
  Action(bp) { request =&amp;gt;
    Logger.info(&quot;Calling action&quot;)
    f(request)
  }
}

def index = LoggingAction(parse.text) { request =&amp;gt;
  Ok(&quot;Hello World&quot;)    
}

#### 包装现有的action

面使用包装模式给原生的`Action`添加额外功能：

case class Logging[A](action: Action[A]) extends Action[A] {

  def apply(request: Request[A]): Result = {
    Logger.info(&quot;Calling action&quot;)
    action(request)
  }

  lazy val parser = action.parser
}

然后这样使用：

def index = Logging { 
  Action { 
    Ok(&quot;Hello World&quot;)
  }
}

你仍然可以指定body parser：

def index = Logging { 
  Action(parse.text) { 
    Ok(&quot;Hello World&quot;)
  }
}
&amp;gt; 另一种等价的写法：
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;pre&gt;&lt;code&gt;def Logging[A](action: Action[A]): Action[A] = {
  Action(action.parser) { request =&amp;gt;
    Logger.info(&quot;Calling action&quot;)
    action(request)
  }
}

#### 更复杂的例子

让我们看看一个更复杂但普通的权限验证的例子。这个例子中，我们需要使用包装过的body parser进行权限验证，并且向action代码块传递一个经过权限验证的user,并且。

def Authenticated[A](action: User =&amp;gt; Action[A]): Action[A] = {

  // Let&apos;s define a helper function to retrieve a User
  def getUser(request: RequestHeader): Option[User] = {
    request.session.get(&quot;user&quot;).flatMap(u =&amp;gt; User.find(u))
  }

  // Wrap the original BodyParser with authentication
  val authenticatedBodyParser = parse.using { request =&amp;gt;
    getUser(request).map(u =&amp;gt; action(u).parser).getOrElse {
      parse.error(Unauthorized)
    }          
  }

  // Now let&apos;s define the new Action
  Action(authenticatedBodyParser) { request =&amp;gt;
    getUser(request).map(u =&amp;gt; action(u)(request)).getOrElse {
      Unauthorized
    }
  }

}

然后在controller中这样使用：

def index = Authenticated { user =&amp;gt;
  Action { request =&amp;gt;
    Ok(&quot;Hello &quot; + user.name)      
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 在&lt;code&gt;play.api.mvc.Security.Authenticated&lt;/code&gt;中已经有&lt;code&gt;Authenticated&lt;/code&gt;的更好实现。这里的例子做了简化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### 另一种创建Authenticated Action的方式

让我们看看如何在既不包装整个action也不authenticating the body parser的情况下改写上面的例子

def Authenticated(f: (User, Request[AnyContent]) =&amp;gt; Result) = {
  Action { request =&amp;gt;
    request.session.get(&quot;user&quot;).flatMap(u =&amp;gt; User.find(u)).map { user =&amp;gt;
      f(user, request)
    }.getOrElse(Unauthorized)      
  }
}

def index = Authenticated { (user, request) =&amp;gt;
   Ok(&quot;Hello &quot; + user.name)    
}

这个例子存在的问题是无法将`request`声明为`implicit`. 可以采用curry的风格解决:

def Authenticated(f: User =&amp;gt; Request[AnyContent] =&amp;gt; Result) = {
  Action { request =&amp;gt;
    request.session.get(&quot;user&quot;).flatMap(u =&amp;gt; User.find(u)).map { user =&amp;gt;
      f(user)(request)
    }.getOrElse(Unauthorized)     
  }
}

def index = Authenticated { user =&amp;gt; implicit request =&amp;gt;
   Ok(&quot;Hello &quot; + user.name)    
}

另一种（也许更简单的）方法是定义一个`Request`的子类`AuthenticatedRequest`，这样我们就可以将两个参数合成一个参数：

case class AuthenticatedRequest(
  val user: User, request: Request[AnyContent]
) extends WrappedRequest(request)

def Authenticated(f: AuthenticatedRequest =&amp;gt; Result) = {
  Action { request =&amp;gt;
    request.session.get(&quot;user&quot;).flatMap(u =&amp;gt; User.find(u)).map { user =&amp;gt;
      f(AuthenticatedRequest(user, request))
    }.getOrElse(Unauthorized)            
  }
}

def index = Authenticated { implicit request =&amp;gt;
   Ok(&quot;Hello &quot; + request.user.name)    
}

对`Authenticated`函数重构一下，使其能指定BodyParser

case class AuthenticatedRequest[A](
  val user: User, request: Request[A]
) extends WrappedRequest(request)

def Authenticated[A](p: BodyParser[A])(f: AuthenticatedRequest[A] =&amp;gt; Result) = {
  Action(p) { request =&amp;gt;
    request.session.get(&quot;user&quot;).flatMap(u =&amp;gt; User.find(u)).map { user =&amp;gt;
      f(AuthenticatedRequest(user, request))
    }.getOrElse(Unauthorized)      
  }
}

// Overloaded method to use the default body parser
import play.api.mvc.BodyParsers._
def Authenticated(f: AuthenticatedRequest[AnyContent] =&amp;gt; Result): Action[AnyContent]  = {
  Authenticated(parse.anyContent)(f)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaActionsComposition&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaActionsComposition&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>05. Http正文解析器</title>
                <link>http://freewind.in/posts/1279-play2-05-http-body-parser</link>
                <pubDate>Tue, 01 Jan 2013 17:00:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1279</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h4&gt;什么是Http正文解析器（Http Body Parser）&lt;/h4&gt;
&lt;p&gt;我们知道Http的PUT请求和POST请求能包含正文（或叫主体）. Http正文能携带任何信息，通过&lt;code&gt;Content-Type&lt;/code&gt;标明正文的类型。Play使用正文解析器（&lt;strong&gt;Body parser&lt;/strong&gt;）将Http正文转换成某种Scala类型的数据。&lt;/p&gt;
&lt;p&gt;一个Http正文解析器用&lt;code&gt;play.api.mvc.BodyParser[A]&lt;/code&gt;表示，它将接收到的字节流转换成类型为A的目标对象.&lt;/p&gt;
&lt;p&gt;然而，http正文可能很大， 如果等所有的正文内容传输完再一次性放到内存进行解析，这样的做法是不高效的。 某些目标对象，比如字符串和文件，完全可以一边接收字节流一边进行构建。&lt;/p&gt;
&lt;p&gt;另外，在开始解析正文之前，&lt;strong&gt;Http正文解析器&lt;/strong&gt;可以获取请求头的内容，从而可以对正文先执行一些检查. 比如客户端上传的文件是否过大，正文类型（Content-Type)是否符合要求等等。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你可以将&lt;code&gt;BodyParser[A]&lt;/code&gt;看成&lt;code&gt;Iteratee[Array[Byte], A]&lt;/code&gt;，但准确来说应该要看成&lt;code&gt;Iteratee[Array[Byte], Either[Result,A]]&lt;/code&gt;。这样设计的目的在于，当无法正确解析Http正文时可以直接返回诸如&lt;code&gt;400 BAD_REQUEST&lt;/code&gt;,&lt;code&gt;412 PRECONDITION_FAILED&lt;/code&gt;或者&lt;code&gt;413 REQUEST_ENTITY_TOO_LARGE&lt;/code&gt;等响应。想了解更多流式处理的内容，请点击 [[这里 | Iteratees]]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完成Http正文的解析之后会返回一个类型为&lt;code&gt;A&lt;/code&gt;的对象并保存在&lt;code&gt;request&lt;/code&gt;对象里，然后执行&lt;code&gt;Action&lt;/code&gt;函数&lt;/p&gt;
&lt;h4&gt;关于Actions&lt;/h4&gt;
&lt;p&gt;前面提到，&lt;code&gt;Action&lt;/code&gt;是一个&lt;code&gt;Request =&amp;gt; Result&lt;/code&gt;的函数，但不完全正确。我们先来看看&lt;code&gt;Action&lt;/code&gt;特质的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;trait Action[A] extends (Request[A] =&amp;gt; Result) {
  def parser: BodyParser[A]
}

首先我们看到`Request`带有一个泛型`A`,并在`Action`中定义了一个象函数`parser`，`parser`的返回类型是`BodyParser[A]`

我们再来看看`Request`特质的定义：

trait Request[+A] extends RequestHeader {
  def body: A
}

这里的`A`类型就是Http正文解析后的类型。我们定义任何我们想要的类型，常见的有`String`,`NodeSeq`,`Array[Byte]`,`JsonValue`和`java.io.File`等，只要提供相应的body parser

总的来说，`Action[A]`使用`BodyParser[A]`将Http正文解析成类型为`A`的对象，然后创建`Request[A]`对象并传递给action代码块

#### 默认的Http正文解析器

如果不指定Http正文解析器，那么Play会使用一个将Http正文解析成`play.api.mvc.AnyContent`的默认解析器(`play.api.mvc.BodyParsers.parser`)。这个解析器会根据`Content-Type`的值决定解析成那种类型的对象；
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;text/plain&lt;/strong&gt;: &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;application/json&lt;/strong&gt;: &lt;code&gt;JsValue&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;text/xml&lt;/strong&gt;: &lt;code&gt;NodeSeq&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;application/form-url-encoded&lt;/strong&gt;: &lt;code&gt;Map[String, Seq[String]]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;multipart/form-data&lt;/strong&gt;: &lt;code&gt;MultipartFormData[TemporaryFile]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;any other content type: &lt;code&gt;RawBuffer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;def save = Action { request =&gt;
&lt;br  /&gt;val body: AnyContent = request.body
&lt;br  /&gt;val textBody: Option[String] = body.asText&lt;/p&gt;
&lt;p&gt;// Expecting text body
&lt;br  /&gt;textBody.map { text =&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ok(&quot;Got: &quot; + text)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}.getOrElse {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BadRequest(&quot;Expecting text/plain request body&quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;h4&gt;指定一个解析器&lt;/h4&gt;
&lt;p&gt;如果&lt;code&gt;Content-Type&lt;/code&gt;的值是&lt;code&gt;text/plain&lt;/code&gt;，可以使用&lt;code&gt;parser.text&lt;/code&gt;将正文解析成&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;def save = Action(parse.text) { request =&gt;
&lt;br  /&gt;Ok(&amp;ldquo;Got: &quot; + request.body)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;你是否注意到这段代码的简洁性？ 实际上，如果在解析过程中发生错误或正文无法解析，那么&lt;code&gt;parse.text&lt;/code&gt;会直接返回&lt;code&gt;400 BAD_REQUEST&lt;/code&gt;的响应，因此我们无需在action代码块中对解析后的&lt;code&gt;request.body&lt;/code&gt;进行检验。&lt;/p&gt;
&lt;p&gt;上面的代码可以改成：&lt;/p&gt;
&lt;p&gt;def save = Action(parse.tolerantText) { request =&gt;
&lt;br  /&gt;Ok(&amp;ldquo;Got: &quot; + request.body)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;所不同的是，&lt;code&gt;parser.tolerantText&lt;/code&gt;不会检查&lt;code&gt;Content-Type&lt;/code&gt;的值，它只是简单地把Http正文转换成&lt;code&gt;java.lang.String&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 每一种body parser都有相应的&lt;code&gt;tolerant&lt;/code&gt;版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的例子将Http正文解析成一个文件&lt;/p&gt;
&lt;p&gt;def save = Action(parse.file(to = new File(&amp;ldquo;/tmp/upload&amp;rdquo;))) { request =&gt;
&lt;br  /&gt;Ok(&amp;ldquo;Saved the request content to &quot; + request.body)
&lt;br  /&gt;}&lt;/p&gt;
&lt;h4&gt;组合正文解析器&lt;/h4&gt;
&lt;p&gt;现在编写一个自定义的正文解析器。这个正文解析器从session中提取用户名, 并为每个用户生成一个唯一的文件。&lt;/p&gt;
&lt;p&gt;val storeInUserFile = parse.using { request =&gt;
&lt;br  /&gt;request.session.get(&amp;ldquo;username&amp;rdquo;).map { user =&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file(to = new File(&quot;/tmp/&quot; + user + &quot;.upload&quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}.getOrElse {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error(Unauthorized(&quot;You don&apos;t have the right to upload here&quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;def save = Action(storeInUserFile) { request =&gt;
&lt;br  /&gt;Ok(&amp;ldquo;Saved the request content to &quot; + request.body)
&lt;br  /&gt;}&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 这里我们没有真正实现自己的正文解析器，只是组合现有的正文解析器。一般来说，Play提供的正文解析器能满足大部分应用场景。后面的章节会介绍如何编写自己的正文解析器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;最大内容长度&lt;/h4&gt;
&lt;p&gt;对于针对文本的正文解析器，比如&lt;strong&gt;text&lt;/strong&gt;,&lt;strong&gt;json&lt;/strong&gt;,&lt;strong&gt;xml&lt;/strong&gt;或者&lt;strong&gt;formUrlEncoded&lt;/strong&gt;, Play会使用一个阀值来限制正文的最大长度。因为这几种解析器会将Http正文全部放到内存进行解析。Play将Http正文的最大长度默认地被限制为100KB,你可以在修改该阀值。请看下面的例子：&lt;/p&gt;
&lt;p&gt;// 只接受不大于10KB的文本
&lt;br  /&gt;def save = Action(parse.text(maxLength = 1024 * 10)) { request =&gt;
&lt;br  /&gt;Ok(&amp;ldquo;Got: &quot; + text)
&lt;br  /&gt;}&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt; 可以在&lt;code&gt;application.conf&lt;/code&gt;配置文件中指定Http文本的最大长度:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`parsers.text.maxLength=128K`
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者使用&lt;code&gt;maxLength&lt;/code&gt;函数；&lt;/p&gt;
&lt;p&gt;// Accept only 10KB of data.
&lt;br  /&gt;def save = Action(maxLength(1024 * 10, parser = storeInUserFile)) { request =&gt;
&lt;br  /&gt;Ok(&amp;ldquo;Saved the request content to &quot; + request.body)
&lt;br  /&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaBodyParsers&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaBodyParsers&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>04. Session的Flash使用</title>
                <link>http://freewind.in/posts/1278-play2-04-session-and-flash</link>
                <pubDate>Tue, 01 Jan 2013 16:59:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1278</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h4&gt;Session和Flash的区别&lt;/h4&gt;
&lt;p&gt;如果你需要在几个Http请求之间保持数据，你可以将他们保存在Session或Flash内. 两者的区别是，保存在Session中的数据在整个用户会话的过程中一直有效，而保存在Flash中数据只在下一次请求中有效。&lt;/p&gt;
&lt;p&gt;需要注意的是，Session和Flash中的数据都不是保存在服务器端的，而是通过cookie机制在几个Http请求之间来回传递。因此保存在Session或Flash中的数据量不宜过大，最好控制在4KB以内，并且只能保存字符串值。&lt;/p&gt;
&lt;p&gt;当然，这些保存在cookie中的数据是经过数字签名的，因此你不需要担心数据被篡改.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;译者：敏感数据尽量保存在服务器缓存或加密后传输&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Session不应该被当做缓存来使用（尽管你可以这么做）。如果你需要缓存某些数据，并且这些数据要跟Session绑定，你可以这样做：使用Play内置的缓存机制将需要缓存的数据保存起来，然后在Session中只保留一个和该缓存数据块关联的ID。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Session中的数据不会超时失效，除非用户终止会话（比如浏览器关闭了）。会话终止后，session会被销毁。如果你需要给Session中某些数据设置超时的阀值，你可以为它们添加一个时间戳，然后在每次读取数据之前和当前时间进行对比.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;从Session中读取数据&lt;/h4&gt;
&lt;p&gt;要从session中读取数据，首先你要从Http的请求对象（&lt;code&gt;play.api.mvc.Request&lt;/code&gt;）获得一个Session对象（&lt;code&gt;play.api.mvc.Session&lt;/code&gt;）. Session对象提供了数据读取操作函数；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def index = Action { request =&amp;gt;
  request.session.get(&quot;connected&quot;).map { user =&amp;gt;
    Ok(&quot;Hello &quot; + user)
  }.getOrElse {
    Unauthorized(&quot;Oops, you are not connected&quot;)
  }
}

如果`request`被声明为隐式参数，那么Session对象会自动从`request`获得。

def index = Action { implicit request =&amp;gt;
  session.get(&quot;connected&quot;).map { user =&amp;gt;
    Ok(&quot;Hello &quot; + user)
  }.getOrElse {
    Unauthorized(&quot;Oops, you are not connected&quot;)
  }
}

想了解scala的隐式转换机制，请参阅：

#### 将数据保存在Session

`play.api.mvc.SimpleResult`对象提供了`withSession`函数设置session。

Ok(&quot;Welcome!&quot;).withSession(
  &quot;connected&quot; -&amp;gt; &quot;user@gmail.com&quot;
)

如果只是希望往session中添加数据，请使用下面的方法：

Ok(&quot;Hello World!&quot;).withSession(
  session + (&quot;saidHello&quot; -&amp;gt; &quot;yes&quot;)
)

如果想从session删除某些数据，可以这样做

Ok(&quot;Theme reset!&quot;).withSession(
  session - &quot;theme&quot;
)

#### 丢弃整个session

Ok(&quot;Bye&quot;).withNewSession

#### Flash对象的使用

Flash的使用方法和Session一样，但有两点不同：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;保存在Flash中的数据只对下一次请求有效*   Flash也是通过cookie机制实现的，但Play不会对Flash中的数据进行数字签名。因此客户端可以修改Flash中的数据&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;重要提示:&lt;/strong&gt; Flash对象应该只用于非Ajax应用中来传输成功或失败的信息, 因为ajax应用的请求是异步的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是使用flash的例子：&lt;/p&gt;
&lt;p&gt;def index = Action { implicit request =&gt;
&lt;br  /&gt;Ok {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flash.get(&quot;success&quot;).getOrElse(&quot;Welcome!&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;def save = Action {
&lt;br  /&gt;Redirect(&amp;ldquo;/home&amp;rdquo;).flashing(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;success&quot; -&amp;gt; &quot;The item has been created&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;)
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;如果需要在views中获取Flash中的数据，那么将flash声明为implicit&lt;/p&gt;
&lt;p&gt;@()(implicit flash: Flash)
&lt;br  /&gt;&amp;hellip;
&lt;br  /&gt;@flash.get(&amp;ldquo;success&amp;rdquo;).getOrElse(&amp;ldquo;noooz&amp;rdquo;)
&lt;br  /&gt;&amp;hellip;&lt;/p&gt;
&lt;p&gt;如果出现&apos;&lt;em&gt;could not find implicit value for parameter flash: play.api.mvc.Flash&lt;/em&gt;&apos;的错误，那是因为你没有在Action的闭包中奖request声明为implicit. 请将&lt;code&gt;request =&amp;gt;&lt;/code&gt;改成&lt;code&gt;implicit request =&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;def index() = Action {
&lt;br  /&gt;implicit request =&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ok(views.html.Application.index())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaSessionFlash&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaSessionFlash&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>03. 生成Http响应</title>
                <link>http://freewind.in/posts/1277-play2-03-generate-http-response</link>
                <pubDate>Tue, 01 Jan 2013 16:59:11 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1277</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h4&gt;修改Content-Type&lt;/h4&gt;
&lt;p&gt;当你使用Play提供的工具函数生成Http响应，Play会为&lt;code&gt;Content-Type&lt;/code&gt;选择一个合适的值. 比如&lt;code&gt;Ok(&quot;Hello World&quot;)&lt;/code&gt;函数会将&lt;code&gt;Content-Type&lt;/code&gt;的值设为&lt;code&gt;text/plain&lt;/code&gt;,&lt;code&gt;Ok(&amp;lt;message&amp;gt;Hello world&amp;lt;/message&amp;gt;)&lt;/code&gt;会将&lt;code&gt;Content-Type&lt;/code&gt;的值设为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// set Content-Type to text/plain
val textResult = Ok(&quot;Hello World!&quot;)

// set Content-Type to text/xml
val xmlResult = Ok(&amp;lt;message&amp;gt;Hello World!&amp;lt;/message&amp;gt;)
&amp;gt; **提示：** Play实际上是使用`play.api.http.ContentTypeOf`来完成`Content-Type`的类型选择

你也可以使用`as(newContentType)`显式指定`Content-Type`的值：

val htmlResult = Ok(&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;).as(&quot;text/html&quot;)

或者

val htmlResult = Ok(&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;).as(HTML)
&amp;gt; **注意:** 使用`HTML`辅助函数的好处是Play会自动为你添加html页面的字符编码，也就说`Content-Type`的值会被设置成形如`text/html; charset=UTF-8`

#### 修改Http响应头

Play提供了工具函数让你随意添加和修改Http响应头

Ok(&quot;Hello World!&quot;).withHeaders(
  CACHE_CONTROL -&amp;gt; &quot;max-age=3600&quot;, 
  ETAG -&amp;gt; &quot;xx&quot;
)
&amp;gt; **注意：**, 添加或修改的Http响应头会覆盖之前或默认的值

#### 设置和删除cookies

Cookie是一种特殊的Http响应头。Play提供了一组工具函数方便设置Cookies，比如：

Ok(&quot;Hello world&quot;).withCookies(
  Cookie(&quot;theme&quot;, &quot;blue&quot;)
)

要删除某个cookie，可以这样做：

Ok(&quot;Hello world&quot;).discardingCookies(&quot;theme&quot;)

#### 修改响应文本的字符集

给响应文本设置正确的字符集是非常重要的。Play默认采用UTF-8字符集

这里所说的字符集，有两个用途。一是用于将响应文本转换成字节流，然后通过网络传输给浏览器, 二是用于设置`Content-Type`的字符集。你可以选择其他字符集，比如ISO-8859-1：

object Application extends Controller {

  implicit val myCustomCharset = Codec.javaSupported(&quot;iso-8859-1&quot;)

  def index = Action {
    Ok(&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;).as(HTML)
  }

}

这里我们定义了一个隐式字符集变量值(`myCustomCharset`)，它会被`Ok(..)`函数用于将XML文本转成`ISO-8859-1`编码的字节流，被HTML函数将`Content-Type`的值设置为`text/html; charset=iso-8859-1`

实际上HTML函数是这样定义的：

def HTML(implicit codec: Codec) = {
  &quot;text/html; charset=&quot; + codec.charset
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然你可以显式指定字符集（而不采用隐式转换的方法）&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;译者：我认为恰当使用隐式转换可以让代码更简洁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文： &lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaResults&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaResults&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>02. HTTP路由</title>
                <link>http://freewind.in/posts/1276-play2-02-http-routing</link>
                <pubDate>Tue, 01 Jan 2013 16:58:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1276</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;h4&gt;内置的Http路由&lt;/h4&gt;
&lt;p&gt;在Play中，路由是负责将Http请求转换为Action的组件。&lt;/p&gt;
&lt;p&gt;在MVC框架中，一个Http请求被看成一个事件。这种事件包含两种信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求路径，比如&lt;code&gt;/clients/1542&lt;/code&gt;, &lt;code&gt;/photos/list&lt;/code&gt;, 也包括查询字符串，比如&lt;code&gt;/users/?id=1001&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求方法，比如GET,POST等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;路由匹配信息定义在&lt;code&gt;conf/routes&lt;/code&gt;文件中，和Play 1.x不同，&lt;em&gt;该文件会被纳入编译范畴&lt;/em&gt;。也就是说，你可以直接在浏览器中看到路由匹配的错误。&lt;/p&gt;
&lt;p&gt;[[images/routesError.png]]&lt;/p&gt;
&lt;h4&gt;路由语法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;conf/routes&lt;/code&gt;文件是路由配置文件。所有的Http路由信息都在该文件定义。每条路由信息占一行，由Http请求方法，URI模式和&lt;code&gt;Action&lt;/code&gt;生成函数组成。下面是&lt;code&gt;routes&lt;/code&gt;文件的一部分内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET   /clients/:id          controllers.Clients.show(id: Long)

这个例子定义了一个路由信息，意思是当客户端向服务器发起形如`GET /clients/123`的请求时，由控制器Clients中的Action生成函数`show`进行处理，其中请求路径上的数字`123`会赋值给`id`变量.

你可以给`route`文件添加注释，只需在每一行的开头加上`#`，比如：

# 这里是注释 
# Display a client
GET   /clients/:id          controllers.Clients.show(id: Long)

#### Http方法

Play支持所有Http请求方法，包括`GET`,`POST`,`PUT`,`DELETE`,`HEAD`等

#### URI模式

URI模式用于匹配Http路由请求路径

##### 静态模式

假如你要准确匹配形如`GET /clients/all`这样的Http请求，你可以这样定义：

GET   /clients/all              controllers.Clients.list()

##### 动态模式

假如客户端希望能根据不同的客户ID查询客户信息，比`GET /clients/1`查询ID为1的客户信息，`GET /clients/2`查询ID为2的客户信息，你可以这样定义：

GET   /clients/:id          controllers.Clients.show(id: Long)
&amp;gt; 注意：你需要在`show`函数声明一个名字为`id`的参数，假如你使用其他名字，比如`clientId`,那么Play不会将`:id`的值传递过去. 此外，你还可以在URI模式上指定更多变量，比如
# 获取某个部门（根据部门ID）的男性或女性员工的信息
GET /departments/:id/gender/:gender controllers.Department.show(id: Long, String gender)
&amp;gt; 注意：URI模式的动态部分，如上例中的`:id`，是采用正则表达式`[^/]+`进行匹配的。也就是说，形如`/client/:id`的URI模式能匹配`/clients/123` ，但不能匹配`/clients/id/123`。

##### 如何让URI模式的动态部分匹配多个路径段？

你可以使用形如`*id`来匹配多个URI路径段，这时Play会使用`.*`正则表达式进行匹配。下面的路由会匹配形如`GET /files/images/logo.png`或`GET images/logo.png`这样的Http请求：

GET   /files/*name          controllers.Application.download(name)

##### 使用正则表达式

要对URI模式的动态部分实现更细粒度的匹配，就需要编写正则表达式。比如，客户的ID只有数字组成，那么可以这样定义路由规则：

GET   /clients/$id&amp;lt;[0-9]+&amp;gt;  controllers.Clients.show(id: Long)

其中`[0-9]+`是正则表达式。

#### 调用Action生成函数

路由定义的最后一部分是处理函数。该函数又叫做Controller Action method，它必须返回一个`play.api.mvc.Action`对象。

如果该函数没有定义任何参数，则给出函数的全路径名并以`()`结束。看下面的例子:

GET   /                     controllers.Application.homePage()

如果action函数定义了参数，那么Play会将URI路径或查询字符串上相应的值传递给函数参数。看下面的例子：

# 将URI路径上的:page值传递给show函数的参数page
GET   /:page                controllers.Application.show(page)

又如:

# 如果客户端发起的请求带有查询字符串?page=XXX，则Play将XXX传递给show函数的参数page
GET   /                     controllers.Application.show(page)

同时，我们要在`controllers.Application`控制器中定义`show`函数:

def show(page: String) = Action {
    loadContentFromDatabase(page).map { htmlContent =&amp;gt;
        Ok(htmlContent).as(&quot;text/html&quot;)
    }.getOrElse(NotFound)
}

##### 参数类型

在定义路由规则时，对于字符串参数，可以省略参数的类型。如果你希望Play把参数转换成某个Scala类型，那么就需要在参数名后声明类型。 比如，客户ID都由整数组成，你可以这样定义路由：

GET   /client/:id           controllers.Clients.show(id: Long)

这样Play会自动将`:id`转换成`Long`类型。如果你将`: Long`省略，那么Play会把`id`的类型视为`String`. 根据上述路由的定义，你要相应修改`show`函数的定义：

def show(id: Long) = Action {
    Client.findById(id).map { client =&amp;gt;
        Ok(views.html.Clients.display(client))
    }.getOrElse(NotFound)
}

##### 参数固定值

有时候你希望给controller action method的参数提供固定值。请看例子：

# Extract the page parameter from the path, or fix the value for /
GET   /                     controllers.Application.show(page = &quot;home&quot;)
GET   /:page                controllers.Application.show(page)

##### 默认参数

可以给参数提供默认值，如果无法从Http请求中解析出参数值

GET   /clients              controllers.Clients.list(page: Int ?= 1)

这个例子中，如果客户端发起的请求形如`GET /clients?page=3`，那么`page`的值是3；如果`GET /clients`，那么`page`的值为1

#### 路由的优先级

假如多条路由规则匹配某个Http请求，Play会按照路由规则在`route`文件中声明的顺序，匹配第一条路由规则

#### 反向路由

`route`文件定义了URL和scala函数之间的映射。你可以通过Http请求调用scala函数，也可以通过调用一个scala函数来模拟一次Http请求。Play在编译时会在`routes`包下给每个控制器（`controller`）生成反向控制器(`reverse controller`)。这些`reverse controller`含有跟`controller`中的action生成函数一样的函数（相同函数名和函数参数），只是返回`play.api.mvc.Call`对象。 一个`play.api.mvc.Call`表示一个Http调用，包含HTTP方法和URI.

比如，我在`controller.Application`定义了一个`hello`函数：

package controllers

import play.api._
import play.api.mvc._

object Application extends Controller {

  def hello(name: String) = Action {
      Ok(&quot;Hello &quot; + name + &quot;!&quot;)
  }

}

然后在`conf/routes`文件中定义路由规则:

# Hello action
GET   /hello/:name          controllers.Application.hello(name)

当Play编译时，会在`routes`包下生成一个反向控制器`Application`. 你可以使用`routes.Application.hello(&quot;Bob&quot;)`模拟客户端发起`GET /hello/Bob`的请求

// Redirect to /hello/Bob
def helloBob = Action {
    Redirect(routes.Application.hello(&quot;Bob&quot;))    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaRouting&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaRouting&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>1.1 Actions, Controllers 和 Results</title>
                <link>http://freewind.in/posts/1275-play2-1-1-actions-controllers-results</link>
                <pubDate>Tue, 01 Jan 2013 16:57:11 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1275</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://www.playframework.org/documentation/2.0.2/JavaActions&quot;&gt;http://www.playframework.org/documentation/2.0.2/JavaActions&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;什么是Action?&lt;/h3&gt;
&lt;p&gt;Play程序接收到的大部分请求，都是由&lt;code&gt;Action&lt;/code&gt;来处理的。&lt;/p&gt;
&lt;p&gt;一个Action基本上就是一个Java方法，它用于解析请求参数，产生结果数据，并发送给客户端。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Result index() {
  return ok(&quot;Got request &quot; + request() + &quot;!&quot;);
}

一个action返回一个`play.mvc.Result`值，用来表示向web客户端发送的回复。在本例中，`ok`方法构造了一个**200 OK**的回复，并且包含了**text/plain**类型的回复内容。

### Controllers

一个controller是指继承了`play.mvc.Controller`的类，它将多个action方法组织在一起。

用于定义一个action的最简单的语法是一个无参数的static方法，并且返回一个`Result`类型的值。

public static Result index() {
  return ok(&quot;It works!&quot;);
}

一个Action方法也可以包含参数：

public static Result index(String name) {
  return ok(&quot;Hello&quot; + name);
}

这些参数将由`Router`处理，它将从request url中取值，并传给action函数。参数的值可以从URL path或者URL的query string中取得。(TODO: 例子，什么是URL path和query string）

### Results

让我们从一个简单的results开始：一个包含了状态码（如200,404,500），一组HTTP头信息和正文的，将发送给web客户端的result.

这些results由`play.mvc.Result`定义, 并且`play.mvc.Results`类提供了几个助手方法可产生标准的HTTP results，比如我们在前一节使用的`ok`方法：

public static Result index() {
  return ok(&quot;Hello world!&quot;);
}

这里有一些例子，用来创建不同的results:

Result ok = ok(&quot;Hello world!&quot;);
Result notFound = notFound();
Result pageNotFound = notFound(&quot;&amp;lt;h1&amp;gt;Page not found&amp;lt;/h1&amp;gt;&quot;).as(&quot;text/html&quot;);
Result badRequest = badRequest(views.html.form.render(formWithErrors));
Result oops = internalServerError(&quot;Oops&quot;);
Result anyStatus = status(488, &quot;Strange response type&quot;);

这些助手类都可以在`play.mvc.Results`类中找到。

### Redirects也是简单的results

让浏览器跳转(Redirecting)到新URL也是一种简单的result。但是这些result没有正文。

有几个助手方法可以用来创建redirect results:

public static Result index() {
  return redirect(&quot;/user/home&quot;);
}

默认使用`303 SEE_OTHER`的回复类型，但你也可以指定状态码：

public static Result index() {
  return temporaryRedirect(&quot;/user/home&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>01. Actions, Controllers and Results</title>
                <link>http://freewind.in/posts/1274-play2-01-actions-controllers-results</link>
                <pubDate>Tue, 01 Jan 2013 16:56:59 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1274</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是爱国者)&lt;/p&gt;
&lt;p&gt;英文文档：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaHome&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaHome&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;什么是Action?&lt;/h4&gt;
&lt;p&gt;Play应用程序接受的大部分http请求都由一个Action处理。一个Action就是形如&lt;code&gt;(play.api.mvc.Rquest =&amp;gt; play.api.mvc.Result)&lt;/code&gt;的函数，其中&lt;code&gt;play.api.mvc.Request&lt;/code&gt;代表一个Http请求，Action处理http请求，然后生成一个Http响应返回给客户端，宝石Http响应用&lt;code&gt;play.api.mvc.Result&lt;/code&gt;表示. 一个典型的Action例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val echo = Action { request =&amp;gt;
  Ok(&quot;Got request [&quot; + request + &quot;]&quot;)
}

这个例子中，`Ok`函数构造了一个**200 OK**的Http响应，并且在响应正文中包含**text/plain**文本.

#### 创建Action

`play.api.mvc.Action`伴随对象(companion object)提供了一些工具函数创建Action. 一个简单的应用如下： 

Action {
  Ok(&quot;Hello world&quot;)
}

如果需要获取Http的请求对象 (即play.api.mvc.Request)，可以使用如下的方法：

Action { request =&amp;gt;
  Ok(&quot;Got request [&quot; + request + &quot;]&quot;)
}

你也可以将`request`声明为**_implicit_**，这样可以方便其他API使用而无需显式引入（想了解implicit的用法，请参考)

Action { implicit request =&amp;gt;
  Ok(&quot;Got request [&quot; + request + &quot;]&quot;)
}

最后一种创建Action的方法是指定一个`BodyParser`参数,比如:

Action(parse.json) { implicit request =&amp;gt;
  Ok(&quot;Got request [&quot; + request + &quot;]&quot;)
}

关于`BodyParser`的用法在后面章节说明，如果你创建Action时不指定一个`BodyParser`,那么Play2会使用一个通用的body parser.

#### 控制器是action的发生器(Controllers are action generators)

控制器（Controller）就是生成一些`Action`对象的伴随对象。一个简单的Controller如下：

package controllers

import play.api.mvc._

object Application extends Controller {

  def index = Action {
    Ok(&quot;It works!&quot;)
  }

}

在这个例子中，我们定义了一个叫`Application`的Controller，它有一个action生成函数`index`. 当然,Action生成函数可以带参数，这些参数可以被Action闭包捕获，例如：

def hello(name: String) = Action {
  Ok(&quot;Hello &quot; + name)
}

#### 创建简单的响应对象

我们知道，Http响应由响应码、Http响应头和消息正文三部分组成。在Play 2.0中，一个简单的Http响应对象由`play.api.mvc.SimpleResult`类表示，比如：

def index = Action {
  SimpleResult(
    header = ResponseHeader(200, Map(CONTENT_TYPE -&amp;gt; &quot;text/plain&quot;)), 
    body = Enumerator(&quot;Hello world!&quot;)
  )
}

当然，我们使用一些工具类来简化上面的代码：

def index = Action {
  Ok(&quot;Hello world!&quot;)
}

以下是一些用于创建常见Http响应的工具函数

val ok = Ok(&quot;Hello world!&quot;)
val notFound = NotFound
val pageNotFound = NotFound(&amp;lt;h1&amp;gt;Page not found&amp;lt;/h1&amp;gt;)
val badRequest = BadRequest(views.html.form(formWithErrors))
val oops = InternalServerError(&quot;Oops&quot;)
val anyStatus = Status(488)(&quot;Strange response type&quot;)

你可以在`play.api.mvc.Results`的特质(trait)和伴随对象中找到更多工具函数

#### 重定向也是简单的`play.api.mvc.Result`

重定向响应也是Http响应的一种，只不过没有消息正文。Play 2.0提供了几种工具函数创建重定向响应.

def index = Action {
  Redirect(&quot;/user/home&quot;)
}

`Redirect`工具函数默认采用`303 SEE_OTHER`响应类型，但你可以根据实际情况设置其他重定向状态码, 比如：

def index = Action {
  Redirect(&quot;/user/home&quot;, status = MOVED_PERMANENTLY)
}

#### 创建空白网页

如果你还没想好这个Action该如何实现，或暂时无法实现，可以使用TODO函数创建一个空白网页。调用TODO函数会返回一个标准的&apos;Not implemented yet&apos;类型的响应。

def index(name:String) = TODO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://github.com/playframework/Play20/wiki/ScalaActions&quot;&gt;https://github.com/playframework/Play20/wiki/ScalaActions&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>4.1 Form definitions</title>
                <link>http://freewind.in/posts/1273-angularjs-4.1-form-definitions</link>
                <pubDate>Tue, 01 Jan 2013 16:55:11 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1273</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;h3&gt;表单的提交处理&lt;/h3&gt;
&lt;h4&gt;表单的定义&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;play.data&lt;/code&gt;中，包含了几个helpers来处理HTTP提交的表单数据和表单数据验证。处理提交的表单的最简单方法是，定义一个 &lt;code&gt;play.data.Form&lt;/code&gt;，来包装现有的类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    public String email;
    public String password;
}
Form&amp;lt;User&amp;gt; userForm = form(User.class);

注:底层的数据绑定均采用的是Spring的数据绑定。

提交的表单可以从HashMap&amp;lt;String,String&amp;gt;中的数据生成`User`对象数据。

Map&amp;lt;String,String&amp;gt; anyData = new HashMap();
anyData.put(&quot;email&quot;, &quot;bob@gmail.com&quot;);
anyData.put(&quot;password&quot;, &quot;secret&quot;);

User user = userForm.bind(anyData).get();
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>3.2 Common use cases</title>
                <link>http://freewind.in/posts/1272-play2-3-2-common-use-cases</link>
                <pubDate>Tue, 01 Jan 2013 16:54:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1272</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是辉)&lt;/p&gt;
&lt;h4&gt;常见的模板使用方式&lt;/h4&gt;
&lt;p&gt;模板，功能比较简单，你可以安装你的想法组合。下面是几个一些常见的场景的例子.&lt;/p&gt;
&lt;h4&gt;Layout&lt;/h4&gt;
&lt;p&gt;我们来声明一个模板: views/main.scala.html ,把它作为一个主布局模板。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@(title: String)(content: Html)
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;@title&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;section class=&quot;content&quot;&amp;gt;@content&amp;lt;/section&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

你可以看到，这个模板有两个参数：一个标题和HTML内容块。现在，我们可以从另一个views/Application/index.scala.html 模板，使用它：

@main(title = &quot;Home&quot;) {

  &amp;lt;h1&amp;gt;Home page&amp;lt;/h1&amp;gt;

}

注意: 你可以采用两种方式来传参数 @main(title = &quot;Home&quot;) 或者 @main(&quot;Home&quot;).

比如，有时你在第二页需要一个侧栏或面包屑的具体内容块。你可以声明一个额外的参数：

@(title: String)(sidebar: Html)(content: Html)
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;@title&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;section class=&quot;content&quot;&amp;gt;@content&amp;lt;/section&amp;gt;
    &amp;lt;section class=&quot;sidebar&quot;&amp;gt;@sidebar&amp;lt;/section&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

在我们的“index”的模板使用，如下：

@main(&quot;Home&quot;) {
  &amp;lt;h1&amp;gt;Sidebar&amp;lt;/h1&amp;gt;

} {
  &amp;lt;h1&amp;gt;Home page&amp;lt;/h1&amp;gt;

}

另外，我们可以单独的声明：

@sidebar = {
  &amp;lt;h1&amp;gt;Sidebar&amp;lt;/h1&amp;gt;
}

@main(&quot;Home&quot;)(sidebar) {
  &amp;lt;h1&amp;gt;Home page&amp;lt;/h1&amp;gt;

}

#### Tags &amp;lt;标签&amp;gt;(它们只是一些scala方法)

我们在views/tags/notice.scala.html 中建立以个tag来显示一个消息

@(level: String = &quot;error&quot;)(body: (String) =&amp;gt; Html)

@level match {

  case &quot;success&quot; =&amp;gt; {
    &amp;lt;p class=&quot;success&quot;&amp;gt;
      @body(&quot;green&quot;)
    &amp;lt;/p&amp;gt;
  }

  case &quot;warning&quot; =&amp;gt; {
    &amp;lt;p class=&quot;warning&quot;&amp;gt;
      @body(&quot;orange&quot;)
    &amp;lt;/p&amp;gt;
  }

  case &quot;error&quot; =&amp;gt; {
    &amp;lt;p class=&quot;error&quot;&amp;gt;
      @body(&quot;red&quot;)
    &amp;lt;/p&amp;gt;
  }

}

现在让我们在另一个模板中使用它：

@import tags._

@notice(&quot;error&quot;) { color =&amp;gt;
  Oops, something is &amp;lt;span style=&quot;color:@color&quot;&amp;gt;wrong&amp;lt;/span&amp;gt;
}

#### Includes(包括？)

在这里没有什么特别。你可以调用任何其他你喜欢的模板（或实际定义的其他任何功能）：

&amp;lt;h1&amp;gt;Home&amp;lt;/h1&amp;gt;

&amp;lt;div id=&quot;side&quot;&amp;gt;
  @common.sideBar()
&amp;lt;/div&amp;gt;

#### 其他Scripts或Css的定义

在scala模板中定义其他Scripts或css(和play1.x一样),你可以这样来定义：

@(title: String, scripts: Html = Html(&quot;&quot;))(content: Html)

&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;@title&amp;lt;/title&amp;gt;
        &amp;lt;link rel=&quot;stylesheet&quot; media=&quot;screen&quot; href=&quot;@routes.Assets.at(&quot;stylesheets/main.css&quot;)&quot;&amp;gt;
        &amp;lt;link rel=&quot;shortcut icon&quot; type=&quot;image/png&quot; href=&quot;@routes.Assets.at(&quot;images/favicon.png&quot;)&quot;&amp;gt;
        &amp;lt;script src=&quot;@routes.Assets.at(&quot;javascripts/jquery-1.7.1.min.js&quot;)&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
        @scripts
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;navbar navbar-fixed-top&quot;&amp;gt;
            &amp;lt;div class=&quot;navbar-inner&quot;&amp;gt;
                &amp;lt;div class=&quot;container&quot;&amp;gt;
                    &amp;lt;a class=&quot;brand&quot; href=&quot;#&quot;&amp;gt;Movies&amp;lt;/a&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;container&quot;&amp;gt;
            @content
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

在扩展模板中，需要添加一个额外的脚本：

@scripts = {
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;alert(&quot;hello !&quot;);&amp;lt;/script&amp;gt;
}

@main(&quot;Title&quot;,scripts){

   Html content here ...

}

在扩展模板，也可不必添加额外的脚本，就像：

@main(&quot;Title&quot;){

   Html content here ...

}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>3.1 Templates syntax</title>
                <link>http://freewind.in/posts/1271-play2-3-1-templates-syntax</link>
                <pubDate>Tue, 01 Jan 2013 16:53:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1271</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是辉)&lt;/p&gt;
&lt;h3&gt;模板引擎&lt;/h3&gt;
&lt;h4&gt;模板建立在Scala基础之上&lt;/h4&gt;
&lt;p&gt;Play2.0 附带了新的、强大的基于Scala的模板引擎,其设计灵感来源于ASP.NET Razor。它的特性:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简洁，易用，灵活：&lt;/strong&gt;在一个模板中最大限度的代码重用，编码快速，灵活。不像大多数模板语言，你不需要显示的引用其他HTML代码块，解析器能够自动解析到所需要的代码。使得这是一个简洁，易用，灵活的很好模板类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;易学习:&lt;/strong&gt;如果你有Html编码经验，可以使用简单的Scala结构，快速的进入模板开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是一个新的编程语言: &lt;/strong&gt;我们选择现有Scala语言，不去创建一个新的语言。我们希望开发者可以使用现有Scala语言，并提供了一个模板标记库，来进行Html编码工作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;易编辑的:&lt;/strong&gt;它并不需要特定的编辑工具，使您可以在任何文本编辑器中编辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;模板引擎使用Scala语言,对于Java开发人员，并不是一个问题,你几乎可以把它作为Java语言。&lt;/p&gt;
&lt;p&gt;切记,不要在模板中编写复杂的Scala代码。大多数的时候你可以从你的模型对象中访问数据,比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myUser.getProfile().getUsername()

模板是被编译过的,所以你能够在浏览器中看到错误提示: 图片

指定参数类型使用一个后缀的语法如：@（title:String）。泛型类型指定使用[]，而不是Java中的&amp;lt; &amp;gt; 。例如,@（list:List[String]）,而不是List&amp;lt;String&amp;gt; list。

#### 概述

Play的一个Scala模板文件是一个简单的文本文件,其中包含小块的Scala代码。模板可以包含任何基于文本格式的内容,如HTML、XML或者CSV。

模板系统对于那些习惯使用HTML的前端开发者是容易处理的。

模板文件被编译成标准Scala函数,以下是简单的命名约定。如果您创建了一个views/application/index.scala.html模板文件,它将生成一个views.html.Application.index Class文件，该Class具有render()方法

例如：

@(customer: Customer, orders: List[Order])

&amp;lt;h1&amp;gt;Welcome @customer.name!&amp;lt;/h1&amp;gt;

&amp;lt;ul&amp;gt; 
@for(order &amp;lt;- orders) {
  &amp;lt;li&amp;gt;@order.getTitle()&amp;lt;/li&amp;gt;
} 
&amp;lt;/ul&amp;gt;

然后，您可以在任何Java代码中调用，如:

Content html = views.html.Application.index.render(customer, orders);

#### @的用法

Scala模板使用@作为单一特殊字符。每次遇到这个字符,它表明动态语句的开始。你不需要显式地关闭代码块-能从你的代码中推断出动态语句的结束:

Hello @customer.getName()!
       ^^^^^^^^^^^^^^^^^^
          Dynamic code

上边这个语法只支持简单的语句。如果你想要插入一个multi-token声明,需使用@（你的Code），如:

Hello @(customer.getFirstName() + customer.getLastName())!
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
                          Dynamic Code

您还可以使用大括号，写一个multi-statement语句块，如：

Hello @{val name = customer.getFirstName() + customer.getLastName(); name}!
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                  Dynamic Code

因为@是一个特殊的字符,有时候你会需要使用一个@。使用“@@”:

My email is bob@@example.com

#### 模板参数

一个模板就像一个函数,所以它可能需要参数,参数的声明必须在模板文件顶部,如：

@(customer: models.Customer, orders: List[models.Order])

您还可以给参数设定默认值:

@(title: String = &quot;Home&quot;)

也可以声明多个参数:

@(title:String)(body: Html)

#### Iterating（迭代）

&amp;lt;p&amp;gt;您可以使用for关键字，来进行迭代：&amp;lt;/p&amp;gt;

&amp;lt;ul&amp;gt;
@for(p &amp;lt;- products) {
  &amp;lt;li&amp;gt;@p.getName() ($@p.getPrice())&amp;lt;/li&amp;gt;
} 
&amp;lt;/ul&amp;gt;

#### If-blocks（if语句块）

if语句块也很简单。用Scala的标准if语句:

@if(items.isEmpty()) {
  &amp;lt;h1&amp;gt;Nothing to display&amp;lt;/h1&amp;gt;
} else {
  &amp;lt;h1&amp;gt;@items.size() items!&amp;lt;/h1&amp;gt;
}

#### 声明可重复使用的语句块

可重用的语句块的声明和使用例子：

@display(product: models.Product) = {
  @product.getName() ($@product.getPrice())
}

&amp;lt;ul&amp;gt;
@for(product &amp;lt;- products) {
  @display(product)
}

您还可以声明可重用的纯代码块:

@title(text: String) = @{
  text.split(&apos; &apos;).map(_.capitalize).mkString(&quot; &quot;)
}

&amp;lt;h1&amp;gt;@title(&quot;hello world&quot;)&amp;lt;/h1&amp;gt;

**注:** 声明语句块这种方式，在一个模板尽量少使用,不推荐在一个模板中编写复杂的逻辑。通常将这些代码具体化到一个Java类中(你可以放在view/package下)。

匿名可重用语句块的声明:

@implicitFieldConstructor = @{ MyFieldConstructor() }

#### 声明可重用的值

您可以使用defining定义作用域内的值:

@defining(user.getFirstName() + &quot; &quot; + user.getLastName()) { fullName =&amp;gt;
  &amp;lt;div&amp;gt;Hello @fullName&amp;lt;/div&amp;gt;
}

#### Import statements (Import 用法)

您可以在参数声明后导入任何你想要的模板（或子模板）：

@(customer: models.Customer, orders: List[models.Order])

@import utils._

...

Import一个绝对路径,使用root前缀在import语句中。

@import _root_.company.product.core._

如果你有一些常用的Import,需要在所有的模板中应用,您可以在Project/ Build.scala中声明

val main = PlayProject(…).settings(
  templatesImport += &quot;com.abc.backend._&quot;
)

#### Comments（注释）

在模板中使用 @_ _@编写注释:

@*********************
 * This is a comment *
 *********************@

你可以把模板的第一行的注解记录到Scala API文档：

@*************************************
 * Home page.                        *
 *                                   *
 * @param msg The message to display *
 *************************************@
@(msg: String)

&amp;lt;h1&amp;gt;@msg&amp;lt;/h1&amp;gt;

#### 转义

默认情况下,动态内容部分会根据模板类型(例如。HTML或XML)规则来解析。如果你想在模板中输出一个原始内容片段。

例如输出原始HTML:

&amp;lt;p&amp;gt;
  @Html(article.content)    
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>1.6 Action composition</title>
                <link>http://freewind.in/posts/1270-play2-1-6-action-composition</link>
                <pubDate>Tue, 01 Jan 2013 16:52:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1270</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;p&gt;原文:&lt;a href=&quot;http://www.playframework.org/documentation/2.0.2/JavaActionsComposition&quot;&gt;http://www.playframework.org/documentation/2.0.2/JavaActionsComposition&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Action 组件&lt;/h3&gt;
&lt;p&gt;这章介绍定义action接口功能的多种方式。&lt;/p&gt;
&lt;h4&gt;actions的提醒&lt;/h4&gt;
&lt;p&gt;前面，我们将action描述为返回&lt;code&gt;play.mvc.Result&lt;/code&gt;类型值的Java 方法。实际上，Play管理acionts的内部原理如同函数。因为Java不支持第一级函数,一个由Java API提供的action 就是一个&lt;code&gt;play.mvc.Action&lt;/code&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Action {

  public abstract Result call(Http.Context ctx);    

}

Play 创建一个根action来调用合适的action方法，这对于复杂的action组件也适用。

#### 构造 actions

你可以使用另一个类`play.mvc.Action`加上`@With`注解来构造action方法提供的代码

@With(VerboseAction.class)
public static Result index() {
  return ok(&quot;It works!&quot;);
}

`VerboseAction`的定义如下：

public class VerboseAction extends Action.Simple {

  public Result call(Http.Context ctx) throws Throwable {
    Logger.info(&quot;Calling action for &quot; + ctx);
    return delegate.call(ctx);
  }
}

在某个位置需要使用`delegate.call(...)`方式对包装的action授权。

你也可以使用多个actions：

@With({Authenticated.class, Cached.class})
public static Result index() {
  return ok(&quot;It works!&quot;);
}

&amp;lt;span style=&quot;background:#FFF7D6&quot;&amp;gt; 注解：`play.mvc.Security.Authenticated`和`play.cache.Cached` annotations和对应已经定义的Actions是一起推出的。TODO:在相关的API文档中查看更多信息。&amp;lt;/span&amp;gt;

#### 定制action annotations

你也可以采用自定义的annotation来标记action组件，它必须使用`@With`对自身进行注解。

@With(VerboseAction.class)
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Verbose {
   boolean value() default true;
}

然后你可以在action方法上使用这个新注解:

@Verbose(false)
public static Result index() {
  return ok(&quot;It works!&quot;);
}

你的Action定义将如同获得配置文件一样检索注解：

public class VerboseAction extends Action&amp;lt;Verbose&amp;gt; {

  public Result call(Http.Context ctx) {
    if(configuration.value) {
      Logger.info(&quot;Calling action for &quot; + ctx);  
    }
    return delegate.call(ctx);
  }
}

#### Annotating 控制器

你也可以在`Controller`类上直接加上action组件注解。这将应用到所有被这个controller定义的action方法。

@Authenticated
public Admin extends Controller {

  …

}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>1.5 Body parsers</title>
                <link>http://freewind.in/posts/1269-play2-1-5-body-parsers</link>
                <pubDate>Tue, 01 Jan 2013 16:52:13 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1269</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.playframework.org/documentation/2.0.2/JavaBodyParsers&quot;&gt;http://www.playframework.org/documentation/2.0.2/JavaBodyParsers&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Body parsers&lt;/h3&gt;
&lt;p&gt;什么是body parser?&lt;/p&gt;
&lt;p&gt;HTTP请求（至少是使用POST和PUT操作的http请求）包含正文。正文可以被HTTP头Content-Type指定的任意格式格式化。一个body parser转变这个请求正文为Java 值。&lt;/p&gt;
&lt;p&gt;注解：你不能直接在Java 中实例化&lt;code&gt;BodyParser&lt;/code&gt;，因为Play 中BodyParser必须使用&lt;code&gt;Iteratee[Array[Byte], A]&lt;/code&gt;来处理增长性的body 内容，这必须使用Scala实例化。&lt;/p&gt;
&lt;p&gt;然而Play 提供默认的&lt;code&gt;BodyParsers&lt;/code&gt;，他能适应大多数用例(解析 Json,Xml,Text,上传文件)。然后你可以直接在Java中重用这些默认的parsers来定制自己的parsers;比如你能在Text基础上提供一个RDF parsers。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;BodyParser&lt;/code&gt;的Java API&lt;/h4&gt;
&lt;p&gt;在Java API中，所有的body parsers必须生成一个&lt;code&gt;play.mvc.Http.RequestBody&lt;/code&gt;值。这个通过body parser 计算的值,随后可以使用&lt;code&gt;request().body()&lt;/code&gt;方法获取：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Result index() {
  RequestBody body = request().body();
  return ok(&quot;Got body: &quot; + body);
}

你可以对action指定`BodyParser`，采用`@BodyParser.Of`注解的方式：

@BodyParser.Of(BodyParser.Json.class)
public static Result index() {
  RequestBody body = request().body();
  return ok(&quot;Got json: &quot; + body.asJson());
}

#### `Http.RequestBody`API

所有Java API里面的body parsers 返回一个`play.mvc.Http.RequestBody`值。检索这个body Ojbect可以取得最合适的Java类型的请求正文。

批注:用来解析请求正文的parser不支持这个content类型,RequestBody中的方法（如`asText()`或者`asJson()`)将返回空。比如在action方法上加入`@BodyParser.Of(BodyParser.Json.class)`注解，在这个方法生成的body上调用`asXml()`将返回null。

某些parsers能提供指定的类型而不只是`Http.RequestBody`（ie. Http.RequestBody的子类)。你可以使用`as(...)`助手方法自动将请求body转换成别的类型：

@BodyParser.Of(BodyLengthParser.class)
pulic static Result index() {
  BodyLength body = request().body().as(BodyLength.class);
  ok(&quot;Request body length: &quot; + body.getLength());
}

#### 默认的body parser：`AnyContent`

如果不自己指定body parser，Play将使用默认的与请求头中`Content-Type`最接近的parser类型：

&amp;gt; text/plain: `String`, 通过 `asText()` 取得该类型。 application/json: `JsonNode`, 通过 `asJson()`取得该类型。 text/xml: `org.w3c.Document`, 通过 `asXml()`取得该类型 application/form-url-encoded: `Map&amp;lt;String, String[]&amp;gt;`, 对应 `asFormUrlEncoded()` multipart/form-data: `Http.MultipartFormData`, 对应 `asMultipartFormData()` 其它content类型: `Http.RawBuffer`, 对应`asRaw()`

例子：

pulic static Result save() {
  RequestBody body = request().body();
  String textBody = body.asText();

  if(textBody != null) {
    ok(&quot;Got: &quot; + text);
  } else {
    badRequest(&quot;Expecting text/plain request body&quot;);
  }
}

#### 最大正文长度

基于text的body parsers(比如text,json,xml或者formUrlEncoded)使用了最大content长度限制，因为parsers需要将所有的正文加载到内存中。

默认的content长度为100KB

要点：默认的正文长度可以在`application.conf`中定义：

parsers.text.maxLength=128K

你也可以通过`@BodyParser.Of`注解的方式指定最大的content长度：

// Accept only 10KB of data.
@BodyParser.Of(value = BodyParser.Text.class, maxLength = 10 * 1024)
pulic static Result index() {
  if(request().body().isMaxSizeExceeded()) {
    return badRequest(&quot;Too much data!&quot;);
  } else {
    ok(&quot;Got body: &quot; + request().body().asText()); 
  }
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>1.4 Session and Flash scopes</title>
                <link>http://freewind.in/posts/1267-play2-1-4-session-and-flash-scopes</link>
                <pubDate>Tue, 01 Jan 2013 16:51:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1267</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;p&gt;原文:&lt;a href=&quot;http://www.playframework.org/documentation/2.0.2/JavaSessionFlash&quot;&gt;http://www.playframework.org/documentation/2.0.2/JavaSessionFlash&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;会话和Flash范围&lt;/h3&gt;
&lt;h4&gt;Play的区别&lt;/h4&gt;
&lt;p&gt;如果要在跨多个HTTP的请求中保存数据，你可以将数据保存为Session或者Flash范围。保存在Session中的数据可以在整个user session中获得，在flash范围的数据只能在下一个请求时候获得。&lt;/p&gt;
&lt;p&gt;Session和Flash 中的数据采用Cookies方式添加到之后的HTTP 请求对象中而不是保存在服务器上。也就是说数据量很小（最多4KB）只能用来保存字符串值。&lt;/p&gt;
&lt;p&gt;Cookies 使用加密钥匙的方式来标记，所以客户无法修改cookie数据（或者是无效的)。Play session 不是作为缓存功能设计的。如果需要缓存数据到关联的特定session,你可以使用Play内置的缓存机制，特定user 通过在user session中保存唯一的ID来关联缓存数据。&lt;/p&gt;
&lt;p&gt;session没有专门的超时，用户关闭浏览器时候即回话超时或到期。如果需要为特定的应用指定超时动作，只要保存时间戳到user Session对象然后在你应用需要的任何时候调用(eg. 最大的session区间，最大的等待区间，等等）。&lt;/p&gt;
&lt;h4&gt;读取Session值&lt;/h4&gt;
&lt;p&gt;从HTTP请求中获得传入的Session：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Result index() {
  String user = session(&quot;connected&quot;);
  if(user != null) {
    return ok(&quot;Hello &quot; + user);
  } else {
    return unauthorized(&quot;Oops, you are not connected&quot;);
  }
}

#### 保存数据至Session

Session是Cookie,也是HTTP头，play提供了一个助手方法保存session 值：

public static Result index() {
  session(&quot;connected&quot;, &quot;user@gmail.com&quot;);
  return ok(&quot;Welcome!&quot;);
}

同样方法，可以删除传入session中任意值:

public static Result index() {
  session.remove(&quot;connected&quot;);
  return ok(&quot;Bye&quot;);
}

#### 废弃整个session

如果想清除整个session，可以如下操作：

public static Result index() {
  session().clear();
  return ok(&quot;Bye&quot;);
}

#### Flash scope

Flash scope 和Session的工作方式很接近，但是有两点不一样：

数据的缓存是针对单一的请求。

Flash的缓存不被签名，用户可以修改它。

重点：Flash scope只能被用来在简单非异步的应用中传输 success/error 信息。因为数据只是为下一个请求保存但不能确保在复杂web应用中的请求顺序，Flash scope受到竞争条件的约束。

这里有几个使用Flash scope的例子：

public static Result index() {
  String message = flash(&quot;success&quot;);
  if(message == null) {
    message = &quot;Welcome!&quot;;
  }
  return ok(message);
}

public static Result save() {
  flash(&quot;success&quot;, &quot;The item has been created&quot;);
  return redirect(&quot;/home&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>1.3 Manipulating the response</title>
                <link>http://freewind.in/posts/1266-play2-1-3-manipulating-the-response</link>
                <pubDate>Tue, 01 Jan 2013 16:50:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1266</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://www.playframework.org/documentation/2.0.2/JavaResponse&quot;&gt;http://www.playframework.org/documentation/2.0.2/JavaResponse&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;处理响应&lt;/h3&gt;
&lt;h4&gt;更改默认的Content-Type&lt;/h4&gt;
&lt;p&gt;结果的内容类型可以通过java值（如body的Content-Type）来推导出来。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Result textResult = ok(&quot;Hello World!&quot;);

将自动设置请求头中`Content-Type`为`text/plain`,然而：

Result jsonResult = ok(jerksonObject);

将会设置请求头中`Content-Type`为`application/json`。

当你需要改变的时候，则需要在结果上用`as(newContentType)`方法去创建一个不同`Content-Type`请求头的相似结果:

Result htmlResult = ok(&quot;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&quot;).as(&quot;text/html&quot;);

你也可以在http响应中设置content type：

public static Result index() {
  response().setContentType(&quot;text/html&quot;);
  return ok(&quot;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&quot;);
}

#### 设置http响应头

你可以添加(或更新)任意HTTP响应头:

public static Result index() {
  response().setContentType(&quot;text/html&quot;);
  response().setHeader(CACHE_CONTROL, &quot;max-age=3600&quot;);
  response().setHeader(ETAG, &quot;xxx&quot;);
  return ok(&quot;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&quot;);
}

注意：setting一个HTTP头将自动舍去先前设置的任意值。

#### 设置或废弃cookies

Cookies，在http头中为特殊格式，但Play提供了一系列助手类去简化。

你可以为HTTP响应添加一个Cookie：

response().setCookie(&quot;theme&quot;, &quot;blue&quot;);

废弃刚才保存在浏览器上的Cookie:

response().discardCookies(&quot;theme&quot;);

#### 为文本结果指定字符编码

为基于文本格式的HTTP响应采用正确的字符编码进行处理很重要。Play使用`utf-8`为默认的字符编码。

编码用来转化文本响应为对应的字节后通过网络套接字通信传输，并扩展请求头`Content-Type`加入`chartset=xxx`

产生`Reuslt`值的时候可以指定编码方式:

public static Result index() {
  response().setContentType(&quot;text/html; charset=iso-8859-1&quot;);
  return ok(&quot;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&quot;, &quot;iso-8859-1&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>1.2 HTTP routing</title>
                <link>http://freewind.in/posts/1265-play2-1-3-http-routing</link>
                <pubDate>Tue, 01 Jan 2013 16:50:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1265</guid>
                <description><![CDATA[&lt;p&gt;(本文译者是子青)&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://www.playframework.org/documentation/2.0.2/JavaRouting&quot;&gt;http://www.playframework.org/documentation/2.0.2/JavaRouting&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;内嵌http路由（router)&lt;/h3&gt;
&lt;p&gt;router将每个http请求转换成action调用（也就是控制器类中一个static,public 方法)&lt;/p&gt;
&lt;p&gt;HTTP请求可以作为MVC框架处理的一个事件。这个事件包含两个主要信息：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;请求路径（eg.&lt;code&gt;/clients/1542&lt;/code&gt;,&lt;code&gt;/photos/list&lt;/code&gt;),包含了查询语句.
&lt;br  /&gt;HTTP方法(GET,POST,DELETE&amp;hellip;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Routes 定义在&lt;code&gt;conf/routes&lt;/code&gt;文件中，需要编译，也就是可以在浏览器中看到route文件中的错误。&lt;/p&gt;
&lt;h3&gt;routes文件的语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;conf/routes&lt;/code&gt;-router的配置文件。文件列举了所有程序用到的routes。每个route包含了HTTP方法和调用action方法所关联的URI样式&lt;/p&gt;
&lt;p&gt;route定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET   /clients/:id          controllers.Clients.show(id: Long)

注解：action调用 参数类型在参数名称的后面，同Scala。

每个route以HTTP 方法开始,URI样式结束。最后的元素是调用说明。

可以在route文件中加入注释，以#开头。

# Display a client.
GET   /clients/:id          controllers.Clients.show(id: Long)

### HTTP 方法

HTTP方法可以是HTTP支持的任意有效方法 (`GET`,` POST`,` PUT`,` DELETE`, `HEAD`).

### URI样式

URI样式定义了route的请求路径，请求路径有些部分可以是动态的。

#### 静态路径

如为了准确匹配`GET /clients/all/` 请求，可以这样定义route:

GET   /clients              controllers.Clients.list()

#### 动态部分

如果想定义一个route,通过用户id取得用户信息，你需要加入动态部分：

GET   /clients/:id          controllers.Clients.show(id: Long)

注解：一个URI样式可以拥有多个动态部分

动态部分默认的匹配策略被定义为正则表达式`[^/]+`，意思是任意定义如`:id`的动态部分将会准确匹配到一个URI路径。

#### 动态部分跨越多个 /

捕获被 / 分割的多个URI路径片段，你可以定义一个采用`*id`语法的动态部分,它运用了`.*`正则表达式语句。

GET   /files/*name          controllers.Application.download(name)

如`GET /files/images/logo.png`,`name`动态部分将捕获`images/logo.png`这个值

#### 动态部分采用定制的正则表达式

采用自己的正则表达式语句定义动态部分，采用`$id&amp;lt;regex&amp;gt; `语法：

GET   /clients/$id&amp;lt;[0-9]+&amp;gt;  controllers.Clients.show(id: Long)

#### action生成器方法的调用

route定义的最后部分是call(调用）。该部分必须定义一个对于action方法有效的调用。

如果是一个无参action方法，只需给定完全匹配的方法名称：

GET   /                     controllers.Application.homePage()

如果是有参action方法,将从请求URI里面寻找对应的参数，即从URI本身或者从查询语句中获得。

# Extract the page parameter from the path.
# i.e. http://myserver.com/index
GET   /:page                controllers.Application.show(page)

或者:

# Extract the page parameter from the query string.
# i.e. http://myserver.com/?page=index
GET   /                     controllers.Application.show(page)

匹配的`show`方法定义在`controllers.Application`控制器:

public static Result show(String page) {
  String content = Page.getContentOf(page);
  response().setContentType(&quot;text/html&quot;);
  return ok(content);
}

#### 参数类型

`String`类型的参数,参数类型可不填。如果想将传参转化为指定的Scala类型，可以加入明确的类型：

GET   /client/:id           controllers.Clients.show(id: Long)

然后在controller中为action方法应用对应参数类型

public static Result show(Long id) {
  Client client = Client.findById(id);
  return ok(views.html.Client.show(client));
}

注解:参数类型的指定使用前缀。泛型类别的用`[]`标记而不是Java中的`&amp;lt;&amp;gt;`。如：`List[String]`等同于Java类型`List&amp;lt;String&amp;gt;`。

#### 参数值固定

有时候需要为参数指定固定值：

# Extract the page parameter from the path, or fix the value for /
GET   /                     controllers.Application.show(page = &quot;home&quot;)
GET   /:page                controllers.Application.show(page)

#### 参数值默认

在请求中没有为指定参数赋值的情况，可以为其提供默认值:

# Pagination links, like /clients?page=3
GET   /clients              controllers.Clients.list(page: Integer ?= 1)

Routing优先级

存在多个路由规则都可以匹配相同的请求的情况。如果有冲突，第一个路由规则(按照声明顺序)将被使用。

#### 反向路由

router可以以java调用方法的形式，来生成一个URL（比如在模板页面上&amp;lt;a herf=&apos;@{Business.index()}&apos;&amp;gt;&amp;lt;/a&amp;gt;） 。这样所有的URI模式可以集中在单一的配置文件中，当你重构程序时候你会更自信。

针对routes 文件中每个controller，router将会在`routes`包中生成一个逆向控制器，使用同样的action 方法，拥有相同的signature，但返回一个`play.mvc.Call`而不是`play.mvc.Result`。

这个`play.mvc.Call`定义一个HTTP调用，并同时提供HTTP方法和URI。

下面的例子创建了一个控制器：

package controllers;

import play.*;
import play.mvc.*;

public class Application extends Controller {

  public static Result hello(String name) {
      return ok(&quot;Hello &quot; + name + &quot;!&quot;);
  }

}

如果将此映射到`conf/routes`文件中：

# Hello action
GET   /hello/:name          controllers.Application.hello(name)

通过使用`controllers.routes.Application`逆向控制器,你可以随后将URL逆向至`hello`action 方法：

// Redirect to /hello/Bob
public static Result index() {
    return redirect(controllers.routes.Application.hello(&quot;Bob&quot;)); 
}

### Imports

如果你厌倦经常去写`controller.Application`,可以如下采用定义默认import的方式

val main = PlayProject(…).settings(
  routesImport += &quot;controller._&quot;
)
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>33. 单元测试</title>
                <link>http://freewind.in/posts/1264-angularjs-33-unit-tests</link>
                <pubDate>Tue, 01 Jan 2013 16:42:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1264</guid>
                <description><![CDATA[&lt;p&gt;JavaScript是一门有强大表现力的动态类型语言，但它几乎无法从compiler中得到任何帮助。因此我们强调任何用JavaScript写的代码都需要有一组测试方法。我们在Angular中添加很多特性让你测试程序更方便，所以没有理由不写测试。&lt;/p&gt;
&lt;h3&gt;说的全都是不要混合专注点（It is all about NOT mixing concerns，怎么翻）&lt;/h3&gt;
&lt;p&gt;单元测试(Unit Test)，如同它的名字所说，是关于单独一块代码的测试。单元测试试图回答这个问题：我认为我的业务逻辑是正确的吗？比如，这个排序函数是否将list按正确的顺序进行了排序？为了能回答这样的问题，隔离代码很重要。因为当我们测试这种函数时，我们不想被强迫去考虑那些如DOM操作、使用XHR取数据等无关操作。&lt;/p&gt;
&lt;p&gt;在一个项目中，我们通常很难只调用一个单独的函数。原因在于开发者们经常把关注者混合在了一起，以致于一块代码中把所有的事情都干了：从XHR中读取数据，排序，然后操作DOM。在Angular中我们尝试让你以简单的方式做正确的事情，所以我们为你的XHR提供了依赖注入（在测试中你可以使用mock）。我们进行了抽象，让你对model进行排序时，无需手动对DOM进行排序操作。所以最终，测试一个“对数据排序”的函数变得容易，因为我们可以在测试中简单地创建一些数据集，应用到该函数，最后验证model中的数据的顺序是正确的。测试代码不需要等待XHR，不需要创建任何DOM，也不需要验证你的函数正确地修改了DOM。&lt;/p&gt;
&lt;p&gt;Angular始终把“可测试性”放在重要位置，但仍然需要你做正确的事情。我们试着让正确的事情变得简单，但Angular不是魔法，如果你没有注意这些，最后可能还是写出了无法测试的代码。&lt;/p&gt;
&lt;h3&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;有几种方法可以取得一个依赖：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;new&lt;/code&gt;操作符创建2.  从一个叫“全局单例”的地方寻找3.  从注册表（如service注册表）中寻找（但你从哪儿找到这个注册表呢？参看2）4.  你也可以期待有人把它递给你&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上面的例子中，只有最后一个是可测试的。让我们看看为什么：&lt;/p&gt;
&lt;h5&gt;使用&lt;code&gt;new&lt;/code&gt;操作符&lt;/h5&gt;
&lt;p&gt;虽然从根本上讲&lt;code&gt;new&lt;/code&gt;操作符没有错，但问题是使用对一个构造器使用&lt;code&gt;new&lt;/code&gt;操作符，等于永久性地将类型与调用位置写死了。例如我们准备初始化一个&lt;code&gt;XHR&lt;/code&gt;用来从server中取数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function MyClass() {
  this.doWork = function() {
    var xhr = new XHR();
    xhr.open(method, url, true);
    xhr.onreadystatechange = function() {...}
    xhr.send();
  }
}

问题在于，在测试中，我们非常希望初始化一个`MockXHR`来返回假数据和模板网络错误。而使用`new XHR()`，我们总是创建了一个真实的XHR，没有好办法来替换它。没错，虽然我们有`monkey patching`，但那从很多方面讲都是一个坏主意，当然这已经超出了本文的范围。

上面的这个类很难测试，因为我们必须求助于monkey patching：

var oldXHR = XHR;
XHR = function MockXHR() {};
var myClass = new MyClass();
myClass.doWork();
// assert that MockXHR got called with the right arguments
XHR = oldXHR; // if you forget this bad things will happen

##### 全局查找

另一种方法是在一个知名位置（全局单例）寻找service。

function MyClass() {
  this.doWork = function() {
    global.xhr({
      method:&apos;...&apos;,
      url:&apos;...&apos;,
      complete:function(response){ ... }
    })
  }
}

由于没有创建依赖的实例，从基本上讲它跟`new`是一样的，在测试中没有好办法拦截对`global.xhr`的调用，除非使用mongo patching。使用全局变量的基本问题是这些全局变量必须是可变的，可以被mock方法替换。关于更进一步的解释，参看[Brittle Global State &amp;amp; Singletons](http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons)。

上面的代码之所以难以被测试，是因为我们必须改变全局状态：

var oldXHR = global.xhr;
global.xhr = function mockXHR() {};
var myClass = new MyClass();
myClass.doWork();
// assert that mockXHR got called with the right arguments
global.xhr = oldXHR; // if you forget this bad things will happen

##### Service注册表

看起来我们可以对所有的services使用一个注册表，然后在测试中替换需要的service。

function MyClass() {
  var serviceRegistry = ????;
  this.doWork = function() {
    var xhr = serviceRegistry.get(&apos;xhr&apos;);
    xhr({
      method:&apos;...&apos;,
      url:&apos;...&apos;,
      complete:function(response){ ... }
    })
}

问题在于，我们从哪里去取得这个`serviceRegistry`?如果它是：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;new&lt;/code&gt;出来的，则测试没有机会在测试中重设services*   从全局位置中找到的，则返回来的这个service也是全局的（虽然重设容易些，因为仅有一个全局变量需要重设）&lt;/p&gt;
&lt;p&gt;上面的类难以测试，是因为我们必须改变全局变量：&lt;/p&gt;
&lt;p&gt;var oldServiceLocator = global.serviceLocator;
&lt;br  /&gt;global.serviceLocator.set(&apos;xhr&apos;, function mockXHR() {});
&lt;br  /&gt;var myClass = new MyClass();
&lt;br  /&gt;myClass.doWork();
&lt;br  /&gt;// assert that mockXHR got called with the right arguments
&lt;br  /&gt;global.serviceLocator = oldServiceLocator; // if you forget this bad things will happen&lt;/p&gt;
&lt;h5&gt;传入依赖&lt;/h5&gt;
&lt;p&gt;最后，如果依赖可以被传入：&lt;/p&gt;
&lt;p&gt;function MyClass(xhr) {
&lt;br  /&gt;this.doWork = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xhr({
  method:&apos;...&apos;,
  url:&apos;...&apos;,
  complete:function(response){ ... }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这是更好的做法，因为我们不需要假设&lt;code&gt;xhr&lt;/code&gt;是从哪儿来的，因为谁创建了这个类谁就有责任传一个xhr进来。由于该类的创建者与使用者不同，所以就从业务逻辑中把创建的责任分离出来了，简单地说，这就是依赖注入。&lt;/p&gt;
&lt;p&gt;上面的类很好测试，因为在测试中我们可以：&lt;/p&gt;
&lt;p&gt;function xhrMock(args) {&amp;hellip;}
&lt;br  /&gt;var myClass = new MyClass(xhrMock);
&lt;br  /&gt;myClass.doWork();
&lt;br  /&gt;// assert that xhrMock got called with the right arguments&lt;/p&gt;
&lt;p&gt;注意在写这个测试过程中，没有出现担心的全局变量&lt;/p&gt;
&lt;p&gt;Angular内置了依赖注入，让正确的事情容易做，但你还是得去做（测试）。&lt;/p&gt;
&lt;h4&gt;Controllers&lt;/h4&gt;
&lt;p&gt;让程序变得与众不同的是它的业务逻辑，这也是我们想测试的东西。如果你的业务逻辑跟DOM操作混合在一起，则它会像下例一样难测：&lt;/p&gt;
&lt;p&gt;function PasswordController() {
&lt;br  /&gt;// get references to DOM elements
&lt;br  /&gt;var msg = $(&apos;.ex1 span&apos;);
&lt;br  /&gt;var input = $(&apos;.ex1 input&apos;);
&lt;br  /&gt;var strength;&lt;/p&gt;
&lt;p&gt;this.grade = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;msg.removeClass(strength);
var pwd = input.val();
password.text(pwd);
if (pwd.length &amp;gt; 8) {
  strength = &apos;strong&apos;;
} else if (pwd.length &amp;gt; 3) {
  strength = &apos;medium&apos;;
} else {
  strength = &apos;weak&apos;;
}
msg
 .addClass(strength)
 .text(strength);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;上面的代码难以测试，因为它需要你的测试代码运行时，有正确的DOM供使用。所以测试代码看起来会是这样：&lt;/p&gt;
&lt;p&gt;var input = $(&apos;&lt;input type=&quot;text&quot; /&gt;&apos;);
&lt;br  /&gt;var span = $(&apos;&lt;span&gt;&apos;);
&lt;br  /&gt;$(&apos;body&apos;).html(&apos;&lt;div class=&quot;ex1&quot;&gt;&apos;)
&lt;br  /&gt;.find(&apos;div&apos;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.append(input)
.append(span);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;var pc = new PasswordController();
&lt;br  /&gt;input.val(&apos;abc&apos;);
&lt;br  /&gt;pc.grade();
&lt;br  /&gt;expect(span.text()).toEqual(&apos;weak&apos;);
&lt;br  /&gt;$(&apos;body&apos;).html(&apos;&apos;);&lt;/p&gt;
&lt;p&gt;在Angular中controller的业务逻辑与DOM操作严格分离，所以测试起来容易多了，见下例：&lt;/p&gt;
&lt;p&gt;function PasswordCntrl($scope) {
&lt;br  /&gt;$scope.password = &apos;&apos;;
&lt;br  /&gt;$scope.grade = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var size = $scope.password.length;
if (size &amp;gt; 8) {
  $scope.strength = &apos;strong&apos;;
} else if (size &amp;gt; 3) {
  $scope.strength = &apos;medium&apos;;
} else {
  $scope.strength = &apos;weak&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;测试代码也很直白：&lt;/p&gt;
&lt;p&gt;var pc = new PasswordController();
&lt;br  /&gt;pc.password(&apos;abc&apos;);
&lt;br  /&gt;pc.grade();
&lt;br  /&gt;expect(span.strength).toEqual(&apos;weak&apos;);&lt;/p&gt;
&lt;p&gt;注意，这个测试不但简短很多，而且很容易看明白它在测什么。我们说这样的一个测试在讲一个故事，而不需要去验证一些不相关的东西。&lt;/p&gt;
&lt;h4&gt;FIlters&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Filters&lt;/code&gt;是一些把数据转换为用户易读的格式的函数。它们很重要，因为它们把格式化数据的功能从程序逻辑中独立出来了，大大简化了程序逻辑。&lt;/p&gt;
&lt;p&gt;myModule.filter(&apos;length&apos;, function() {
&lt;br  /&gt;return function(text){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return (&apos;&apos;+(text||&apos;&apos;)).length;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;var length = $filter(&apos;length&apos;);
&lt;br  /&gt;expect(length(null)).toEqual(0);
&lt;br  /&gt;expect(length(&apos;abc&apos;)).toEqual(3);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Directives&lt;/h4&gt;
&lt;p&gt;Angular中的Directives在model发生变化时，有责任更新DOM。（这段没写完）&lt;/p&gt;
&lt;p&gt;（这段只有标题）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>32. 理解Angular的服务</title>
                <link>http://freewind.in/posts/1263-angularjs-32-understanding-service</link>
                <pubDate>Tue, 01 Jan 2013 16:42:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1263</guid>
                <description><![CDATA[&lt;p&gt;Anguar的services是一些包含了web开发中常用的任务的实例对象，比如&lt;code&gt;$http&lt;/code&gt; service就提供了对浏览器的&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的底层访问。&lt;/p&gt;
&lt;p&gt;使用Anguar的service，你需要在一个依赖service的元素（如controller，或其它service）中声明依赖于该service。Angular的依赖注入子系统自动处理其它的杂事，如service初始化，依赖的解决，在需要的时候把依赖提供给工厂函数等。&lt;/p&gt;
&lt;p&gt;Angular使用&quot;构造器&quot;来注入依赖(service通过工厂函数传入)。因为JavaScript是一个动态类型的这篇文章，Angular的依赖注入子系统不能使用静态类型来确定属性的依赖，所以必须显式地使用&lt;code&gt;$inject&lt;/code&gt;属性来声明依赖的services。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myController.$inject = [&apos;$location&apos;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Angular提供了一组web开发中常用操作的services。与其它Angular核心变量和标识符一样，内置的services总是以&lt;code&gt;$&lt;/code&gt;开头（例如上面提到的&lt;code&gt;$http&lt;/code&gt;）。你也可以创建自己的services。&lt;/p&gt;
&lt;h4&gt;相关API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;injector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>31. 测试Angular的服务</title>
                <link>http://freewind.in/posts/1262-angularjs-31-test-service</link>
                <pubDate>Tue, 01 Jan 2013 16:41:51 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1262</guid>
                <description><![CDATA[&lt;p&gt;下面是对&lt;code&gt;创建Angular Services&lt;/code&gt;一节中的示例的单元测试。测试中使用Jasmine spy(mock)来代替真实浏览器的&lt;code&gt;alert&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var mock, notify;

beforeEach(function() {
  mock = {alert: jasmine.createSpy()};

  module(function($provide) {
    $provide.value(&apos;$window&apos;, mock);
  });

  inject(function($injector) {
    notify = $injector.get(&apos;notify&apos;);
  });
});

it(&apos;should not alert first two notifications&apos;, function() {
  notify(&apos;one&apos;);
  notify(&apos;two&apos;);

  expect(mock.alert).not.toHaveBeenCalled();
});

it(&apos;should alert all after third notification&apos;, function() {
  notify(&apos;one&apos;);
  notify(&apos;two&apos;);
  notify(&apos;three&apos;);

  expect(mock.alert).toHaveBeenCalledWith(&quot;one\ntwo\nthree&quot;);
});

it(&apos;should clear messages after alert&apos;, function() {
  notify(&apos;one&apos;);
  notify(&apos;two&apos;);
  notify(&apos;third&apos;);
  notify(&apos;more&apos;);
  notify(&apos;two&apos;);
  notify(&apos;third&apos;);

  expect(mock.alert.callCount).toEqual(2);
  expect(mock.alert.mostRecentCall.args).toEqual([&quot;more\ntwo\nthird&quot;]);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;相关API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>30. 管理服务依赖</title>
                <link>http://freewind.in/posts/1261-angularjs-30-manage-dependencies</link>
                <pubDate>Tue, 01 Jan 2013 16:41:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1261</guid>
                <description><![CDATA[&lt;p&gt;Anguar允许service声明其它services作为构建自己实例的依赖。&lt;/p&gt;
&lt;p&gt;为了声明依赖，你需要在工厂函数的签名中指定它们，使用&lt;code&gt;$inject&lt;/code&gt;属性以service名称数组的方式，或使用数组标记的方式来声明。其中&lt;code&gt;$inject&lt;/code&gt;属性声明可以被丢弃（参看&lt;strong&gt;推断&lt;code&gt;$inject&lt;/code&gt;&lt;/strong&gt;），不过要注意这目前还是一个实验性的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用数组标记&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function myModuleCfgFn($provide) {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$provide.factory(&apos;myService&apos;, [&apos;dep1&apos;, &apos;dep2&apos;, function(dep1, dep2) {}]);
&lt;br  /&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用$inject属性：
&lt;br  /&gt;function myModuleCfgFn($provide) {
&lt;br  /&gt;var myServiceFactory = function(dep1, dep2) {};
&lt;br  /&gt;myServiceFactory.$inject = [&apos;dep1&apos;, &apos;dep2&apos;];
&lt;br  /&gt;$provide.factory(&apos;myService&apos;, myServiceFactory);
&lt;br  /&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用DI推断（与代码压缩不兼容）
&lt;br  /&gt;function myModuleCfgFn($provide) {
&lt;br  /&gt;$provide.factory(&apos;myService&apos;, function(dep1, dep2) {});
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;下面这个例子中，自定义了两个service，一个依赖于另一个，还依赖Anguar中提供的其它service:&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;batchLog service allows for messages to be queued in memory and flushed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;to the console.log every 50 seconds.
&lt;br  /&gt;*&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@param {&lt;em&gt;} message Message to be logged.
&lt;br  /&gt;&lt;/em&gt;/
&lt;br  /&gt;function batchLogModule($provide){
&lt;br  /&gt;$provide.factory(&apos;batchLog&apos;, [&apos;$timeout&apos;, &apos;$log&apos;, function($timeout, $log) {
&lt;br  /&gt;var messageQueue = [];&lt;/p&gt;
&lt;p&gt;function log() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (messageQueue.length) {
  $log(&apos;batchLog messages: &apos;, messageQueue);
  messageQueue = [];
}
$timeout(log, 50000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// start periodic checking
&lt;br  /&gt;log();&lt;/p&gt;
&lt;p&gt;return function(message) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;messageQueue.push(message);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}]);&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;routeTemplateMonitor monitors each $route change and logs the current&lt;/li&gt;
&lt;li&gt;template via the batchLog service.
&lt;br  /&gt;*/
&lt;br  /&gt;$provide.factory(&apos;routeTemplateMonitor&apos;,&lt;pre&gt;&lt;code&gt;    [&apos;$route&apos;, &apos;batchLog&apos;, &apos;$rootScope&apos;,
&lt;/code&gt;&lt;/pre&gt;
function($route,   batchLog,   $rootScope) {
&lt;br  /&gt;$rootScope.$on(&apos;$routeChangeSuccess&apos;, function() {
&lt;br  /&gt;batchLog($route.current ? $route.current.template : null);
&lt;br  /&gt;});
&lt;br  /&gt;}]);
&lt;br  /&gt;}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// get the main service to kick of the application
&lt;br  /&gt;angular.injector([batchLogModule]).get(&apos;routeTemplateMonitor&apos;);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本例中需要注意的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;batchLog&lt;/code&gt; service依赖于内置的&lt;code&gt;$timeout&lt;/code&gt;和&lt;code&gt;$log&lt;/code&gt; services，它允许信息以批处理方式写进&lt;code&gt;console.log&lt;/code&gt;中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;routeTemplateMonitor&lt;/code&gt; service依赖于内置的&lt;code&gt;$route&lt;/code&gt; service，和自定义的&lt;code&gt;batchLog&lt;/code&gt; service&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这两个services都使用了array notation方式来声明依赖。注意数组中的字符串顺序非常重要，它们与最后传给工厂方法中的service的顺序相同。与“依赖推断”不同，那个是根据参数名来推断的，顺序不重要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;相关api&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;injector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>29. 把服务注入到控制器中</title>
                <link>http://freewind.in/posts/1260-angularjs-29-inject-service-to-controllers</link>
                <pubDate>Tue, 01 Jan 2013 16:40:56 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1260</guid>
                <description><![CDATA[&lt;p&gt;在controller中使用services当作依赖与一个service把另一个service当作依赖的情况是非常相似的。&lt;/p&gt;
&lt;p&gt;由于JavaScript是动态类型语言，DI无法像静态语言那样，由类型找到需要注入的service。因此，你需要使用&lt;code&gt;$inject&lt;/code&gt;属性来指明用哪一种service，&lt;code&gt;$inject&lt;/code&gt;是一个包含了service名称的由字符串组成的数组。Service ID的顺序很重要，注入的顺序与声明的顺序相同。但service的名字不重要，但它们通常与service的ID相同，以便于查看和修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function myController($loc, $log) {
this.firstMethod = function() {
 // use $location service
 $loc.setHash();
};
this.secondMethod = function() {
 // use $log service
 $log.info(&apos;...&apos;);
};
}
// which services to inject ?
myController.$inject = [&apos;$location&apos;, &apos;$log&apos;];

### 源代码

**index.html**

&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app=&quot;MyServiceModule&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;myController&quot;&amp;gt;
      &amp;lt;p&amp;gt;Let&apos;s try this simple notify service, injected into the controller...&amp;lt;/p&amp;gt;
      &amp;lt;input ng-init=&quot;message=&apos;test&apos;&quot; ng-model=&quot;message&quot; &amp;gt;
      &amp;lt;button ng-click=&quot;callNotify(message);&quot;&amp;gt;NOTIFY&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

**script.js**

angular.
 module(&apos;MyServiceModule&apos;, []).
 factory(&apos;notify&apos;, [&apos;$window&apos;, function(win) {
    var msgs = [];
    return function(msg) {
      msgs.push(msg);
      if (msgs.length == 3) {
        win.alert(msgs.join(&quot;\n&quot;));
        msgs = [];
      }
    };
  }]);

function myController(scope, notifyService) {
  scope.callNotify = function(msg) {
    notifyService(msg);
  };
}

myController.$inject = [&apos;$scope&apos;,&apos;notify&apos;];

**End to end test**

it(&apos;should test service&apos;, function() {
  expect(element(&apos;:input[ng\\:model=&quot;message&quot;]&apos;).val()).toEqual(&apos;test&apos;);
});

jsfiddle TODO

#### 隐式注入

Angular DI的一个新特性是从参数名称来决定使用哪些依赖。让我们重写上面的例子，来演示隐式依赖注入`$window`,`$scope`和我们自定义的`notify` service：

### 源代码

**index.html**

&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app=&quot;MyServiceModuleDI&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;myController&quot;&amp;gt;
      &amp;lt;p&amp;gt;Let&apos;s try the notify service, that is implicitly injected into the controller...&amp;lt;/p&amp;gt;
      &amp;lt;input ng-init=&quot;message=&apos;test&apos;&quot; ng-model=&quot;message&quot;&amp;gt;
      &amp;lt;button ng-click=&quot;callNotify(message);&quot;&amp;gt;NOTIFY&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

**script.js**

angular.
 module(&apos;MyServiceModuleDI&apos;, []).
 factory(&apos;notify&apos;, function($window) {
    var msgs = [];
    return function(msg) {
      msgs.push(msg);
      if (msgs.length == 3) {
        $window.alert(msgs.join(&quot;\n&quot;));
        msgs = [];
      }
    };
  });

function myController($scope, notify) {
  $scope.callNotify = function(msg) {
    notify(msg);
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jsfiddle demo&lt;/p&gt;
&lt;p&gt;但是，如果你想最小化你的代码（参见：&lt;a href=&quot;http://en.wikipedia.org/wiki/Minification_(programming)&quot;&gt;http://en.wikipedia.org/wiki/Minification_(programming)&lt;/a&gt;），你的参数名可能会被修改，这样你还得使用&lt;code&gt;$inject&lt;/code&gt;属性再次显式声明你的依赖。&lt;/p&gt;
&lt;h4&gt;相关API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>28. 创建Services</title>
                <link>http://freewind.in/posts/1259-angularjs-28-create-services</link>
                <pubDate>Tue, 01 Jan 2013 16:40:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1259</guid>
                <description><![CDATA[&lt;p&gt;虽然Anguar提供了一些常用的services，但对于一个普通的程序来说，你会需要创建自己的Services。通常在一个module的service factory函数中通过&lt;code&gt;Module#factory&lt;/code&gt; api注册一个service，或者直接在module的&lt;code&gt;config&lt;/code&gt;函数中使用&lt;code&gt;$provide&lt;/code&gt; api注册。&lt;/p&gt;
&lt;p&gt;所有的Anguar services都使用一个唯一的name(id)注册到Anguar的依赖注入(DI)系统当中，同时它也可以声明它自己依赖的、需要提供给其工厂函数的其他service。services拥有可被替换的能力，所以在测试中可将services替换为mocks/stubs/dummies，这让services高度可测。&lt;/p&gt;
&lt;h3&gt;注册Services&lt;/h3&gt;
&lt;p&gt;为了注册一个service，你必须让它属于某一个module。然后，你可以通过&lt;code&gt;Module&lt;/code&gt; api或在module的配置函数中使用&lt;code&gt;$provide&lt;/code&gt; service来注册该service。下面的伪代码展示了这两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;angular.Module&lt;/code&gt; api:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var myModule = angular.module(&apos;myModule&apos;, []);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;myModule.factory(&apos;serviceId&apos;, function() {
&lt;br  /&gt;var shinyNewServiceInstance;
&lt;br  /&gt;//factory function body that constructs shinyNewServiceInstance
&lt;br  /&gt;return shinyNewServiceInstance;
&lt;br  /&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用$provide service:
&lt;br  /&gt;angular.module(&apos;myModule&apos;, [], function($provide) {
&lt;br  /&gt;$provide.factory(&apos;serviceId&apos;, function() {
&lt;br  /&gt;var shinyNewServiceInstance;
&lt;br  /&gt;//factory function body that constructs shinyNewServiceInstance
&lt;br  /&gt;return shinyNewServiceInstance;
&lt;br  /&gt;});
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;注意，你注册的不是一个service实例，而是一个工厂函数，它将在被调用时生成一个实例。&lt;/p&gt;
&lt;h3&gt;依赖&lt;/h3&gt;
&lt;p&gt;Services不光可被依赖，它自己也可以有自己的依赖。这些依赖可在工厂函数中以参数的方式来指定。关于Angular的DI，以及如何在压缩js代码时使用数组和$inject属性来处理依赖的声明，&lt;a href=&quot;http://shuzu.org:9000/angularjs/books/angular-dev-guide/articles/di&quot;&gt;参见这里&lt;/a&gt;。TODO&lt;/p&gt;
&lt;p&gt;下面是一个简单service的例子。这个service依赖于&lt;code&gt;$window&lt;/code&gt; service（它将以参数方式传给工厂方法），它仅仅是一个函数。这个函数简单地保存了所有的通知，并收到第三个之后，它会把所有的通知由&lt;code&gt;alert&lt;/code&gt;方式弹出。&lt;/p&gt;
&lt;p&gt;angular.module(&apos;myModule&apos;, [], function($provide) {
&lt;br  /&gt;$provide.factory(&apos;notify&apos;, [&apos;$window&apos;, function(win) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var msgs = [];
return function(msg) {
  msgs.push(msg);
  if (msgs.length == 3) {
    win.alert(msgs.join(&quot;\n&quot;));
    msgs = [];
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}]);
&lt;br  /&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;初始化Angular Services&lt;/h3&gt;
&lt;p&gt;Angular中所有的services都是延迟初始化，这表明只有当一个service被程序组件依赖或初始化另一个service时，它才会被创建。换言之，Angular只有当一个service被直接或间接请求时，才会初始化它。&lt;/p&gt;
&lt;h3&gt;单例形式的Services&lt;/h3&gt;
&lt;p&gt;最后，需要着重注意的是，所有的angular services都是程序级的单例对象。这表明对于每一个injector，每个service只有一个实例。由于Angular非常不喜欢全局状态，所以可以使用多个injector，每个都有自己单独的service实例。这种需求很少见，除非是在测试中（这个功能对于测试来说很重要）。&lt;/p&gt;
&lt;h4&gt;相关API&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>27. 使用 $location 服务</title>
                <link>http://freewind.in/posts/1258-angularjs-27-use-location-service</link>
                <pubDate>Tue, 01 Jan 2013 16:39:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1258</guid>
                <description><![CDATA[&lt;h3&gt;它是做什么的？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$location&lt;/code&gt;服务用来解析浏览器地址栏中的URL（基于&lt;a href=&quot;https://developer.mozilla.org/en/window.location&quot;&gt;window.location&lt;/a&gt;），使得它在我们的程序中可用。当改变了地址栏中的URL，&lt;code&gt;$location&lt;/code&gt;中的数据会跟着变，反之亦然。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$location服务:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把当前浏览器地址栏的URL暴露出来，你可以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   观察和监视该URL.*   改变该URL.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当用户进行以下操作时，同步浏览器的URL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   改变地址栏（什么意思?）*   点击了前进、后退或历史链接*   点击了页面上某链接
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将URL对象以一组方法的形式展示出来(protocol, host, port, path, search, hash).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;$location&lt;/code&gt;与&lt;code&gt;window.location&lt;/code&gt;比较&lt;/h4&gt;
 &lt;table border=&quot;1&quot; cellpadding=&quot;6&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td class=&quot;empty-corner-lt&quot;&gt;&lt;/td&gt; &lt;td&gt;window.location&lt;/td&gt; &lt;td&gt;$location service&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;目的&lt;/td&gt; &lt;td&gt;允许对浏览器当前地址进行读写&lt;/td&gt; &lt;td&gt;相同&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;API&lt;/td&gt; &lt;td&gt;暴露包含属性的&quot;原始&quot;对象，可直接修改&lt;/td&gt; &lt;td&gt;暴露jQuery风格的getters/setters&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;与Anguar程序生命周期结合&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;了解所有内部生命周期，与`$watch`结合， ...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;与HTML5 API无缝集成&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;有 (并且与旧浏览器兼容)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;知道程序导入的根文档/上下文&lt;/td&gt; &lt;td&gt;否 - `window.location.path`返回&quot;/docroot/actual/path&quot;&lt;/td&gt; &lt;td&gt;是 - `$location.path()`返回&quot;/actual/path&quot;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;
&lt;h4&gt;什么时候我应该使用$location&lt;/h4&gt;
&lt;p&gt;&lt;p&gt;任何你需要与当前URL交互的时候。&lt;/p&gt;
&lt;h4&gt;它不能做什么？&lt;/h4&gt;
&lt;p&gt;当浏览器URL改变的时候，不会重新导入整个页面。如果你想在改变URL时重载整个页面，可使用底层的API:&lt;code&gt;$window.location.href&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;API的概览&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;$location&lt;/code&gt;初始化时的设置不同，则它的行为也不同。默认的设置对于大多数程序是合适的，你也可以自定义它以使用新的功能。&lt;/p&gt;
&lt;p&gt;一旦&lt;code&gt;$location&lt;/code&gt;初始化完成，你就可以通过jQuery风格的getter/setter方法与它交互，以取得或改变浏览器当前的URL。&lt;/p&gt;
&lt;h4&gt;$location服务配置&lt;/h4&gt;
&lt;p&gt;为了配置&lt;code&gt;$location&lt;/code&gt;服务，取得&lt;code&gt;$locationProvider&lt;/code&gt;并设置以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;html5Mode(mode)&lt;/strong&gt;: {boolean}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `true` - 使用HTML5模式*   `false` - 使用Hashbang模式*   默认值: `false`
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;hashPrefix(prefix)&lt;/strong&gt;: {string}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   在Hashbang URL使用的前缀 (在Hashbang模式，或者在旧浏览器中使用Html5模式）&amp;lt;br /&amp;gt;*   默认值: `&apos;!&apos;`
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;配置示例&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;$locationProvider.html5Mode(true).hashPrefix(&apos;!&apos;);

#### Getter/Setter

`$location` service为URL中的只读部分提供了getter方法（abUrl,protocal,host,port），为url,path,search,hash提供了getter/setter方法。

// get the current path
$location.path();

// change the path
$location.path(&apos;/newValue&apos;)

所有的setter方法都返回同一个`$location`对象以方便链式操作。例如，你可以把多个调用串起来：

$location.path(&apos;/newValue&apos;).search({key: value});

有一个特别的方法叫`replace`，可以让`$location` service在下次与浏览器同步的时候，不要创建新的历史记录，而是替换掉之前最后一个历史记录。这个功能在你实现跳转的时候很有用，因为你不这么做的话，就会破坏掉后退按钮的功能（因为它会反复触发跳转）。

示例如下：

$location.path(&apos;/someNewPath&apos;);
$location.replace();
// or you can chain these as: $location.path(&apos;/someNewPath&apos;).replace();

注意这个方法不会马上更新`window.location`，相反，`$location` service了解scope的生命周期，并把多次对`$location`的改变合并为一个操作，在`$digest`阶段提交给`window.location`。因此只用调用`replace()`一次就可以完成整个替换操作，而不会新境历史记录。当浏览器被更新以后，`replace()`将更新标识，以后的操作将会产生新的历史记录，直到再次调用`replace()`

##### Settters和字符集

你可以向`$location` service传特殊字符，它们会根据[RFC 3986](http://www.ietf.org/rfc/rfc3986.txt)中制定的规则被转码。当你访问以下方法时：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有被传入到&lt;code&gt;$location&lt;/code&gt;的setter方法，如&lt;code&gt;path()&lt;/code&gt;, &lt;code&gt;search()&lt;/code&gt;, &lt;code&gt;hash()&lt;/code&gt;中的值，都被转码&lt;em&gt;   对以下方法&lt;code&gt;path()&lt;/code&gt;, &lt;code&gt;search()&lt;/code&gt;, &lt;code&gt;hash()&lt;/code&gt;的getter调用（无参数）的返回值都将被解码。&lt;/em&gt;   当你调用&lt;code&gt;absUrl()&lt;/code&gt;方法时，返回值是一个被部分编码的完整url*   当你调用&lt;code&gt;url()&lt;/code&gt;方法时，返回值是一个由path,search,hash组成的字符串：&lt;code&gt;/path?search=a&amp;amp;b=c#hash&lt;/code&gt;。将被部分转码。&lt;/p&gt;
&lt;h3&gt;hashbang(&lt;code&gt;#!&lt;/code&gt;)和HTML5模式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$location&lt;/code&gt; service有两个配置模式，用来控制浏览器地址栏中的URL的格式：默认的&lt;strong&gt;Hashbang模式&lt;/strong&gt;和基于HTML5 &lt;a href=&quot;http://www.w3.org/TR/html5/history.html&quot;&gt;History API&lt;/a&gt;的&lt;strong&gt;HTML5模式&lt;/strong&gt;。使用不同模式时，我们使用的代码和API调用完全一致，&lt;code&gt;$location&lt;/code&gt; service会自动根据情况来生成不同的URL并管理历史记录。&lt;/p&gt;
&lt;p&gt;注：hashbang中，hash是指&lt;code&gt;#&lt;/code&gt;，bang是指&lt;code&gt;!&lt;/code&gt;。这是一种使用浏览器端mvc的约定符号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://docs.angularjs.org/img/guide/hashbang_vs_regular_url.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;6&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td class=&quot;empty-corner-lt&quot;&gt;&lt;/td&gt; &lt;td&gt;Hashbang模式&lt;/td&gt; &lt;td&gt;HTML5模式&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;配置&lt;/td&gt; &lt;td&gt;默认&lt;/td&gt; &lt;td&gt;{ html5Mode: true }&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;URL格式&lt;/td&gt; &lt;td&gt;在所有的浏览器中使用hashbang URL&lt;/td&gt; &lt;td&gt;在现在浏览器中使用常规URL，在旧浏览器中使用hashbang URL&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;&lt;a href=&quot;&quot;&gt; link重写&lt;/td&gt; &lt;td&gt;否&lt;/td&gt; &lt;td&gt;是&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;head&quot;&gt;需要服务器端设置&lt;/td&gt; &lt;td&gt;否&lt;/td&gt; &lt;td&gt;是&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;
&lt;h4&gt;Hashbang模式（默认）&lt;/h4&gt;
&lt;p&gt;在该模式下，&lt;code&gt;$location&lt;/code&gt;在所有的浏览器中都使用Hashbang URL&lt;/p&gt;
&lt;h5&gt;示例&lt;/h5&gt;
&lt;p&gt;it(&apos;should show example&apos;, inject(
&lt;br  /&gt;function($locationProvider) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$locationProvider.html5mode = false;
$locationProvider.hashPrefix = &apos;!&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;},
&lt;br  /&gt;function($location) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// open http://host.com/base/index.html#!/a
$location.absUrl() == &apos;http://host.com/base/index.html#!/a&apos;
$location.path() == &apos;/a&apos;

$location.path(&apos;/foo&apos;)
$location.absUrl() == &apos;http://host.com/base/index.html#!/foo&apos;

$location.search() == {}
$location.search({a: &apos;b&apos;, c: true});
$location.absUrl() == &apos;http://host.com/base/index.html#!/foo?a=b&amp;amp;c&apos;

$location.path(&apos;/new&apos;).search(&apos;x=y&apos;);
$location.absUrl() == &apos;http://host.com/base/index.html#!/new?x=y&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;));&lt;/p&gt;
&lt;h5&gt;让你的程序对搜索引擎友好&lt;/h5&gt;
&lt;p&gt;为了让搜索引擎能索引到你的ajax程序，你需要在head中添加一个特殊的meta标签：&lt;/p&gt;
&lt;p&gt;&lt;meta name=&quot;fragment&quot; content=&quot;!&quot;  /&gt;&lt;/p&gt;
&lt;p&gt;这么做，搜索引擎爬虫会在请求的的参数中加上&lt;code&gt;_escaped_fragment_&lt;/code&gt;参数，你的服务器程序就可以识别这是一个爬虫，返回给它一个正常的HTML文件。关于这项技术的细节，可参考&lt;a href=&quot;http://code.google.com/web/ajaxcrawling/docs/specification.html&quot;&gt;让你的AJAX程序可被索引&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;HTML5模式&lt;/h4&gt;
&lt;p&gt;在HTML5模式中，&lt;code&gt;$location&lt;/code&gt; service的getter/setter通过HTML5 history API与浏览器URL地址交互，允许我们使用正常的URL路径和search片断，而不用&lt;code&gt;hashbang&lt;/code&gt;格式。如果浏览器不支持HTML5 History API，则&lt;code&gt;$location&lt;/code&gt; service会自动降级使用hashbang URL。这样你就不需要担心你的程序在不同浏览器上的运行状态，&lt;code&gt;$location&lt;/code&gt;会自己选择最优方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在旧浏览器上打开一个正常的URL -&gt; 跳转为hashbang URL*   在现代浏览器上打开一个hashbang URL -&gt; 重写为一个正常的URL&lt;/p&gt;
&lt;h5&gt;Example&lt;/h5&gt;
&lt;p&gt;it(&apos;should show example&apos;, inject(
&lt;br  /&gt;function($locationProvider) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$locationProvider.html5mode = true;
$locationProvider.hashPrefix = &apos;!&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;},
&lt;br  /&gt;function($location) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// in browser with HTML5 history support:
// open http://host.com/#!/a -&amp;gt; rewrite to http://host.com/a
// (replacing the http://host.com/#!/a history record)
$location.path() == &apos;/a&apos;

$location.path(&apos;/foo&apos;);
$location.absUrl() == &apos;http://host.com/foo&apos;

$location.search() == {}
$location.search({a: &apos;b&apos;, c: true});
$location.absUrl() == &apos;http://host.com/foo?a=b&amp;amp;c&apos;

$location.path(&apos;/new&apos;).search(&apos;x=y&apos;);
$location.url() == &apos;new?x=y&apos;
$location.absUrl() == &apos;http://host.com/new?x=y&apos;

// in browser without html5 history support:
// open http://host.com/new?x=y -&amp;gt; redirect to http://host.com/#!/new?x=y
// (again replacing the http://host.com/new?x=y history item)
$location.path() == &apos;/new&apos;
$location.search() == {x: &apos;y&apos;}

$location.path(&apos;/foo/bar&apos;);
$location.path() == &apos;/foo/bar&apos;
$location.url() == &apos;/foo/bar?x=y&apos;
$location.absUrl() == &apos;http://host.com/#!/foo/bar?x=y&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;));&lt;/p&gt;
&lt;h5&gt;在旧浏览器上降级&lt;/h5&gt;
&lt;h5&gt;HTML连接重写&lt;/h5&gt;
&lt;p&gt;当你使用History API模式时，虽然在不同的浏览器中需要不同的链接，但你只要使用正常URL就可以了，例如：&lt;code&gt;&amp;lt;a href=&quot;/some?foo=bar&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当用户点击链接时：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在旧浏览器中，该URL变为：&lt;code&gt;/index.html#!/some?foo=bar&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在现代浏览器中，该URL变为： &lt;code&gt;/some?foo=bar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在以下情况中，链接不会被重写。相反，浏览器会对原来的链接进行一次完全的页面重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接中包含&lt;code&gt;target&lt;/code&gt;属性： &lt;code&gt;&amp;lt;a href=&quot;/ext/link?a=b&quot; target=&quot;_self&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指向不同域的绝对链接：&lt;code&gt;&amp;lt;a href=&quot;http://angularjs.org/&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当&lt;code&gt;base&lt;/code&gt;定义了，链接以&lt;code&gt;/&lt;/code&gt;开头，并指向了一个不同的base: &lt;code&gt;&amp;lt;a href=&quot;/not-my-base/link&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;服务器端&lt;/h5&gt;
&lt;p&gt;使用该模式，需要在服务器端重写URL。通常你需要把你所有的链接都指向程序的入口（如&lt;code&gt;index.html&lt;/code&gt;)&lt;/p&gt;
&lt;h5&gt;相对链接&lt;/h5&gt;
&lt;p&gt;请注意检查你的全部相对链接、图片、脚本等。你要么得在入口html文件的head中增加一个base标签指明你的url base(&lt;code&gt;&amp;lt;base href=&quot;/my-base&quot;&amp;gt;&lt;/code&gt;)，要么就在每个地方都使用绝对路径（以&lt;code&gt;/&lt;/code&gt;开头），因为相对路径会以文档的初始绝对url作为它的基准，而该初始绝对url通常与程序真正的根路径不同。&lt;/p&gt;
&lt;p&gt;在Angular程序中从文档的root处启用History API，是强烈推荐的做法，因为它会处理好全部的相对路径的问题。&lt;/p&gt;
&lt;h5&gt;在不同的浏览器中打开链接&lt;/h5&gt;
&lt;p&gt;由于在HTML5模式中，会自动重写URL，所以你的用户可以在旧浏览器中打开正常的url，或者在现代浏览器中打开hashbang url:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在现代浏览器中，会自动把hashbang url重写为正常的url*   在旧浏览器中，会自动把正常的url重写为hashbang url&lt;/p&gt;
&lt;h5&gt;示例&lt;/h5&gt;
&lt;p&gt;在这里你可以看到两个&lt;code&gt;$location&lt;/code&gt;实例，都在HTML5模式下，但在不同的浏览器上。所以你能看到它们的差别。这些&lt;code&gt;$location&lt;/code&gt; services都连接到一个假的浏览器上。每一个input控件代表了一个浏览器的地址栏。&lt;/p&gt;
&lt;p&gt;注意当你向第一个浏览器中输入hashbang url时，它不会重写/跳转到常规url，反之亦然。因为这种转换仅仅发生在页面导入时解析初始URL的时候。&lt;/p&gt;
&lt;p&gt;这个例子中，我们使用&lt;code&gt;&amp;lt;base href=&quot;/base/index.html&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-non-bindable class=&quot;html5-hashbang-example&quot;&amp;gt;
  &amp;lt;div id=&quot;html5-mode&quot; ng-controller=&quot;Html5Cntl&quot;&amp;gt;
    &amp;lt;h4&amp;gt;Browser with History API&amp;lt;/h4&amp;gt;
    &amp;lt;div ng-address-bar browser=&quot;html5&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
    $location.protocol() = {{$location.protocol()}}&amp;lt;br&amp;gt;
    $location.host() = {{$location.host()}}&amp;lt;br&amp;gt;
    $location.port() = {{$location.port()}}&amp;lt;br&amp;gt;
    $location.path() = {{$location.path()}}&amp;lt;br&amp;gt;
    $location.search() = {{$location.search()}}&amp;lt;br&amp;gt;
    $location.hash() = {{$location.hash()}}&amp;lt;br&amp;gt;
    &amp;lt;a href=&quot;http://www.host.com/base/first?a=b&quot;&amp;gt;/base/first?a=b&amp;lt;/a&amp;gt; |
    &amp;lt;a href=&quot;http://www.host.com/base/sec/ond?flag#hash&quot;&amp;gt;sec/ond?flag#hash&amp;lt;/a&amp;gt; |
    &amp;lt;a href=&quot;/other-base/another?search&quot;&amp;gt;external&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div id=&quot;hashbang-mode&quot; ng-controller=&quot;HashbangCntl&quot;&amp;gt;
    &amp;lt;h4&amp;gt;Browser without History API&amp;lt;/h4&amp;gt;
    &amp;lt;div ng-address-bar browser=&quot;hashbang&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
    $location.protocol() = {{$location.protocol()}}&amp;lt;br&amp;gt;
    $location.host() = {{$location.host()}}&amp;lt;br&amp;gt;
    $location.port() = {{$location.port()}}&amp;lt;br&amp;gt;
    $location.path() = {{$location.path()}}&amp;lt;br&amp;gt;
    $location.search() = {{$location.search()}}&amp;lt;br&amp;gt;
    $location.hash() = {{$location.hash()}}&amp;lt;br&amp;gt;
    &amp;lt;a href=&quot;http://www.host.com/base/first?a=b&quot;&amp;gt;/base/first?a=b&amp;lt;/a&amp;gt; |
    &amp;lt;a href=&quot;http://www.host.com/base/sec/ond?flag#hash&quot;&amp;gt;sec/ond?flag#hash&amp;lt;/a&amp;gt; |
    &amp;lt;a href=&quot;/other-base/another?search&quot;&amp;gt;external&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function FakeBrowser(initUrl, baseHref) {
&lt;br  /&gt;this.onUrlChange = function(fn) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.urlChange = fn;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;this.url = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return initUrl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;this.defer = function(fn, delay) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() { fn(); }, delay || 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;this.baseHref = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return baseHref;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;this.notifyWhenOutstandingRequests = angular.noop;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;var browsers = {
&lt;br  /&gt;html5: new FakeBrowser(&apos;http://www.host.com/base/path?a=b#h&apos;, &apos;/base/index.html&apos;),
&lt;br  /&gt;hashbang: new FakeBrowser(&apos;http://www.host.com/base/index.html#!/path?a=b#h&apos;, &apos;/base/index.html&apos;)
&lt;br  /&gt;};&lt;/p&gt;
&lt;p&gt;function Html5Cntl($scope, $location) {
&lt;br  /&gt;$scope.$location = $location;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;function HashbangCntl($scope, $location) {
&lt;br  /&gt;$scope.$location = $location;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;function initEnv(name) {
&lt;br  /&gt;var root = angular.element(document.getElementById(name + &apos;-mode&apos;));
&lt;br  /&gt;angular.bootstrap(root, [function($compileProvider, $locationProvider, $provide){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$locationProvider.html5Mode(true).hashPrefix(&apos;!&apos;);

$provide.value(&apos;$browser&apos;, browsers[name]);
$provide.value(&apos;$document&apos;, root);
$provide.value(&apos;$sniffer&apos;, {history: name == &apos;html5&apos;});

$compileProvider.directive(&apos;ngAddressBar&apos;, function() {
  return function(scope, elm, attrs) {
    var browser = browsers[attrs.browser],
        input = angular.element(&apos;&amp;lt;input type=&quot;text&quot;&amp;gt;&apos;).val(browser.url()),
        delay;

    input.bind(&apos;keypress keyup keydown&apos;, function() {
      if (!delay) {
        delay = setTimeout(fireUrlChange, 250);
      }
    });

    browser.url = function(url) {
      return input.val(url);
    };

    elm.append(&apos;Address: &apos;).append(input);

    function fireUrlChange() {
      delay = null;
      browser.urlChange(input.val());
    }
  };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}]);
&lt;br  /&gt;root.bind(&apos;click&apos;, function(e) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;e.stopPropagation();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;initEnv(&apos;html5&apos;);
&lt;br  /&gt;initEnv(&apos;hashbang&apos;);&lt;/p&gt;
&lt;h3&gt;附加说明&lt;/h3&gt;
&lt;h4&gt;页面重载&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;$location&lt;/code&gt; service仅仅允许你修改URL，不允许你重载页面。如果你想重载整个页面，或跳到另一个页面，使用底层API&lt;code&gt;$window.location.href&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;在scope生命周期之外使用&lt;code&gt;$location&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;$location&lt;/code&gt;知道Angular的&lt;code&gt;scope&lt;/code&gt;的生命周期。当浏览器中的URL改变了，它会更新&lt;code&gt;$location&lt;/code&gt;并调用&lt;code&gt;$apply&lt;/code&gt;，所以所有的&lt;code&gt;$watch&lt;/code&gt;/&lt;code&gt;$observers&lt;/code&gt;都会被通知到。&lt;/p&gt;
&lt;p&gt;如果你想在&lt;code&gt;$digest&lt;/code&gt;阶段改变&lt;code&gt;$location&lt;/code&gt;，一切都很正常。&lt;code&gt;$location&lt;/code&gt;会把这个改变传播给浏览器，并通知$watchers/$observers.&lt;/p&gt;
&lt;p&gt;但你在Angular之外（如DOM事件，或测试中）改变&lt;code&gt;$location&lt;/code&gt;，则你必须调用&lt;code&gt;$apply&lt;/code&gt;来传播这些改变。&lt;/p&gt;
&lt;h4&gt;$location.path()和 ! 或 / 前缀&lt;/h4&gt;
&lt;p&gt;一个路径总是以&lt;code&gt;/&lt;/code&gt;开头。&lt;code&gt;$location.path()&lt;/code&gt; setter始终会在需要的时候在路径前加一个&lt;code&gt;/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意hashbang模式中的&lt;code&gt;!&lt;/code&gt;前缀不是&lt;code&gt;$location.path()&lt;/code&gt;中的一部分。它实际上是hash前缀（hashPrefix）&lt;/p&gt;
&lt;h3&gt;测试$location service&lt;/h3&gt;
&lt;p&gt;当在测试中使用&lt;code&gt;$location&lt;/code&gt; service时，你就处于&lt;code&gt;scope&lt;/code&gt;的生命周期之外了。这表明，你必须手动调用&lt;code&gt;scope.$apply()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;describe(&apos;serviceUnderTest&apos;, function() {
&lt;br  /&gt;beforeEach(module(function($provide) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$provide.factory(&apos;serviceUnderTest&apos;, function($location){
  // whatever it does...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;it(&apos;should&amp;hellip;&apos;, inject(function($location, $rootScope, serviceUnderTest) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$location.path(&apos;/new/path&apos;);
$rootScope.$apply();

// test whatever the service should do...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}));
&lt;br  /&gt;});&lt;/p&gt;
&lt;h3&gt;从之前的AngularJS版本中迁移&lt;/h3&gt;
&lt;p&gt;在Angrlar之前的版本中，&lt;code&gt;$location&lt;/code&gt;使用了&lt;code&gt;hashPath&lt;/code&gt;或&lt;code&gt;hashSearch&lt;/code&gt;来处理pyth和search方法。在当前的版本中，&lt;code&gt;$location&lt;/code&gt;自己处理path和search方法，然后在需要的时候，使用这些信息来拼装hashbang URL（例如&lt;code&gt;http://server.com/#!/path?search=a&lt;/code&gt;）&lt;/p&gt;
&lt;h4&gt;代码的改变&lt;/h4&gt;
&lt;div class=&quot;mycode&quot;&gt;
&lt;table border=&quot;1&quot; cellpadding=&quot;6&quot;&gt;
    &lt;tr class=&quot;head&quot;&gt;
        &lt;td&gt;在程序中寻找&lt;/td&gt;
        &lt;td&gt;改为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.href = value&lt;br/&gt;$location.hash = value&lt;br/&gt;$location.update(value)&lt;br/&gt;$location.updateHash(value)
        &lt;/td&gt;
        &lt;td&gt;$location.path(path).search(search)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.hashPath = path&lt;/td&gt;
        &lt;td&gt;$location.path(path)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.hashSearch = search&lt;/td&gt;
        &lt;td&gt;$location.search(search)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr class=&quot;head&quot;&gt;
        &lt;td&gt;Navigation outside the app&lt;/td&gt;
        &lt;td&gt;Use lower level API&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.href = value&lt;br/&gt;$location.update(value)&lt;/td&gt;
        &lt;td&gt;$window.location.href = value&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location[protocol | host | port | path | search]&lt;/td&gt;
        &lt;td&gt;$window.location[protocol | host | port | path | search]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr class=&quot;head&quot;&gt;
        &lt;td&gt;Read access&lt;/td&gt;
        &lt;td&gt;Change to&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.hashPath&lt;/td&gt;
        &lt;td&gt;$location.path()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.hashSearch&lt;/td&gt;
        &lt;td&gt;$location.search()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.href&lt;br/&gt;$location.protocol&lt;br/&gt;$location.host&lt;br/&gt;$location.port&lt;br/&gt;$location.hash&lt;/td&gt;
        &lt;td&gt;$location.absUrl()&lt;br/&gt;$location.protocol()&lt;br/&gt;$location.host()&lt;br/&gt;$location.port()&lt;br/&gt;$location.path() +
            $location.search()
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;$location.path&lt;br/&gt;$location.search&lt;/td&gt;
        &lt;td&gt;$window.location.path&lt;br/&gt;$window.location.search&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h4&gt;$location中的双向绑定&lt;/h4&gt;
&lt;p&gt;Anguar编译器当前不支持方法的双向绑定（参看&lt;a href=&quot;https://github.com/angular/angular.js/issues/404&quot;&gt;issue&lt;/a&gt;）。如果你需要$location对象的双向绑定（在input上使用&lt;code&gt;ngModel&lt;/code&gt;directive），你需要指定一个额外的model属性（e.g. &lt;code&gt;locationPath&lt;/code&gt;），并使用两个watchers向两边推送&lt;code&gt;$location&lt;/code&gt;的更新。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;!-- html --&gt;
&lt;p&gt;&lt;input type=&quot;text&quot; ng-model=&quot;locationPath&quot;  /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;pre&amp;gt;
// js - controller
$scope.$watch(&apos;locationPath&apos;, function(path) {
  $location.path(path);
});

$scope.$watch(&apos;$location.path()&apos;, function(path) {
  scope.locationPath = path;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>26. Angular的服务</title>
                <link>http://freewind.in/posts/1257-angularjs-26-services</link>
                <pubDate>Tue, 01 Jan 2013 16:38:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1257</guid>
                <description><![CDATA[&lt;p&gt;Services是一种在服务器端已经长期使用的编程方式，Angular把它带到了客户端。在Anguar程序中，services是一些可使用依赖注入组合在一起的可替换的对象。Services经常与依赖注入一起使用，它也是angular程序的一个关键特性。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>24. 使用Angular的过滤器</title>
                <link>http://freewind.in/posts/1256-angularjs-24-use-filters</link>
                <pubDate>Tue, 01 Jan 2013 16:37:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1256</guid>
                <description><![CDATA[&lt;p&gt;Filter可以作为任意的Scope求值中的一部分，不过它最主要是用来在模板中格式化表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{ expression | filter }}

Filters通常把数据转为新的类型，在这个过程中对它进行格式化。Filter也可以被串连起来，还可以传入可选的参数。

你可以像这样串连起filters:

{{ expression | filter1 | filter2 }}

你也可以把以冒号分隔的参数传到filter中，比如下例中，“以２位小数显示数字123”：

123 | number:2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里还有一些例子用来演示filter用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无filter: &lt;code&gt;{{1234.5678}}&lt;/code&gt; =&gt; &lt;code&gt;1234.5678&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数字filter: &lt;code&gt;{{1234.5678|number}}&lt;/code&gt; =&gt; &lt;code&gt;1,234.57&lt;/code&gt;. 注意格式化之后的数字中，有一个逗号*   使用带参数的filter: &lt;code&gt;{{1234.5678|number:5}}&lt;/code&gt; =&gt; &lt;code&gt;1,234.56780&lt;/code&gt;. Filters可以带参数，且参数可选，它们使用冒号分隔。在本例中5即为传给number这个filter的参数，表示显示5位小数。&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>23. 创建Angular的过滤器</title>
                <link>http://freewind.in/posts/1255-angularjs-23-create-filters</link>
                <pubDate>Tue, 01 Jan 2013 16:37:22 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1255</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://docs.angularjs.org/guide/dev_guide.templates.filters.creating_filters&quot;&gt; &lt;br  /&gt;http://docs.angularjs.org/guide/dev_guide.templates.filters.creating_filters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建你自己的filter非常简单：只需要向你的module中注册一个新的filter factory函数即可。在factory中返回一个函数，它的第一个参数是输入的值，后面其它的参数，是在调用该filter时可向它传入的其它参数。&lt;/p&gt;
&lt;p&gt;（anguljarjs中最简单的就是这个filter了）&lt;/p&gt;
&lt;p&gt;下面定义了一个filter，可以把一段文本内容颠倒。同时它还能接受一个“将文本转为大写”的参数。&lt;/p&gt;
&lt;h4&gt;源代码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app=&quot;MyReverseModule&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;Ctrl&quot;&amp;gt;
      &amp;lt;input ng-model=&quot;greeting&quot; type=&quot;greeting&quot;&amp;gt;&amp;lt;br&amp;gt;
      No filter: {{greeting}}&amp;lt;br&amp;gt;
      Reverse: {{greeting|reverse}}&amp;lt;br&amp;gt;
      Reverse + uppercase: {{greeting|reverse:true}}&amp;lt;br&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

**script.js**

angular.module(&apos;MyReverseModule&apos;, []).
  filter(&apos;reverse&apos;, function() {
    return function(input, uppercase) {
      var out = &quot;&quot;;
      for (var i = 0; i &amp;lt; input.length; i++) {
        out = input.charAt(i) + out;
      }
      // conditional based on optional argument
      if (uppercase) {
        out = out.toUpperCase();
      }
      return out;
    }
  });

function Ctrl($scope) {
  $scope.greeting = &apos;hello&apos;;
}

**End to end test**

it(&apos;should reverse greeting&apos;, function() {
  expect(binding(&apos;greeting|reverse&apos;)).toEqual(&apos;olleh&apos;);
  input(&apos;greeting&apos;).enter(&apos;ABC&apos;);
  expect(binding(&apos;greeting|reverse&apos;)).toEqual(&apos;CBA&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jsfiddle demo&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>22. 理解Angular的过滤器</title>
                <link>http://freewind.in/posts/1254-angularjs-22-understand-filters</link>
                <pubDate>Tue, 01 Jan 2013 16:36:51 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1254</guid>
                <description><![CDATA[&lt;p&gt;Angular的filters用来格式化数据，以显示给用户。&lt;/p&gt;
&lt;p&gt;例如，你有一些数据，希望以用户所在的区域的格式来显示。你可以把数据传给一些filter，如下：&lt;/p&gt;
&lt;p&gt;（下面的例子跟这段话有点对不上）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name | uppercase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表达式求值器会简单地把&lt;code&gt;name&lt;/code&gt;的值传给&lt;code&gt;uppercase&lt;/code&gt;这个filter.&lt;/p&gt;
&lt;p&gt;除此之外，它还能修改DOM。因此可用filter来处理如“给输出增加css样式”的任务。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>21. Angular中的数据绑定</title>
                <link>http://freewind.in/posts/1253-angularjs-21-data-binding</link>
                <pubDate>Tue, 01 Jan 2013 16:36:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1253</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/docs/content/guide/dev_guide.templates.databinding.ngdoc&quot;&gt; &lt;br  /&gt;https://github.com/angular/angular.js/blob/master/docs/content/guide/dev_guide.templates.databinding.ngdoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Angular web程序中的数据绑定可自动将model和view间的数据同步。Angular实现数据绑定的方式，可以让我们把model当作程序中唯一可信的数据来源。view始终是model的投影。当model发生变化时，会自动反映到view上，反之亦然。&lt;/p&gt;
&lt;h4&gt;经典模板系统中的数据绑定&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1253-1.png&quot;&gt;&lt;img src=&quot;/user_images/1253-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大多数模板系统中的数据绑定都是单向的：它们把模板与model合并在一起变成view，如上图所示。如果在合并之后，model发生了变化，不会自动反映到view上。更糟的是，用户在view上的交互也不会反映到model中。这表示开发者必须写大量代码不断地在view与model之间同步数据。&lt;/p&gt;
&lt;h4&gt;Anguar模板中的数据绑定&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1253-3.png&quot;&gt;&lt;img src=&quot;/user_images/1253-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Angular模板的工作方式不同，与上图所示。它们之所以不同，是因为，首先模板（由HTML和附加的markup和directive组成）是在浏览器中编译的，其次，在编译阶段产生了一个实时更新(live)的视图。我们说它是“live&quot;是因为不论在model或是view上发生了变化，都会立刻反映到对方。这样让model成为程序中唯一真实的数据来源，极大地简化了开发者需要处理的编程模型。你可以认为view是model的实时投影。&lt;/p&gt;
&lt;p&gt;由于view只是投影，controller完全与view分开，完全无视它的存在。这样让测试很容易，因为它让你的controller在一个与DOM/浏览器无关的独立状态下进行测试。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>20. 使用Angular中的样式表</title>
                <link>http://freewind.in/posts/1248-angularjs-20-styles</link>
                <pubDate>Tue, 01 Jan 2013 16:35:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1248</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/docs/content/guide/dev_guide.templates.css-styling.ngdoc&quot;&gt; &lt;br  /&gt;https://github.com/angular/angular.js/blob/master/docs/content/guide/dev_guide.templates.css-styling.ngdoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Angular提供了这些CSS classes。你可以在自己的程序中为它们设置合适的样式。&lt;/p&gt;
&lt;h3&gt;Angular使用的CSS classes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ng-invalid&lt;/code&gt;, &lt;code&gt;ng-valid&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   **用法:**当一个input控件的值没有通地验证时，angular会把这些class应用到元素上。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ng-pristine&lt;/code&gt;, &lt;code&gt;ng-dirty&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   **用法:** Anguar把`ng-pristine`类应用到一个新创建的还没有与用户交互过的input控件上。一旦该控件与用户交互后，它的class就变成了`ng-dirty`
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(参见directive一节).&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>19. 理解Angular的模板</title>
                <link>http://freewind.in/posts/1247-angularjs-19-templates</link>
                <pubDate>Tue, 01 Jan 2013 16:35:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1247</guid>
                <description><![CDATA[&lt;p&gt;Angular模板是一份声明式的文档，它使用了从model和controller中抽取出来的信息，最后被渲染为用户可在浏览器中看到的视图。它是一些静态的DOM，由HTML、CSS和angular相关的元素和属性组成。其中，Angular元素及属性将向DOM中添加行为，并把模板DOM转换为动态视图DOM。&lt;/p&gt;
&lt;p&gt;下面是可以在模板中使用的anguar元素和元素属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Directive - 一个用来改变已有DOM元素或表示可复用的DOM组件的属性或元素 - 一个部件&lt;em&gt;   Markup - 用双花括号&lt;code&gt;{{ }}&lt;/code&gt;把表达式绑定到元素上的语法，是Angular内置的标记&lt;/em&gt;   filter - 格式化你的数据，显示给用户*   Form controls - 验证用户输入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：除了可以在模板中声明以上元素，你还可以在JavaScript代码中访问这些元素。&lt;/p&gt;
&lt;p&gt;下面的代码片断演示了一个由HTML标签、angular directives和双花括号绑定的表达式，组成的简单的angular模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html ng-app&amp;gt;
 &amp;lt;!-- Body tag augmented with ngController directive  --&amp;gt;
 &amp;lt;body ng-controller=&quot;MyController&quot;&amp;gt;
   &amp;lt;input ng-model=&quot;foo&quot; value=&quot;bar&quot;&amp;gt;
   &amp;lt;!-- Button tag with ng-click directive, and
          string expression &apos;buttonText&apos;
          wrapped in &quot;{{ }}&quot; markup --&amp;gt;
   &amp;lt;button ng-click=&quot;changeFoo()&quot;&amp;gt;{{buttonText}}&amp;lt;/button&amp;gt;
   &amp;lt;script src=&quot;angular.js&quot;&amp;gt;
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在一个简单的单页面程序中，模板通常是一个HTML文件（如&lt;code&gt;index.html&lt;/code&gt;），由HTML、CSS和angular directives组成。在更复杂的程序中，你可能在一个主页面中使用片断页（partials）来显示多个view，它们是分散于多个文件中的模板片断。你在主页面中使用&lt;code&gt;$route&lt;/code&gt; service和&lt;code&gt;ngView&lt;/code&gt; directive将这些片断页包含进来。使用这个技术的一个例子是在angular tutorial中的第七步和第八步。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>18. E2E测试</title>
                <link>http://freewind.in/posts/1246-angularjs-18-e2e-testing</link>
                <pubDate>Tue, 01 Jan 2013 16:34:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1246</guid>
                <description><![CDATA[&lt;p&gt;当程序越来越大，越来越复杂的时候，靠人工手动测试新特性、抓bug变得越来越不可靠了。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们创建了Angular Scenario Runner来模拟用户与程序的交互，来帮助我们检查Angular程序的健康状况。&lt;/p&gt;
&lt;h3&gt;概览&lt;/h3&gt;
&lt;p&gt;你使用JavaScript来写情景测试，描述在一个确定的状态下给定一个确定的交互，你的程序如何反应。一个情景包含了一个或多个&lt;code&gt;it(..)&lt;/code&gt;块（你可以把它们想像你的程序要满足的需求），由&lt;strong&gt;命令&lt;/strong&gt;和&lt;strong&gt;预期&lt;/strong&gt;组成。命令用来指挥Runner让程序做一些操作（比如转到某个页面，或者点击一个按钮），而预期用来指挥Runner验证程序状态（如某个字段的值，或者当前的URL）。如果验证出错，runner把当前的&lt;code&gt;it&lt;/code&gt;块标记为&quot;failed&quot;并继续运行下一个。情景脚本还可以有&lt;strong&gt;beforeEach&lt;/strong&gt;和&lt;strong&gt;afterEach&lt;/strong&gt;块，它们会在每一个&lt;code&gt;it&lt;/code&gt;块之前或之后运行，不管测试过程中有没有失败。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1246-1.png&quot;&gt;&lt;img src=&quot;/user_images/1246-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为对上面元素的补充，情景脚本还可以包含一些工具函数，用来减少&lt;code&gt;it&lt;/code&gt;块中的重复代码。&lt;/p&gt;
&lt;p&gt;这里是一个简单的情景脚本的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;describe(&apos;Buzz Client&apos;, function() {
  it(&apos;should filter results&apos;, function() {
    input(&apos;user&apos;).enter(&apos;jacksparrow&apos;);
    element(&apos;:button&apos;).click();
    expect(repeater(&apos;ul li&apos;).count()).toEqual(10);
    input(&apos;filterText&apos;).enter(&apos;Bees&apos;);
    expect(repeater(&apos;ul li&apos;).count()).toEqual(1);
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一段情景脚本描述了&quot;Buzz Client&quot;的需求，它应该可以对用户数据流进行过滤。开始时，它向&quot;user&quot;这个input中输入一个值&apos;jacksparrow&apos;，然后点了页面中仅有的一个按钮，最后验证列表中有10个元素。然后再输入&apos;Bees&apos;，验证列表中只有1个元素。&lt;/p&gt;
&lt;p&gt;下面的API列表描述了Runner中的可用命令和验证。&lt;/p&gt;
&lt;h3&gt;API&lt;/h3&gt;
&lt;p&gt;源代码：&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/src/ngScenario/dsl.js&quot;&gt;https://github.com/angular/angular.js/blob/master/src/ngScenario/dsl.js&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;pause()&lt;/h4&gt;
&lt;p&gt;暂停测试的运行直到你在控制台中调用了&lt;code&gt;resume()&lt;/code&gt;（或点击了Runner UI上的resume链接）&lt;/p&gt;
&lt;h4&gt;sleep(seconds)&lt;/h4&gt;
&lt;p&gt;暂停测试指定的秒数&lt;/p&gt;
&lt;h4&gt;browser().navigateTo(url)&lt;/h4&gt;
&lt;p&gt;把指定的url导入到测试框架中&lt;/p&gt;
&lt;h4&gt;browser().navigateTo(url, fn)&lt;/h4&gt;
&lt;p&gt;将&lt;code&gt;fn&lt;/code&gt;返回的URL导入到测试框架中。给定的&lt;code&gt;url&lt;/code&gt;仅仅用来在测试输出中作为提示信息显示出来。当要测试的url是动态生成的时候，可使用这个方法。&lt;/p&gt;
&lt;h4&gt;browser().reload()&lt;/h4&gt;
&lt;p&gt;重新导入当前的页面&lt;/p&gt;
&lt;h4&gt;browser().window().href()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;window.location.href&lt;/code&gt;值&lt;/p&gt;
&lt;h4&gt;browser().window().path()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;window.location.pathname&lt;/code&gt;值&lt;/p&gt;
&lt;h4&gt;browser().window().search()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;window.location.search&lt;/code&gt;的值&lt;/p&gt;
&lt;h4&gt;browser().window().hash()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;window.location.hash&lt;/code&gt;（ 不包含&lt;code&gt;#&lt;/code&gt;）的值&lt;/p&gt;
&lt;h4&gt;browser().location().url()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;$location.url()&lt;/code&gt;的值&lt;/p&gt;
&lt;h4&gt;browser().location().path()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;$location.path()&lt;/code&gt;的值&lt;/p&gt;
&lt;h4&gt;browser().location().search()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;$location.search()&lt;/code&gt;的值&lt;/p&gt;
&lt;h4&gt;browser().location().hash()&lt;/h4&gt;
&lt;p&gt;返回当前测试框架中页面的&lt;code&gt;$location.hash()&lt;/code&gt;的值&lt;/p&gt;
&lt;h4&gt;expect(future).{matcher}&lt;/h4&gt;
&lt;p&gt;验证给定的&lt;code&gt;future&lt;/code&gt;的值是否满足&lt;code&gt;matcher&lt;/code&gt;。所有返回一个&lt;code&gt;future&lt;/code&gt;对象的API，在它们运行结束后都会得到一个&lt;code&gt;value&lt;/code&gt;。Matcher使用&lt;code&gt;angular.scenario.matcher&lt;/code&gt;定义，并且将使用future的值来验证。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;expect(browser().location().href()).toEqual(&apos;http://www.google.com&apos;)&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;expect(future).not().{matcher}&lt;/h4&gt;
&lt;p&gt;验证给定&lt;code&gt;fufure&lt;/code&gt;的值满足&lt;code&gt;matcher&lt;/code&gt;的相反值。&lt;/p&gt;
&lt;h4&gt;using(selector, label)&lt;/h4&gt;
&lt;p&gt;选择下一个DSL元素的域&lt;/p&gt;
&lt;h4&gt;binding(name)&lt;/h4&gt;
&lt;p&gt;返回与给定&lt;code&gt;name&lt;/code&gt;匹配的第一个绑定值&lt;/p&gt;
&lt;h4&gt;input(name).enter(value)&lt;/h4&gt;
&lt;p&gt;将给定&lt;code&gt;value&lt;/code&gt;输入到&lt;code&gt;name&lt;/code&gt;对应的文本输入框中&lt;/p&gt;
&lt;h4&gt;input(name).check()&lt;/h4&gt;
&lt;p&gt;将&lt;code&gt;name&lt;/code&gt;对应的checobox选中或取消选择&lt;/p&gt;
&lt;h4&gt;input(name).select(value)&lt;/h4&gt;
&lt;p&gt;选中&lt;code&gt;name&lt;/code&gt;单选框组中&lt;code&gt;value&lt;/code&gt;对应的那个单选框&lt;/p&gt;
&lt;h4&gt;input(name).val()&lt;/h4&gt;
&lt;p&gt;得到&lt;code&gt;name&lt;/code&gt;输入框中的值&lt;/p&gt;
&lt;h4&gt;repeater(selector, label).count()&lt;/h4&gt;
&lt;p&gt;返回jQuery &lt;code&gt;selector&lt;/code&gt; 匹配的repeater中的行数。&lt;code&gt;Label&lt;/code&gt;用于在测试中输出为提示信息。&lt;/p&gt;
&lt;h4&gt;repeater(selector, label).row(index)&lt;/h4&gt;
&lt;p&gt;得到jquery &lt;code&gt;selector&lt;/code&gt;匹配的repeater中&lt;code&gt;index&lt;/code&gt;所对应的&lt;strong&gt;行&lt;/strong&gt;中的绑定数据的数组。&lt;code&gt;label&lt;/code&gt;用于在测试中输出信息。&lt;/p&gt;
&lt;h4&gt;repeater(selector, label).column(binding)&lt;/h4&gt;
&lt;p&gt;得到jquery &lt;code&gt;selector&lt;/code&gt;匹配的repeater中&lt;code&gt;index&lt;/code&gt;所对应的&lt;strong&gt;列&lt;/strong&gt;中的绑定数据的数组。&lt;code&gt;label&lt;/code&gt;用于在测试中输出信息。&lt;/p&gt;
&lt;h4&gt;select(name).option(value)&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;name&lt;/code&gt;对应的select控件中，选择&lt;code&gt;value&lt;/code&gt;对应的那一项&lt;/p&gt;
&lt;h4&gt;select(name).option(value1, value2&amp;hellip;)&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;name&lt;/code&gt;对应的select控件中，选择&lt;code&gt;value1, value2&lt;/code&gt;对应的那几项&lt;/p&gt;
&lt;h4&gt;element(selector, label).count()&lt;/h4&gt;
&lt;p&gt;返回jquery &lt;code&gt;selector&lt;/code&gt;匹配的元素的个数。&lt;code&gt;label&lt;/code&gt;用于输出信息。&lt;/p&gt;
&lt;h4&gt;element(selector, label).click()&lt;/h4&gt;
&lt;p&gt;对jquery &lt;code&gt;selector&lt;/code&gt;对应的元素进行单击操作。&lt;code&gt;label&lt;/code&gt;用于输出信息。&lt;/p&gt;
&lt;h4&gt;element(selector, label).query(fn)&lt;/h4&gt;
&lt;p&gt;对jquery &lt;code&gt;selector&lt;/code&gt;匹配的元素(标记为&lt;code&gt;selectedElements&lt;/code&gt;)执行&lt;code&gt;fn(selectedElements, done)&lt;/code&gt;操作。其中&lt;code&gt;done&lt;/code&gt;是在&lt;code&gt;fn&lt;/code&gt;函数执行结束时要运行的一个函数。&lt;code&gt;label&lt;/code&gt;用于输出信息。&lt;/p&gt;
&lt;h4&gt;element(selector, label).{method}()&lt;/h4&gt;
&lt;p&gt;对jquery &lt;code&gt;selector&lt;/code&gt;匹配的元素执行&lt;code&gt;method&lt;/code&gt;操作，其中method可以是下列jQuery方法中的任一个： &lt;code&gt;val&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;,&lt;code&gt;html&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;innerHeight&lt;/code&gt;, &lt;code&gt;outerHeight&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;innerWidth&lt;/code&gt;, &lt;code&gt;outerWidth&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt;,&lt;code&gt;scrollLeft&lt;/code&gt;, &lt;code&gt;scrollTop&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;。&lt;code&gt;label&lt;/code&gt;用于在测试中输出提示信息。&lt;/p&gt;
&lt;h4&gt;element(selector, label).{method}(value)&lt;/h4&gt;
&lt;p&gt;对jquery &lt;code&gt;selector&lt;/code&gt;匹配的元素执行&lt;code&gt;method&lt;/code&gt;操作，&lt;code&gt;value&lt;/code&gt;作为传入的参数，其中method可以是下列jQuery方法中的任一个：&lt;code&gt;val&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, &lt;code&gt;innerHeight&lt;/code&gt;, &lt;code&gt;outerHeight&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;innerWidth&lt;/code&gt;, &lt;code&gt;outerWidth&lt;/code&gt;,&lt;code&gt;position&lt;/code&gt;, &lt;code&gt;scrollLeft&lt;/code&gt;, &lt;code&gt;scrollTop&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;。&lt;code&gt;label&lt;/code&gt;用于在测试中输出提示信息。&lt;/p&gt;
&lt;h4&gt;element(selector, label).{method}(key)&lt;/h4&gt;
&lt;p&gt;对jquery &lt;code&gt;selector&lt;/code&gt;匹配的元素执行&lt;code&gt;method&lt;/code&gt;操作，&lt;code&gt;key&lt;/code&gt;作为传入的参数，其中method可以是下列jQuery方法中的任一个：&lt;code&gt;attr&lt;/code&gt;, &lt;code&gt;prop&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;。&lt;code&gt;label&lt;/code&gt;用于在测试中输出提示信息。&lt;/p&gt;
&lt;h4&gt;element(selector, label).{method}(key, value)&lt;/h4&gt;
&lt;p&gt;对jquery &lt;code&gt;selector&lt;/code&gt;匹配的元素执行&lt;code&gt;method&lt;/code&gt;操作，&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;作为传入的参数。其中method可以是下列jQuery方法中的任一个：&lt;code&gt;attr&lt;/code&gt;, &lt;code&gt;prop&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;。&lt;code&gt;label&lt;/code&gt;用于在测试中输出提示信息。&lt;/p&gt;
&lt;p&gt;JavaScript是一种拥有强大表现力的动态类型语言，但是它几乎没有办法从编译器中得到任何帮助。因此，我们强烈建议对于用JavaScript所写的任何代码，都要有相对应的一组测试。我们给Anguar增加了很多可以让你更容易测试Angular程序的特性，所以没有理由不用它。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>17. 理解Anguar中的视图组件</title>
                <link>http://freewind.in/posts/1243-angularjs-17-understand-view-components</link>
                <pubDate>Tue, 01 Jan 2013 16:34:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1243</guid>
                <description><![CDATA[&lt;p&gt;在Anguar中，视图(view)是指在angular根据模板、controller和model的信息转换之后的DOM，在浏览器中导入并渲染之后的DOM。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1243-1.png&quot;&gt;&lt;img src=&quot;/user_images/1243-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Anguar的MVC实现中，view同时知道model和controller。View知道model发生了双向绑定，也通过&lt;code&gt;ngCOntroller&lt;/code&gt;和&lt;code&gt;ngView&lt;/code&gt;这些directives或者表达式&lt;code&gt;{{someControllerFuction()}}&lt;/code&gt;知道了controller。通过这些方式，view可以调用关联的controller中的方法。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>16. 理解Anguar中的控制器组件</title>
                <link>http://freewind.in/posts/1240-angularjs-16-understand-controller-components</link>
                <pubDate>Tue, 01 Jan 2013 16:33:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1240</guid>
                <description><![CDATA[&lt;p&gt;在Anguar中，一个controller是一个JavaScript函数（类），用来创建angular的scope实例（除了根scope外）。当你或angular通过&lt;code&gt;scope.$new&lt;/code&gt; API来创建一个子scope对象时，可以选择是否将一个controller作为参数传入。这表示让Angular把该controller与新创建的scope关联起来，以增加它的行为。&lt;/p&gt;
&lt;p&gt;使用controller可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置一个scope对象的初始状态*   为scope对象增加行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;设置scope对象的初始状态&lt;/h3&gt;
&lt;p&gt;通常当你创建了一个应用程序时，你需要给angular的scope设置初始状态。&lt;/p&gt;
&lt;p&gt;Angular将一个controller的构造函数应用(apply，跟Javascript的&lt;code&gt;Fuction#apply&lt;/code&gt;意思相同)到一个新创建的angular的scope对象上，用于给它设置初始状态。这表示angular从来不会创建controller的实例（比如&lt;code&gt;new MyController&lt;/code&gt;）。构造函数永远只被应用到已经存在的scope对象上。&lt;/p&gt;
&lt;p&gt;你可以通过创建model属性来初始化一个scope。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function GreetingCtrl($scope) {
 $scope.greeting = &apos;Hola!&apos;;
}

`GreetingCtrl`这个controller创建了一个`greeting`的model，它可以在模板中被引用。

### 为scope对象添加行为

Angular中的行为表现为scope上的方法属性，它们可在模板中被调用。行为与model交互，并可修改model。

如`model`章节所说，所有赋给scope的对象都被当作model属性。所有赋给scope的函数也都在模板中可用，并且可使用angular表达式，或者`ng`事件处理器（如`ngClick`）调用。

### 正确使用Controller

通常来说，一个controller中不要做太多事情。它通常只应该包含一个view所需要的业务逻辑。

让controller瘦身的常用方法是把不属于controller的代码提出来，做成services，然后在controller中通过依赖注入的方式调用它们。这在**依赖注入**一章探讨过。

不要用controller来做：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;任何DOM操作 - controller只应该包含业务逻辑。DOM操作属于展示逻辑，难以被测试。Angular提供了数据绑定的功能来自动维护DOM。如果你需要操作DOM，把相关代码放在directive中&lt;em&gt;   对输入进行格式化 - 使用Angular的form controls代替&lt;/em&gt;   输出过滤 - 使用Anguar的filters代替&lt;em&gt;   在controller间运行无状态或有状态的代码 - 使用angular的services来代替&lt;/em&gt;   初始化或管理其它组件的生命周期（例如，创建service实例）&lt;/p&gt;
&lt;h3&gt;将controller与scope对象关联&lt;/h3&gt;
&lt;p&gt;你可以使用&lt;code&gt;scope.$new&lt;/code&gt;来显式将controllers与scope关联，或者用&lt;code&gt;ngController&lt;/code&gt;这个directive来隐式创建，或者使用&lt;code&gt;$route&lt;/code&gt; service。&lt;/p&gt;
&lt;h4&gt;Controller构造器和方法示例&lt;/h4&gt;
&lt;p&gt;为了演示Anguar中controller组件是如何工作的，我们来创建一个简单的包含以下组件的程序：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个拥有两个按钮和一个简单信息的模板&lt;em&gt;   一个名为&lt;code&gt;spice&lt;/code&gt;由字符串组成的model&lt;/em&gt;   一个拥有两个函数的controller，它给&lt;code&gt;spice&lt;/code&gt;赋值&lt;/p&gt;
&lt;p&gt;在我们的模板中的信息包含对&lt;code&gt;spice&lt;/code&gt; model的绑定，默认值为&lt;code&gt;very&lt;/code&gt;。按下不同的按钮，&lt;code&gt;spice&lt;/code&gt; model的值可能被设为&lt;code&gt;chili&lt;/code&gt;或&lt;code&gt;jalapeño&lt;/code&gt;，且该信息将自动由数据绑定功能更新。&lt;/p&gt;
&lt;h3&gt;一个香辣(Spicy)的controller示例&lt;/h3&gt;
&lt;p&gt;&lt;body ng-controller=&quot;SpicyCtrl&quot;&gt;
&lt;br  /&gt;&lt;button ng-click=&quot;chiliSpicy()&quot;&gt;Chili&lt;/button&gt;
&lt;br  /&gt;&lt;button ng-click=&quot;jalapenoSpicy()&quot;&gt;Jalapeño&lt;/button&gt;&lt;/p&gt;
 &lt;p&gt;The food is {{spice}} spicy!&lt;/p&gt;
&lt;p&gt;&lt;/body&gt;&lt;/p&gt;
&lt;p&gt;function SpicyCtrl($scope) {
&lt;br  /&gt;$scope.spice = &apos;very&apos;;
&lt;br  /&gt;$scope.chiliSpicy = function() {
&lt;br  /&gt;$scope.spice = &apos;chili&apos;;
&lt;br  /&gt;}
&lt;br  /&gt;$scope.jalapenoSpicy = function() {
&lt;br  /&gt;$scope.spice = &apos;jalapeño&apos;;
&lt;br  /&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;上面的例子中，需要注意以下几点：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ngController&lt;/code&gt;这个directive用来隐式创建一个scope，并且这个scope将由&lt;code&gt;SpicyCtrl&lt;/code&gt; 这个controller管理&lt;em&gt;   &lt;code&gt;SpicyCtrl&lt;/code&gt;只是一个普通的JavaScript函数。这里有一个（可选的）命名约定，即单词首字母大写，且以&lt;code&gt;Ctrl&lt;/code&gt;或&lt;code&gt;Controller&lt;/code&gt;结尾&lt;/em&gt;   向&lt;code&gt;$scope&lt;/code&gt;的属性赋值以创建或更新相应的model&lt;em&gt;   Controller中的方法可通过直接赋值的方式创建 （比如&lt;code&gt;chiliSpicy&lt;/code&gt;或&lt;code&gt;jalapenoSpicy&lt;/code&gt;方法）&lt;/em&gt;   两个controller方法在模板中都可用（对于&lt;code&gt;body&lt;/code&gt;及它的子元素）*   注意：以前的Anguar版本（1.0RC前），允许我们使用&lt;code&gt;this&lt;/code&gt;替换&lt;code&gt;$scope&lt;/code&gt;来&lt;code&gt;$scope&lt;/code&gt;的方法，但现在不允许了。现在只能在$scope上的方法定义中使用&lt;code&gt;this&lt;/code&gt;来指代&lt;code&gt;$scope&lt;/code&gt;，在其它地方不行。 -注意： 以前的Anguar版本（1.0RC前），自动把controller的prototype方法加到scope中。但现在不允许了。现在所有的方法都只能手动向$scope添加。&lt;/p&gt;
&lt;p&gt;controller中的方法也可以有参数，见下例（对前面例子的修改）：&lt;/p&gt;
&lt;h3&gt;拥有参数的controller中的方法&lt;/h3&gt;
&lt;p&gt;&lt;body ng-controller=&quot;SpicyCtrl&quot;&gt;
&lt;br  /&gt;&lt;input ng-model=&quot;customSpice&quot; value=&quot;wasabi&quot;&gt;
&lt;br  /&gt;&lt;button ng-click=&quot;spicy(&apos;chili&apos;)&quot;&gt;Chili&lt;/button&gt;
&lt;br  /&gt;&lt;button ng-click=&quot;spicy(customSpice)&quot;&gt;Custom spice&lt;/button&gt;&lt;/p&gt;
 &lt;p&gt;The food is {{spice}} spicy!&lt;/p&gt;
&lt;p&gt;&lt;/body&gt;&lt;/p&gt;
&lt;p&gt;function SpicyCtrl($scope) {
&lt;br  /&gt;$scope.spice = &apos;very&apos;;
&lt;br  /&gt;$scope.spicy = function(spice) {
&lt;br  /&gt;$scope.spice = spice;
&lt;br  /&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;注意&lt;code&gt;SpicyCtrl&lt;/code&gt;这个controller只定义一个方法，叫&lt;code&gt;spicy&lt;/code&gt;，它有一个参数叫&lt;code&gt;spice&lt;/code&gt;。在模板中，调用可以调用这个方法，并在第一个按钮中传入一个参数&lt;code&gt;chili&lt;/code&gt;，在第二个按钮中传入一个参数&lt;code&gt;spice&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;Controller的继承&lt;/h4&gt;
&lt;p&gt;Controller的继承基于&lt;code&gt;scope&lt;/code&gt;的继承。让我们看个例子：&lt;/p&gt;
&lt;p&gt;&lt;body ng-controller=&quot;MainCtrl&quot;&gt;&lt;/p&gt;
 &lt;p&gt;Good {{timeOfDay}}, {{name}}!&lt;/p&gt;
&lt;p&gt;&lt;div ng-controller=&quot;ChildCtrl&quot;&gt;&lt;/p&gt;
   &lt;p&gt;Good {{timeOfDay}}, {{name}}!&lt;/p&gt;
   &lt;p ng-controller=&quot;BabyCtrl&quot;&gt;Good {{timeOfDay}}, {{name}}!&lt;/p&gt;
&lt;p&gt;&lt;/body&gt;&lt;/p&gt;
&lt;p&gt;function MainCtrl($scope) {
&lt;br  /&gt;$scope.timeOfDay = &apos;morning&apos;;
&lt;br  /&gt;$scope.name = &apos;Nikki&apos;;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;function ChildCtrl($scope) {
&lt;br  /&gt;$scope.name = &apos;Mattie&apos;;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;function BabyCtrl($scope) {
&lt;br  /&gt;$scope.timeOfDay = &apos;evening&apos;;
&lt;br  /&gt;$scope.name = &apos;Gingerbreak Baby&apos;;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;注意，我们在模板中嵌套了三个&lt;code&gt;ngController&lt;/code&gt;指令。这个模板将会产生4个scope：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;root scope&lt;em&gt;   &lt;code&gt;MainCtrl&lt;/code&gt; scope, 包含&lt;code&gt;timeOfDay&lt;/code&gt;和&lt;code&gt;name&lt;/code&gt;这两个models&lt;/em&gt;   &lt;code&gt;ChildCtrl&lt;/code&gt; scope, 它继承了&lt;code&gt;timeOfDay&lt;/code&gt;，但遮盖了上层的&lt;code&gt;name&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BabyCtrl&lt;/code&gt; scope, 它遮盖了&lt;code&gt;MainCtrl&lt;/code&gt;中的&lt;code&gt;timeOfDay&lt;/code&gt;和&lt;code&gt;ChildCtrl&lt;/code&gt;中的&lt;code&gt;name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Controller间的继承原理，与model相同。所以在我们之间的例子中，所有的model都可以被返回字符串的controller方法代替。&lt;/p&gt;
&lt;p&gt;注意：两个controller间的原型继承并不会像人们期待的那样工作，就像我们在前面提过的一样，controller并不会由angular实例化，它们只是被应用到scope对象上了。&lt;/p&gt;
&lt;h4&gt;测试Controllers&lt;/h4&gt;
&lt;p&gt;虽然 我们有很多方法来测试一个controller，但最方便的还是像下面这样，通过注入&lt;code&gt;$rootScope&lt;/code&gt;和&lt;code&gt;$controller&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Controller Function:&lt;/p&gt;
&lt;p&gt;function myController($scope) {
&lt;br  /&gt;$scope.spices = [{&amp;ldquo;name&amp;rdquo;:&amp;ldquo;pasilla&amp;rdquo;, &amp;ldquo;spiciness&amp;rdquo;:&amp;ldquo;mild&amp;rdquo;},&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;              {&quot;name&quot;:&quot;jalapeno&quot;, &quot;spiceiness&quot;:&quot;hot hot hot!&quot;},
              {&quot;name&quot;:&quot;habanero&quot;, &quot;spiceness&quot;:&quot;LAVA HOT!!&quot;}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$scope.spice = &amp;ldquo;habanero&amp;rdquo;;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;Controller Test:&lt;/p&gt;
&lt;p&gt;describe(&apos;myController function&apos;, function() {&lt;/p&gt;
&lt;p&gt;describe(&apos;myController&apos;, function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var scope;

beforeEach(inject(function($rootScope, $controller) {
  scope = $rootScope.$new();
  var ctrl = $controller(myController, {$scope: scope});
}));

it(&apos;should create &quot;spices&quot; model with 3 spices&apos;, function() {
  expect(scope.spices.length).toBe(3);
});

it(&apos;should set the default value of spice&apos;, function() {
  expect(scope.spice).toBe(&apos;habanero&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;如果你想要测试一个嵌套的controller，需要在你的test中，创建与DOM已经存在的scope相同的继承层次。&lt;/p&gt;
&lt;p&gt;describe(&apos;state&apos;, function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var mainScope, childScope, babyScope;

beforeEach(inject(function($rootScope, $controller) {
    mainScope = $rootScope.$new();
    var mainCtrl = $controller(MainCtrl, {$scope: mainScope});
    childScope = mainScope.$new();
    var childCtrl = $controller(ChildCtrl, {$scope: childScope});
    babyScope = $rootScope.$new();
    var babyCtrl = $controller(BabyCtrl, {$scope: babyScope});
}));

it(&apos;should have over and selected&apos;, function() {
    expect(mainScope.timeOfDay).toBe(&apos;morning&apos;);
    expect(mainScope.name).toBe(&apos;Nikki&apos;);
    expect(childScope.timeOfDay).toBe(&apos;morning&apos;);
    expect(childScope.name).toBe(&apos;Mattie&apos;);
    expect(babyScope.timeOfDay).toBe(&apos;evening&apos;);
    expect(babyScope.name).toBe(&apos;Gingerbreak Baby&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>15. 理解Anguar中的模型组件</title>
                <link>http://freewind.in/posts/1239-angularjs-15-understand-model-components</link>
                <pubDate>Tue, 01 Jan 2013 16:32:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1239</guid>
                <description><![CDATA[&lt;p&gt;根据Angular文档中讨论的上下文，_model_这个词，既可指代一个表示实体的对象（例如，一个model叫&quot;phones&amp;rdquo;，它的值是一个phone数组），也可指代程序的整体数据（所有实体）。&lt;/p&gt;
&lt;p&gt;在Angular中，一个model是指&lt;code&gt;scope&lt;/code&gt;对象的一个可访问的属性。属性的名称是model的标识符，值是任意一个JavaScript对象（包括数组和基础类型）。&lt;/p&gt;
&lt;p&gt;一个JavaScript对象要想成为angular的一个model，唯一的要求是它必须作为一个scope的属性被引用。属性引用的创建可显式或隐式。&lt;/p&gt;
&lt;p&gt;你可以像下面这样显式创建models：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接在JavaScript代码中把一个对象赋给scope的一个属性，通常在controller中这么做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function MyCtrl($scope) {
   // create property &apos;foo&apos; on the MyCtrl&apos;s scope
   // and assign it an initial value &apos;bar&apos;
   $scope.foo = &apos;bar&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在模板中使用表达式的赋值操作符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;button ng-click=&quot;{{foos=&apos;ball&apos;}}&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在模板中使用&lt;code&gt;ngInit&lt;/code&gt; directive（只在练手项目中使用，不要在真实项目中使用）：
&lt;br  /&gt;&lt;body ng-init=&quot; foo = &apos;bar&apos; &quot;&gt;&lt;/p&gt;
&lt;p&gt;Anguar在解析下面的模板代码时，会隐式创建models（通过创建一个scope的property，并给它赋一个合适的值）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表单中的input, select, textarea和其它表单元素：
&lt;br  /&gt;&lt;input ng-model=&quot;query&quot; value=&quot;fluffy cloud&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的代码会在当前scope上创建一个叫&lt;code&gt;query&lt;/code&gt;的model，并把它的值设为&lt;code&gt;fluffy cloud&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;ngRepeater&lt;/code&gt;中声明一个遍历器&lt;/p&gt;
  &lt;p ng-repeat=&quot;phone in phones&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的代码将为phones中的每一个元素创建一个子scope，并在每个子scope中创建一个叫&quot;phone&quot;的model，其值为phones中的相应元素。&lt;/p&gt;
&lt;p&gt;在Anguar中，以下情况中，一个普通的JavaScript对象不会成为model：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scope中没有属性指向该对象*   虽然有scope引用了该对象，但所有引用了该对象的scope，都已经不可用，等待垃圾回收器的回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图演示了一个由简单的模板隐式生成的简单model：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1239-1.png&quot;&gt;&lt;img src=&quot;/user_images/1239-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>14. Angular中的MVC</title>
                <link>http://freewind.in/posts/1236-angularjs-14-mvc</link>
                <pubDate>Tue, 01 Jan 2013 16:31:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1236</guid>
                <description><![CDATA[&lt;p&gt;MVC(Model-View-Controller)在它出现的这些年里，意义发生了很多变化，但在Angular中，它把原始的&lt;a href=&quot;http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt;软件设计模式用到了客户端web程序中。&lt;/p&gt;
&lt;p&gt;MVC模式总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将数据分层：表现，数据和逻辑组件*   鼓励在组件间解耦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用services和依赖注入，MVC让angular程序结构更好，更容易维护和测试。&lt;/p&gt;
&lt;p&gt;下列文章解释了Angular中如何使用MVC来开发web程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解Model组件&lt;em&gt;   理解Controller组件&lt;/em&gt;   理解View组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO加链接&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>13. 依赖注入</title>
                <link>http://freewind.in/posts/1235-angularjs-13-dependency-injection</link>
                <pubDate>Tue, 01 Jan 2013 16:31:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1235</guid>
                <description><![CDATA[&lt;h3&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;依赖注入(Dependency Injection)是一种软件设计模式，用来处理代码如何获取它的依赖。&lt;/p&gt;
&lt;p&gt;如果想对依赖注入进入更深入的讨论，参看&lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Wikipedia上的文章&lt;/a&gt;，以及由Martin Fowler写的&lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Inversion of Controller&lt;/a&gt;，或者自行找书。&lt;/p&gt;
&lt;h4&gt;DI起步&lt;/h4&gt;
&lt;p&gt;一个对象或函数，只有这三种方式可取得依赖：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;new&lt;/code&gt;操作符创建一个依赖&lt;/li&gt;
&lt;li&gt;使用一个全局变量来寻找一个依赖&lt;/li&gt;
&lt;li&gt;在需要的时候，由外部传入一个依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前两种方式都不是最佳的，因为它们都需要在代码中“硬编码”依赖，以致于难以甚至无法修改依赖。在测试时这会是一个大问题，因为测试时通常都会使用一些mock来代替原有的依赖，以方便测试。&lt;/p&gt;
&lt;p&gt;第三种方式最可行，因为它把“定位依赖”的责任从组件中移除了。依赖可以简单的传递给组件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function SomeClass(greeter) {
  this.greeter = greeter
}

SomeClass.prototype.doSomething = function(name) {
  this.greeter.greet(name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中，&lt;code&gt;SomeClass&lt;/code&gt;不用关心它的依赖&lt;code&gt;greeter&lt;/code&gt;从何而来，直接用就行了。&lt;code&gt;greeter&lt;/code&gt;会在运行时直接传入。&lt;/p&gt;
&lt;p&gt;这么做虽然可行，但它却把取得依赖的责任踢给了&lt;code&gt;SomeClass&lt;/code&gt;的构造函数。&lt;/p&gt;
&lt;p&gt;为了管理依赖的创建，每个angular程序都有一个&lt;code&gt;injector&lt;/code&gt;。该injector是一个定位服务，专门用于创建和寻找依赖。&lt;/p&gt;
&lt;p&gt;下面是使用injector的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// Provide the wiring information in a module
angular.module(&apos;myModule&apos;, []).

  // Teach the injector how to build a &apos;greeter&apos;
  // Notice that greeter itself is dependent on &apos;$window&apos;
  factory(&apos;greeter&apos;, function($window) {
    // This is a factory function, and is responsible for 
    // creating the &apos;greet&apos; service.
    return {
      greet: function(text) {
        $window.alert(text);
      }
    };
  }).

// New injector is created from the module. 
// (This is usually done automatically by angular bootstrap)
var injector = angular.injector(&apos;myModule&apos;);

// Request any dependency from the injector
var greeter = injector.get(&apos;greeter&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然用“请求依赖”解决了“硬编码”的问题，但它也意味着有一个injector需要传到程序中。传入injector破坏了&lt;a href=&quot;http://en.wikipedia.org/wiki/Law_of_Demeter&quot;&gt;迪米特法则&lt;/a&gt;，即“一个软件实体应当与尽可能少的其他实体发生相互作用&amp;rdquo;。为了解决这个问题，我们把寻找依赖的责任通过声明依赖的方式，转移给injector。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!-- Given this HTML --&amp;gt;
&amp;lt;div ng-controller=&quot;MyController&quot;&amp;gt;
  &amp;lt;button ng-click=&quot;sayHello()&quot;&amp;gt;Hello&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
// And this controller definition
function MyController($scope, greeter) {
  $scope.sayHello = function() {
    greeter(&apos;Hello World&apos;);
  };
}

// The &apos;ng-controller&apos; directive does this behind the scenes
injector.instantiate(MyController);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，当我们使用&lt;code&gt;ng-controller&lt;/code&gt;这个directive来实例化这个类时，它会自动向&lt;code&gt;MyController&lt;/code&gt;传入它需要的依赖，而controller根本不需要知道injector的存在。这是最好的结果。程序代码不需要与injector交互，就可以请求它所需要的依赖。这也没有违反&lt;strong&gt;迪米特法则&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;injector如何知道哪个service应该被注入进去呢？&lt;/p&gt;
&lt;p&gt;程序开发者需要提供注解信息，让injector用来寻找依赖。根据Angular的API文档，Angular的API函数都是由injector调用的。Injector需要知道哪些services应该注入到函数中。下面是将service名称注解到代码中的三种等价方式。你可以根据需要使用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推断依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最简单的方式，就是直接用函数参数名来表示依赖名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function MyController($scope, greeter) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Injector可以检查函数定义，找到参数名，并以此去寻找依赖。在上例中，&lt;code&gt;$scope&lt;/code&gt;和&lt;code&gt;greeter&lt;/code&gt;就是需要注入的两个依赖。&lt;/p&gt;
&lt;p&gt;然而，如果你使用一些工具，对JavaScript代码进行了压缩或混淆处理，则这种方式就行不通了，因为参数名会被修改。所以这种方式常用于原型或演示程序。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;$inject&lt;/code&gt;注解&lt;/h3&gt;
&lt;p&gt;为了配合压缩工具，可以使用&lt;code&gt;$inject&lt;/code&gt;属性。它是一个由service名称组成的数组，用于寻找依赖。如果设置了它，则参数名将不再用来寻找依赖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var MyController = function(renamed$scope, renamedGreeter) { ... } MyController.$inject = [&apos;$scope&apos;, &apos;greeter&apos;]; ```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;$inject&lt;/code&gt;中的数据要跟Controller函数中的参数保持一致。&lt;/p&gt;
&lt;p&gt;对于controller的声明，这种方法比较有用，因为它把注解信息赋给了函数。&lt;/p&gt;
&lt;h3&gt;行内注解&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;$inject&lt;/code&gt;向directives添加注解信息不太方便。&lt;/p&gt;
&lt;p&gt;比如这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;someModule.factory(&apos;greeter&apos;, function($window) { ...; }); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要使用&lt;code&gt;$inject&lt;/code&gt;，需要用到临时变量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var greeterFactory = function(renamed$window) { ...; }; greeterFactory.$inject = [&apos;$window&apos;]; someModule.factory(&apos;greeter&apos;, greeterFactory); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以Angular提供了第三种注解方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;someModule.factory(&apos;greeter&apos;, [&apos;$window&apos;, function(renamed$window) { ...; }]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意上面三种方式是完全等价的，在Angular中任何地方都可以使用它们中任意一种。&lt;/p&gt;
&lt;h3&gt;我应该在哪儿使用DI?&lt;/h3&gt;
&lt;p&gt;DI在Angular中使用得非常普遍。最常用在controller和factory方法中。&lt;/p&gt;
&lt;h4&gt;controllers中的DI&lt;/h4&gt;
&lt;p&gt;Controllers是用来描述程序行为的类。推荐使用下面的方式来声明controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var MyController = function(dep1, dep2) {
  ...
}
MyController.$inject = [&apos;dep1&apos;, &apos;dep2&apos;];

MyController.prototype.aMethod = function() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;工厂方法&lt;/h4&gt;
&lt;p&gt;工厂方法用来创建Angular中大多数的对象。例如directives, services，和filters。工厂方法注册到模块上，推荐的声明方式为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;angualar.module(&apos;myModule&apos;, []).
  config([&apos;depProvider&apos;, function(depProvider){
    ...
  }]).
  factory(&apos;serviceId&apos;, [&apos;depService&apos;, function(depService) {
    ...
  }]).
  directive(&apos;directiveName&apos;, [&apos;depService&apos;, function(depService) {
    ...
  }]).
  filter(&apos;filterName&apos;, [&apos;depService&apos;, function(depService) {
    ...
  }]).
  run([&apos;depService&apos;, function(depService) {
    ...
  }]
);
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>12. Type</title>
                <link>http://freewind.in/posts/1234-angularjs-12-type</link>
                <pubDate>Tue, 01 Jan 2013 16:30:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1234</guid>
                <description><![CDATA[&lt;p&gt;TODO&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>11.域对象</title>
                <link>http://freewind.in/posts/1233-angularjs-11-scope</link>
                <pubDate>Tue, 01 Jan 2013 16:30:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1233</guid>
                <description><![CDATA[&lt;p&gt;原文：&lt;a href=&quot;http://docs.angularjs.org/guide/scope&quot;&gt;http://docs.angularjs.org/guide/scope&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;什么是域对象(Scopes)&lt;/h3&gt;
&lt;p&gt;scope用于指代程序的model，它是angularjs表达式的运行上下文。Scope使用了分层结构，与程序相应的DOM结构相似。Scope可以观察表达式，也可以传播事件。&lt;/p&gt;
&lt;h4&gt;Scope的特色&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Scopes提供了API&lt;code&gt;$watch&lt;/code&gt;可观察model的变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scopes提供了API&lt;code&gt;$apply&lt;/code&gt;可把AngularJs体系（controllers,services,angularjs event handlers）的model的变化传播到系统内至view层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scopes可访问共享的model属性，同时也可以嵌入到孤立(isolate)的程序组件之中。Scope以原型方式从上级Scope继承属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scope提供了表达式的运行上下文。例如，&lt;code&gt;{{username}}&lt;/code&gt;只有在一个提供了&lt;code&gt;username&lt;/code&gt;属性的scope中才能正确地求值，否则它只是一个普通的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Scope as Data-Model&lt;/h4&gt;
&lt;p&gt;Scope是程序的controller和view之间的胶水。在模板linking阶段，directives会在scope上设置&lt;code&gt;$watch&lt;/code&gt;表达式。&lt;code&gt;$watch&lt;/code&gt;允许当属性变化时，directives会得到通知，因此可更新相应的DOM上的内容。&lt;/p&gt;
&lt;p&gt;controller与directives都有到scope的引用，但它们两者之间没有引用。这么做让controller与directive与DOM之间都保持独立。这一点很重要，因为它让controllers没有绑死在代码中，大大方便了写测试用例。&lt;/p&gt;
&lt;h4&gt;Source&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;MyController&quot;&amp;gt;
      Your name:
        &amp;lt;input type=&quot;text&quot; ng-model=&quot;username&quot;&amp;gt;
        &amp;lt;button ng-click=&apos;sayHello()&apos;&amp;gt;greet&amp;lt;/button&amp;gt;
      &amp;lt;hr&amp;gt;
      {{greeting}}
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

**script.js**

function MyController($scope) {
  $scope.username = &apos;World&apos;;

  $scope.sayHello = function() {
    $scope.greeting = &apos;Hello &apos; + $scope.username + &apos;!&apos;;
  };
}

jsfiddle

在上面的例子中，请注意在`MyController`中，把`World`赋给了`username`。然后，scope将这次赋值通知了`input`，input中会显示新值。这里演示了controller如何把数据写入到scope中。

与之相似，controller也可以把行为赋给scope，比如那个`sayHello`方法，当用户点击了`greet`按钮时将会调用它。该方法会从scope中读取`username`属性，并新建了一个`greeting`属性。这里演示了HTML上的部件可以自动更新scope上的属性。

逻辑上，`{{greeting}}`的渲染涉及到：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在模板中&lt;code&gt;{{greeting}}&lt;/code&gt;定义处的DOM节点上取得scope。本例中，该scope就是传给&lt;code&gt;MyController&lt;/code&gt;的 scope。（稍后讨论）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在scope中对&lt;code&gt;greeting&lt;/code&gt;表达式进行求值，并把结果赋给所在的DOM元素的文本。&lt;/p&gt;
&lt;p&gt;你可以把scope和它的属性看作是用来演示view的数据。Scope是与view相关的所有数据的唯一合法可信来源。&lt;/p&gt;
&lt;p&gt;为了提高可测试性，将controller与view分开是可取的。因为它允许我们在测试行为的同时，无须考虑渲染的细节。&lt;/p&gt;
&lt;p&gt;it(&apos;should say hello&apos;, function() {
&lt;br  /&gt;var scopeMock = {};
&lt;br  /&gt;var cntl = new MyController(scopeMock);&lt;/p&gt;
&lt;p&gt;// Assert that username is pre-filled
&lt;br  /&gt;expect(scopeMock.username).toEqual(&apos;World&apos;);&lt;/p&gt;
&lt;p&gt;// Assert that we read new username and greet
&lt;br  /&gt;scopeMock.username = &apos;angular&apos;;
&lt;br  /&gt;scopeMock.sayHello();
&lt;br  /&gt;expect(scopeMock.greeting).toEqual(&apos;Hello angular!&apos;);
&lt;br  /&gt;});&lt;/p&gt;
&lt;h4&gt;Scope的层次结构&lt;/h4&gt;
&lt;p&gt;每个angularjs程序，都仅有一个root scope，但可以有多个子scope。&lt;/p&gt;
&lt;p&gt;程序可以拥有多个子scopes，是因为一些directives可以创建新的子scopes(参见directive章节)。当新的scopes创建之后，它们就会被当作子scope。这样就可以创建出一个与它们所在的DOM并行的树结构。&lt;/p&gt;
&lt;p&gt;当Angular对&lt;code&gt;{{username}}&lt;/code&gt;进行求值，它首先会去到所在元素关联的scope中查看&lt;code&gt;username&lt;/code&gt;属性。如果找不到，则到上级scope继续，直到到达了root scope。在Javascript中，这种行为被称为原型继承，angularjs中的scope也是原型继承。&lt;/p&gt;
&lt;p&gt;下面的例子演示了程序中的scopes，以及它们属性的原型继承。&lt;/p&gt;
&lt;h4&gt;Source&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;EmployeeController&quot;&amp;gt;
  Manager: {{employee.name}} [ {{department}} ]&amp;lt;br&amp;gt;
  Reports:
    &amp;lt;ul&amp;gt;
      &amp;lt;li ng-repeat=&quot;employee in employee.reports&quot;&amp;gt;
        {{employee.name}} [ {{department}} ]
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;hr&amp;gt;
  {{greeting}}
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;style.css&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;/&lt;em&gt; remove .doc-example-live in jsfiddle &lt;/em&gt;/
&lt;br  /&gt;.doc-example-live .ng-scope {
&lt;br  /&gt;border: 1px dashed red;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function EmployeeController($scope) {
&lt;br  /&gt;$scope.department = &apos;Engineering&apos;;
&lt;br  /&gt;$scope.employee = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: &apos;Joe the Manager&apos;,
reports: [
  {name: &apos;John Smith&apos;},
  {name: &apos;Mary Run&apos;}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;jsfiddle&lt;/p&gt;
&lt;p&gt;注意angularjs会自动在scope所关联到的元素上增加一个&lt;code&gt;ng-scope&lt;/code&gt;的class。在css中，定义其为边框红色高亮。&lt;/p&gt;
&lt;p&gt;子scope是必须的，因为repeater对表达式&lt;code&gt;{{employee.name}}&lt;/code&gt;求值，不同的scope将产生不同的结果。而&lt;code&gt;{{department}}&lt;/code&gt;属性以原型方式继承于root scope，因为只在root scope中定义了&lt;code&gt;department&lt;/code&gt;属性。&lt;/p&gt;
&lt;h4&gt;从DOM中取得Scopes&lt;/h4&gt;
&lt;p&gt;Scope会以&lt;code&gt;$scope&lt;/code&gt;为名添加到DOM的属性中，也可以被取回（常用于调试，通常我们不会在程序中以这种方式来取$scope）。root scope所在的位置是声明&lt;code&gt;ng-app&lt;/code&gt;这个directive的元素，通常是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;，但也可以放在其它元素中，比如只你想让页面中的某一块归angularjs管。&lt;/p&gt;
&lt;p&gt;如何在debugger中检查scope:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在浏览器中右键点击感兴趣的元素，并选择“inspect element”。你可以看到浏览器调试器会将你选中的元素进行高亮。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;debugger允许你在console中，以&lt;code&gt;$0&lt;/code&gt;变量来访问当前选中的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在console中取出关联的scope的命令：&lt;code&gt;angular.element($0).scope()&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;Scopes 事件传播&lt;/h4&gt;
&lt;p&gt;Scope可以用与DOM事件相似的风格来传播事件。事件可以被&lt;code&gt;broadcasted&lt;/code&gt;到下级scope中，或者&lt;code&gt;emitted&lt;/code&gt;到上级scope中。&lt;/p&gt;
&lt;h4&gt;Source&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;EventController&quot;&amp;gt;
  Root scope &amp;lt;tt&amp;gt;MyEvent&amp;lt;/tt&amp;gt; count: {{count}}
  &amp;lt;ul&amp;gt;
    &amp;lt;li ng-repeat=&quot;i in [1]&quot; ng-controller=&quot;EventController&quot;&amp;gt;
      &amp;lt;button ng-click=&quot;$emit(&apos;MyEvent&apos;)&quot;&amp;gt;$emit(&apos;MyEvent&apos;)&amp;lt;/button&amp;gt;
      &amp;lt;button ng-click=&quot;$broadcast(&apos;MyEvent&apos;)&quot;&amp;gt;$broadcast(&apos;MyEvent&apos;)&amp;lt;/button&amp;gt;
      &amp;lt;br&amp;gt;
      Middle scope &amp;lt;tt&amp;gt;MyEvent&amp;lt;/tt&amp;gt; count: {{count}}
      &amp;lt;ul&amp;gt;
        &amp;lt;li ng-repeat=&quot;item in [1, 2]&quot; ng-controller=&quot;EventController&quot;&amp;gt;
          Leaf scope &amp;lt;tt&amp;gt;MyEvent&amp;lt;/tt&amp;gt; count: {{count}}
        &amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function EventController($scope) {
&lt;br  /&gt;$scope.count = 0;
&lt;br  /&gt;$scope.$on(&apos;MyEvent&apos;, function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$scope.count++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;jsfiddle&lt;/p&gt;
&lt;h4&gt;Scope生命周期&lt;/h4&gt;
&lt;p&gt;浏览器接受到一个事件的通常处理流程，是执行其相应的JavaScript回调函数。一旦回调函数执行完成后，浏览器将重新渲染DOM，然后返回，等待下一个事件。&lt;/p&gt;
&lt;p&gt;当浏览器在anguljar的运行上下文之外执行JavaScript代码时，angularjs将收不到model的修改。为了能够正确地处理model的修改，必须使用angularjs提供的&lt;code&gt;$apply&lt;/code&gt;方法进入到angularjs的运行上下文中。强调一遍，只有在angularjs的&lt;code&gt;$apply&lt;/code&gt;方法中进行的model修改，才能正确的通知给angularjs。&lt;/p&gt;
&lt;p&gt;举例来说，如果一个directive来监听DOM事件，比如&lt;code&gt;ng-click&lt;/code&gt;，它必须在&lt;code&gt;$apply&lt;/code&gt;方法中来对表达式求值。&lt;/p&gt;
&lt;p&gt;当对表达式求完值后，&lt;code&gt;$apply&lt;/code&gt;会执行一个&lt;code&gt;$digest&lt;/code&gt;的方法。在&lt;code&gt;$digest&lt;/code&gt;阶段，scope会检查所有&lt;code&gt;$watch&lt;/code&gt;表达式，并与之前的值比较。这个“脏数据”检查，是异步执行的。这表明，对于&lt;code&gt;$scope.username=&quot;&quot;angular&quot;&lt;/code&gt;这样的赋值不会立刻通知&lt;code&gt;$watch&lt;/code&gt;，相反，&lt;code&gt;$watch&lt;/code&gt;通知会延迟到&lt;code&gt;$digest&lt;/code&gt;阶段。这种延迟的做法是可取的，因为它可以把对同一个&lt;code&gt;$watch&lt;/code&gt;的多次通知合并为一个，并且保证了对一个&lt;code&gt;$watch&lt;/code&gt;进行通知时其它的&lt;code&gt;$watch&lt;/code&gt;不会处于运行状态。如果一个&lt;code&gt;$watch&lt;/code&gt;改变了model的值，将会强制增加一个新的&lt;code&gt;$digest&lt;/code&gt;周期。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;创建&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;root scope在程序引导期由&lt;code&gt;$injector&lt;/code&gt;创建。在模板的linking阶段，某些directives将会产生新的子scopes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;注册观察器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在模板linking阶段，directives在scope上注册观察器。这些观察器用来把model的值传播给DOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Model变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能正确地观察到model的变化，我们应该让它们处于&lt;code&gt;scope.$apply()&lt;/code&gt;之中。（Angularjs的api隐式地完成了这件工作，因为我们在controller中进行同步工作，或在&lt;code&gt;$http&lt;/code&gt;或&lt;code&gt;$timeout&lt;/code&gt;中进行异步工作时，不需要再手动调用&lt;code&gt;$apply&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;变化的观察&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;$apply&lt;/code&gt;结束时，angular在root scope上执行一个&lt;code&gt;$digest&lt;/code&gt;周期，之后将传播给所有的子scopes。在&lt;code&gt;$digest&lt;/code&gt;周期，如果model发生了变化，所有的&lt;code&gt;$watch&lt;/code&gt;表达式或函数都将被检查，并且会调用&lt;code&gt;$watch&lt;/code&gt;的监听器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Scope的销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当子scope不再需要时，子scope的创建者有责任通过&lt;code&gt;$scope.$destroy()&lt;/code&gt;API来销毁它们。这次使&lt;code&gt;$digest&lt;/code&gt;停止向该子scope继承传播，也同时允许垃圾回收器来回收子scope占用的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Scopes and Directives&lt;/h4&gt;
&lt;p&gt;在编译阶段，编译器从DOM模板中来匹配directives。这些directives通常会被归到两类中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;观察类（Observing）directives，比如表达式&lt;code&gt;{{expression}}&lt;/code&gt;，使用&lt;code&gt;$watch&lt;/code&gt;来注册监听器。每当表达式变化了，都需要向这类directive通知，好让它们去更新view&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听类（Listener）directives，比如&lt;code&gt;ng-click&lt;/code&gt;，在DOM上注册一个监听器。当ＤＯＭ的监听器触发了，这类directive将执行相关的表达式，并使用&lt;code&gt;$apply&lt;/code&gt;方法来更新view&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当外部事件（例如用户操作，timer或者XHR）到达了，相关联的表达式必须使用&lt;code&gt;$apply&lt;/code&gt;方法把它们应用到scope中，才能让所有的监听器(listener)正确的更新。&lt;/p&gt;
&lt;h4&gt;会创建scope的directives&lt;/h4&gt;
&lt;p&gt;在大多数情况下，directives和scopes互相作用，但不创建新的scope实例。但是，某些directives，比如&lt;code&gt;ng-controller&lt;/code&gt;和&lt;code&gt;ng-repeat&lt;/code&gt;，会创建新的scope并把它们关联到相应的DOM上。&lt;/p&gt;
&lt;p&gt;你可以从任意的DOM元素上使用&lt;code&gt;angular.element(aDomElement).scope()&lt;/code&gt;方法，来取得相应的scope。&lt;/p&gt;
&lt;h4&gt;Controllers and Scopes&lt;/h4&gt;
&lt;p&gt;在以下情况，scopes和controllers互相作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Controller使用scopes把controller中的方法暴露给模板（参考ng-controller)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Controller定义一些可以改变model（scope上的属性）的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Controller可以在model上注册观察器(watches)。当controller执行了操作，相应的观察器也会立刻执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详情参考ng-controller&lt;/p&gt;
&lt;h4&gt;Scope &lt;code&gt;$watch&lt;/code&gt; 的性能考虑&lt;/h4&gt;
&lt;p&gt;在angularjs中，当属性变化时，对scope进行“脏数据”检查是一件很常见的操作，因此该检查必须很高效。注意在检查中，不要进行任何的DOM访问，因为DOM访问要比JavaScript对象访问慢上几个数量级。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>10. 模块</title>
                <link>http://freewind.in/posts/1232-angularjs-10-modules</link>
                <pubDate>Tue, 01 Jan 2013 16:29:55 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1232</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://docs.angularjs.org/guide/module&quot;&gt;http://docs.angularjs.org/guide/module&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;什么是模块(Module)&lt;/h4&gt;
&lt;p&gt;很多程序都有一个入口方法用来引导和初始化程序。Angular的程序没有main方法，而是用“模块”来实现同样的功能。它有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理过程更加透明，更容易理解&lt;em&gt;   在单元测试中，没有必要导入所有的模块，让单元测试更好写&lt;/em&gt;   在scenario测试中，可以使用额外的模块来覆盖原来的设置，以帮助测试&lt;em&gt;   第三方代码可打包为可复用的模块&lt;/em&gt;   模块可以以并行或任意方式导入（因为module可以延迟运行）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基础&lt;/h4&gt;
&lt;p&gt;我很忙，快上一个&quot;Hello world&quot;的模块瞧瞧？&lt;/p&gt;
&lt;p&gt;重点内容需注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Module API*   注意在&lt;code&gt;&amp;lt;html ng-app=&quot;myApp&quot;&amp;gt;&lt;/code&gt;中对&lt;code&gt;myApp&lt;/code&gt;模块的引用，这句话说明指示用什么模块来初始化你的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Source&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app=&quot;simpleApp&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
      {{ &apos;World&apos; | greet }}
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

**script.js**

// declare a module
var simpleAppModule = angular.module(&apos;simpleApp&apos;, []);

// configure the module.
// in this example we will create a greeting filter
simpleAppModule.filter(&apos;greet&apos;, function() {
 return function(name) {
    return &apos;Hello, &apos; + name + &apos;!&apos;;
  };
});

#### 推荐的设置

上面的例子很简单，它不适用于大程序。我们推荐你把自己的程序，分成以下几个模块来组织：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;service模块，用来声明service&lt;em&gt;   directive模块，用来声明directive&lt;/em&gt;   filter模块，用来声明filter*   一个依赖于以上几个模块的程序级的模块，包含初始化代码&lt;/p&gt;
&lt;p&gt;之所以这样是为了方便测试。在测试中，通常忽略初始化代码，因为它们很难测试。分开以后，我们就可以只针对某些功能进行测试，忽略其它。&lt;/p&gt;
&lt;p&gt;以上仅仅是建议，请根据你的实际情况进行更改&lt;/p&gt;
&lt;h4&gt;Source&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app=&quot;xmpl&quot;&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;XmplController&quot;&amp;gt;
  {{ greeting }}!
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;angular.module(&apos;xmpl.service&apos;, []).
&lt;br  /&gt;value(&apos;greeter&apos;, {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;salutation: &apos;Hello&apos;,
localize: function(localization) {
  this.salutation = localization.salutation;
},
greet: function(name) {
  return this.salutation + &apos; &apos; + name + &apos;!&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}).
&lt;br  /&gt;value(&apos;user&apos;, {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;load: function(name) {
  this.name = name;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;angular.module(&apos;xmpl.directive&apos;, []);&lt;/p&gt;
&lt;p&gt;angular.module(&apos;xmpl.filter&apos;, []);&lt;/p&gt;
&lt;p&gt;angular.module(&apos;xmpl&apos;, [&apos;xmpl.service&apos;, &apos;xmpl.directive&apos;, &apos;xmpl.filter&apos;]).
&lt;br  /&gt;run(function(greeter, user) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// This is effectively part of the main method initialization code
greeter.localize({
  salutation: &apos;Bonjour&apos;
});
user.load(&apos;World&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;p&gt;// A Controller for your app
&lt;br  /&gt;var XmplController = function($scope, greeter, user) {
&lt;br  /&gt;$scope.greeting = greeter.greet(user.name);
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;jsfiddle&lt;/p&gt;
&lt;h4&gt;模块的导入和依赖&lt;/h4&gt;
&lt;p&gt;模块就是在程序初始化阶段的配置和执行操作。在最简单的简单下，只考虑以下两种情况：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置块&lt;/strong&gt; - 在provider的注册与配置阶段执行。只有providers和常量可以被注入到配置块里。这么做是为了防止在services配置好之前，就将它们意外初始化了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;执行块&lt;/strong&gt; - 在injector创建好之后执行，用来启动程序。只有实例和常量可以被注入到执行块中。这么做是为了防止在程序运行阶段还在对系统进行配置。
&lt;br  /&gt;angular.module(&apos;myModule&apos;, []).
&lt;br  /&gt;config(function(injectables) { // provider-injector&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// This is an example of config block.
// You can have as many of these as you want.
// You can only inject Providers (not instances)
// into the config blocks.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}).
&lt;br  /&gt;run(function(injectables) { // instance-injector&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// This is an example of a run block.
// You can have as many of these as you want.
// You can only inject instances (not Providers)
// int the run blocks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;h4&gt;配置块&lt;/h4&gt;
&lt;p&gt;对于配置块，angular提供了一些更便于使用的方法，用来代替对上例中&lt;code&gt;config&lt;/code&gt;方法的调用。&lt;/p&gt;
&lt;p&gt;angular.module(&apos;myModule&apos;, []).
&lt;br  /&gt;value(&apos;a&apos;, 123).
&lt;br  /&gt;factory(&apos;a&apos;, function() { return 123; }).
&lt;br  /&gt;directive(&apos;directiveName&apos;, &amp;hellip;).
&lt;br  /&gt;filter(&apos;filterName&apos;, &amp;hellip;);&lt;/p&gt;
&lt;p&gt;// is same as&lt;/p&gt;
&lt;p&gt;angular.module(&apos;myModule&apos;, []).
&lt;br  /&gt;config(function($provide, $compileProvider, $filterProvider) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$provide.value(&apos;a&apos;, 123)
$provide.factory(&apos;a&apos;, function() { return 123; })
$compileProvider.directive(&apos;directiveName&apos;, ...).
$filterProvider.register(&apos;filterName&apos;, ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;配置块按它们声明的顺序来执行。唯一的例外是常量声明，它们会提前到配置块的最前部。&lt;/p&gt;
&lt;h4&gt;执行块&lt;/h4&gt;
&lt;p&gt;执行块是angular中最像main方法的东西。一个执行块就是一些用来启动程序的代码。它在所有的service被配置好，所有的injector创建好之后执行。执行块中经常包含一些难以单元测试的代码，所以它应该被声明在一个孤立的模块中，以便在测试时忽略它。&lt;/p&gt;
&lt;h4&gt;依赖&lt;/h4&gt;
&lt;p&gt;模块可以声明依赖于其它的模块。被依赖的模块会被先导入并执行（包括配置块和执行块）。每个模块只能导入一次，不管它被多少个模块依赖。&lt;/p&gt;
&lt;h4&gt;异步导入&lt;/h4&gt;
&lt;p&gt;模块仅仅是用来管理&lt;code&gt;$injector&lt;/code&gt;配置的一种方式，与“把脚本导入到VM“中无关。当前已经有一些库专门用来处理脚本的导入，它们可以跟angular一起使用。由于模块在导入阶段什么也不做，所以它们可以以任意顺序导入到VM中，所以可以利用一些库来并行导入，提高页面响应速度。&lt;/p&gt;
&lt;h4&gt;单元测试&lt;/h4&gt;
&lt;p&gt;在最简单的情况下，单元测试是一种在测试中初始化程序的功能子集并触发它们的方式。认识到“对于一个injector每个模块只会被导入一次”很重要。在典型的情况下，一个程序只有一个injector。但是在测试中，每个测试都有它自己的injector，这表明在每个VM上，模块可能被导入多次。以适当的结构组织好的模块可以帮助我们进行测试。&lt;/p&gt;
&lt;p&gt;在所有的示例中，我们都假设有以下定义：&lt;/p&gt;
&lt;p&gt;angular.module(&apos;greetMod&apos;, []).&lt;/p&gt;
&lt;p&gt;factory(&apos;alert&apos;, function($window) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return function(text) {
  $window.alert(text);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}).&lt;/p&gt;
&lt;p&gt;value(&apos;salutation&apos;, &apos;Hello&apos;).&lt;/p&gt;
&lt;p&gt;factory(&apos;greet&apos;, function(alert, salutation) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return function(name) {
  alert(salutation + &apos; &apos; + name + &apos;!&apos;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;写些测试：&lt;/p&gt;
&lt;p&gt;describe(&apos;myApp&apos;, function() {
&lt;br  /&gt;// load the application relevant modules then load a special
&lt;br  /&gt;// test module which overrides the $window with mock version,
&lt;br  /&gt;// so that calling window.alert() will not block the test
&lt;br  /&gt;// runner with a real alert box. This is an example of overriding
&lt;br  /&gt;// configuration information in tests.
&lt;br  /&gt;beforeEach(module(&apos;greetMod&apos;, function($provide) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$provide.value(&apos;$window&apos;, {
  alert: jasmine.createSpy(&apos;alert&apos;)
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}));&lt;/p&gt;
&lt;p&gt;// The inject() will create the injector and inject the greet and
&lt;br  /&gt;// $window into the tests. The test need not concern itself with
&lt;br  /&gt;// wiring of the application, only with testing it.
&lt;br  /&gt;it(&apos;should alert on $window&apos;, inject(function(greet, $window) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;greet(&apos;World&apos;);
expect($window.alert).toHaveBeenCalledWith(&apos;Hello World!&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}));&lt;/p&gt;
&lt;p&gt;// this is another way of overriding configuration in the
&lt;br  /&gt;// tests using an inline module and inject methods.
&lt;br  /&gt;it(&apos;should alert using the alert service&apos;, function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var alertSpy = jasmine.createSpy(&apos;alert&apos;);
module(function($provide) {
  $provide.value(&apos;alert&apos;, alertSpy);
});
inject(function(greet) {
  greet(&apos;World&apos;);
  expect(alertSpy).toHaveBeenCalledWith(&apos;Hello World!&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>09. 介绍</title>
                <link>http://freewind.in/posts/1231-angularjs-09-introduction</link>
                <pubDate>Tue, 01 Jan 2013 16:29:24 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1231</guid>
                <description><![CDATA[&lt;p&gt;Anguar是一种纯客户端技术，完全使用JavaScript实现。它使用经过长期实践的web技术(HTML,CSS和JavaScript)让web程序的开发比以前更快更简单。&lt;/p&gt;
&lt;p&gt;Angular简化web开发的一个重要方式，就是增加了开发者每天都要面对的web底层开发活动的抽象级别。Angular自动处理以下任务，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM维护&lt;em&gt;   设置Listeners和Notifiers&lt;/em&gt;   输入验证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于Angular处理了这些任务中的大部分工作，所以开发者能把精力集中在业务逻辑上，而不是繁琐、易错的底层编码上。&lt;/p&gt;
&lt;p&gt;同时，Angular也为客户端开发带来了优秀的技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据、业务逻辑、表现层组件的分离&lt;em&gt;   数据与表现层组件之间的绑定&lt;/em&gt;   Services (常用的web操作，实现为可替换的对象)&lt;em&gt;   依赖注入 (用来把Services拼在一起)&lt;/em&gt;   可扩展的HTML编译器 (完全使用JavaScript写成)*   易测试性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些技术在客户端方面已经缺失太久了。&lt;/p&gt;
&lt;h4&gt;单页/多页面程序&lt;/h4&gt;
&lt;p&gt;你可以使用angular来开发单页程序或多页面程序，但angular主要是设计来开发单页程序的。Anguar在单页程序中，也支持浏览器历史、前进和后退按钮，以及书签。&lt;/p&gt;
&lt;p&gt;你不会希望在每次页面发生变化的时候，都重新导入angular，就像开发多页面程序那样。但有时虽然你不得不这么做，但仍然是有价值的，比如你想在一个已经存在的多页面程序中使用Angular的部分功能（比如数据绑定），而不想把它转换为一个单页面的angular程序。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>08. IE浏览器的兼容性</title>
                <link>http://freewind.in/posts/1230-angularjs-08-ie-browser-compatibility</link>
                <pubDate>Tue, 01 Jan 2013 16:28:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1230</guid>
                <description><![CDATA[&lt;h3&gt;概览&lt;/h3&gt;
&lt;p&gt;本页主要描述IE在处理自定义的HTML标签和属性上的一些特别做法。如果你打算让自己的程序支持IE8或之前的版本，请阅读本文。&lt;/p&gt;
&lt;h3&gt;长话短说&lt;/h3&gt;
&lt;p&gt;你需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要使用如&lt;code&gt;&amp;lt;ng:view&amp;gt;&lt;/code&gt;的自定义标签，改用&lt;code&gt;&amp;lt;div ng-view&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你一定要使用自定义标签，你必须这么做：&lt;/p&gt;
&lt;p&gt;&lt;html xmlns:ng=&quot;http: //angularjs.org&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;head&amp;gt;
  &amp;lt;!--[if lte IE 8]&amp;gt;
    &amp;lt;script&amp;gt;
      document.createElement(&apos;ng-include&apos;);
      document.createElement(&apos;ng-pluralize&apos;);
      document.createElement(&apos;ng-view&apos;);

      // Optionally these for CSS
      document.createElement(&apos;ng:include&apos;);
      document.createElement(&apos;ng:pluralize&apos;);
      document.createElement(&apos;ng:view&apos;);
    &amp;lt;/script&amp;gt;
  &amp;lt;![endif]--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  ...
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;重点在于：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;xmlns:ng&lt;/code&gt; - 命名空间 - 你必须为你打算使用的自定义标签的前缀，定义一个命名空间2.  &lt;code&gt;document.createElement(yourTagName)&lt;/code&gt; - 创建自定义标签名 - 由于这只是某些旧版本的IE存在的问题，所以你必须使用条件语句&lt;code&gt;&amp;lt;!--[if lte IE 8]&amp;gt;&lt;/code&gt; 这样的。对于每一个你使用的自定义标签，你都需要这样声明一下。&lt;/p&gt;
&lt;h3&gt;长话长说&lt;/h3&gt;
&lt;p&gt;IE对于非标签的HTML标签不能正确地处理。具体情况分为两类，需要分别解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果标签名以&lt;code&gt;my:&lt;/code&gt;开头，则它被看作为一个XML命名空间，需要用&lt;code&gt;&amp;lt;html xmlns:my=&quot;ignored&quot;&amp;gt;&lt;/code&gt;声明&lt;em&gt;   如果标签中没有&lt;code&gt;:&lt;/code&gt;但它不是标准的HTML标签，是需要使用&lt;code&gt;document.createElement(&apos;my-tag&apos;)&lt;/code&gt;预定义一下&lt;/em&gt;   如果你想在自定义的标签上使用CSS选择器，则必须使用&lt;code&gt;document.createElement(&apos;my-tag&apos;)&lt;/code&gt;，不管有没有定义过XML命名空间&lt;/p&gt;
&lt;h4&gt;好消息&lt;/h4&gt;
&lt;p&gt;好消息是这些问题仅出现在标签名上，属性就没问题。所以对于&lt;code&gt;&amp;lt;div my-tag your:tag&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;则完全不需要特别处理。&lt;/p&gt;
&lt;h4&gt;如果我不处理会怎么样？&lt;/h4&gt;
&lt;p&gt;假设你的HTML中有自定义的标签&lt;code&gt;mytag&lt;/code&gt;(或者&lt;code&gt;my:tag&lt;/code&gt;或者&lt;code&gt;my-tag&lt;/code&gt;)：&lt;/p&gt;
&lt;p&gt;&lt;html&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;mytag&amp;gt;some text&amp;lt;/mytag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;它将被会解析为下面的DOM:&lt;/p&gt;
&lt;h1&gt;document&lt;/h1&gt;
&lt;p&gt;+- HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; +- BODY
    +- mytag
       +- #text: some text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;预想的行为是&lt;code&gt;BODY&lt;/code&gt;下有&lt;code&gt;mytag&lt;/code&gt;，它有文本&lt;code&gt;some test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但在IE是不是这样的（如果没有特别处理的话）：&lt;/p&gt;
&lt;h1&gt;document&lt;/h1&gt;
&lt;p&gt;+- HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; +- BODY
    +- mytag
    +- #text: some text
    +- /mytag
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;BODY&lt;/code&gt;元素下有三个子元素了：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个自关闭的&lt;code&gt;mytag&lt;/code&gt;。它跟&lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;的处理类似，最后的&lt;code&gt;/&lt;/code&gt;是可选的。由于&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;不允许有子元素，所以&lt;code&gt;&amp;lt;br&amp;gt;some text&amp;lt;/br&amp;gt;&lt;/code&gt;将被浏览器处理为三个相邻的元素，而不是&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;下有一个文本元素2.  一个文本节点，跟&lt;code&gt;mytag&lt;/code&gt;是兄弟结点3.  一个无法处理的自关闭结点&lt;code&gt;/mytag&lt;/code&gt;。由于标签名中不允许有&lt;code&gt;/&lt;/code&gt;，所以它是无法处理的，它不会是DOM中的一部分。&lt;/p&gt;
&lt;h4&gt;自定义标签的CSS&lt;/h4&gt;
&lt;p&gt;不管有没有声明过XML命名空间，只要想对自定义标签使用CSS选择器选择，都需要使用&lt;code&gt;document.createElement(&apos;my-tag&apos;)&lt;/code&gt;进行声明。&lt;/p&gt;
&lt;p&gt;&lt;html xmlns:ng=&quot;needed for ng: namespace&quot;&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--[if lte IE 8]&amp;gt;
  &amp;lt;script&amp;gt;
    // needed to make ng-include parse properly
    document.createElement(&apos;ng-include&apos;);

    // needed to enable CSS reference
    document.createElement(&apos;ng:view&apos;);
  &amp;lt;/script&amp;gt;
&amp;lt;![endif]--&amp;gt;
&amp;lt;style&amp;gt;
  ng\\:view {
    display: block;
    border: 1px solid red;
  }

  ng-include {
    display: block;
    border: 1px solid blue;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ng:view&amp;gt;&amp;lt;/ng:view&amp;gt;
&amp;lt;ng-include&amp;gt;&amp;lt;/ng-include&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>07. 国际化与本地化</title>
                <link>http://freewind.in/posts/1229-angularjs-07-i18n-i10n</link>
                <pubDate>Tue, 01 Jan 2013 16:28:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1229</guid>
                <description><![CDATA[&lt;h3&gt;在AnguarJs中的国际化与本地化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是i18n和l10n&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国际化(Internationalization)，缩写为i18n，是指在开发可适应多种不同的语言和文化的产品的过程。本地化（Localization），缩写为l10n，是指将程序和文字变为某种特定语言和文化的过程。对于程序员来说，国际化表示在程序中把所有与地区相关的文字和格式都抽象到程序之外。而本地化是指为刚才的抽象提供不同地区的翻译内容和相关的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anguar目前对国际化和本地化的支持如何&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前，Anguar通过&lt;code&gt;date&lt;/code&gt;,&lt;code&gt;number&lt;/code&gt;和&lt;code&gt;currency&lt;/code&gt;这几个filter来支持i18n/l10n.&lt;/p&gt;
&lt;p&gt;另外，Anguar还通过&lt;code&gt;ngPluralize&lt;/code&gt;这个directive来支持区域多元化。&lt;/p&gt;
&lt;p&gt;在Angular中，所有支持区域多元化的组件，都依赖于&lt;code&gt;$locale&lt;/code&gt;这个service管理的与区域相关的规则。&lt;/p&gt;
&lt;p&gt;如果你想直接看例子，我们准备了一些页面用来演示Angular中filter的各种不同的区域规则。你可以在&lt;a href=&quot;https://github.com/angular/angular.js/tree/master/i18n/e2e&quot;&gt;Github&lt;/a&gt;，或Angular开发包下的&lt;code&gt;i18n/e2e&lt;/code&gt;目录中找到它们。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是区域代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区域是依据地理、政治或文化的而形成的地区。最常用的区域代码由两部分组成：语言代码和国家代码。例如，en-US，en-AU，zh_CN都是此例。其中国家代码是可选的，所以en，zh，sk也是合法的区域代码。参见&lt;a href=&quot;http://userguide.icu-project.org/locale&quot;&gt;ICU&lt;/a&gt;网站了解更详细的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Angular支持的locales&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Angular将数字与日期根据不同的区域拆分为不同的文件，一个区域一个。你可以在&lt;a href=&quot;https://github.com/angular/angular.js/tree/master/i18n/locale&quot;&gt;这里&lt;/a&gt;找到Angular当前支持的区域列表。&lt;/p&gt;
&lt;h3&gt;Angular中的区域规则&lt;/h3&gt;
&lt;p&gt;Angular中提供了两种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 预绑定的规则集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以把想支持的区域相关的文件添加到&lt;code&gt;angular.js&lt;/code&gt;或&lt;code&gt;angular.min.js&lt;/code&gt;文件的最后，以绑定它们。&lt;/p&gt;
&lt;p&gt;比如在*nix系统中，可以使用以下命令，把德国的相关文件添加到angular.js后面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat angular.js i18n/angular-locale_de-ge.js &amp;gt; angular_de-ge.js

如果在程序中直接引用`angular_de-ge.js`而不是原始的angular.js文件，则Angular会自动为德国区域配置好本地化规则。

**在index.html页面中包含locale js文件**

你也可以在index.html页面中包含与locale相关的js文件。比如，当客户端需要德国的区域时，你提供一个像这样的`index_de-ge.html`：

&amp;lt;html ng-app&amp;gt;
 &amp;lt;head&amp;gt;
….
   &amp;lt;script src=&quot;angular.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
   &amp;lt;script src=&quot;i18n/angular-locale_de-ge.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
….
 &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;两种做法的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两种做法都需要你为不同的区域准备不同的&lt;code&gt;index.html&lt;/code&gt;或js文件。你还需要配置你的服务器为不同的区域返回正确的文件。&lt;/p&gt;
&lt;p&gt;但是第二种做法（在index.html页面中包含locale js文件）会比第一种慢，因为它需要另外导入一些文件。&lt;/p&gt;
&lt;h3&gt;“陷阱”&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;货币符号的陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Angular的&lt;code&gt;currency&lt;/code&gt;filter允许你从&lt;code&gt;locale&lt;/code&gt; service中使用默认的货币符号，或者你为该filter提供一些自定义的货币符号。如果你的程序仅仅用于一个区域，则可以只使用默认的货币符号。否则的话，你应该提供你自定义的货币符号来保证实际显示的值是正确的。&lt;/p&gt;
&lt;p&gt;比如，你想显示1000美元：&lt;code&gt;{{ 1000 | currency }}&lt;/code&gt;。如果程序在&lt;code&gt;en-US&lt;/code&gt;区域被访问，则会显示&lt;code&gt;$1000.00&lt;/code&gt;。但如果在一个不同的区域（比如日本）来访问的话（它的locale为ja），则会显示为&lt;code&gt;¥1000.00&lt;/code&gt;，这显然是不正确的。&lt;/p&gt;
&lt;p&gt;这种情况下，你需要使用&lt;code&gt;currency&lt;/code&gt; filter来覆盖默认的货币符号。你可以传入一个参数，比如：&lt;code&gt;{{ 1000 | currency:&quot;USD$&quot;}}&lt;/code&gt;。这样不论在哪个区域访问，都会显示一样的值&lt;code&gt;$1000.00&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;翻译长度的陷阱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意&quot;字符串/时间日期&quot;的格式，在不同的区域长度可能相差很大。比如，&lt;code&gt;June 3, 1977&lt;/code&gt;，翻译成西班牙语，会变成&lt;code&gt;3 de junio de 1977&lt;/code&gt;。可能还有更夸张的情况。所以，为你的程序提供国际化的时候，要让你的CSS样式尽量满足多种情况，多测试，不要让UI组件的布局被打乱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意Anguar的&lt;code&gt;datetime&lt;/code&gt; filter使用浏览器的time zone的设置。所以同样的程序，在不同的时区的电脑上，可能显示的时间不同。不论是JavaScript或Angular，目前都不支持由开发者指定一个时区。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>06. 表单</title>
                <link>http://freewind.in/posts/1228-angularjs-06-form</link>
                <pubDate>Tue, 01 Jan 2013 16:27:43 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1228</guid>
                <description><![CDATA[&lt;p&gt;表单中有很多控件，如&lt;code&gt;input&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt;等，是用来让用户输入数据的。&lt;/p&gt;
&lt;p&gt;如果表单支持验证，用户在输入了不合法的数据时，能得到实时提示（比如哪儿错了，如何修正等），会是一种很好的用户体验。需要明白的是，不论“客户端验证”对于提升用户的使用体验如何重要，也不要忘了在服务器端再次验证。因为用户可以绕过客户端验证直接向服务器端发送非法数据。&lt;/p&gt;
&lt;h3&gt;简单表单&lt;/h3&gt;
&lt;p&gt;理解双向绑定最关键的directive是&lt;code&gt;ng-model&lt;/code&gt;这个directive。它通过model数据同步到view，以及将view变化同步到model的方式，提供了双向绑定。另外，它还通过&lt;code&gt;NgModelController&lt;/code&gt;提供了用于改变其它directive的行为的API&lt;/p&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;indexhtml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;Controller&quot;&amp;gt;
      &amp;lt;form novalidate class=&quot;simple-form&quot;&amp;gt;
        Name: &amp;lt;input type=&quot;text&quot; ng-model=&quot;user.name&quot; /&amp;gt;&amp;lt;br /&amp;gt;
        E-mail: &amp;lt;input type=&quot;email&quot; ng-model=&quot;user.email&quot; /&amp;gt;&amp;lt;br /&amp;gt;
        Gender: &amp;lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;male&quot; /&amp;gt;male
        &amp;lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;female&quot; /&amp;gt;female&amp;lt;br /&amp;gt;
        &amp;lt;button ng-click=&quot;reset()&quot;&amp;gt;RESET&amp;lt;/button&amp;gt;
        &amp;lt;button ng-click=&quot;update(user)&quot;&amp;gt;SAVE&amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
      &amp;lt;pre&amp;gt;form = {{user | json}}```
      &amp;lt;pre&amp;gt;master = {{master | json}}```
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

**script.js**

function Controller($scope) {
  $scope.master= {};

  $scope.update = function(user) {
    $scope.master= angular.copy(user);
  };

  $scope.reset = function() {
    $scope.user = angular.copy($scope.master);
  };

  $scope.reset();
}

demo

注意：`novalidate`用来关闭浏览器自己的form验证

### 使用CSS classes

为了让表单跟控件一样可以被修饰，`ngModel`提供了以下CSS classes:
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ng-valid&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ng-invalid&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ng-pristine&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ng-dirty&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面这个例子，使用CSS来显示表单中每一个控件的合法性。其中&lt;code&gt;user.name&lt;/code&gt;和&lt;code&gt;user.email&lt;/code&gt;是必填的，但仅当它们被修改过才会显示红色背景。这样保证了用户仅仅在与某个控件交互过之后，才会在输入不合法的时候显示错误信息。&lt;/p&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;Controller&quot;&amp;gt;
  &amp;lt;form novalidate class=&quot;css-form&quot;&amp;gt;
    Name:
      &amp;lt;input type=&quot;text&quot; ng-model=&quot;user.name&quot; required /&amp;gt;&amp;lt;br /&amp;gt;
    E-mail: &amp;lt;input type=&quot;email&quot; ng-model=&quot;user.email&quot; required /&amp;gt;&amp;lt;br /&amp;gt;
    Gender: &amp;lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;male&quot; /&amp;gt;male
    &amp;lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;female&quot; /&amp;gt;female&amp;lt;br /&amp;gt;
    &amp;lt;button ng-click=&quot;reset()&quot;&amp;gt;RESET&amp;lt;/button&amp;gt;
    &amp;lt;button ng-click=&quot;update(user)&quot;&amp;gt;SAVE&amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style type=&quot;text/css&quot;&amp;gt;
  .css-form input.ng-invalid.ng-dirty {
    background-color: #FA787E;
  }

  .css-form input.ng-valid.ng-dirty {
    background-color: #78FA89;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;scripts.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function Controller($scope) {
&lt;br  /&gt;$scope.master= {};&lt;/p&gt;
&lt;p&gt;$scope.update = function(user) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$scope.master= angular.copy(user);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;$scope.reset = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$scope.user = angular.copy($scope.master);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;$scope.reset();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;demo&lt;/p&gt;
&lt;h3&gt;绑定到表单与控件的状态&lt;/h3&gt;
&lt;p&gt;每一个表单都是&lt;code&gt;FormController&lt;/code&gt;的一个实例。如果你给表单增加了一个&lt;code&gt;name&lt;/code&gt;属性，则它自动会加到$scope中，方便引用。同样表单中的控件也可以使用&lt;code&gt;name&lt;/code&gt;添加到$scope中（控件对应的controller是&lt;code&gt;NgModelController&lt;/code&gt;）。这样我们在view中如果想引用某些表单或控制，检查它们的状态，就很方便了。&lt;/p&gt;
&lt;p&gt;我们利用这些特性来给前面的例子增加以下功能：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RESET按钮只有当表单发生了变化时，才可点2.  SAVE按钮只有当表单内容发生了&lt;strong&gt;合法的&lt;/strong&gt;变化时，才可点3.  为&lt;code&gt;user.email&lt;/code&gt;和&lt;code&gt;user.agree&lt;/code&gt;添加自定义的错误信息&lt;/p&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;Controller&quot;&amp;gt;
  &amp;lt;form name=&quot;form&quot; class=&quot;css-form&quot; novalidate&amp;gt;
    Name:
      &amp;lt;input type=&quot;text&quot; ng-model=&quot;user.name&quot; name=&quot;uName&quot; required /&amp;gt;&amp;lt;br /&amp;gt;
    E-mail:
      &amp;lt;input type=&quot;email&quot; ng-model=&quot;user.email&quot; name=&quot;uEmail&quot; required/&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;div ng-show=&quot;form.uEmail.$dirty &amp;amp;&amp;amp; form.uEmail.$invalid&quot;&amp;gt;Invalid:
      &amp;lt;span ng-show=&quot;form.uEmail.$error.required&quot;&amp;gt;Tell us your email.&amp;lt;/span&amp;gt;
      &amp;lt;span ng-show=&quot;form.uEmail.$error.email&quot;&amp;gt;This is not a valid email.&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

    Gender: &amp;lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;male&quot; /&amp;gt;male
    &amp;lt;input type=&quot;radio&quot; ng-model=&quot;user.gender&quot; value=&quot;female&quot; /&amp;gt;female&amp;lt;br /&amp;gt;

    &amp;lt;input type=&quot;checkbox&quot; ng-model=&quot;user.agree&quot; name=&quot;userAgree&quot; required /&amp;gt;
    I agree: &amp;lt;input ng-show=&quot;user.agree&quot; type=&quot;text&quot; ng-model=&quot;user.agreeSign&quot;
              required /&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;div ng-show=&quot;!user.agree || !user.agreeSign&quot;&amp;gt;Please agree and sign.&amp;lt;/div&amp;gt;

    &amp;lt;button ng-click=&quot;reset()&quot; ng-disabled=&quot;isUnchanged(user)&quot;&amp;gt;RESET&amp;lt;/button&amp;gt;
    &amp;lt;button ng-click=&quot;update(user)&quot;
            ng-disabled=&quot;form.$invalid || isUnchanged(user)&quot;&amp;gt;SAVE&amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function Controller($scope) {
&lt;br  /&gt;$scope.master= {};&lt;/p&gt;
&lt;p&gt;$scope.update = function(user) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$scope.master= angular.copy(user);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;$scope.reset = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$scope.user = angular.copy($scope.master);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;$scope.isUnchanged = function(user) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return angular.equals(user, $scope.master);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;$scope.reset();
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;jsfiddle demo&lt;/p&gt;
&lt;h3&gt;自定义验证&lt;/h3&gt;
&lt;p&gt;Angular已经为大多数常用的html5控件：&lt;code&gt;text&lt;/code&gt;,&lt;code&gt;number&lt;/code&gt;,&lt;code&gt;url&lt;/code&gt;,&lt;code&gt;email&lt;/code&gt;,&lt;code&gt;radio&lt;/code&gt;,&lt;code&gt;checkbox&lt;/code&gt;提供了基本的验证功能，比如这些directives(&lt;code&gt;required&lt;/code&gt;,&lt;code&gt;pattern&lt;/code&gt;,&lt;code&gt;minlength&lt;/code&gt;,&lt;code&gt;maxlength&lt;/code&gt;,&lt;code&gt;min&lt;/code&gt;,&lt;code&gt;max&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;你可以通过定义一些给&lt;code&gt;ngModel&lt;/code&gt;(对应于&lt;code&gt;NgModelController&lt;/code&gt;)添加自定义验证函数的directive来定义自己的验证器。&lt;/p&gt;
&lt;p&gt;为了取得相应的controller，directive需要指定一些依赖。在下面详述。&lt;/p&gt;
&lt;p&gt;验证可以发生在两个地方：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Model向View更新 - &lt;code&gt;NgModelController#$formatters&lt;/code&gt;中的各函数是串联的，只要model发生了变化，每个formatter函数都有机会来格式化数据，并通过&lt;code&gt;NgModelController#$setValidity&lt;/code&gt;来改变表单控件的验证状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;View向model更新 - 同样，当用户操作控件后，其值发生了变化，控件后调用&lt;code&gt;NgModelController#$setViewValue&lt;/code&gt;。它将继续调用&lt;code&gt;NgModelController#$parsers&lt;/code&gt;中的每个函数，它们每个函数都有机会转换数据，并通过&lt;code&gt;NgModelController#$setValidity()&lt;/code&gt;来改变表单控件的验证状态。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们将创建两个指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第一个是&lt;code&gt;integer&lt;/code&gt;，它用来验证输入是否是一个合法的integer. 例如&lt;code&gt;1.23&lt;/code&gt;不合法。注意，我们会把验证函数放在数组的最前端，而不是最后面。这是因为我们想让这个验证器首先检查输入的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二个是&lt;code&gt;smart-float&lt;/code&gt;. 它可以把&lt;code&gt;1.2&lt;/code&gt;和&lt;code&gt;1,2&lt;/code&gt;（注意用的是逗号）都转换为一个合法的数字&lt;code&gt;1.2&lt;/code&gt;。注意，我们不能使用html5中的&lt;code&gt;number&lt;/code&gt;控件，因为它不会允许我们输入&lt;code&gt;1,2&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app=&quot;form-example1&quot;&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;Controller&quot;&amp;gt;
  &amp;lt;form name=&quot;form&quot; class=&quot;css-form&quot; novalidate&amp;gt;
    &amp;lt;div&amp;gt;
      Size (integer 0 - 10):
      &amp;lt;input type=&quot;number&quot; ng-model=&quot;size&quot; name=&quot;size&quot;
             min=&quot;0&quot; max=&quot;10&quot; integer /&amp;gt;{{size}}&amp;lt;br /&amp;gt;
      &amp;lt;span ng-show=&quot;form.size.$error.integer&quot;&amp;gt;This is not valid integer!&amp;lt;/span&amp;gt;
      &amp;lt;span ng-show=&quot;form.size.$error.min || form.size.$error.max&quot;&amp;gt;
        The value must be in range 0 to 10!&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div&amp;gt;
      Length (float):
      &amp;lt;input type=&quot;text&quot; ng-model=&quot;length&quot; name=&quot;length&quot; smart-float /&amp;gt;
      {{length}}&amp;lt;br /&amp;gt;
      &amp;lt;span ng-show=&quot;form.length.$error.float&quot;&amp;gt;
        This is not a valid float number!&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;scripts.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;var app = angular.module(&apos;form-example1&apos;, []);&lt;/p&gt;
&lt;p&gt;var INTEGER_REGEXP = /^-?\d*$/;
&lt;br  /&gt;app.directive(&apos;integer&apos;, function() {
&lt;br  /&gt;return {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require: &apos;ngModel&apos;,
link: function(scope, elm, attrs, ctrl) {
  ctrl.$parsers.unshift(function(viewValue) {
    if (INTEGER_REGEXP.test(viewValue)) {
      // it is valid
      ctrl.$setValidity(&apos;integer&apos;, true);
      return viewValue;
    } else {
      // it is invalid, return undefined (no model update)
      ctrl.$setValidity(&apos;integer&apos;, false);
      return undefined;
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;var FLOAT_REGEXP = /^-?\d+((.|\,)\d+)?$/;
&lt;br  /&gt;app.directive(&apos;smartFloat&apos;, function() {
&lt;br  /&gt;return {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require: &apos;ngModel&apos;,
link: function(scope, elm, attrs, ctrl) {
  ctrl.$parsers.unshift(function(viewValue) {
    if (FLOAT_REGEXP.test(viewValue)) {
      ctrl.$setValidity(&apos;float&apos;, true);
      return parseFloat(viewValue.replace(&apos;,&apos;, &apos;.&apos;));
    } else {
      ctrl.$setValidity(&apos;float&apos;, false);
      return undefined;
    }
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;jsfiddle上的demo&lt;/p&gt;
&lt;h3&gt;使用(&lt;code&gt;ngModel&lt;/code&gt;)来自定义表单控件&lt;/h3&gt;
&lt;p&gt;Angular实现了所有的基本控件，比如：&lt;code&gt;input&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt;，大多数情况下够用了。但如果你需要更灵活的功能，你可以使用directive来创建属于自己的表单控件。&lt;/p&gt;
&lt;p&gt;为了让你自定义的控件能与&lt;code&gt;ngModel&lt;/code&gt;一起工作，并且还能“双向绑定”，你需要：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现&lt;code&gt;render&lt;/code&gt;方法。当它添加到&lt;code&gt;NgModelController#$formatters&lt;/code&gt;后，它将会用来渲染数据。*   调用&lt;code&gt;$setViewValue&lt;/code&gt;方法。每当用户与控件交互后，model都需要被更新，使用这个方法。通常这放在一个DOM事件的listener中完成。&lt;/p&gt;
&lt;p&gt;参见&lt;code&gt;$compileProvider&lt;/code&gt;了解更深入的内容。&lt;/p&gt;
&lt;p&gt;面的例子展示了如何给一个&lt;code&gt;contentEditable&lt;/code&gt;元素添加“双向绑定”&lt;/p&gt;
&lt;h3&gt;源代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app=&quot;form-example2&quot;&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div contentEditable=&quot;true&quot; ng-model=&quot;content&quot; title=&quot;Click to edit&quot;&amp;gt;Some&amp;lt;/div&amp;gt;
&amp;lt;pre&amp;gt;model = {{content}}```

&amp;lt;style type=&quot;text/css&quot;&amp;gt;
  div[contentEditable] {
    cursor: pointer;
    background-color: #D0D0D0;
  }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;angular.module(&apos;form-example2&apos;, []).directive(&apos;contenteditable&apos;, function() {
&lt;br  /&gt;return {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;require: &apos;ngModel&apos;,
link: function(scope, elm, attrs, ctrl) {
  // view -&amp;gt; model
  elm.bind(&apos;blur&apos;, function() {
    scope.$apply(function() {
      ctrl.$setViewValue(elm.html());
    });
  });

  // model -&amp;gt; view
  ctrl.render = function(value) {
    elm.html(value);
  };

  // load init value from DOM
  ctrl.$setViewValue(elm.html());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>05. 表达式</title>
                <link>http://freewind.in/posts/1227-angularjs-05-expressions</link>
                <pubDate>Tue, 01 Jan 2013 16:27:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1227</guid>
                <description><![CDATA[&lt;p&gt;表达式（Expressions）是与javascript相似的代码片断。虽然相似，但并不完全与javascript相同，也不是由javascript引擎直接执行的。所以某些javascript语法并不能直接在angularjs的表达式中使用。&lt;/p&gt;
&lt;p&gt;表达式通常放在binding中，比如&lt;code&gt;{{expression}}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;表达式由&lt;code&gt;$parse&lt;/code&gt;服务处理。&lt;/p&gt;
&lt;p&gt;下面是几种合法的angularjs表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1+2&lt;em&gt;   3&lt;/em&gt;10 | currency*   user.name&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Angular Expressions vs. JS Expressions&lt;/h4&gt;
&lt;p&gt;把angularjs的表达式当成javascript表达式是一件很诱人的事情，可惜这不完全正确，因为它不是用Javascript的&lt;code&gt;eval()&lt;/code&gt;来执行的。&lt;/p&gt;
&lt;p&gt;它们之间有以下几点区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;属性求值 Attribute Evaluation&lt;/strong&gt;: 所有的属性是从scope中计算，而不像Javascript那样，从全局的&lt;code&gt;window&lt;/code&gt;对象中计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;空值友好 Forgiving&lt;/strong&gt;: 如果表达式中遇到了&lt;code&gt;undefined&lt;/code&gt;或&lt;code&gt;null&lt;/code&gt;，会跳过它们处理其它的，不会抛出&lt;code&gt;NullPointerExceptions&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;没有控制语句 No Control Flow Statements&lt;/strong&gt;: 没有条件判断语句、循环、抛异常等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;过滤器 Filters&lt;/strong&gt;: 可以把表达式的计算结果传给filters继续处理。比如，你可以把一个date对象交给filter处理成易读的本地格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，如果你想运行Javascript代码，你必须在controller中新建一个方法，然后在angularjs表达式中调用它。如果你想在Javascript中执行angularjs表达式，可使用由angularjs提供的&lt;code&gt;$eval()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h4&gt;例子&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    1+2={{1+2}}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;End to end test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;it(&apos;should calculate expression in binding&apos;, function() {
&lt;br  /&gt;expect(binding(&apos;1+2&apos;)).toEqual(&apos;3&apos;);
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;jsfiddle link?&lt;/p&gt;
&lt;p&gt;你可以在下面的示例中尝试不同的表达式（需要到相应的jsfiddle页面上）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;Cntl2&quot; class=&quot;expressions&quot;&amp;gt;
      Expression:
      &amp;lt;input type=&apos;text&apos; ng-model=&quot;expr&quot; size=&quot;80&quot;/&amp;gt;
      &amp;lt;button ng-click=&quot;addExp(expr)&quot;&amp;gt;Evaluate&amp;lt;/button&amp;gt;
      &amp;lt;ul&amp;gt;
       &amp;lt;li ng-repeat=&quot;expr in exprs&quot;&amp;gt;
         [ &amp;lt;a href=&quot;&quot; ng-click=&quot;removeExp($index)&quot;&amp;gt;X&amp;lt;/a&amp;gt; ]
         &amp;lt;tt&amp;gt;{{expr}}&amp;lt;/tt&amp;gt; =&amp;gt; &amp;lt;span ng-bind=&quot;$parent.$eval(expr)&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;/li&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function Cntl2($scope) {
  var exprs = $scope.exprs = [];
  $scope.expr = &apos;3*10|currency&apos;;
  $scope.addExp = function(expr) {
     exprs.push(expr);
  };

  $scope.removeExp = function(index) {
    exprs.splice(index, 1);
  };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;End to end test&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;it(&apos;should allow user expression testing&apos;, function() {
   element(&apos;.expressions :button&apos;).click();
   var li = using(&apos;.expressions ul&apos;).repeater(&apos;li&apos;);
   expect(li.count()).toBe(1);
   expect(li.row(0)).toEqual([&quot;3*10|currency&quot;, &quot;$30.00&quot;]);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jsfiddle link&lt;/p&gt;
&lt;h4&gt;属性求值&lt;/h4&gt;
&lt;p&gt;属性的求值发生在&lt;code&gt;scope&lt;/code&gt;上。在Javascript中，属性名默认是在全局的&lt;code&gt;window&lt;/code&gt;对象上，在angular表达式中，使用&lt;code&gt;$window&lt;/code&gt;对象来引用全局&lt;code&gt;window&lt;/code&gt;对象。比如，你想调用&lt;code&gt;alert()&lt;/code&gt;，在angularjs中就必须使用&lt;code&gt;$window.alert()&lt;/code&gt;。这么做是为了防止我们的代码意外访问了全局状态，容易引起bug。&lt;/p&gt;
&lt;h4&gt;示例源代码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;example2&quot; ng-controller=&quot;Cntl1&quot;&amp;gt;
      Name: &amp;lt;input ng-model=&quot;name&quot; type=&quot;text&quot;/&amp;gt;
      &amp;lt;button ng-click=&quot;greet()&quot;&amp;gt;Greet&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function Cntl1($window, $scope){
  $scope.name = &apos;World&apos;;

  $scope.greet = function() {
    ($window.mockWindow || $window).alert(&apos;Hello &apos; + $scope.name);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;End to end test&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;it(&apos;should calculate expression in binding&apos;, function() {
  var alertText;
  this.addFutureAction(&apos;set mock&apos;, function($window, $document, done) {
    $window.mockWindow = {
      alert: function(text){ alertText = text; }
    };
    done();
  });
  element(&apos;:button:contains(Greet)&apos;).click();
  expect(this.addFuture(&apos;alert text&apos;, function(done) {
    done(null, alertText);
  })).toBe(&apos;Hello World&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jsfiddle link ?&lt;/p&gt;
&lt;h4&gt;空值友好&lt;/h4&gt;
&lt;p&gt;表达式对于&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;是友好的。在Javascript中，对于表达式&lt;code&gt;a.b.c&lt;/code&gt;，如果&lt;code&gt;a&lt;/code&gt;不是一个对象，则会抛出异常。虽然这么做对于一个通用语言来说是很有意义的，但对于表达式求值这种主要用来绑定数据的用法来说，意义不大而且很繁琐。&lt;/p&gt;
&lt;p&gt;因为我们经常会写下这样的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{a.b.c}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当&lt;code&gt;a&lt;/code&gt;为&lt;code&gt;undefined&lt;/code&gt;的时候（可能我们正在等服务器端返回数据），什么也不显示通常更有意义一些。如果我们不这么处理，上面的代码就必须写成这种让人头晕的形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{((a||{}).b||{}).c}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，调用一个&lt;code&gt;undefined&lt;/code&gt;或&lt;code&gt;null&lt;/code&gt;上的函数，如&lt;code&gt;a.b.c()&lt;/code&gt;，也会简单地返回&lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;没有控制语句&lt;/h4&gt;
&lt;p&gt;在angularjs表达式中，不能使用如条件判断、循环或抛异常这种控制语句。主要原因是这种通常与业务逻辑相关的代码，应该放在controller中，而不是view中。&lt;/p&gt;
&lt;p&gt;如果你的确需要，可以在controller中定义一个javascript函数，再在angularjs表达式中调用它。&lt;/p&gt;
&lt;h4&gt;过滤器 Filters&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;name | uppercase
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;name的值将会直接传给&lt;code&gt;uppercase&lt;/code&gt;这个filter.&lt;/p&gt;
&lt;p&gt;Filter还可以串起来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value | filter1 | filter2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可还以使用冒号&lt;code&gt;:&lt;/code&gt;向filter传参数。比如，把数字&lt;code&gt;123&lt;/code&gt;显示为两个小数点的形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;123 | number:2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;The $&lt;/h4&gt;
&lt;p&gt;你可能会注意到，有一些对象或者方法，它们以&lt;code&gt;$&lt;/code&gt;开头，是什么意思？这是一个默认约定，由angularjs提供的api以&lt;code&gt;$&lt;/code&gt;开头，与其它相区别。&lt;/p&gt;
&lt;p&gt;所以我们在定义变量或者函数时，不要使用&lt;code&gt;$&lt;/code&gt;开头，以免跟angularjs冲突。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>04. 指令</title>
                <link>http://freewind.in/posts/1226-angularjs-04-directives</link>
                <pubDate>Tue, 01 Jan 2013 16:26:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1226</guid>
                <description><![CDATA[&lt;h4&gt;指令(directive)&lt;/h4&gt;
&lt;p&gt;指令(directive)是教会HTML新技能的方法。在DOM编译期间，与HTML相匹配的指令会执行。这样，我们就可以利用指令来注册一些动作，或者执行转换DOM的操作。&lt;/p&gt;
&lt;p&gt;Angular内置了一些非常有用、并且可被扩展的指令，这样我们就能把HTML变身为DSL（可声明的领域专用语言）。&lt;/p&gt;
&lt;h4&gt;从HTML中调用指令&lt;/h4&gt;
&lt;p&gt;指令的命名方式采用驼峰式，如&apos;ngBind&apos;。但在调用时，可采用“蛇行式”，以及特定的分隔符：&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;。甚至可以在它们前面加上&lt;code&gt;x-&lt;/code&gt;或&lt;code&gt;data-&lt;/code&gt;以便通过HTML格式验证。&lt;/p&gt;
&lt;p&gt;这里举几个有效的例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ng:bind&lt;/code&gt;, &lt;code&gt;ng-bind&lt;/code&gt;, &lt;code&gt;ng_bind&lt;/code&gt;, &lt;code&gt;x-ng-bind&lt;/code&gt;, &lt;code&gt;data-ng-bind&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指令可被放置于以下位置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素名称2.  属性名称3.  css类名称4.  注释&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下几个例子都是完全相同的调用指令&lt;code&gt;myDir&lt;/code&gt;的方法。（不过大多数情况，我们仅会使用属性式指令）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;span my-dir=&quot;exp&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;my-dir: exp;&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;my-dir&amp;gt;&amp;lt;/my-dir&amp;gt;
&amp;lt;!-- directive: my-dir exp --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指令可被多种不同的方式调用，但在下面例子的测试代码中，它们是完全相同的。&lt;/p&gt;
&lt;h4&gt;Demo Source Code&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;Ctrl1&quot;&amp;gt;
      Hello &amp;lt;input ng-model=&apos;name&apos;&amp;gt; &amp;lt;hr/&amp;gt;
      &amp;lt;span ng:bind=&quot;name&quot;&amp;gt; &amp;lt;span ng:bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br/&amp;gt;
      &amp;lt;span ng_bind=&quot;name&quot;&amp;gt; &amp;lt;span ng_bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br/&amp;gt;
      &amp;lt;span ng-bind=&quot;name&quot;&amp;gt; &amp;lt;span ng-bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br/&amp;gt;
      &amp;lt;span data-ng-bind=&quot;name&quot;&amp;gt; &amp;lt;span data-ng-bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br/&amp;gt;
      &amp;lt;span x-ng-bind=&quot;name&quot;&amp;gt; &amp;lt;span x-ng-bind=&quot;name&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;br/&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function Ctrl1($scope) {
  $scope.name = &apos;angular&apos;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;End to end test&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;it(&apos;should show off bindings&apos;, function() {
  expect(element(&apos;div[ng-controller=&quot;Ctrl1&quot;] span[ng-bind]&apos;).text()).toBe(&apos;angular&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以在jsfiddle上&lt;a href=&quot;http://jsfiddle.net/api/post/library/pure/&quot;&gt;查看并修改&lt;/a&gt;该示例&lt;/p&gt;
&lt;h4&gt;字符串插补(interpolation)&lt;/h4&gt;
&lt;p&gt;在编译阶段，编译器使用&lt;code&gt;$interpolate&lt;/code&gt;服务来匹配文本和属性，检查它们是否嵌入了表达式。这些表达式注册为“观察者”，在digest周期中将被更新。&lt;/p&gt;
&lt;p&gt;以下是一个&lt;code&gt;interpolation&lt;/code&gt;的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img /{{username}}.jpg&quot;&gt;Hello {{username}}!&lt;/img&gt;&lt;/p&gt;
&lt;h4&gt;编译过程和指令(directive)匹配&lt;/h4&gt;
&lt;p&gt;HTML的编译过程，发生在三处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先HTML由标准浏览器api解析为DOM。认识到这一点很重要，因为模板代码必须为可解析的HTML。多数模板系统操作字符串，与它们不同的是，angularjs操作DOM元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;$compile()&lt;/code&gt;方法对DOM进行编译。该方法遍历DOM和寻找可匹配的指令(directive)，找到后则把它加到该DOM关联的指令列表中。一旦某DOM所有的指令都被找到，则按照指令中定义的优先级对它们进行排序，并调用它们的&lt;code&gt;@compile()&lt;/code&gt;方法。该编译方法有机会修改DOM结构，并且有责任提供一个&lt;code&gt;link()&lt;/code&gt;函数（将在后面解释）。&lt;code&gt;$compile()&lt;/code&gt;方法返回一组连接(linking)方法，它们是一个集合，由该DOM关联的所有指令返回的link函数组成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用在上一步中返回的连接(link)函数，将模板与域对象(scope)连接起来。这将依次调用每一个指令(directvie)的连接函数，允许它们在元素上注册任意的监听器(listener)。结果将得到一个在域对象与DOM之间的实时绑定(live binding)。当域对象(scope)变化了，将立刻反映到DOM上。&lt;/p&gt;
&lt;p&gt;var $compile = &amp;hellip;; // injected into your code
&lt;br  /&gt;var scope = &amp;hellip;;&lt;/p&gt;
&lt;p&gt;var html = &apos;&lt;div ng-bind=&apos;exp&apos;&gt;&lt;/div&gt;&apos;;&lt;/p&gt;
&lt;p&gt;// Step 1: parse HTML into DOM element
&lt;br  /&gt;var template = angular.element(html);&lt;/p&gt;
&lt;p&gt;// Step 2: compile the template
&lt;br  /&gt;var linkFn = $compile(template);&lt;/p&gt;
&lt;p&gt;// Step 3: link the compiled template with the scope.
&lt;br  /&gt;linkFn(scope);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;为什么要把编译(compile)与链接(link)分开&lt;/h4&gt;
&lt;p&gt;现在你也许会好奇，为什么我们要把编译过程分解为编译和连接两个步骤。为了理解这点，让我们看一下真实世界中的&lt;code&gt;repeater&lt;/code&gt;的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;Hello {{user}}, you have these actions:
&amp;lt;ul&amp;gt;
  &amp;lt;li ng-repeat=&quot;action in user.actions&quot;&amp;gt;
    {{action.description}}
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单来说，只要当模型类改变时需要更新DOM结构（就像repeater），我们就需要将编译与连接分开。&lt;/p&gt;
&lt;p&gt;上面的例子在编译时，编译器访问每一个节点来寻找指令(directive)。&lt;code&gt;{{user}}&lt;/code&gt;是插补指令的一个例子，&lt;code&gt;ngRepeat&lt;/code&gt;是另一种。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;ngRepeat&lt;/code&gt;有一个困境：它需要为&lt;code&gt;user.actions&lt;/code&gt;中的每一个action快速生成一个新的&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;，这表示它需要持有&lt;code&gt;li&lt;/code&gt;元素的一个干净的copy用来复制，每当有新的actions插入时，&lt;code&gt;li&lt;/code&gt;模板元素需要被快速复制被插入到&lt;code&gt;ul&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;但是仅仅复制是不够的，它还需要编译&lt;code&gt;li&lt;/code&gt;，所以它的指令（如&lt;code&gt;{{action.descriptions}}&lt;/code&gt;也需要在正确的域(scope)中执行一遍。有一种很天真的处理方式是简单地插入一个&lt;code&gt;li&lt;/code&gt;元素的copy并编译它。但是编译每一个li元素会很慢，因为编译过程需要遍历DOM树并寻找指令还要运行它们。如果我们把编译过程放在一个需要展示100个元素的repeater里，我们很快就会遇到性能问题。&lt;/p&gt;
&lt;p&gt;解决方案是把编译过程分解为两步：第一步编译，寻找所有的指令并给它们按优先级排序；第二步连接，将把&lt;code&gt;li&lt;/code&gt;的某实例与&lt;code&gt;scope&lt;/code&gt;的某实例连接起来。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ngRepeat&lt;/code&gt;的运行方式不是把编译过程下放到&lt;code&gt;li&lt;/code&gt;元素中，而是它们分开编译。结果是得到一个连接函数，它包括了&lt;code&gt;li&lt;/code&gt;元素中所有将被附加到某一个指定的li的复制体上的指令。在运行期，ngRepeat会监视表达式，每当有新的元素添加到数组中时，它将复制li元素，为它创建一个新的域对象，并调用li元素上的连接函数。&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译(compile)函数 - 在指令(directive)中相对较少使用，因为大多数指令只在某一个指定的DOM元素实例上执行，而不会对模板DOM元素进行转换。所有需要在指令实例间进行共享的操作，因为性能原因应该放在本函数中&lt;/li&gt;
&lt;li&gt;连接(link)函数 - 指令基本上都会用到连接函数。连接函数允许指令在指定的DOM元素的复制体上注册监听器，也可以从scope中复制一些内容到DOM中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;编写指令（精简版）&lt;/h4&gt;
&lt;p&gt;在本例中，我们将创建一个显示当前时间的指令。&lt;/p&gt;
&lt;h4&gt;源代码&lt;/h4&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app=&quot;time&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;Ctrl2&quot;&amp;gt;
      Date format: &amp;lt;input ng-model=&apos;format&apos;&amp;gt; &amp;lt;hr/&amp;gt;
      Current time is: &amp;lt;span my-current-time=&quot;format&quot;&amp;gt;&amp;lt;/span
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;script.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function Ctrl2($scope) {
  $scope.format = &apos;M/d/yy h:mm:ss a&apos;;
}

angular.module(&apos;time&apos;, [])
  // Register the &apos;myCurrentTime&apos; directive factory method.
  // We inject $timeout and dateFilter service since the factory method is DI.
  .directive(&apos;myCurrentTime&apos;, function($timeout, dateFilter) {
    // return the directive link function. (compile function not needed)
    return function(scope, element, attrs) {
      var format,  // date format
          deferId; // deferId, so that we can cancel the time updates

      // used to update the UI
      function updateTime() {
        element.text(dateFilter(new Date(), format));
      }

      // watch the expression, and update the UI on change.
      scope.$watch(attrs.myCurrentTime, function(value) {
        format = value;
        updateTime();
      });

      // schedule update in one second
      function updateLater() {
        // save the deferId for canceling
        deferId = $timeout(function() {
          updateTime(); // update DOM
          updateLater(); // schedule another update
        }, 1000);
      }

      // listen on DOM destroy (removal) event, and cancel the next UI update
      // to prevent updating time ofter the DOM element was removed.
      element.bind(&apos;$destroy&apos;, function() {
        $timeout.cancel(deferId);
      });

      updateLater(); // kick of the UI update process.
    }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上例可在jsfiddle上&lt;a href=&quot;http://jsfiddle.net/api/post/library/pure/&quot;&gt;查看效果及修改&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;编写指令（完整版）&lt;/h4&gt;
&lt;p&gt;这里是一个指令的结构骨架，完整的解释在后面。&lt;/p&gt;
&lt;p&gt;var myModule = angular.module(&amp;hellip;);&lt;/p&gt;
&lt;p&gt;myModule.directive(&apos;directiveName&apos;, function factory(injectables) {
&lt;br  /&gt;var directiveDefinitionObject = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;priority: 0,
template: &apos;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&apos;,
templateUrl: &apos;directive.html&apos;,
replace: false,
transclude: false,
restrict: &apos;A&apos;,
scope: false,
compile: function compile(tElement, tAttrs, transclude) {
  return {
    pre: function preLink(scope, iElement, iAttrs, controller) { ... },
    post: function postLink(scope, iElement, iAttrs, controller) { ... }
  }
},
link: function postLink(scope, iElement, iAttrs) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;return directiveDefinitionObject;
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;在大多数情况下，你不需要如此彻底的控制，所以上面的例子可以简化。所以与本示例不同的地方，将在下面几节中讲解。在本节我们仅仅对该示例感兴趣。&lt;/p&gt;
&lt;p&gt;第一步是简化代码，尽管使用默认值。所以上面的代码可以简化为：&lt;/p&gt;
&lt;p&gt;var myModule = angular.module(&amp;hellip;);&lt;/p&gt;
&lt;p&gt;myModule.directive(&apos;directiveName&apos;, function factory(injectables) {
&lt;br  /&gt;var directiveDefinitionObject = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile: function compile(tElement, tAttrs) {
  return function postLink(scope, iElement, iAttrs) { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;return directiveDefinitionObject;
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;大多数指令只关系它们自己的实例，而不关心模板的转换，所以可以进一步简化为：&lt;/p&gt;
&lt;p&gt;var myModule = angular.module(&amp;hellip;);&lt;/p&gt;
&lt;p&gt;myModule.directive(&apos;directiveName&apos;, function factory(injectables) {
&lt;br  /&gt;return function postLink(scope, iElement, iAttrs) { &amp;hellip; }
&lt;br  /&gt;});&lt;/p&gt;
&lt;h4&gt;工厂方法&lt;/h4&gt;
&lt;p&gt;工厂方法的责任是创建指令。它只会在编译器第一次匹配到某指令时，被调用一次。你可以在这里执行任意的初始化操作。该方法被&lt;code&gt;$injector.invoke&lt;/code&gt;调用，所以可被注入(injectable)，并遵守injection注解的所有规则。&lt;/p&gt;
&lt;h4&gt;指令定义对象&lt;/h4&gt;
&lt;p&gt;指令定义对象为编译器提供了一些必要信息。有以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;name - 当前域(scope)对象的名称。默认与注册时使用的名称相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;priority - 优先级。当一个DOM元素上有多个指令时，有时候很有必要指定指令的顺序。优先级(priority)用来在编译函数调用之前来对它们进行排序。数字大的排在前面，数字相同的顺序不确定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;terminal - 是否为终结。如果设为true，则与当前priority相同的指令将在最后一批执行（该批中的各指令也将被执行，因为priority相同的指令运行顺序不确定）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;scope - 域对象。如果设为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `true` - 则会为该指令创建一个新的scope。如果在同一元素上的多个指令同时要求创建新scope，则只会创建一个scope。该规则不适用于模板的root，因为root总是创建一个新scope。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{}&lt;/code&gt;(object hash) - 创建一个新的&apos;孤立&apos;的scope。该scope与普通的scope不同的是，它不会以原型方式从上级scope中继承内容。它对于创建一些可利用的组件很有用，因为它不会让我们意外修改了上级scope中的数据。该&apos;孤立&apos;的scope将上级scope中的属性复制到本地的一个object hash中。这些本地属性可为模板提供数据。本地变量的定义是一个由源到本地属性的hash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    *   `@` 或 `@attr` - 将scope的一个本地属性绑定到DOM属性。由于DOM属性都是字符串，所以它的值总是字符串。如果属性名称没有指定，则本地变量名称与属性名称一致。假设给定`&amp;lt;widget my-attr=&quot;hello {{name}}&quot;&amp;gt;`以及定义：`{localName:&apos;@myAttr&apos;}`，则widget scope的属性`localName`将会反映到`hello, {{name}}`中。反过来也一样，如果`name`变了，则`localName`的值也会变。其中`name`是从上级scope中读取的（而不是在当前的组件中）。

    *   `=` 或 `=attr` - 在本地scope与上级scope的属性之间设置双向绑定。如果`attr`的值没有设置，则本地与上级scope的属性名相同。假设给定`&amp;lt;widget my-attr=&quot;parentModel&quot;&amp;gt;`以及定义`{scope: { localModel:&apos;=myAttr&apos;}`,则当`localName`的值变了，`parentModel`会跟着变，反之亦然。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;attr&lt;/code&gt; - （这一段原文有问题，等修正后再翻译）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;controller&lt;/code&gt; - Controller的构造函数。该controller将在pre-linking阶段前被初始化，并且可被多个directives通过名称引用共享(参考 &lt;code&gt;require&lt;/code&gt;属性). 因此我们利用它在不同的directives之间通信或改变行为。controller可注入以下对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `$scope` - 当前元素关联的scope*   `$element` - 当前元素*   `$attrs` - 当前元素对应的属性对象*   `$transclude` - A transclude linking function pre-bound to the correct transclusion scope:`function(cloneLinkingFn)`.（这一句没理解）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;require&lt;/code&gt; - 要求将另一个controller传入到当前的linking function中。&lt;code&gt;require&lt;/code&gt;要求传入一个controller的名称。如果找不到，则可以控制是否抛出一个异常。controller名称可有以下前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `?` - 不抛异常（所以依赖的controller为可选）*   `^` - 继续向上级元素中寻找
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;restrict&lt;/code&gt; - &lt;code&gt;EACM&lt;/code&gt;这四个字母中的一个或多个，默认为&apos;A&apos;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `E` - **E**lement name: `&amp;lt;my-directive&amp;gt;&amp;lt;/my-directive&amp;gt;`
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; - &lt;strong&gt;A&lt;/strong&gt;ttribute: &lt;code&gt;&amp;lt;div my-directive=&quot;exp&quot;&amp;gt; &amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; - &lt;strong&gt;C&lt;/strong&gt;lass: &lt;code&gt;&amp;lt;div class=&quot;my-directive: exp;&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt; - Co&lt;strong&gt;m&lt;/strong&gt;ment: &lt;code&gt;&amp;lt;!-- directive: my-directive exp --&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template&lt;/code&gt; - 模板。将使用该模板来替换HTML的内容。该替换过程将把旧元素中的attribute/classes迁移到新元素中（TODO未理解）。参考下面的“创建widget”一节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;templateUrl&lt;/code&gt; - 与&lt;code&gt;template&lt;/code&gt;相同但是从指定的URL导入内容。由于导入是异步，所以compilation/linking过程将被暂停直到模板导入成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;replace&lt;/code&gt; - 如果设为&lt;code&gt;true&lt;/code&gt;则用前面替换当前元素，否则在后面添加。&lt;/p&gt;
&lt;p&gt;（这一段很难，完全没看懂）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;transclude&lt;/code&gt; - compile the content of the element and make it available to the directive. Typically used with&lt;code&gt;ngTransclude&lt;/code&gt;. The advantage of transclusion is that the linking function receives a transclusion function which is pre-bound to the correct scope. In a typical setup the widget creates an &lt;code&gt;isolate&lt;/code&gt; scope, but the transclusion is not a child, but a sibling of the &lt;code&gt;isolate&lt;/code&gt; scope. This makes it possible for the widget to have private state, and the transclusion to be bound to the parent (pre-&lt;code&gt;isolate&lt;/code&gt;) scope.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `true` - transclude the content of the directive.*   `&apos;element&apos;` - transclude the whole element including any directives defined at lower priority.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;compile&lt;/code&gt; - 编译函数，将在下节讲。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;link&lt;/code&gt;: 连接函数，将在下节讲。只有当compile属性没有定义时，才会使用本属性。&lt;/p&gt;
&lt;h4&gt;编译函数&lt;/h4&gt;
&lt;p&gt;function compile(tElement, tAttrs, transclude) { &amp;hellip; }&lt;/p&gt;
&lt;p&gt;编译函数用来转换模板DOM。由于多数directives不需要模板转换，所以它不常用。什么时候才会用到呢？比如像&lt;code&gt;ngRepeat&lt;/code&gt;这样需要转换模板的directive，或者像&lt;code&gt;ngView&lt;/code&gt;这样需要异步导入模板的。&lt;/p&gt;
&lt;p&gt;编译函数有以下参数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tElement&lt;/code&gt; - 模板元素(template element)，即directive被声明的那个元素。在各操作中，只有在元素（或子元素）上进行模板转换的操作才是安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tAttrs&lt;/code&gt; - 模板属性(template attributes)。在元素上声明的属性集，它在该元素上所有的directives编译函数中共享。参看Attributes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;transclude&lt;/code&gt; - A transclude linking function: &lt;code&gt;function(scope, cloneLinkingFn)&lt;/code&gt;.（未理解）&lt;/p&gt;
&lt;p&gt;注意：如果模板被cloned，则template示例与instance实例可能不再相同。所以在编译函数中进行除DOM转换以外的任何操作都是不安全的。特别是，“DOM监听器注册”的操作应该在linking函数中，而不是在compile函数中。&lt;/p&gt;
&lt;p&gt;编译函数可以返回一个函数，或者是一个object。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数： 相当于使用了&lt;code&gt;link&lt;/code&gt;属性且保持&lt;code&gt;compile&lt;/code&gt;为空*   object: 如果包含了&lt;code&gt;pre&lt;/code&gt;或&lt;code&gt;post&lt;/code&gt;属性，则可以用来控制linking函数何时被调用。详细内容参考下面内容。&lt;/p&gt;
&lt;h4&gt;连接函数&lt;/h4&gt;
&lt;p&gt;function link(scope, iElement, iAttrs, controller) { &amp;hellip; }&lt;/p&gt;
&lt;p&gt;Link函数用来注册DOM监听器或更新DOM，当模板被cloned之后被调用。多数时候在这里放置directive的逻辑代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;scope&lt;/code&gt; - 让directive用它来注册watches&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;iElement&lt;/code&gt; - instance element - directive使用的元素实例。只有在&lt;code&gt;postLink&lt;/code&gt;中维护当前元素的子元素才是安全的，因为子元素已经被link了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;iAttrs&lt;/code&gt; - instance attributes - 在元素上声明的属性集，它在该元素上所有的directives编译函数中共享。See Attributes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;controller&lt;/code&gt; - 一个controller实例 - 如果该元素上至少有一个directive定义了controller。它在不同的directives之间共享，可当作它们互相通信的通道。&lt;/p&gt;
&lt;h5&gt;Pre-linking函数&lt;/h5&gt;
&lt;p&gt;在子元素被link之前调用。不要进行DOM转换的操作，因为可能导致编译器的linking函数找不到正确的元素而失败。&lt;/p&gt;
&lt;h5&gt;Post-linking函数&lt;/h5&gt;
&lt;p&gt;在子元素被link之后调用。在这里执行DOM转换操作是安全的。&lt;/p&gt;
&lt;h4&gt;Attributes&lt;/h4&gt;
&lt;p&gt;属性对象可当作&lt;code&gt;link()&lt;/code&gt;和&lt;code&gt;compile()&lt;/code&gt;函数的参数传过去 ，它提供了一种访问方式：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;规范化之后的属性名：由于一个directive可使用多种方式来声明（如&lt;code&gt;ng:bind&lt;/code&gt;,&lt;code&gt;x-ng-bind&lt;/code&gt;），所以该对象提供了一种规范的方式来访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;directive内部通信：元素上所有的directive共享同一个atrribute object，所以可用经作为directive的内部通信载体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持插补：（TODO）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监听插补属性：使用&lt;code&gt;$observe&lt;/code&gt;来监听包含了表达式的属性的变化（如&lt;code&gt;src=&quot;{{bar}}&quot;&lt;/code&gt;）。这种方式不但高效，而且是得到其值的唯一方法，因为在linking阶段插补的值还没有被执行，所以这个值在当前还是&lt;code&gt;undefined&lt;/code&gt;.
&lt;br  /&gt;function linkingFn(scope, elm, attrs, ctrl) {
&lt;br  /&gt;// get the attribute value
&lt;br  /&gt;console.log(attrs.ngModel);&lt;/p&gt;
&lt;p&gt;// change the attribute
&lt;br  /&gt;attrs.$set(&apos;ngModel&apos;, &apos;new value&apos;);&lt;/p&gt;
&lt;p&gt;// observe changes to interpolated attribute
&lt;br  /&gt;attrs.$observe(&apos;ngModel&apos;, function(value) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;ngModel has changed value to &apos; + value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;}&lt;/p&gt;
&lt;h4&gt;理解transclusion和scopes&lt;/h4&gt;
&lt;p&gt;我们都想要可复用的组件。下面是一个简化的对话框组件的假想工作方式。&lt;/p&gt;
&lt;p&gt;&lt;div&gt;
&lt;br  /&gt;&lt;button ng-click=&quot;show=true&quot;&gt;show&lt;/button&gt;
&lt;br  /&gt;&amp;lt;dialog title=&amp;ldquo;Hello {{username}}.&amp;rdquo;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      visible=&quot;show&quot;
      on-cancel=&quot;show = false&quot;
      on-ok=&quot;show = false; doSomething()&quot;&amp;gt;
 Body goes here: {{username}} is {{title}}.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/dialog&gt;&lt;/p&gt;
&lt;p&gt;点击“show&quot;按钮，将打开对话框。该对话框包含一个标题，其数据被绑定到&lt;code&gt;username&lt;/code&gt;上。它还包含一个body，将被我们transclude到dialog中。&lt;/p&gt;
&lt;p&gt;下面是为该对话框部件准备的模板代码示例：&lt;/p&gt;
&lt;div ng-show=&quot;show()&quot;&gt;
  &lt;h3&gt;{{title}}&lt;/h3&gt;
  &lt;div class=&quot;body&quot; ng-transclude&gt;&lt;/div&gt;
  &lt;div class=&quot;footer&quot;&gt;
    &lt;button ng-click=&quot;onOk()&quot;&gt;Save changes&lt;/button&gt;
    &lt;button ng-click=&quot;onCancel()&quot;&gt;Close&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这段代码还不能正确的渲染，除非我们来点魔术。&lt;/p&gt;
&lt;p&gt;我们需要解决的每一个问题是dialog要有一个title，并且它要与&lt;code&gt;username&lt;/code&gt;绑定。另外在scope中，还需要有&lt;code&gt;onOk&lt;/code&gt;和&lt;code&gt;onCancel&lt;/code&gt;函数。这都将限制该widget的用途。为了解决这些问题，我们将使用&lt;code&gt;locals&lt;/code&gt;来创建一些本地变量，与模板相匹配：&lt;/p&gt;
&lt;p&gt;scope: {
&lt;br  /&gt;title: &apos;bind&apos;,          // set up title to accept data-binding
&lt;br  /&gt;onOk: &apos;expression&apos;,     // create a delegate onOk function
&lt;br  /&gt;onCancel: &apos;expression&apos;, // create a delegate onCancel function
&lt;br  /&gt;show: &apos;accessor&apos;        // create a getter/setter function for visibility.
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;但在widget的scope上创建本地属性，会产生两个问题：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;isolation - 如果用户忘了给title设置，dialog会尝试到上级scope中寻找。这会产生未知的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;transclusion - transcluded DOM可以看到widget的本地变量，可能会覆盖transclusion用来数据绑定的属性。在我们的例子中，widget的&lt;code&gt;title&lt;/code&gt;属性就会灭掉transclusion的title属性。(TODO：翻译有问题)&lt;/p&gt;
&lt;p&gt;为了解决第一个问题，directive将声明一个新的isolated scope。一个isolated scope不会以原型方式从子类中继承属性，所以我们不用担心意味损坏了数据。&lt;/p&gt;
&lt;p&gt;但isolated scope又带来了一个新问题：如果transcluded DOM是该widget的isolated scope的子域，则它不会继承到任何数据。因此，transcluded scope是原scope的子，并在widget创建的isolated scope之前。于是，transcluded与widget两者的isolated scope成了兄弟。&lt;/p&gt;
&lt;p&gt;这看起来有点复杂，不过这可以让widget用户和开发者尽量不会觉得意外。&lt;/p&gt;
&lt;p&gt;因此，最终的directive的声明看起来如下：&lt;/p&gt;
&lt;p&gt;transclude: true,
&lt;br  /&gt;scope: {
&lt;br  /&gt;title: &apos;bind&apos;,          // set up title to accept data-binding
&lt;br  /&gt;onOk: &apos;expression&apos;,     // create a delegate onOk function
&lt;br  /&gt;onCancel: &apos;expression&apos;, // create a delegate onCancel function
&lt;br  /&gt;show: &apos;accessor&apos;        // create a getter/setter function for visibility.
&lt;br  /&gt;}&lt;/p&gt;
&lt;h4&gt;创建组件&lt;/h4&gt;
&lt;p&gt;我们通常想使用复杂一些的DOM结构来代替单一的directive。This allows the directives to become a short hand for reusable components from which applications can be built.（这句怎么翻？）&lt;/p&gt;
&lt;p&gt;下面是一个创建可复用的widget的例子。&lt;/p&gt;
&lt;h4&gt;Source&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app=&quot;zippyModule&quot;&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div ng-controller=&quot;Ctrl3&quot;&amp;gt;
  Title: &amp;lt;input ng-model=&quot;title&quot;&amp;gt; &amp;lt;br&amp;gt;
  Text: &amp;lt;textarea ng-model=&quot;text&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
  &amp;lt;hr&amp;gt;
  &amp;lt;div class=&quot;zippy&quot; zippy-title=&quot;Details: {{title}}...&quot;&amp;gt;{{text}}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;style.css&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.zippy {
&lt;br  /&gt;border: 1px solid black;
&lt;br  /&gt;display: inline-block;
&lt;br  /&gt;width: 250px;
&lt;br  /&gt;}
&lt;br  /&gt;.zippy.opened &gt; .title:before { content: &apos;▼ &apos;; }
&lt;br  /&gt;.zippy.opened &gt; .body { display: block; }
&lt;br  /&gt;.zippy.closed &gt; .title:before { content: &apos;► &apos;; }
&lt;br  /&gt;.zippy.closed &gt; .body { display: none; }
&lt;br  /&gt;.zippy &gt; .title {
&lt;br  /&gt;background-color: black;
&lt;br  /&gt;color: white;
&lt;br  /&gt;padding: .1em .3em;
&lt;br  /&gt;cursor: pointer;
&lt;br  /&gt;}
&lt;br  /&gt;.zippy &gt; .body {
&lt;br  /&gt;padding: .1em .3em;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function Ctrl3($scope) {
&lt;br  /&gt;$scope.title = &apos;Lorem Ipsum&apos;;
&lt;br  /&gt;$scope.text = &apos;Neque porro quisquam est qui dolorem ipsum quia dolor&amp;hellip;&apos;;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;angular.module(&apos;zippyModule&apos;, [])
&lt;br  /&gt;.directive(&apos;zippy&apos;, function(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return {
  restrict: &apos;C&apos;,
  // This HTML will replace the zippy directive.
  replace: true,
  transclude: true,
  scope: { title:&apos;@zippyTitle&apos; },
  template: &apos;&amp;lt;div&amp;gt;&apos; +
              &apos;&amp;lt;div class=&quot;title&quot;&amp;gt;{{title}}&amp;lt;/div&amp;gt;&apos; +
              &apos;&amp;lt;div class=&quot;body&quot; ng-transclude&amp;gt;&amp;lt;/div&amp;gt;&apos; +
            &apos;&amp;lt;/div&amp;gt;&apos;,
  // The linking function will add behavior to the template
  link: function(scope, element, attrs) {
        // Title element
    var title = angular.element(element.children()[0]),
        // Opened / closed state
        opened = true;

    // Clicking on title should open/close the zippy
    title.bind(&apos;click&apos;, toggle);

    // Toggle the closed/opened state
    function toggle() {
      opened = !opened;
      element.removeClass(opened ? &apos;closed&apos; : &apos;opened&apos;);
      element.addClass(opened ? &apos;opened&apos; : &apos;closed&apos;);
    }

    // initialize the zippy
    toggle();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;End to end test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;it(&apos;should bind and open / close&apos;, function() {
&lt;br  /&gt;input(&apos;title&apos;).enter(&apos;TITLE&apos;);
&lt;br  /&gt;input(&apos;text&apos;).enter(&apos;TEXT&apos;);
&lt;br  /&gt;expect(element(&apos;.title&apos;).text()).toEqual(&apos;Details: TITLE&amp;hellip;&apos;);
&lt;br  /&gt;expect(binding(&apos;text&apos;)).toEqual(&apos;TEXT&apos;);&lt;/p&gt;
&lt;p&gt;expect(element(&apos;.zippy&apos;).prop(&apos;className&apos;)).toMatch(/closed/);
&lt;br  /&gt;element(&apos;.zippy &gt; .title&apos;).click();
&lt;br  /&gt;expect(element(&apos;.zippy&apos;).prop(&apos;className&apos;)).toMatch(/opened/);
&lt;br  /&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://jsfiddle.net/api/post/library/pure/&quot;&gt;http://jsfiddle.net/api/post/library/pure/&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>03. HTML编译器</title>
                <link>http://freewind.in/posts/1225-angularjs-03-html-compiler</link>
                <pubDate>Tue, 01 Jan 2013 16:25:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1225</guid>
                <description><![CDATA[&lt;h3&gt;概览&lt;/h3&gt;
&lt;p&gt;Angular的compiler允许开发者都会浏览器新语法。它能让你把自定义的行为附加（甚至新建）到任何一个HTML元素或属性上。Angularjs把这些行为扩展称为指令(directive)。&lt;/p&gt;
&lt;p&gt;HTML有很多声明式的设施用来格式化静态文档的HTML。比如，你想让页面上某个元素在中间显示，你不需要手动计算位置，仅仅添加一个&lt;code&gt;align=&quot;center&quot;&lt;/code&gt;的属性即可。这就是声明式语言的威力。&lt;/p&gt;
&lt;p&gt;但是声明式语言也有很大的限制，因为它不允许你自定义新的语法，只能使用它已经定义好的。比如，你想让浏览器把一段文本放在屏幕的1/3之处，很难实现。所以我们需要一种方式，可以让浏览器学习新的HTML语法。&lt;/p&gt;
&lt;p&gt;Angular已经预定义了很多常用的directives，用来帮助创建程序。我们也期待你将会创建与程序相关的指令。这些扩展将变为你创建程序的DSL。&lt;/p&gt;
&lt;p&gt;所有这些编译操作都在浏览器中进行，不需要服务器端参与，也不需要预编译过程。&lt;/p&gt;
&lt;h3&gt;编译器&lt;/h3&gt;
&lt;p&gt;编译器是一个angular服务，它可以遍历DOM寻找属性。编译过程发生在两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Compile&lt;/strong&gt;: 遍历DOM，并收集所有的指令。结果返回一个linking函数2.  &lt;strong&gt;Link&lt;/strong&gt;: 把directives与scope组合起来，产生一些实时动态的视图。当scoe发生变化时，将会反映到view中，当用户操作了view，其变化也会反映到model中。scope model是唯一值得信赖的数据来源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;某些directives例如&lt;code&gt;ng-repeat&lt;/code&gt;会为集合中的每一个元素克隆一遍DOM元素。把编译过程分为compile和link两个阶段，对于性能的提升很有帮助 ，因为克隆的模板仅仅需要编译一次即可（然后link到每一个克隆后的示例）&lt;/p&gt;
&lt;h3&gt;指令&lt;/h3&gt;
&lt;p&gt;Directive是指我们添加到HTML代码中，在编译阶段需要特别处理的那些结构性代码。Directive可以放在元素名上，属性上，class名上，甚至注释中。下面是几个调用&lt;code&gt;ng-bind&lt;/code&gt;这个directive的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;span ng-bind=&quot;exp&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;ng-bind: exp;&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;ng-bind&amp;gt;&amp;lt;/ng-bind&amp;gt;
  &amp;lt;!-- directive: ng-bind exp --&amp;gt;

可参看directive章节以深入了解如何编写自己的directives。

这里有一个directive，可以让何意一个元素“可拖动“。注意`&amp;lt;span&amp;gt;`上的`draggable`元素。

### 源代码

**index.html**

&amp;lt;span draggable&amp;gt;Drag ME&amp;lt;/span&amp;gt;

**script.js**

angular.module(&apos;drag&apos;, []).
      directive(&apos;draggable&apos;, function($document) {
        var startX=0, startY=0, x = 0, y = 0;
        return function(scope, element, attr) {
          element.css({
           position: &apos;relative&apos;,
           border: &apos;1px solid red&apos;,
           backgroundColor: &apos;lightgrey&apos;,
           cursor: &apos;pointer&apos;
          });
          element.bind(&apos;mousedown&apos;, function(event) {
            startX = event.screenX - x;
            startY = event.screenY - y;
            $document.bind(&apos;mousemove&apos;, mousemove);
            $document.bind(&apos;mouseup&apos;, mouseup);
          });

          function mousemove(event) {
            y = event.screenY - startY;
            x = event.screenX - startX;
            element.css({
              top: y + &apos;px&apos;,
              left:  x + &apos;px&apos;
            });
          }

          function mouseup() {
            $document.unbind(&apos;mousemove&apos;, mousemove);
            $document.unbind(&apos;mouseup&apos;, mouseup);
          }
        }
      });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;任意一个元素添加了&lt;code&gt;draggable&lt;/code&gt;属性后，就有了新的行为。这种方式的美妙之处在于，我们教会了浏览器新的技能，扩展了它所支持词汇，对于熟悉HTML的人来说，这种方式非常自然。&lt;/p&gt;
&lt;h3&gt;理解view&lt;/h3&gt;
&lt;p&gt;市面上有很多模板系统。大多数是把一些静态的文本模板与数据组合起来，产生一个新的文本。然后，把它通过&lt;code&gt;innerHTML&lt;/code&gt;放入到一个元素中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1225-1.png&quot;&gt;&lt;img src=&quot;/user_images/1225-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这表明数据一旦有变化，就必须重新跟模板结合产生新结果，再次通过&lt;code&gt;innerHTML&lt;/code&gt;放入到DOM中。但这么做有很多地方比较麻烦：读取用户输入，与数据结合，覆盖用户输入，管理更新过程，缺乏表达行为的方式等。&lt;/p&gt;
&lt;p&gt;Angular不同。Angular通过directives来使用DOM，而不是字符串模板。它的结果是一个将linking函数，将与scope model结合起来产生实时动态的view。view和scope model的绑定是透明的，开发者无须参与即可更新view。因为不需要使用&lt;code&gt;innerHTML&lt;/code&gt;，所以不会因为替换数据而丢失用户的输入。还有，angular的directive不仅包含文本绑定，还提供了有与行为相关的结构。（这点难翻）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1225-3.png&quot;&gt;&lt;img src=&quot;/user_images/1225-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Angular的做法可以产生稳定的DOM。绑定到model示例上的DOM元素，在绑定期间不会改变。这意味着，代码可以持有元素，在上面注册事件处理器，但不必担心在模板数据合并时，这些引用会被破坏。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>02. 起步程序</title>
                <link>http://freewind.in/posts/1220-angularjs-02-bootstrap</link>
                <pubDate>Tue, 01 Jan 2013 16:23:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1220</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/docs/content/guide/bootstrap.ngdoc&quot;&gt;https://github.com/angular/angular.js/blob/master/docs/content/guide/bootstrap.ngdoc&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;概览&lt;/h3&gt;
&lt;p&gt;本页讲解Angular的初始化过程，以及你在需要的时候如何手动初始化。&lt;/p&gt;
&lt;h3&gt;Angular的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签&lt;/h3&gt;
&lt;p&gt;下面这个例子是我们推荐的“自动初始化Angular”的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html xmlns:ng=&quot;http://angularjs.org&quot; ng-app&amp;gt;
  &amp;lt;body&amp;gt;
    ...
    &amp;lt;script src=&quot;angular.js&quot;&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;把&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签放在页面的底部。这样做可以减少页面的导入时间，因为HTML的导入过程不会因为导入&lt;code&gt;angular.js&lt;/code&gt;而阻塞。你可以从&lt;a href=&quot;http://code.angularjs.org/&quot;&gt;http://code.angularjs.org&lt;/a&gt;获取最新版的angularjs。注意，不要在你的生产环境的代码中引用这个url，因为这样做有安全问题。但是在开发过程中这么做是没问题的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*   `angular-[version].js`是一个未经压缩的版本，可读性好，适合开发及调试，但体积较大*   `angular-[version].min.js`是压缩过的版本，体积小，适合生产环境
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把&lt;code&gt;ng-app&lt;/code&gt;放在程序的根结点，如果你想让angularjs自动初始化你的程序，最好放在&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签中。
&lt;br  /&gt;&lt;html ng-app&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你想使用以前的指令(directive)风格&lt;code&gt;ng:&lt;/code&gt;，你需要在&lt;code&gt;html&lt;/code&gt;中包含xml-namespace以兼容IE。（我们不推荐使用&lt;code&gt;ng:&lt;/code&gt;，写在这里仅仅是因为历史原因）
&lt;br  /&gt;&lt;html xmlns:ng=&quot;http: //angularjs.org&quot;&gt;&lt;/p&gt;
&lt;h3&gt;自动初始化&lt;/h3&gt;
&lt;p&gt;Angular在&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件时自动初始化，此时它会寻找&lt;code&gt;ng-app&lt;/code&gt;这个表示根程序的directive。找到了，则:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入该directive关联的module&lt;em&gt;   创建程序injector&lt;/em&gt;   把&lt;code&gt;ng-app&lt;/code&gt;这个directive当作程序的根来编译DOM。这样允许你仅仅把页面中的一部分当作交给Angular
&lt;br  /&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html ng-app=&quot;optionalModuleName&quot;&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I can add: {{ 1+2 }}.
&amp;lt;script src=&quot;angular.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;h3&gt;手动初始化&lt;/h3&gt;
&lt;p&gt;如果你需要对初始化过程进行更多的控制，你可以手动调用初始化方法。当你想使用一个第三方的script loaders来管理导入（如headjs等），或者想在Angularjs初始化页面之前先执行某些操作的时候，你可能需要手动初始化。&lt;/p&gt;
&lt;p&gt;这里是一个手动初始化的示例。它与直接使用&lt;code&gt;ng-app&lt;/code&gt;的directive效果相同。&lt;/p&gt;
&lt;p&gt;&lt;!doctype html&gt;
&lt;br  /&gt;&lt;html xmlns:ng=&quot;http: //angularjs.org&quot;&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello {{&apos;World&apos;}}!
&amp;lt;script src=&quot;http://code.angularjs.org/angular.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
   angular.element(document).ready(function() {
     angular.bootstrap(document);
   });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你的代码应该遵循以下顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当页面和所有代码导入完毕后，寻找HTML模板的根，它通常也是文档的根2.  调用&lt;code&gt;bootstrap&lt;/code&gt;方法来编译模板，把它变成一个可执行的、双向绑定的程序&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>01. 概览</title>
                <link>http://freewind.in/posts/1219-angularjs-01-overview</link>
                <pubDate>Tue, 01 Jan 2013 15:59:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1219</guid>
                <description><![CDATA[&lt;h2&gt;Angular是什么&lt;/h2&gt;
&lt;p&gt;AngularJS是一个为动态网站而生的结构性的框架（这句太难翻了）。它让你使用HTML作为模板语言，可以扩展HTML的语法，从而以清晰高效的方式来实现程序的组件。它创造性地以数据绑定和依赖注入技术减少了我们需要写的大量代码。由于它完全在浏览器端以JavaScript实现，所以它可以和任何服务器端技术完美搭配。&lt;/p&gt;
&lt;p&gt;如果当初HTML被设计成开发应用程序的话，那它就应该是angularjs现在的样子。HTML是一种伟大的面向静态文档的声明式语言，但是它在创建应用程序方面欠缺很多，结果现在创建web程序就像是一种“我要做的，就是得用各种技巧哄着浏览器去做我想做的”的练习。&lt;/p&gt;
&lt;p&gt;为了弥补动态应用程序与静态文档之间的鸿沟，我们经常这么做：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;library&lt;/strong&gt; - 一组用来编写web程序的函数集。你的代码是主体，看到哪个库合适就调用哪个库。比如：&lt;code&gt;jQuery&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;frameworks&lt;/strong&gt; - 一个web程序的特殊实现，你往上填代码，补充细节。framework是主体，当它需要某些特定的与程序相关的东西，它会来调用你的代码。比如：&lt;code&gt;knockout&lt;/code&gt;,&lt;code&gt;sproutcore&lt;/code&gt;，等等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Angular不走寻常路。它通过创建新的HTML结构来填充文档与程序之间的空隙。Angular使用一种我们称为&quot;directive&quot;的结构来教会浏览器使用新的语法。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;{{}}&lt;/code&gt;进行数据绑定- 通过重复/隐藏DOM片断来控制DOM结构- 支持form和form验证- Attaching code-behind to DOM elements.- 将HTML分组形成可复用的组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;端到端的解决方案&lt;/h4&gt;
&lt;p&gt;Angularjs开箱提供了以下特色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有你创建一个CRUD程序所需要的工具：数据绑定，基本的模板指令(directive)，form验证，routing，deep-linking，可复用的组件，依赖注入- 可测试性：单元测试，端对端测试，mock，测试保护带- 预定义好目录结构和测试脚本的Seed程序作为快速起步项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Angular想成为一种创建web应用程序的“端到端”的解决方案。意思是说，它不是在“创建web程序“这块大拉图上的一小块，而是一种”端到端“的解决方案（这不没解释吗？）This makes Angular opinionated about how a CRUD application should be built（TODO不会翻）。但因为它重视意见，所以它尽量让自己成为一个起点，你可以随时改变它。&lt;/p&gt;
&lt;h4&gt;Angular的看点&lt;/h4&gt;
&lt;p&gt;Angular通过向开者者提供更高层次的抽象来简化程序开发。当然，也所有的抽象一样，复杂性是它的代价。换言之，不是每一个程序都适合用angularjs来做。Angular适合用来做CRUD程序，所幸的是，90%的web程序都是CRUD程序。为了了解Angular适合做什么，也必须了解Angular不适合做什么。&lt;/p&gt;
&lt;p&gt;游戏，GUI编辑器都是需要精细巧妙操作DOM的例子。这种程序跟CRUD差别太大，不适合用Angular。这种情况使用&lt;code&gt;jQuery&lt;/code&gt;可能更合适。&lt;/p&gt;
&lt;h4&gt;一个引导性的Angular示例&lt;/h4&gt;
&lt;p&gt;下面是一个包含了Form的典型的CRUD程序。表单的值需要验证，要计算总数，并且按用户的区域来显示格式。这些都是一个应用程序开发者可能需要面对的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把数据附加到UI上- 对用户输入进行读写和验证- 根据model计算新值- 根据用户指定的区域格式化输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;源代码&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html ng-app&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&quot;http://code.angularjs.org/angular-1.0.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;script.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div ng-controller=&quot;InvoiceCntl&quot;&amp;gt;
      &amp;lt;b&amp;gt;Invoice:&amp;lt;/b&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;br&amp;gt;
      &amp;lt;table&amp;gt;
       &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Quantity&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;Cost&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
       &amp;lt;tr&amp;gt;
         &amp;lt;td&amp;gt;&amp;lt;input type=&quot;integer&quot; min=&quot;0&quot; ng-model=&quot;qty&quot; required &amp;gt;&amp;lt;/td&amp;gt;
         &amp;lt;td&amp;gt;&amp;lt;input type=&quot;number&quot; ng-model=&quot;cost&quot; required &amp;gt;&amp;lt;/td&amp;gt;
       &amp;lt;/tr&amp;gt;
      &amp;lt;/table&amp;gt;
      &amp;lt;hr&amp;gt;
      &amp;lt;b&amp;gt;Total:&amp;lt;/b&amp;gt; {{qty * cost | currency}}
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;script.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;div class=&quot;mycode&quot;&amp;gt;
function InvoiceCntl($scope) {
  $scope.qty = 1;
  $scope.cost = 19.95;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;End to end test&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;it(&apos;should show of angular binding&apos;, function() {
  expect(binding(&apos;qty * cost&apos;)).toEqual(&apos;$19.95&apos;);
  input(&apos;qty&apos;).enter(&apos;2&apos;);
  input(&apos;cost&apos;).enter(&apos;5.00&apos;);
  expect(binding(&apos;qty * cost&apos;)).toEqual(&apos;$10.00&apos;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a jsfiddle demo (TODO)&lt;/p&gt;
&lt;p&gt;试试上面的实例，然后我们看看这个例子，描述一下发生了什么&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签，我们用&lt;code&gt;ng-app&lt;/code&gt;指令(directive)指明这是一个Angular程序。这个&lt;code&gt;ng-app&lt;/code&gt;将触发Angular自动初始化你的程序。&lt;/p&gt;
&lt;p&gt;我们使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签引入需要的angular文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;script src=&quot;http://code.angularjs.org/angular-?.?.?.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;标签的&lt;code&gt;ng-model&lt;/code&gt;属性，angular自动设置好了双向数据绑定。我们也演示了如何简单地对输入进行验证：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;Quantity: &amp;lt;input type=&quot;integer&quot; min=&quot;0&quot; ng-model=&quot;qty&quot; required &amp;gt;
Cost: &amp;lt;input type=&quot;number&quot; ng-model=&quot;cost&quot; required &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些input部件看起来相当普通，但考虑下这几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当页面导入后，angular把input的名字(&lt;code&gt;qty&lt;/code&gt;和&lt;code&gt;cost&lt;/code&gt;)绑定到变量上。可把这些变量想像成MVC设计模式中的Model&lt;/li&gt;
&lt;li&gt;注意这些input部件有特别的能力。当你输入了不合法的数据，或者留空它们时，它们会自动变成红色。这些新的行为，让这些部件实现CRUD程序中常见的字段验证变得简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，是这个神奇的&lt;code&gt;{{ 双层花括号 }}&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Total: {{qty * cost | currency}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;{{ _expression_ }}&lt;/code&gt;标记，是angularjs中用于数据绑定的特殊语法。表达式本身还可以为一个表达式与filter的组合：&lt;code&gt;{{ express | filter }}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Angular提供了filter用于格式化显示数据。&lt;/p&gt;
&lt;p&gt;在上面的例子中，双花括号表达式指示Angular：“把我们从input部件中取到的数据绑定到显示区，把它们乘起来，并把结果格式化成货币的形式输出”&lt;/p&gt;
&lt;p&gt;注意，我们实现了这种功能，却没有调用过Angular的方法，也没有像框架那样实现与程序紧密相关的行为。我们让浏览器的行为更像是动态web程序需要的，而不是静态文件需要的。因为不需要调用library/framework，Angular降低了这种阻抗不匹配。&lt;/p&gt;
&lt;h4&gt;Anguar信仰&lt;/h4&gt;
&lt;p&gt;Angular坚信对于构建UI和拼装组件，声明式的代码比命令式的更好，命令式的代码更适合实现业务逻辑。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把DOM操作与逻辑代码分开是一个好主意。它将显著提高代码的可测试性。- 把测试与写程序看得同等重要是一个更好的主意。测试的难度将显著影响代码的结构。- 把客户端与服务器端分开是一个很好的主意。因为它允许两边并行开发，和重用- 如果框架可以在全程引导开发者，是非常有帮助的：从设计UI，到业务逻辑，到测试- 如果能让常见的任务简单化，让难事变得容易，总是好的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Angular让你从以下痛苦中解脱出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;注册回调函数&lt;/strong&gt;：注册回调函数让你的代码变得凌乱，让人难以看到代码的全貌。把像这样的繁冗的代码移除，既能减少你的JavaScript代码量，又能让代码看起来清晰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;手动操作DOM&lt;/strong&gt;: 操作HTML DOM是AJAX程序的基础，但它既笨重又容易出错。Angular以声明的方式描述“当程序状态变化时，UI应该怎么变”的功能，让你不需要再做这种底层的工作。用Angular写的大多数程序，根本不需要这些操作，当然，如果需要你也可以做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据与UI之间的交互&lt;/strong&gt;: CRUD操作是AJAX程序的主要工作。考虑一下数据从server到HTML form的流程，我们要允许用户修改form，验证form，显示验证错误，将数据返回给内部model，再发送给server，这将会产生大量繁冗的代码。Angular几乎可省去全部这种代码，只剩下描述流程的代码，而不用管细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;大量初始化工作&lt;/strong&gt;: 通常你需要写大量的起始代码才能写一个简单的&quot;Hello World&quot;的AJAX程序。使用Angular，你可以使用与&lt;a href=&quot;http://code.google.com/p/google-guice/&quot;&gt;guice&lt;/a&gt;相似的风格来写代码，使用由Angular提供的大量services对象。这可以让你快速开发新的功能。另外，在自动化测试中，你拥有初始化阶段的完全控制权。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;播放Angular的一个宣传片&lt;/h4&gt;
&lt;p&gt;这个宣传片比较早，不过可以注意到在2010年６月，angularjs就已经处于充实的开发期了。&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>AngularJs Tutorial 中文版(1)</title>
                <link>http://freewind.in/posts/1216-angularjs-tutorial-cn-1</link>
                <pubDate>Tue, 01 Jan 2013 11:59:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1216</guid>
                <description><![CDATA[&lt;p&gt;学习AngularJS的一个好办法，就是在这份简明教程的帮助下，动手实现一个简单的AngularJS web程序。该程序以分类方式来显示一些Andorid设备，你可以筛选出感兴趣的设备，并查看某个设备的详细资料。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1216-1.png&quot;&gt;&lt;img src=&quot;/user_images/1216-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Angular可以让你的浏览器更好更强大（不需要用浏览器插件或者扩展程序）。当你阅读这份教程时，你将会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看到示例演示如何使用client-side的数据绑定和依赖注入来创建动态的数据视图，当用户进行操作后，相应数据视图会立刻跟着变化&lt;/li&gt;
&lt;li&gt;看到Angular如何监听数据的变化，但不需要操作DOM&lt;/li&gt;
&lt;li&gt;学习到一种更好更简单的方法来测试你的web程序&lt;/li&gt;
&lt;li&gt;学习如何使用Angular提供的服务，来更轻松地实现常见的web任务，如把数据嵌入到程序中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它们可以在任何浏览器中工作，不需要对浏览器做任何改变！&lt;/p&gt;
&lt;p&gt;当你完成了这份“简明教程”后，你可以做到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立一个可以运行于任意浏览器中的动态程序&lt;/li&gt;
&lt;li&gt;了解AngularJs与其它JavaScript框架之间的区别&lt;/li&gt;
&lt;li&gt;理解AngularJs中的数据绑定是如何工作的&lt;/li&gt;
&lt;li&gt;使用angular-seed项目快速搭建你自己的项目&lt;/li&gt;
&lt;li&gt;编写并运行测试&lt;/li&gt;
&lt;li&gt;自行找到更多的资源来进一步学习AngularJS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该教程将带领你走完创建一个简单web程序的全过程，甚至包括如何编写和运行end-to-end的测试。每一步最后的实验将向你提供一些建议，帮助你学习更多AngularJS的知识，和理解你正在创建的程序。&lt;/p&gt;
&lt;p&gt;你只需要花几个小时就能看完这整份文档，或者花一天时间来享受深入研究它的乐趣。如果你在寻找一份更简短的AngularJS介绍，请看新手指南。&lt;/p&gt;
&lt;h2&gt;示例代码在哪儿&lt;/h2&gt;
&lt;p&gt;在你阅读这份教程的时候，你可以在Mac/Linux/Windows上，亲手编写运行示例代码。你可以使用Git版本控制工具从github上来获取和管理示例，或者用一个脚本把最新的项目文件复制到你的工具目录中。&lt;/p&gt;
&lt;p&gt;从下面的几种方式中，选择一种适合你的方式，先把工作环境搭好。&lt;/p&gt;
&lt;h2&gt;在Mac/Linux上使用Git&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;检查你电脑上是否安装了java。在命令行中输入以下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;mycode&quot;&gt;java -version&lt;/div&gt;
&lt;p&gt;Java用来跑单元测试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从Git官网上下载Git&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以从Git源代码编译，或者使用预编译的包。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用以下命令，从github上clone我们的示例项目angular-phonecat的仓库到本机：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;git clone git://github.com/angular/angular-phonecat.git&lt;/p&gt;
&lt;p&gt;该命令将在你当前目录下建立一个angular-phonecat目录，并把文件放置其中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入angular-phonecat目录:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cd angular-phonecat&lt;/p&gt;
&lt;p&gt;在本教程中，都假设你的命令运行于angular-phonecat目录下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你需要在本机运行一个http服务器。 Mac和Linux通常都预装了apahce。如果你的机子上没有，你也可以安装node.js. 使用node来运行angular-phonecat目录下的scripts/web-server.js文件即可，它是一个简单的http server。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;在Windows上使用Git&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;你需要使用java来运行单元测试，所以运行以下命令来检查你的电脑上是否安装了java，并且它位于环境变量的PATH中。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;mycode&quot;&gt;java -version&lt;/div&gt;
&lt;p&gt;&lt;p&gt;
&lt;br  /&gt;如果没有，请到java官网上下载安装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从Git官网下载并安装msysGit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开msysGit的命令行工具并从Github上clone下angular-phonecat仓库。使用以下命令：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;mycode&quot;&gt;git clone git://github.com/angular/angular-phonecat.git&lt;/div&gt;
&lt;p&gt;该命令将在你当前目录下建立一个angular-phonecat目录，并把文件放置其中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入angular-phonecat目录:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;mycode&quot;&gt;cd angular-phonecat&lt;/div&gt;
&lt;p&gt;&lt;p&gt;
&lt;br  /&gt;在本教程中，都假设你的命令运行于angular-phonecat目录下。&lt;/p&gt;
&lt;p&gt;你应该在msysGit的命令行工具中，运行所有的git命令。&lt;/p&gt;
&lt;p&gt;而其它的命令（比如test-server.bat或test.bat）可以直接在windows的命令行中执行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你的系统上需要运行一个http服务器。如果没有的话，可以下载node.js。确保nodejs\bin已经加入到环境变量的PATH中。然后使用node来运行angular-phonecat下的scripts\web-server.js，来启动一个简单的内置服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;在Mac/Linux上使用Snapshots&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;检查你电脑上是否安装了java。在命令行中输入以下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;mycode&quot;&gt;java -version&lt;/div&gt;
&lt;p&gt;Java用来跑单元测试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载包含了最新文件的zip包，并把它解压到某目录下（假设为tutorial-dir）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入tutorial-dir/sandbox目录:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cd tutorial-dir/sandbox&lt;/p&gt;
&lt;p&gt;在本教程中，都假设你的命令运行于sandbox目录下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你需要在本机运行一个http服务器。 Mac和Linux通常都预装了apahce。如果你的机子上没有，你也可以安装node.js. 使用node来运行angular-phonecat目录下的scripts/web-server.js文件即可，它是一个简单的http server。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;在Windows上使用Snapshots&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;你需要使用java来运行单元测试，所以运行以下命令来检查你的电脑上是否安装了java，并且它位于环境变量的PATH中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java -version&lt;/p&gt;
&lt;p&gt;如果没有，请到java官网上下载安装。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载包含了最新文件的zip包，并把它解压到某目录下（假设为tutorial-dir）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入tutorial-dir/sandbox目录:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;cd tutorial-dir/sandbox&lt;/p&gt;
&lt;p&gt;在本教程中，都假设你的命令运行于sandbox目录下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你的系统上需要运行一个http服务器。如果没有的话，可以下载node.js。确保nodejs\bin已经加入到环境变量的PATH中。然后使用node来运行angular-phonecat下的scripts\web-server.js，来启动一个简单的内置服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后需要确定的是，你的电脑上要有一个浏览器和一个编辑器。&lt;/p&gt;
&lt;p&gt;现在，让我们开始做一些很酷的事情吧！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>有关Android的一些链接</title>
                <link>http://freewind.in/posts/1213-android-resources</link>
                <pubDate>Tue, 01 Jan 2013 11:44:13 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1213</guid>
                <description><![CDATA[&lt;p&gt;Android 和 OpenCV：&lt;/p&gt;
&lt;p&gt;http://opencv.org/platforms/android.html &lt;a href=&quot;http://underthehood.blog.51cto.com/2531780/670169&quot;&gt;http://underthehood.blog.51cto.com/2531780/670169&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android版本号与API版本号对应关系&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels&quot;&gt;http://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;收集一个Android开发的教程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.vogella.com/articles/Android/article.html#overview_manifest&quot;&gt;http://www.vogella.com/articles/Android/article.html#overview_manifest&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>我在stackoverflow上android提问与收藏</title>
                <link>http://freewind.in/posts/1212-my-android-questions-on-stackoverflow</link>
                <pubDate>Tue, 01 Jan 2013 11:42:44 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1212</guid>
                <description><![CDATA[&lt;p&gt;我的提问&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12137527/what-technologies-should-i-use-to-create-an-postcard-android-app&quot;&gt;What technologies should I use to create an postcard android app?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12156171/imageview-will-reset-to-original-state-after-rotating&quot;&gt;ImageView will reset to original state after rotating?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12156891/get-the-image-after-rotating-from-imageview&quot;&gt;Get the image after rotating from ImageView&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12159852/why-this-image-switching-code-has-memory-leak&quot;&gt;Why this image-switching code has memory leak?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12163801/rotate-an-image-multiple-times-but-keep-the-corners-aligned&quot;&gt;Rotate an image multiple times but keep the corners aligned&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我的收藏&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4486034/get-root-view-from-current-activity&quot;&gt;Get root view from current activity&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3042961/how-can-i-get-the-resource-id-of-an-image-if-i-know-its-name&quot;&gt;How can i get the resource id of an image if I know its name?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4617898/how-can-i-give-imageview-click-effect-like-a-button-in-android&quot;&gt;How can i give imageview click effect like a button in Android?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2082707/android-multitouch-possible-to-test-in-emulator&quot;&gt;Android Multitouch - Possible to test in emulator?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1949066/java-lang-outofmemoryerror-bitmap-size-exceeds-vm-budget-android&quot;&gt;java.lang.OutOfMemoryError: bitmap size exceeds VM budget - Android&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2298208/how-to-discover-memory-usage-of-my-application-in-android&quot;&gt;How to discover memory usage of my application in Android&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3035692/how-to-convert-a-drawable-to-a-bitmap&quot;&gt;How to convert a Drawable to a Bitmap?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4166917/android-how-to-rotate-a-bitmap-on-a-center-point&quot;&gt;Android: How to rotate a bitmap on a center point&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3263611/border-for-an-image-view-in-android&quot;&gt;Border for an Image view in Android?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4207067/how-to-implement-touch-listener-on-image&quot;&gt;How to implement touch listener on image?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>我这两天搞的一个图片操作的示例项目</title>
                <link>http://freewind.in/posts/1211-an-android-demo-sample-to-operate-images</link>
                <pubDate>Tue, 01 Jan 2013 11:41:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1211</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;https://github.com/freewind/Android-RotateTest&quot;&gt;https://github.com/freewind/Android-RotateTest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要功能：旋转，平移，缩放，捕获图片，用手触屏移动图片。基本上图片的常用操作都包括了。&lt;/p&gt;
&lt;p&gt;搞了两天，遇到无数问题，好在终于差不多都解决了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Android中可以对图片进行哪些效果处理？</title>
                <link>http://freewind.in/posts/1210-android-image-effects</link>
                <pubDate>Tue, 01 Jan 2013 11:40:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1210</guid>
                <description><![CDATA[&lt;p&gt;可以确定的是：亮度调整、对比度调整&lt;/p&gt;
&lt;p&gt;其它的不知道有哪些，像模糊、锐化、素描什么的。&lt;/p&gt;
&lt;p&gt;效果还真不少呢：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/android/hardware/Camera.Parameters.html#EFFECT_AQUA&quot;&gt;http://developer.android.com/reference/android/hardware/Camera.Parameters.html#EFFECT_AQUA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过不清楚每一种代表什么效果，得做个程序演示一下。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>一个很强的多平台通用的图片效果库</title>
                <link>http://freewind.in/posts/1209-a-powerful-cross-platform-image-effect-library-aviary</link>
                <pubDate>Tue, 01 Jan 2013 11:40:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1209</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://www.aviary.com/&quot;&gt;http://www.aviary.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提供了很多图片增强效果，以及对图片减切、变形的功能。有一个很吸引人的功能是同时提供了iphone, android, wphone, web的支持。&lt;/p&gt;
&lt;p&gt;需要申请一个key，免费版有功能限制。&lt;/p&gt;
&lt;p&gt;免费版不方便的地方有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编辑图片时，最后一个tab是about this editor，点击后会跳出程序，返回不方便2.  不能把这些功能集成到自己的程序中，比如想在上面增加一个“相框”就不行，只能在选择图片时使用它提供的编辑器，弄好后再放回来。（需要确认）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有一个叫“湖畔”的应用(iphone下，android中没去找），使用了这个库，可以下载看看效果。&lt;/p&gt;
&lt;p&gt;关于license，看这个页面：&lt;a href=&quot;http://www.aviary.com/licensing&quot;&gt;http://www.aviary.com/licensing&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>关于LOMO（怀旧）风格的效果</title>
                <link>http://freewind.in/posts/1208-android-lomo-effect</link>
                <pubDate>Tue, 01 Jan 2013 11:40:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1208</guid>
                <description><![CDATA[&lt;p&gt;客户指定要实现LOMO风格，android自带的库中没有。aviary.com中有这个效果，不过不一定用它。&lt;/p&gt;
&lt;p&gt;所以先找一些资料记下来，说不定以后要自己写算法了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;LOMO是什么：&lt;a href=&quot;http://baike.baidu.com/view/18671.htm&quot;&gt;http://baike.baidu.com/view/18671.htm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用photoshop实现LOMO：&lt;a href=&quot;http://tutorialpulse.com/photoshop-tutorials/lomo/&quot;&gt;http://tutorialpulse.com/photoshop-tutorials/lomo/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LOMO算法：&lt;a href=&quot;http://stackoverflow.com/questions/6633231/is-there-any-library-implementing-the-color-effect-like-lomography&quot;&gt;http://stackoverflow.com/questions/6633231/is-there-any-library-implementing-the-color-effect-like-lomography&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个国人的项目实现了LOMO，可惜算法不够快，示例中的图片要经过四五秒才能处理完：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ragnraok/android-image-filter&quot;&gt;https://github.com/ragnraok/android-image-filter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外产生的LOMO效果不是很好，周围的黑圈太重了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>国人的效果库</title>
                <link>http://freewind.in/posts/1207-an-android-effect-lib-from-chinese</link>
                <pubDate>Tue, 01 Jan 2013 11:39:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1207</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;https://github.com/ragnraok/android-image-filter&quot;&gt;https://github.com/ragnraok/android-image-filter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面提供了十三种特效，算法都是作者自己写的，可以用来学习&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用真机测试android程序</title>
                <link>http://freewind.in/posts/1205-use-phone-to-test-android-app</link>
                <pubDate>Tue, 01 Jan 2013 11:34:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1205</guid>
                <description><![CDATA[&lt;p&gt;之前一直使用模拟器，但无法测试触屏操作：比如想把一张图片拉大，在模拟器上就没法做。&lt;/p&gt;
&lt;p&gt;Idea/eclipse都支持直接把程序发布到usb设备上，所以使用真机测试也一样方便。&lt;/p&gt;
&lt;p&gt;但我在使用真机时，遇到了一些麻烦，弄了一上午才搞好，特记录一下：&lt;/p&gt;
&lt;h2&gt;我的环境&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Windows 7 x642.  Android平板：智器ten3, android 4.0&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;把平板连接到电脑上&lt;/h2&gt;
&lt;p&gt;Android连接到电脑上，比想像中的麻烦，因为它与电脑之间传输，使用的是mtp协议，而不像U盘那样插上去就直接能用。&lt;/p&gt;
&lt;p&gt;有一些注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装Windows media player 11。如果在winxp下，需要安装这个，因为它才支持那个什么协议。如果是在win7下，就不用了，已自带。2.  平板上有一个&quot;usb调试&quot;的选项。如果关闭它，操作系统会把它当作一种设备；如果开启它，又会把它当作另一种设备。所以需要安装两种驱动。对于我们开发人员来说，要打开&quot;usb调试&amp;rdquo;，这时操作系统会安装mtp驱动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不知道为什么，我的win7 x64在安装mtp驱动时，总是提示失败，搞了一上午。网上也能搜出一大堆同样的问题，后来我照着这个网页&lt;a href=&quot;http://www.tomshardware.com/forum/242140-44-device-refuses-installed-please&quot;&gt;http://www.tomshardware.com/forum/242140-44-device-refuses-installed-please&lt;/a&gt;的bestanswer安装了这个：mtppk12.exe，还是不行，非常泄气。正准备放弃的时候，看到有人提示可以重启一下android设备，于是重启了一下平板，奇迹出现了，一下子全都安装好了！&lt;/p&gt;
&lt;p&gt;期间使用了腾讯的手机精灵和豌豆夹，都提示设备离线，无法连接，而现在都能连进去管理了！&lt;/p&gt;
&lt;h2&gt;使用idea直接发布项目&lt;/h2&gt;
&lt;p&gt;打开idea，打开之前的一个项目，修改发布配置，改为“发布到usb设备“，然后点击发布按钮。但失败了，控制台上输出：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;Failure [INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES]&lt;/div&gt;
&lt;p&gt;在这里找到了答案：&lt;a href=&quot;http://stackoverflow.com/questions/3185444/how-to-deal-with-install-parse-failed-inconsistent-certificates-without-uninstal&quot;&gt;http://stackoverflow.com/questions/3185444/how-to-deal-with-install-parse-failed-inconsistent-certificates-without-uninstal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原来我之前已经在平板上，通过http下载方式安装了这个程序，把它卸载后，再点发布按钮，就成功了！&lt;/p&gt;
&lt;p&gt;使用真机的速度，比在电脑上使用模拟器还要快一些，而且没有任何不便之处，推荐使用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>多点触控是个难点</title>
                <link>http://freewind.in/posts/1204-multitouch-is-hard-on-android</link>
                <pubDate>Tue, 01 Jan 2013 11:32:45 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1204</guid>
                <description><![CDATA[&lt;p&gt;OnTouchListener可用来监听屏幕的touch事件，事件数据使用MotionEvent类，它里面包含了以下数据：有几个点，每个点的坐标，判断当前行为（落下、移动、抬起）。&lt;/p&gt;
&lt;p&gt;难点在于如何通过MotionEvent中的相关数据，准确判断当前的行为。如果不能&lt;strong&gt;准确&lt;/strong&gt;判断，会导致所操作的图片出现闪动。&lt;/p&gt;
&lt;p&gt;考虑这样一个操作：窗口上显示了一张图片，用户可以用手指移动、放大缩小、旋转它。既可以一个手指，又可以多个手指（两个或更多），如何让图片的处理既符合用户的期望，又很流畅呢？&lt;/p&gt;
&lt;p&gt;比如移动图片，用户既可以一个手指，又可以多个。如果是多个的话，在移动过程中，手指之间的位置还可能发生变化。&lt;/p&gt;
&lt;p&gt;比如放大缩小图片，如果用户使用多个手指，在放大时以哪些手指为准？&lt;/p&gt;
&lt;p&gt;这篇文章非常好，一定要好好看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://android-developers.blogspot.com/2010/06/making-sense-of-multitouch.html&quot;&gt;http://android-developers.blogspot.com/2010/06/making-sense-of-multitouch.html&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>LogCat有什么特别的地方？</title>
                <link>http://freewind.in/posts/1203-is-there-any-special-about-logcat</link>
                <pubDate>Tue, 01 Jan 2013 11:32:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1203</guid>
                <description><![CDATA[&lt;p&gt;在android中，记录日志时用:&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;`Log.i(&quot;tag&quot;, &quot;message&quot;);`&lt;/div&gt;
&lt;p&gt;在很多地方提到这好像是LogCat，为什么会给它一个专门的词，它有什么特别的地方吗？现在看来，只是它在android模拟机或者真机上运行时，会把log信息发回到idea的控制台。很有用，不过不知道是不是还有别的功能。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在Eclipse下用Scala开发Android程序</title>
                <link>http://freewind.in/posts/1202-use-scala-to-dev-android-with-eclipse</link>
                <pubDate>Tue, 01 Jan 2013 11:31:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1202</guid>
                <description><![CDATA[&lt;p&gt;(此文是唐古拉山写的)&lt;/p&gt;
&lt;h2&gt;一、 Why Scala？&lt;/h2&gt;
&lt;p&gt;最直接的想法就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先把Scala当作更好的Java用&lt;/li&gt;
&lt;li&gt;保护好对Scala语言的已有投资&lt;/li&gt;
&lt;li&gt;看看别人怎么说：&lt;a href=&quot;http://www.slideshare.net/jakub.kahovec/scala-on-android-12657430&quot;&gt;Scala on Android&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;二、 Why Eclipse?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;已经习惯了Eclipse&lt;/li&gt;
&lt;li&gt;Scala-IDE for Eclipse 有了很大改进&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;三、 配置环境&lt;/h2&gt;
&lt;h2&gt;3.1 下载安装android-sdk&lt;/h2&gt;
&lt;p&gt;下载页面： &lt;a href=&quot;http://developer.android.com/sdk/index.html。&quot;&gt;http://developer.android.com/sdk/index.html。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过SDK Manager按需下载相关的packages。（我这里主要有Tools, Android 4.1, Android 2.2, Extras/Android support library）&lt;/p&gt;
&lt;p&gt;使用AVD Manager创建一个avd, Target为Android 4.1, 选中SNAPSHOT为enabled&lt;/p&gt;
&lt;p&gt;将tools和platform-tools目录添加到PATH环境变量&lt;/p&gt;
&lt;h2&gt;3.2 安装Eclipse&lt;/h2&gt;
&lt;p&gt;使用Eclipse indigo JEE版, 下载页面是: &lt;a href=&quot;http://www.eclipse.org/downloads/packages/release/indigo/sr2&quot;&gt;http://www.eclipse.org/downloads/packages/release/indigo/sr2&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3.3 安装配置ADT plugin for Eclipse&lt;/h2&gt;
&lt;p&gt;具体说明参考 &lt;a href=&quot;http://developer.android.com/sdk/installing/installing-adt.html&quot;&gt;http://developer.android.com/sdk/installing/installing-adt.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Update Site是: &lt;a href=&quot;https://dl-ssl.google.com/android/eclipse/&quot;&gt;https://dl-ssl.google.com/android/eclipse/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3.4 安装Scala IDE for Eclipse&lt;/h2&gt;
&lt;p&gt;使用Scala IDE 2.1 Milestone 1版， 参考http://scala-ide.org/download/milestone.html#scala_ide_21_milestone_1&lt;/p&gt;
&lt;p&gt;我使用的是For Scala2.9.x的版本, Update Site 是：&lt;a href=&quot;http://download.scala-ide.org/releases-29/milestone/site&quot;&gt;http://download.scala-ide.org/releases-29/milestone/site&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3.5 安装AndroidProguardScala Nature&amp;rdquo;&lt;/h2&gt;
&lt;p&gt;AndroidProguardScala这个插件集成了Proguard, 主要用来去掉工程依赖包中用不到的类， 有了它，就算引入Scala运行时库和其他依赖包， 也能保证发布包apk足够的苗条(等下我们通过一个实际的工程来验证)&lt;/p&gt;
&lt;p&gt;安装方式参考https://github.com/banshee/AndroidProguardScala&lt;/p&gt;
&lt;p&gt;Update Site是：&lt;a href=&quot;https://androidproguardscala.s3.amazonaws.com/UpdateSiteForAndroidProguardScala&quot;&gt;https://androidproguardscala.s3.amazonaws.com/UpdateSiteForAndroidProguardScala&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;四、用Scala写个HelloWorld Android应用&lt;/h2&gt;
&lt;h2&gt;4.1 使用向导创建Android工程并配置&lt;/h2&gt;
&lt;p&gt;使用Eclipse向导创建一个&quot;Android Applicaton Project&amp;rdquo;, 选择创建一个Blank Activity即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给工程添加&quot;Scala Nature&amp;rdquo;: 工程, 右键 -&gt; Configure -&gt; Add Scala Nature&lt;/li&gt;
&lt;li&gt;给工程添加&quot;AndroidProguardScala Nature&amp;rdquo;: 工程, 右键 -&gt; Add AndroidProguardScala Nature&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4.2 相关代码&lt;/h2&gt;
&lt;p&gt;修改res/layout/activity_main.xml, 给TextView设置一个id android:id=&amp;ldquo;@+id/hello&amp;rdquo;&lt;/p&gt;
&lt;p&gt;将MainActivity.java删除, 用Scala重写&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;mycode&quot;&gt;&lt;/p&gt;
&lt;p&gt;package com.example.helloworld&lt;/p&gt;
&lt;p&gt;import android.os.Bundle
&lt;br  /&gt;import android.app.Activity
&lt;br  /&gt;import android.view.Menu
&lt;br  /&gt;import android.widget.TextView&lt;/p&gt;
&lt;p&gt;class MainActivity extends Activity {&lt;/p&gt;
&lt;p&gt;override def onCreate(savedInstanceState: Bundle) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;super.onCreate(savedInstanceState)      
setContentView(R.layout.activity_main)      
val hello = findViewById(R.id.hello).asInstanceOf[TextView]      
hello.setText(hello.getText + &quot; 世界!&quot;)      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;override def onCreateOptionsMenu(menu: Menu): Boolean = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getMenuInflater().inflate(R.menu.activity_main, menu)      
true      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;4.3 运行&lt;/h2&gt;
&lt;p&gt;工程右键 -&gt; Run As -&gt; Android Application&lt;/p&gt;
&lt;p&gt;默认会使用之前创建的Android Virtual Device 仿真器运行&lt;/p&gt;
&lt;h2&gt;4.4 导出apk&lt;/h2&gt;
&lt;p&gt;工程右键 -&gt; Android Tools -&gt; Export Singed Application Package &amp;hellip;, 按向导一步一步走即可.&lt;/p&gt;
&lt;p&gt;导出的apk大概300k, 可以与Java版的做一个对比, Java版的大概150K. Scala版的HelloWorld 体积上个人是可以接受的.&lt;/p&gt;
&lt;p&gt;有人将Android的samples用Scala重写, 然后专门做了一个对比, 详细信息请参考: &lt;a href=&quot;http://lampwww.epfl.ch/~michelou/android/library-code-shrinking.html&quot;&gt;http://lampwww.epfl.ch/~michelou/android/library-code-shrinking.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;五、 总结&lt;/h2&gt;
&lt;p&gt;用Scala开发Android应用算是走通了. 从上面看, 生成的apk体积方面完全不用担心, 至于像memory footprint等问题, 要等深入之后再来看.&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>fill_parent与match_parent是一个意思</title>
                <link>http://freewind.in/posts/1201-is-fill_parent-the-same-as-match-parent</link>
                <pubDate>Tue, 01 Jan 2013 11:25:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1201</guid>
                <description><![CDATA[&lt;p&gt;FILL_PARENT (renamed MATCH_PARENT in API Level 8 and higher)&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Android中的测试框架</title>
                <link>http://freewind.in/posts/1200-android-testings-frameworks</link>
                <pubDate>Tue, 01 Jan 2013 11:25:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1200</guid>
                <description><![CDATA[&lt;p&gt;写的那个可移动缩放旋转的ImageView有点复杂，出现很多bug。虽然花了大力气让数据可视，但测试起来还是很麻烦，偶尔会出现图片跳动的情况，一直找不到问题所在。&lt;/p&gt;
&lt;p&gt;所以找了一下Android下的测试框架，看看能不能解决问题。&lt;/p&gt;
&lt;p&gt;InstrumentationTestRunner: &lt;a href=&quot;http://developer.android.com/reference/android/test/InstrumentationTestRunner.html&quot;&gt;http://developer.android.com/reference/android/test/InstrumentationTestRunner.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方提供的测试类。好像不是很推荐。&lt;/p&gt;
&lt;p&gt;robotium: &lt;a href=&quot;http://code.google.com/p/robotium/&quot;&gt;http://code.google.com/p/robotium/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行时自动点击屏幕上的按钮，检查结果。由于是模拟用户操作，有点慢，一个测试可能要做半天。首页上有视频演示。&lt;/p&gt;
&lt;p&gt;Robolectric: &lt;a href=&quot;http://pivotal.github.com/robolectric/&quot;&gt;http://pivotal.github.com/robolectric/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可直接在IDE中就运行测试，速度非常快，就像之前的Java程序测试一样。&lt;/p&gt;
&lt;p&gt;calculon: &lt;a href=&quot;https://github.com/kaeppler/calculon&quot;&gt;https://github.com/kaeppler/calculon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Calculon is a testing DSL for Google Android。提供了一些好用的api&lt;/p&gt;
&lt;p&gt;我还没有试用，不知道哪个能符合我的需求，先记在这里。现在去试下Robolectric&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Robolectric例子跑通</title>
                <link>http://freewind.in/posts/1199-run-the-robolectric-examples</link>
                <pubDate>Tue, 01 Jan 2013 11:24:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1199</guid>
                <description><![CDATA[&lt;p&gt;Robolectric: &lt;a href=&quot;http://pivotal.github.com/robolectric/&quot;&gt;http://pivotal.github.com/robolectric/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android测试太慢了，每次发布再加上从头点起，最快也要1分钟才能开始手动测试，非常浪费时间。&lt;/p&gt;
&lt;p&gt;今天把这个跑通了，很简单，在junit中跑测试非常快，几秒钟就测完。&lt;/p&gt;
&lt;p&gt;使用方法不像官网上写的那么误导人，不需要maven，直接把robolectric-1.2-20120910.162821-126-jar-with-dependencies.jar和junit-xxx.jar拷到项目中，并且把它们两个上移到依赖的最上方即可。&lt;/p&gt;
&lt;p&gt;然后像下面写测试即可：&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;mycode&quot;&gt;&lt;/p&gt;
&lt;p&gt;import android.app.Activity;
&lt;br  /&gt;import android.widget.Button;
&lt;br  /&gt;import android.widget.TextView;
&lt;br  /&gt;import com.example.MyActivity;
&lt;br  /&gt;import com.example.R;
&lt;br  /&gt;import com.xtremelabs.robolectric.RobolectricTestRunner;
&lt;br  /&gt;import org.junit.Before;
&lt;br  /&gt;import org.junit.Test;
&lt;br  /&gt;import org.junit.runner.RunWith;&lt;/p&gt;
&lt;p&gt;import static org.hamcrest.core.IsEqual.equalTo;
&lt;br  /&gt;import static org.junit.Assert.assertThat;&lt;/p&gt;
&lt;p&gt;@RunWith(RobolectricTestRunner.class)
&lt;br  /&gt;public class MyActivityTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private MyActivity activity;      
private Button pressMeButton;      
private TextView results;

@Before     
public void setUp() throws Exception {      
    activity = new MyActivity();      
    activity.onCreate(null);      
    pressMeButton = (Button) activity.findViewById(R.id.press_me_button);      
    results = (TextView) activity.findViewById(R.id.results_text_view);      
}

@Test     
public void shouldUpdateResultsWhenButtonIsClicked() throws Exception {      
    pressMeButton.performClick();      
    String resultsText = results.getText().toString();      
    assertThat(resultsText, equalTo(&quot;Testing Android Rocks!&quot;));      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;目前只跑了它最基本的例子，没问题，不知道测复杂的功能时会怎么样。我现在在用ormlite写一些数据库测试的代码，这些东西要手动测的话麻烦死，希望能用这个测。等这两天写了测试后再过反馈过来。&lt;/p&gt;
&lt;p&gt;原理：Android上的vm跟电脑上的jvm不是一回事，按说是不能通用的。Robolectric是通过一些shadow类，模拟android的功能，拦截我们代码对于底层的调用，然后使用它提供的方法响应。这要才能做到在jvm上测android功能。&lt;/p&gt;
&lt;p&gt;据说它实现了大部分android的功能，也就是说，还有一部分没有实现，目前还不知道是哪些。希望我用到的都实现了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>SQLite: android上的orm</title>
                <link>http://freewind.in/posts/1198-android-orm-for-sqlite</link>
                <pubDate>Tue, 01 Jan 2013 11:22:50 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1198</guid>
                <description><![CDATA[&lt;p&gt;Android内置了sqlite作为数据库，但没有提供jdbc。它提供了一些类来执行sql的增删改，但对于查，却是提供了一个query方法，而不能直接通过sql查询（需验证）。&lt;/p&gt;
&lt;p&gt;这个query方法有七八个参数，用起来十分不方便。而有时候项目中需要的表还比较多（比如我这个明信片，在android上就需要十来个表），如果只用这个query，实在太低效了。&lt;/p&gt;
&lt;p&gt;这个时候还是得用orm。&lt;/p&gt;
&lt;p&gt;但Android上的vm跟jvm完全不一样，导致我们通常用的那些orm都不能用了，比如我最喜欢的Ebean。好在有些人写了一些轻量级的可用于anroid的orm，这个SQLite即是一个。&lt;/p&gt;
&lt;p&gt;另外还看到一个：&lt;a href=&quot;http://code.google.com/p/droidpersistence&quot;&gt;http://code.google.com/p/droidpersistence&lt;/a&gt;，这个是gpl3的，所以不推荐。&lt;/p&gt;
&lt;p&gt;Ormlite是自定的开源协议，没有要求商业开源，所以可以放心使用：&lt;a href=&quot;http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite_9.html#SEC70&quot;&gt;http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite_9.html#SEC70&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Ormlite的原因之一，是作者在stackoverflow上的贡献值已有 25k+，还是比较靠谱的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在电脑上运行的Android程序？</title>
                <link>http://freewind.in/posts/1197-how-to-run-android-apps-on-computer</link>
                <pubDate>Tue, 01 Jan 2013 11:21:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1197</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://www.bluestacks.com/&quot;&gt;http://www.bluestacks.com&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在x86上运行的android</title>
                <link>http://freewind.in/posts/1196-make-android-running-on-x86</link>
                <pubDate>Tue, 01 Jan 2013 11:20:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1196</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://android-x86.org&quot;&gt;http://android-x86.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android的emulator太慢了，因为它是arm架构的。android-x86项目是在x86上运行android，速度比较快，可用来代替emulator测试android程序。&lt;/p&gt;
&lt;p&gt;直接使用virtualbox建一个虚拟机，下载它的iso安装即可。&lt;/p&gt;
&lt;p&gt;参考这篇文章： &lt;a href=&quot;http://be-evil.org/create-an-x86-emulator-based-height-performance-android-develop-environment.html&quot;&gt;http://be-evil.org/create-an-x86-emulator-based-height-performance-android-develop-environment.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：上面这篇文章下载的是2.x，有点老了，我们下载最新的4.0的epc那款，如果选别的，可能安装不了。&lt;/p&gt;
&lt;p&gt;关于ip，跑起来后按alt+F1进行console, 运行：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;netcfg eth0 up     
netcfg eth0 dhcp      &lt;/div&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;mycode&quot;&gt;&lt;/p&gt;
&lt;p&gt;netcfg&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;可查看到分配的ip。&lt;/p&gt;
&lt;p&gt;我把它跑起来了，速度非常快，可惜的是鼠标控制很不方便，需要不断的按right-ctrl跳出。而且我要模拟的是800&amp;#215;1280的屏幕，我的显示度显示不下，调整时更加麻烦。我把一个显示器竖着，旋转显示方向后，可以完全显示了，可惜在这种情况下，鼠标完全无法控制，甚至想解个锁都解不了。&lt;/p&gt;
&lt;p&gt;真可惜。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Matrix中的z轴</title>
                <link>http://freewind.in/posts/1193-the-z-axis-of-matrix</link>
                <pubDate>Tue, 01 Jan 2013 11:18:22 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1193</guid>
                <description><![CDATA[&lt;p&gt;Matrix类在图形变换时很有用，《Pro Android Media》书的第55页有这样一段话：&lt;/p&gt;
&lt;p&gt;The Matrix class represents transformations with an array of nine numbers. In many cases, these can be generated by a formula that mathematically represents the transformation that should occur. For instance, the formula for rotation involves using sine and cosine to generate the number in the matrix.&lt;/p&gt;
&lt;p&gt;Each number in the Matrix applies to one of the three (x, y, or z) coordinates for each point in the image.&lt;/p&gt;
&lt;p&gt;For instance, here is a Matrix of nine floats:&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;mycode&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 0 0
&amp;lt;br /&amp;gt;0 1 0
&amp;lt;br /&amp;gt;0 0 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;有点不太明白，为什么会有z轴？难道它还可以处理立体的图像吗？&lt;/p&gt;
&lt;p&gt;书中第58页提到了一个wiki网页，讲了这种“矩阵变形”的原理：&lt;a href=&quot;http://en.wikipedia.org/wiki/Transformation_matrix&quot;&gt;http://en.wikipedia.org/wiki/Transformation_matrix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;晚点需要了解一下。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>推荐衡天小张的博客主机</title>
                <link>http://freewind.in/posts/1189-recomment-blog-host-from-hengtianxiaozhang</link>
                <pubDate>Mon, 31 Dec 2012 16:02:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1189</guid>
                <description><![CDATA[&lt;p&gt;在这里向大家推荐一下&lt;a href=&quot;http://my.hengtian.org/aff.php?aff=1312&quot;&gt;衡天小张的博客主机&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本博客使用的是他们提供的美国主机，已经一年多了，感觉很不错。虽然主机在国外，但在国内的访问速度还可以，基本都可以在1到2秒内打开。&lt;/p&gt;
&lt;p&gt;我之所以用的是国外主机，主要是因为嫌备案麻烦，前前后后得一个月。另外相对于国内主机，价格要便宜一些。&lt;/p&gt;
&lt;p&gt;我的这个是1G空间，月流量15G，可建3个站，一年100元，对于我来说还是可以接受的。刚看了一下，写了一年多的博客，才用了100多M，每月流量才2G（要加油啊），有需要的朋友可以去看看。&lt;/p&gt;
&lt;p&gt;另外，从其微博上看，近期在力推国内双线主机，最低的配置是300M/月流量6G，一年150元。我正在考虑补差价换成国内的，毕竟速度能更快一点。&lt;/p&gt;
&lt;p&gt;我对小张的主机还是比较满意的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;价格不贵，性价比高2.  主机稳定，很少出问题3.  访问速度不错4.  有事情能很快解决&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这一年多，好像只发现了一两次无法访问的情况，而且很快就解决了。相比我之前用过的一个（差不多两天一挂），真是天壤之别。&lt;/p&gt;
&lt;p&gt;如果你有购买博客主机的打算，不妨猛击右边的链接去看看：&lt;a href=&quot;http://my.hengtian.org/aff.php?aff=1312&quot;&gt;&lt;font color=&quot;#ff0000&quot; size=&quot;4&quot;&gt;衡天小张的博客主机&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐其主机也可以为我带来一点点佣金，虽然比较少（每月不到10元），不过能把自己觉得好的东西推荐给更多人使用，我觉得很开心。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用MathType输入数学符号</title>
                <link>http://freewind.in/posts/1183-use-mathtype-to-input-math-symbols</link>
                <pubDate>Fri, 28 Dec 2012 14:04:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1183</guid>
                <description><![CDATA[&lt;p&gt;在群里交流，各种数学符号是少不了的，特介绍一个非常好的数学软件，叫MathType。&lt;/p&gt;
&lt;p&gt;截图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1183-1.png&quot;&gt;&lt;img src=&quot;/user_images/1183-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面是各种各样的符号，下面是输入区。可以输入各种各样的公式：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1183-3.png&quot;&gt;&lt;img src=&quot;/user_images/1183-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意在中间有一个“标签”面板，可以把自己常用的拉到上面，方便使用。可先在输入区输入，然后用鼠标选中某个符号，把它拉上去即可：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1183-5.gif&quot;&gt;&lt;img src=&quot;/user_images/1183-5.gif&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每次从上面点一个符号非常不方便，可以把常用的，设置快捷键，这样输入起来就方便了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1183-7.gif&quot;&gt;&lt;img src=&quot;/user_images/1183-7.gif&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自从用了它，我连草稿纸都省了。因为用它打数学公式，比我在纸上画的还快还美观。&lt;/p&gt;
&lt;p&gt;软件已经传到“计算机数学”热情交流群（245125585）的群共享中。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>我的web开发最强组合：Play1+angularjs+bootstrap ++ (idea + livereload)</title>
                <link>http://freewind.in/posts/1167-my-most-powerful-tools-for-web-dev-play1-angularjs-bootstrap-idea-livereload</link>
                <pubDate>Wed, 26 Dec 2012 20:57:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1167</guid>
                <description><![CDATA[&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;800&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;107&quot;&gt;2012-12-26&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;693&quot;&gt;初稿，包含play1+angularjs+bootstrap+idea+livereload介绍&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;107&quot;&gt;2012-01-21&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;693&quot;&gt;添加了haxejs部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;107&quot;&gt;2013-01-28&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;693&quot;&gt;删除haxejs，添加typescript部分，并修改了在play1中使用angularjs的方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;107&quot;&gt;2013-01-30&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;693&quot;&gt;暂时不再使用typescript，因为相关工具不成熟&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;首先说明我开发web的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;个人开发&lt;em&gt;   前后端全部自己搞定&lt;/em&gt;   网站类型多为传统多页面程序&lt;em&gt;   注重开发效率&lt;/em&gt;   Javascritp能力不强*   美术细胞很少&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于每个人情况不同，选择技术及方案的重点也不同，所以内容仅供参考。对于我来说，这一套不论开发效率还是开发感受都是很好的。&lt;/p&gt;
&lt;h2&gt;一、编辑器&lt;/h2&gt;
&lt;p&gt;我选用的是idea Ultimate，它除了超强的java编辑功能之外，还提供了功能完善的play1和play2插件，angularjs插件，javascript/css编辑功能，让人开发时事半功倍。这里截几个图说明一下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot; width=&quot;782&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;**Play1支持**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;模板标签的提示与补全&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-1.png &quot;image&quot;)](/user_images/1167-1.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;href属性中，可提示controller及action&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-3.png &quot;image&quot;)](/user_images/1167-3.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;routes文件中的提示&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-5.png &quot;image&quot;)](/user_images/1167-5.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;html中play标签的高亮和格式化&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-7.png &quot;image&quot;)](/user_images/1167-7.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;从action中快速跳转到view&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-9.png &quot;image&quot;)](/user_images/1167-9.png)           
点击红框后自动打开：           
[![image](/user_images/1167-11.png &quot;image&quot;)](/user_images/1167-11.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;**Play2支持**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;因为我不使用play2，所以未实际测试过。不过play2支持作为idea12的卖点之一，其支持程度应该不会低于play1。详情可参看idea官网上的介绍。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;对于play2中scala模板的支持应该是很多人想要的&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-13.png &quot;image&quot;)](/user_images/1167-13.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;**Angularjs支持**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;html属性提示&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-15.png &quot;image&quot;)](/user_images/1167-15.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;**Bootstrap支持**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;idea没有对bootstrap有特别的支持，不过因为它本身对css的支持比较好，所以也可以方便的得到提示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;class提示&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;[![image](/user_images/1167-17.png &quot;image&quot;)](/user_images/1167-17.png)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;**Javascript支持**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;idea ultimate对javascript的支持非常强大，是我用过的编辑器中，对js支持最好的。不论是js文件，还是在html中嵌入的js代码，高亮、格式化、查错、提示等功能，都是一流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;234&quot;&gt;**css支持**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;546&quot;&gt;idea ultimate对css的支持也是非常强大&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;需要注意的是，上面提示的各功能，基本上都是idea ultimate才提供的（idea社区版中基本上没有上述功能）。如果你经济能力足够并且喜欢idea，不妨购买license对它进行支持；否则的话，自行google解决。&lt;/p&gt;
&lt;h2&gt;二、Live Reload&lt;/h2&gt;
&lt;p&gt;LiveReload是指当我们修改了项目中的文件时，浏览器会自动刷新，显示修改之后的效果。&lt;/p&gt;
&lt;p&gt;在开发网站时，这个功能非常有用。想想你面前开着两个显示器，中间这个是编辑器，旁边的那个是浏览器。每当修改了java/html/css/js代码时，手不离键盘、光标不离编辑区，浏览器就自动刷新了！只需要眼睛轻轻一瞟，脖子都不用动，就能看到修改之后的效果，这种感觉何等舒畅！钛合金的F5都不需要了！&lt;/p&gt;
&lt;p&gt;这种方式对于web框架有要求，首先是修改文件后不需要重启服务器。像纯html/php/rails都天生支持，java中某些框架支持，而play1的支持相当优秀。不论修改html/css/javascript，还是java源代码，甚至是配置文件，都不用重启，直接刷新浏览器了。刷新时间大约为1秒到4秒。&lt;/p&gt;
&lt;p&gt;另一点是：因为livereload检查到文件修改后，只会触发浏览器刷新一次，所以要保证一次刷新就可以看到修改后的效果。某些框架利用tomcat/jetty的自动重启，无法很好的配合livereload。因为还没有重启完时，livereload就刷新了，取得的可能还是修改前的页面，必须手动刷新多次才能确定看到的是修改后的效果。对于这种情况，livereload几乎没用。而play在刷新过程中，会阻塞http请求，可以保证一次刷新就拿到修改之后的页面。&lt;/p&gt;
&lt;p&gt;Livereload的官网是&lt;a href=&quot;http://livereload.com&quot;&gt;http://livereload.com&lt;/a&gt;，它支持mac/linux/windows，同时还有chrome/firefox的浏览器插件。它对windows的支持比较差，很容易崩溃，而且是收费的。所以我们只需要用它的浏览器插件就可以了（免费的），然后再找一个免费的替代器换掉服务器端。&lt;/p&gt;
&lt;p&gt;我选择的是：&lt;a href=&quot;https://github.com/lepture/python-livereload&quot;&gt;https://github.com/lepture/python-livereload&lt;/a&gt;，它是一个python程序，以命令行方式启动，可以跟livereload的浏览器插件通信，效果不错。注意最好从github中下载源代码安装，因为通过pip或easy_install安装的版本有点旧，使用过程中有问题。（不清楚现在是否已经更新）&lt;/p&gt;
&lt;p&gt;使用如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd myproject 
cd app 
livereload

然后启用浏览器的livereload插件即可。

来段gif演示一下（注意每次刷新都是我按了ctrl+s后自动触发的）:

[![image](/user_images/1167-19.gif &quot;image&quot;)](/user_images/1167-19.gif)

## 三、Why play, and why play1

参考我写的另一个日志：[http://freewind.me/blog/20120728/965.html](http://freewind.me/blog/20120728/965.html)

## 四、Why angularjs

曾经有一段时间，我对前端javascript框架很感兴趣，试用了很多，比如backbone/knockout/knockback/angularjs/...（以及一大堆已经忘了名字的），其中有两个让我印象深刻。一个是backbone，一个是angularjs。

Backbone的优点在于学习成本很低，与jquery的思路接近，偏向于底层及手动控制。采用backbone的项目比较多，资料也比较多，社区也比较大，还有一些基于backbone发展起来的高一级的框架（如[https://github.com/backbone-boilerplate/grunt-bbb](https://github.com/backbone-boilerplate/grunt-bbb)）。这个bbb我没有用过，只是在js群中有人说使用它之后，开发效率比之前纯backbone有很大的提高，所以这里提一下。对于技术较普通的团队来说，使用backbone可能会比较保险一些。

而angularjs则是一个让我感到惊艳的框架，相对于同类无数个mv**框架，它的优势达到了数量级。如果用几个词来形容它，应该是：学习成本高，开发效率高，写代码时思路流畅。

它拥有双向绑定、directive、直接改写html标签等特性，使用它你可以对现有的html标签进行改进和增强，甚至还可以重写一套完全属于自己的html标签。也许你会觉得像“双向绑定”这种烂大街的特性有什么值得拿出来说的，关键在于anguarljs的设计非常统一，各个功能搭配得很流畅、一气呵成。这种感觉就像是eclipse与idea在操作上的区别：idea虽然有很多功能eclipse也提供了，但是用起来总不像idea中那么流畅 &amp;amp;#8212; 不论编辑什么类型的文件，在idea中都可以使用非常类似的操作，得到非常类似的界面反馈。

Angularjs的学习成本比较高，主要原因是其设计思路与我们以前写jquery代码时有很大的不同，不能套用。Angularjs的核心思想就是“复用”，它的“复用”体现在&quot;directive&quot;上。Directive既是angularjs的核心，也是它的重点、难点和杀手级特性。简单的说，directive可以是一个自定义的html标签、或者属性、或者注释，它的背后是一些函数，可以对所在的html标签进行增强，比如修改html的dom内容，增强它的功能（如用第三方js插件包装它）。

编写Directive比较复杂，需要理解它的内部原理才能定义出自己的directive。在掌握它以前，以前一些很简单的事情可能都没办法做，容易让人沮丧。比如在使用jquery时，经常会这样操作：

$(&quot;#mydiv&quot;).dialog();

但这种写法在使用angularjs的html页面中，是无法使用的。你必须把它写成一个directive（比如ui-dialog），然后在它的postLink()方法中，对传入的element元素操作：

element.dialog()

如果不理解postLink的各参数以及它是如何被angularjs使用的话，很难写出来。所以在使用angularjs的前期，很容易被卡住。

在学习angularjs时，一定要细读官网提供的develop guide ([http://docs.angularjs.org/guide/](http://docs.angularjs.org/guide/))，把各章节读懂，知道angularjs的内部运行原理。千万别按jquery的方式学习，光看示例是绝对不够的。

Angularjs的另一个杀手级特性，就是把流程控制、事件绑定等代码，直接写在html标签上。这其实就是前面所说的directive的使用方式。先看一段代码：

[![image](/user_images/1167-21.png &quot;image&quot;)](/user_images/1167-21.png)

在这段html代码中，你可以看到那些位于html标签上由蓝色背影标出来的内容，都是angularjs提供的directive。有的是绑定事件（如ng-click,ng-submit），有的是控制流程（如ng-repeat）。这种方式我非常喜欢，简单直接，可读性又很好。当然有人不喜欢这种方式，认为html就应该干干净净，应该把这些东西分享到javascript中，就像下面这样：

$(&quot;form&quot;).submit(function() { ... });

其实对于这种情况，angularjs也有相似的做法，即为该form定义一个directive，比如my-add-form，然后把那些逻辑代码放到它里面：

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
&amp;lt;form my-add-form&amp;gt;...&amp;lt;/form&amp;gt; // js code 
module.directive(&quot;myAddForm&quot;, function() { 
    // the logic 
});
&amp;lt;/div&amp;gt;

不过这种方式对于一个不那么通用的逻辑来说有点重。所以我们通常还是采用在html标签上写控制，在controller中写逻辑的方式来做，通过合理的分配，在可读性与方便性之间取得平衡。

直接在标签上绑定事情处理函数，可以减少大量的命名，减少无谓代码，而且阅读起来更直观。想当初看backbone代码时，发现有二分之一的代码，都是通地css selector来获取元素，再将其某个事件与某个函数绑定起来。这样的代码一旦写完，html就不敢随便动了。因为若更改了html结构、id或者css class，这边的js代码都可能无法正常执行。

熟悉angularjs以后，会发现实现前端效果时，开发效率很高。在写html的同时，基本上就可以把大部分的交互效果写出来。同时，angularjs以model为中心，在编码时只需要考虑model。当改变了model的内容时，view就会自动更新，这可以让我们需要关注的东西更少。使用了angularjs后，你会发现html标签的表现力变强了，以前需要一些js插件实现的功能（比如简单的tab、tree等），使用angularjs几行代码就可以实现，而且所有的东西都是可定制的。

比如一个tab:

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
&amp;lt;div&amp;gt; 
    &amp;lt;a ng-click=&quot;tab=1&quot;&amp;gt;Tab1&amp;lt;/a&amp;gt; 
    &amp;lt;a ng-click=&quot;tab=2&quot;&amp;gt;Tab2&amp;lt;/a&amp;gt; 
    &amp;lt;a ng-click=&quot;tab=3&quot;&amp;gt;Tab3&amp;lt;/a&amp;gt; 
&amp;lt;/div&amp;gt;&amp;lt;div ng-show=&quot;tab==1&quot;&amp;gt;This is tab1&amp;lt;/div&amp;gt; 
&amp;lt;div ng-show=&quot;tab==2&quot;&amp;gt;This is tab2&amp;lt;/div&amp;gt; 
&amp;lt;div ng-show=&quot;tab==3&quot;&amp;gt;This is tab3&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

比如一个tree

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
&amp;lt;script type=&quot;ng/template&quot; id=&quot;&apos;node.html&apos;&quot;&amp;gt; 
    {{node.name}} 
    &amp;lt;ul&amp;gt; 
        &amp;lt;li ng-repeat=&quot;node in node.children&quot; ng-include=&quot;&apos;node.html&apos;&quot;&amp;gt;&amp;lt;/li&amp;gt; 
    &amp;lt;/ul&amp;gt; 
&amp;lt;/script&amp;gt;&amp;lt;ul&amp;gt; 
    &amp;lt;li ng-repeat=&quot;node in rootNodes&quot; ng-include=&quot;&apos;node.html&apos;&quot;&amp;gt;&amp;lt;/li&amp;gt; 
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;

我在做某个网站后台时，开始打算用angularjs，后来感觉功能比较简单，就直接采用jquery，少引用一个库。开始还好，很快就发现只要增加一点复杂的功能时，所花的时间就大大增加。如果同样的功能使用angularjs来写，会非常简单。

## 五、单页面程序以及前后端交互

一般认为前端mv**框架适合于单页面程序，无刷新、局部更新的那种。前后端完全分离，之间以restful api交互，使用json交换数据。在前端做好router，当点击了某个按钮需要展示新内容时，直接由前端获取并显示另一个局部html页面，同时调用某个restful api获取json数据填充。这种程序，通常前端的功能比较复杂，而对后端要求较少。采用这类mv**框架，前端程序员们可以充分发挥自己的才智，完全使用javascript/css/html来实现功能。而对于后台，只需知道restful api接口即可。这是前端mv**推荐的方式，也是目前来说比较好的方式。其特点是“**&amp;lt;font color=&quot;#c0504d&quot;&amp;gt;以前端js框架为主，后端为辅&amp;lt;/font&amp;gt;**”。

Anguarljs对于这种方式，有着非常好的支持。它除了提供前端router外，还提供了一些与后台交互的service，如与ajax相关的$http，与restful相关的$resource；对于cookie与本地存储支持也很好，基本上使用angularjs就可以把程序做完。后台可以使用各种语言、各种框架来提供restful api。比如，我尝试过couchdb这个数据库，它直接在数据库层面提供了restful api作为外界操作数据库的接口，angularjs与它配合起来，连服务端程序都不用了。

在开发android程序时，我也尝试过将phonegap与angularjs结合起来，直接使用angularjs来实现程序。与后台之间通过restful api交互。最后虽然因为性能要求改用了android原生方式，但对于普通的安卓或ios应用来说，这种方式是一种很好的选择，开发效率很高。

## 六、传统多页面程序

对于我来说，大部分的网站还是传统多页面的。比如一个信息管理系统的后台。这种情况下能否使用angularjs呢？

最开始的时候，我想采用单页面的方式来做，按照前面所说的流程。但是很快遇到了不少麻烦：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;页面跳转：这种网站页面很多，在前端定义比较麻烦，因为需要写长长的url，容易出错，检查也不方便。而使用play的模板引擎，可以直接写@{Controller.action(params)}，play会自动把它变为url，并且会检查是否有拼写错误，非常方便。2.  &lt;strike&gt;&lt;font color=&quot;#a5a5a5&quot;&gt;权限：页面上某些按钮的显示与隐藏，取决于当前用户的角色。所以每次显示某个新页面时，都需要后台传过来一些json数据，例如：{ buttons: [{show: true}, {edit: false}]}，来告诉前台显示或隐藏哪些按钮。有的时候这个操作非常繁琐。&lt;/font&gt;&lt;/strike&gt;3.  多次请求：当显示一个新页面时，可能需要多次请求。首先html模板一次，然后取json数据一次（或多次）。这样给人的感觉就有点慢。虽然可通过一些手段（如缓存html模板，为每一个请求返回一个大的合并过的json数据），但由于模板显示的时间与取得json数据的时间之间总有一些间隔，有时候还是会让人觉得不太流畅，卡。&lt;/p&gt;
&lt;p&gt;这几个问题我想了很久也没好办法，甚至打算放弃angularjs，还是采用以前完全由服务端生成页面的方式来做。好在最后改变了思路，“&lt;strong&gt;&lt;font color=&quot;#c0504d&quot;&gt;以后端框架为主，前端为辅&lt;/font&gt;&lt;/strong&gt;”，找到了比较好的办法。&lt;/p&gt;
&lt;h3&gt;使用play模板的继承、包含功能&lt;/h3&gt;
&lt;p&gt;我没有像angularjs推荐的那样，采用静态的html，而继续使用play模板引擎，因为它有两大好处：&lt;/p&gt;
&lt;h4&gt;在服务器端装配好最终的html页面&lt;/h4&gt;
&lt;p&gt;利用play的模板引擎，我们可以把模板分开为多个文件，使用#{extends/}和#{include/}等标签，来继承及包含另一个页面。这个过程是在服务器端完成的，发给前端的是一个单独的html页面。它可以减少html请求的次数，并且文件组织起来也很灵活。&lt;/p&gt;
&lt;p&gt;但如果我们用静态html来做，就有麻烦。如果将文件分为多个，使用ng-include包含，则它会产生一个新的html请求。这个请求将会在主页面处理完之后才请求，所以会有比较明显的延迟。另外，并且当页面分块较多时，很不方便。比如一个页面是“品”字型结构，顶端可以改变下面的页面，左边又能改变右边的页面，则在angularjs中不好实现，因为angularjs不支持嵌套的ng-view，只能用ng-include模拟，而这个过程是很繁琐的，并且可能产生更多的延迟性的请求。&lt;/p&gt;
&lt;h4&gt;可生成调用地址&lt;/h4&gt;
&lt;p&gt;使用前端mvc框架的另一个不方便的地方，就是配置routes很麻烦，这是全手动的过程。当页面很多并且有嵌套时，更加痛苦。但如果我们使用Play模板系统，则访问一个html页面还是得通过Play的action，这样就可以在服务器端生成一个js文件，找到这些入口，把它们对应的url算出来，传给前端直接用。前端要访问一个页面，只需要这样写：&lt;/p&gt;
&lt;ul&gt;
  &lt;li ng-repeat=&quot;user in users&quot;&gt;&lt;a ng-href=&quot;{{Users.show(user.id)}}&quot;&gt;{{user.name}}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意其中的&lt;code&gt;User.show()&lt;/code&gt;这个方法，它实际上是由后台生成的。它到底对应哪个url，在前台是完全不用操心的。哪怕以后url改了，但也丝毫不会影响页面中的代码，因为url是自动生成的。&lt;/p&gt;
&lt;p&gt;如果不使用Play的模板系统，很难做到这些。另外，由于我们仅用到最基本的功能，所以可以考虑采用性能更好的模板系统来代替Play的模板引擎，比如green同学的&lt;a href=&quot;http://rythmengine.com&quot;&gt;rythm&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;后端生成Js文件供前端调用&lt;/h3&gt;
&lt;p&gt;Angularjs在前台需要调用后台的方法时，往往通过一些restful api接口。由于restful api的意义在于良好、稳定的结构，让前后台解耦，但对于我来说，这点意义不大。&lt;/p&gt;
&lt;p&gt;所以我可以利用Play的目录结构，让Play根据action的信息，生成一个jsRoutes文件，把每个action的get/post的调用方式，以及生成url的功能都包含进去。前台的angularjs要跳转页面，或者调用一个ajax方法，都只需要调用其中的一个函数即可，不需要关心url是什么。这里在下面将详细说明。&lt;/p&gt;
&lt;p&gt;这种方式让事情变得简单多了，不追求无刷新，而追求开发效率与写代码时的舒适性。&lt;/p&gt;
&lt;h2&gt;七、关于angularjs的$resource&lt;/h2&gt;
&lt;p&gt;在angularjs中提供了一个service叫$resource：&lt;a href=&quot;http://docs.angularjs.org/api/ngResource.$resource&quot;&gt;http://docs.angularjs.org/api/ngResource.$resource&lt;/a&gt;，它可以通过一个url和一些参数，定义一个resouce对象。通过调用该对象的某些方法，可以与后台交互，并且直接得到经过它处理之后的数据。使用的感觉有点像我们在后端常用的dao。&lt;/p&gt;
&lt;p&gt;这个$resource服务对于“单页面，以restful api交互”的情况比较合适。它要求所给出来的url可以按restful api的方式调用，正好满足适合这种情况。&lt;/p&gt;
&lt;p&gt;但对于“传统多页面程序”不好用，特别是那种信息管理系统。因为它们的url形式并不重要，是否restful也不重要，只要提供get/post两种方式，能把参数传过去就行了。如果在这里使用$resource，按它的规定来套，需要花很多心思来设计url，非常痛苦。我在这里卡了很长时间，因为我想不明白，为什么这个$resource看起来很好，但用起来就是不对劲呢。最后终于想通，原来我的情况不需要restful api。&lt;/p&gt;
&lt;p&gt;最后我的做法是，在服务端把各action收集起来，生成一个js文件，在这个文件里把action以js函数的方式暴露出来，供angularjs直接调用（内部使用了angularjs提供的$http服务，而没有用$resource）。在本例中，这个js文件中定义了一个叫JsRoutes的object供使用。&lt;/p&gt;
&lt;p&gt;Angularjs调用它的方式是这样的：&lt;/p&gt;
&lt;p&gt;function Ctrl($scope, JsRoutes) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$scope.submit = function() { 
    JsRoutes.Users.create.post({ 
          username: username, 
          password: password 
    }, function(res) { 
          alert(&quot;ok&quot;); 
    }); 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这样，当我需要向后台传user相关的数据时，直接调用预定义的JsRoutes.Users.create即可，而不需要关注它对应的url到底是什么。&lt;/p&gt;
&lt;p&gt;这个js文件的代码是这样的：&lt;/p&gt;
&lt;p&gt;angular.module(&apos;JsRoutes&apos;, []).factory(&apos;JsRoutes&apos;, function ($http) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var defaultErrorHandler = function (data, status, headers, config) {
    alert(&apos;Sorry, server responses &apos; + status + &apos; error: &apos; + data);
};
// angular post json by default, change it to key value pairs
var keyValuesTransformFn = function (d) {
    return jQuery.param(d);
};
var commonHandler = function (method, url, params, data, success, error, config) {
    config = config || {};
    config.method = config.method || method;
    config.params = config.params || params;
    config.data = config.data || data;
    config.url = config.url || url;
    config.timeout = config.timeout || 120 * 1000;
    var postType = config.postType || &apos;form&apos;;
    if (postType === &apos;form&apos;) {
        config.transformRequest = keyValuesTransformFn;
        config.headers = config.headers || {};
        config.headers[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;;
        // config.headers[&apos;Accept&apos;] = &quot;application/json, text/html, text/plain, */*&quot;;
    }
    $http(config).success(success).error(error || defaultErrorHandler);
};
var jsRoutesHandler = function (path) {
    return {
        get: function (params, success, error, config) {
            commonHandler(&apos;get&apos;, path, params, {}, success, error, config);
        },
        post: function (data, success, error, config) {
            commonHandler(&apos;post&apos;, path, {}, data, success, error, config);
        },
        link: function(params) {
            return path + &quot;?&quot; + jQuery.param(params);
        }
    }
};

return {
    #{list actions.keySet(), as: &apos;module&apos;, separator: &apos;,&apos;}
        #{if module}
            ${module} : {
                #{list actions.get(module).keySet(), as: &apos;controller&apos;, separator: &apos;,&apos;}
                ${controller} : {
                    #{list actions.get(module).get(controller), as: &apos;item&apos;, separator: &apos;,&apos;}
                        ${item.action}: jsRoutesHandler(&apos;${item.path}&apos;)
                    #{/list}
                }
                #{/list}
            }
        #{/if}
        #{else}
            #{list actions.get(module).keySet(), as: &apos;controller&apos;, separator: &apos;,&apos;}
            ${controller} : {
                #{list actions.get(module).get(controller), as: &apos;item&apos;, separator: &apos;,&apos;}
                    ${item.action}: jsRoutesHandler(&apos;${item.path}&apos;)
                #{/list}
            }
            #{/list}
        #{/else}
    #{/list}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;注意其中的get/post/link三处，这是前台调用它们的关键方法。（现在使用typescript后，还可以考虑生成typescript的声明文件）&lt;/p&gt;
&lt;p&gt;采用这种方式后，在前端js代码中完全不需要跟url打交道，因为它们都是在服务器端根据routes文件生成的。以后url有什么变化，js这里不需要修改一行代码。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，angularjs默认会向服务端发送json格式的数据，而play对key-value形式的数据处理的比较好，所以我就把它默认值改为了&lt;code&gt;&apos;application/x-www-form-urlencoded&apos;&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;八、Angularjs中如何集成第三方js插件&lt;/h2&gt;
&lt;p&gt;有时候需要用一些第三方插件，比如datepicker，slider，或者tree等。以前的做法是直接通过jquery取得某个元素，然后调用某个方法即可。但在angularjs中，不能直接这么写，必须写在directive中。&lt;/p&gt;
&lt;p&gt;有一个叫augular-ui的项目：&lt;a href=&quot;https://github.com/angular-ui/angular-ui&quot;&gt;https://github.com/angular-ui/angular-ui&lt;/a&gt;，已经集成了一些常用的插件（来自jqueryui），很方便。但如果还是需要自己定义，该怎么做呢？&lt;/p&gt;
&lt;p&gt;基本的思路就是，创建一个directive，把调用jquery插件的代码放在它里面。这里以jqueryui的slider为例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1167-23.png&quot;&gt;&lt;img src=&quot;/user_images/1167-23.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;样子如上，其示例在：&lt;a href=&quot;http://jqueryui.com/slider/&quot;&gt;http://jqueryui.com/slider/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在jquery中，它的调用方式是这样的：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;
&lt;div id=&quot;slider&quot;&gt;&lt;/div&gt;$(&quot;#slider&quot; ).slider({ 
    min: 0, 
    max: 100, 
    value: 10, 
    step: 5    
});
&lt;/div&gt;
&lt;p&gt;而在angularjs中，我们需要定义一个directive，假设是ui-slider：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;
app.directive(&apos;slider&apos;, function () { 
    return { 
        require: &apos;?ngModel&apos;, 
        restrict: &apos;A&apos;, 
        link: function (scope, element, attrs, ngModel) { 
            var opts; 
            opts = angular.extend({}, scope.$eval(attrs.slider)); 
            var slider = element.slider({ 
                min: opts.min || 0, 
                max: opts.max || 100, 
                step: opts.step || 10, 
                value: attrs.ngModel &amp;&amp; scope.$eval(attrs.ngModel) || 50, 
                slide: function (event, ui) { 
                    if (ngModel) { 
                        scope.$apply(function () { 
                            ngModel.$setViewValue(ui.value); 
                        }) 
                    } 
                } 
            }); 
            scope.$watch(attrs.ngModel, function (v) { 
                slider.slider({ 
                    value: v 
                }); 
            }); 
        } 
    }; 
});
&lt;/div&gt;
&lt;p&gt;在html中的调用方式是：&lt;/p&gt;
&lt;div slider=&quot;{min:0,max:500,step:5}&quot; ng-model=&quot;row.width&quot;&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在directive中的代码比jquery的多了不少，不过主要是增加了与双向绑定有关的两个函数。例如在&quot;slide: function(event, ui)“中，是把sider的值传回给某个model（本例中为row.width）。在后面的scope.$watch中，是把model的值传给slider。这样当拖动slider上的刻度时，row.witdh的值会自动改变；或者改变了row.width的值之后，slider的刻度也会自动变化。&lt;/p&gt;
&lt;p&gt;基本的思路就是这样，更详细的需要看相关文档。与angularjs相关的就讲到这里，在这里你可以看到很多angularjs的可执行的例子：&lt;a href=&quot;https://github.com/angular/angular.js/wiki/JsFiddle-Examples&quot;&gt;https://github.com/angular/angular.js/wiki/JsFiddle-Examples&lt;/a&gt;，可以直接感受。&lt;/p&gt;
&lt;p&gt;最后需要补充的两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Angularjs的社区气氛很好。其google group人气很旺，有问题很快就能得到详细的回复2.  Angularjs对IE6/7支持不好。如果一定要支持ie6/7，可考虑backbone或其它框架。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;九、Bootstrap&lt;/h2&gt;
&lt;p&gt;Bootstrap是像我们这样缺少艺术细胞的程序员的福音。只需要记一些css class和某些js component的用法，就可以做出看起来比较美观、专业的页面效果出来。虽然过不了多久，人们也许就会对它出现审美疲劳，但好在它的社区已经形成，已经有不少基于它的模板出来，相信以后会有更多更美观的bootstrap theme可供选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wrapbootstrap.com/&quot;&gt;https://wrapbootstrap.com/&lt;/a&gt;*   &lt;a href=&quot;http://bootswatch.com/&quot;&gt;http://bootswatch.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strike&gt;十、Why HaxeJs&lt;/strike&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strike&gt;我的Js能力不强，主要是因为觉得Js里陷阱太多，总是觉得不安。所以我一直想找一个有静态类型、功能强大、能生成js并且生成的代码体识较小的语言，来代替它。经过多次尝试，终于让我找到了。&lt;/strike&gt;&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;它就是HaxeJs。参看：&lt;/strike&gt;&lt;a href=&quot;http://freewind.me/blog/20130122/2019.html&quot;&gt;&lt;strike&gt;我为什么选择haxejs，而不是dart/typescript&lt;/strike&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;HaxeJs对于我来说，意义是很大的，因为Javascript是我长久以来心中的痛。不想用，但经常又不能不用，所以我尽量把逻辑写在后台，前台通过Ajax调用。但对于页面效果，不写JavaScript是不行的，所以我总为这犯愁。使用了Angularjs后，虽然对于javascript的要求大大降低，但当逻辑复杂的时候，上百行的js代码还是让我很不安。&lt;/strike&gt;&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;但现在有了haxejs，我可以在一种类型安全的环境中写js代码，感觉就安全不一样了。以后我可以把更多的逻辑放在前台由js实现，或者使用haxe来写后台（比如nodejs/php等），感觉脚下的路一下子变宽了。&lt;/strike&gt;&lt;/p&gt;
&lt;p&gt;经过几天的试用，我&lt;a href=&quot;http://freewind.me/blog/20130126/2022.html&quot;&gt;发现Haxejs与Angularjs之间不合适&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strike&gt;十、Why Typescript&lt;/strike&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strike&gt;在haxejs之后，又尝试了由微软推出的typescript。它的语言特性没有haxejs那么强，但是正好避开了haxejs与angularjs之间不匹配的那几个问题：&lt;/strike&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strike&gt;Typescript的思路还是javascript，并且兼容js语法，angularjs再侵入html也不怕 &lt;/strike&gt;&lt;/li&gt;
&lt;li&gt;&lt;strike&gt;Typescript中允许使用$作为变量名 &lt;/strike&gt;&lt;/li&gt;
&lt;li&gt;&lt;strike&gt;Typescript的类型功能基本可用，并且可下载到Angular的声明文件 &lt;/strike&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strike&gt;详细内容可参考我的另一个文章：&lt;/strike&gt;&lt;a href=&quot;http://freewind.me/blog/20130128/2034.html&quot;&gt;&lt;strike&gt;使用Typescript来写javascript&lt;/strike&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经过几天的试用，Typescript倒在了工具和语言本身还不够成熟：&lt;a href=&quot;http://freewind.me/blog/20130128/2034.html&quot;&gt;使用Typescript来写javascript (目前相关工具不够成熟)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;等到idea能支持直接在编辑器中实时检查错误时，再使用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Groovy的JsonBuilder还是不够groovy</title>
                <link>http://freewind.in/posts/1138-the-jsonbuilder-of-groovy-is-not-groovy-enough</link>
                <pubDate>Fri, 21 Dec 2012 16:36:31 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1138</guid>
                <description><![CDATA[&lt;p&gt;之前特别想把groovy的支持集成到play中，最主要的原因是看中了它的JsonBuilder。看下面这段代码：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; json() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    def builder = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; groovy.json.JsonBuilder()
    def root = builder.people {
        person {
            firstName &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Guillame&apos;&amp;lt;/span&amp;gt;
            lastName &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Laforge&apos;&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (1 == 0) {
                address {
                    city &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Paris&apos;&amp;lt;/span&amp;gt;
                    country &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;France&apos;&amp;lt;/span&amp;gt;
                    zip 12345
                }
            }
            married &amp;lt;span class=&quot;kwrd&quot;&amp;gt;true&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;rem&quot;&amp;gt;// a list of values&amp;lt;/span&amp;gt;
            conferences &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;JavaOne&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Gr8conf&apos;&amp;lt;/span&amp;gt;
        }
    }
    renderJSON(builder.toString())
}&amp;lt;style type=&quot;text/css&quot;&amp;gt;.csharpcode, .csharpcode pre
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }
&lt;br  /&gt;&lt;/style&gt;```&lt;/p&gt;
&lt;p&gt;这个JsonBuilder的结构我非常喜欢，简洁明了，最重要的是还可以在中间随意穿插自己的控制逻辑。&lt;/p&gt;
&lt;p&gt;为什么我这么看重JsonBuilder，因为我使用了angularjs这样的前端框架，前后台经常需要用json通信。为了得到最好的性能，为每个页面定制json是非常必要的手段。但使用gson/jackson把bean转换为json，控制的粒度不够细；而在java代码中拼json，不用想就知道有多痛苦；而在play模板中拼json，除了要对每个值进行raw()的处理外，还需要处理分隔符，少不了这样的语句：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;${if var_isLast ? &amp;ldquo;&amp;rdquo; : &amp;ldquo;,&amp;ldquo;}&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有够麻烦。&lt;/p&gt;
&lt;p&gt;当我看到groovy的JsonBuilder的时候，我眼前一亮，这东西太好了。&lt;/p&gt;
&lt;p&gt;（后来发现不需要专门集成groovy，因为play的模板就是基于groovy的，我们可以把这个builder直接写在模板里，用 %{}%括起来就行了。这是另一个问题，不在本文中说了）&lt;/p&gt;
&lt;p&gt;然而现在却发现这个JsonBuilder还不够groovy，还不够好，因为如果想生成一个array形式的json，它的这种语法不支持。&lt;/p&gt;
&lt;p&gt;比如我想生成一个这样的json:&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;[&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;code&quot;&amp;lt;/span&amp;gt;: &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;111&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;value&quot;&amp;lt;/span&amp;gt;:&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;222&quot;&amp;lt;/span&amp;gt;},
{&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;code&quot;&amp;lt;/span&amp;gt;: &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;333&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;value&quot;&amp;lt;/span&amp;gt;:&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;444&quot;&amp;lt;/span&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;]```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;JsonBuilder没办法按前面的语法来写，因为它只能生成object形式的，比如例中的那样，或者下面这样的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;code&quot; : &quot;111&quot;, 

&quot;value&quot; : &quot;222&quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么JsonBuilder是否能生成array形式的json呢？可以是可以，但语法形式就不一样了。如下例：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;def list = [&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[code: &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;111&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;value&amp;lt;/span&amp;gt;: &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;222&quot;&amp;lt;/span&amp;gt;],
[code: &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;333&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;value&amp;lt;/span&amp;gt;: &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;444&quot;&amp;lt;/span&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;]&lt;/p&gt;
&lt;p&gt;builder = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; groovy.json.JsonBuilder(list)
&lt;br  /&gt;println builder.toString()```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;可以看到，这已经是纯粹的groovy代码了。这时候要使用[]而不是{}，而且list和map都是用[]。&lt;/p&gt;
&lt;p&gt;看一下这两种写法之间的不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JsonBuilder的语法，使用{}，每行结果没有逗号，key与value之间没有冒号2.  使用groovy内置的集合语法时，使用[]，而且list和map都是[]，并且各元素之间都要有逗号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里存在着一大坑：如果你写错了，比如多写了冒号或少写了逗号，它有可能不报错，但结果不同；也有可能报一个完全让人摸不着头脑的错误！&lt;/p&gt;
&lt;p&gt;比如，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果用JsonBuilder的语法，在key与value之间多写了一个冒号，不会报错，只是那一项被忽略了2.  如果用集合的写法，但在list的元素之间，少写了行尾的逗号，会报一个NullPointerException!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种混乱会让人在使用过程中极易犯错，而花费大量的调试时间。&lt;/p&gt;
&lt;p&gt;就算我强制只使用object形式的json，对于array，就给它加上一个无意义的key，也不能完全避免以上混乱。假设我现在有如下的一个list:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def list = [&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [code: 111, value: 222], 

    [code: 333, value: 444], 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在生成json的时候，我要用它这个list，并且把它的每个值都加倍，应该怎么做呢？&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;def builder = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; groovy.json.JsonBuilder()
&lt;br  /&gt;builder.system {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;mysystem&quot;&amp;lt;/span&amp;gt;
settings list.collect {
    [
            code: it.code * 2,
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;value&amp;lt;/span&amp;gt;: it.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;value&amp;lt;/span&amp;gt; * 2
    ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;println builder.toPrettyString()```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;看到了吗？要使用collect方法对原list进行变换，它要把每个元素转换为一个map，即[]包裹起来的代码。在复杂的情况下，这实在让人难以接受。&lt;/p&gt;
&lt;p&gt;综上所述，在play中引入groovy的JsonBuilder，带来的混乱要大于其方便性，所以决定抛弃它。如果抛弃了JsonBuilder，则集成groovy的意义也不大了，所以我打算不再考虑groovy。&lt;/p&gt;
&lt;p&gt;现在想到的办法，还是对play进行扩展，增加以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给list标签增加separator属性，方便增加json间的逗号2.  添加一个新的render方法，以字符串形式返回生成的模板内容，而不是抛出异常。以方便在模板中调用拿结果。3.  增加一个将object转换为json的扩展方法，返回Raw类型，方便在模板中调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后两者可以在自己的代码中实现，而对于1，必须要修改play的源代码，因为list标签是写死在代码中(GroovyInlineTag)，没有办法对它进行扩展。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>离散数学学习疑问 – 真值函数</title>
                <link>http://freewind.in/posts/1134-question-about-discrete-math-truth-function</link>
                <pubDate>Sat, 01 Dec 2012 16:56:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1134</guid>
                <description><![CDATA[&lt;p&gt;在《离散数学（耿素云、屈婉玲编著）》这本书里第37页（第二章命题逻辑等值演算 2.3 联结词的完备集）里，提到了n元真值函数。&lt;/p&gt;
&lt;p&gt;对于这个概念，我想了几个小时终于基本想通（可能还不正确），先记在这里，怕又忘了。n元真值函数的定义不贴，只贴我的理解。&lt;/p&gt;
&lt;p&gt;最难理解的地方在于：n个命题变项，可以构成2&lt;sup&gt;2&lt;/sup&gt;n个真值函数。为什么有2&lt;sup&gt;2&lt;/sup&gt;n个？&lt;/p&gt;
&lt;p&gt;还有它给出来的表，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1134-1.png&quot;&gt;&lt;img src=&quot;/user_images/1134-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也不太理解。里面的F0/F1等等，到底指什么？&lt;/p&gt;
&lt;p&gt;当我想通这个问题时，脑海中冒出一句话：数学就是不断的抽象，在抽象的基础上进一步抽象。&lt;/p&gt;
&lt;p&gt;现在先不管F函数，先看前面讲的比较好理解的极小项（极大项）的概念。&lt;/p&gt;
&lt;p&gt;极小项就是一个抽象，对于一个含有2个变项的命题来说，m0代表的是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;┐p ∧ ┐q&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;m1代表的是:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;┐p ∧ q&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于3变项的命题来说，m0代表的就是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;┐p ∧ ┐q ∧ ┐r&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这对于简单变项来说，极小项与极大项是一层抽象。以前看到的都是p, q之类，现在研究的都是它们的组合（只是用简单的符号代替了），就像是“字”与“词”的关系。眼睛清静了，但脑袋里的抽象层次要高一层。&lt;/p&gt;
&lt;p&gt;等到真值函数时，抽象又高了一层。&lt;/p&gt;
&lt;p&gt;变项之间可以通过联结符组成无穷无尽个命题。研究无限的东西总是比较困难的，能否把它们变为有限的什么？&lt;/p&gt;
&lt;p&gt;这无限个命题中，有很多其实是互相等值的。如果把每个命题都化简为它所对应的唯一的主合取范式或主析取范式，那么等于把这无限个命题分成了很多组。每个组中各命题都可以化简为同一个主范式，而组的个数是有限的。对于n个变项来说，它的主范式个数为2&lt;sup&gt;2&lt;/sup&gt;n个，即分成了2&lt;sup&gt;2&lt;/sup&gt;n个组。&lt;/p&gt;
&lt;p&gt;这样就把无限变为了有限。&lt;/p&gt;
&lt;p&gt;然后为了方便研究这“有限个主范式”，提出n元真值函数的定义F。F是个黑盒子，它只管内容，只看输入和输出。&lt;/p&gt;
&lt;p&gt;以2元真值函数为例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1134-3.png&quot;&gt;&lt;img src=&quot;/user_images/1134-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它有2&lt;sup&gt;2&lt;/sup&gt;2，即16个真值函数，分别定义为：&lt;a href=&quot;/user_images/1134-5.png&quot;&gt;&lt;img src=&quot;/user_images/1134-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/user_images/1134-7.png&quot;&gt;&lt;img src=&quot;/user_images/1134-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;，这些函数到底是什么样子的呢？&lt;/p&gt;
&lt;p&gt;每一个真值函数，都对应着无数的命题，只要它们的输入和输出满足这个条件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1134-9.png&quot;&gt;&lt;img src=&quot;/user_images/1134-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;则都可以以&lt;a href=&quot;/user_images/1134-11.png&quot;&gt;&lt;img src=&quot;/user_images/1134-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;代之。观察它，可以发现，不论输入是什么，值总为0，是一个矛盾式。故所有的由2个变项组成的矛盾式都与它等值。&lt;/p&gt;
&lt;p&gt;再看&lt;a href=&quot;/user_images/1134-13.png&quot;&gt;&lt;img src=&quot;/user_images/1134-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;，它可以有很多形式，比如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;p -&gt; q  &lt;=&gt; (┐p ∨ q) &lt;=&gt; ┐(p ∧ ┐q) &lt;=&gt; (┐p ∧ ┐q) ∨ (┐p ∧ q) ∨ ( p ∧ q ) &lt;=&gt; &amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些不同的命题，它们虽然形式万千，但输入与输出都满足这个条件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1134-15.png&quot;&gt;&lt;img src=&quot;/user_images/1134-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果用最小项来表示，是这样的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;m1 ∨ m3 ∨ m4&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这里，前面的极小项已经成为了它的一个基本单位，可见抽象层次又提高了一层，到达了“句”。&lt;/p&gt;
&lt;p&gt;先写到这里，在写的过程中，几次写不下去，发现自己理解上的错误。现在也还不是十分的清楚，等以后再有理解后补充。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用groovy写play程序的监控脚本</title>
                <link>http://freewind.in/posts/1115-use-groovy-to-write-a-shell-to-monitor-play-website</link>
                <pubDate>Wed, 21 Nov 2012 20:49:27 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1115</guid>
                <description><![CDATA[&lt;p&gt;之前做过的一个网站又挂了，老师留言让我及时修复。一查看原来访问量过大，OutOfMemoryError了。于是想写一个脚本自动监测网站运行情况，不能访问时自动重启，这样我就省事了。&lt;/p&gt;
&lt;p&gt;主要功能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每隔一分钟访问一次首页2.  如果有数据返回，检查它是否包含某些关键字3.  如果有误，则检查数据库是否运行正常4.  再重启play&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于服务器的环境限制得很严格，不能访问其它网站，很多常用工具都没法下载，用bash来写比较麻烦。用java写的话，有点繁琐，而且修改起来也不方便，还要编译。最后决定用groovy，毕竟跟java比较接近好入手。&lt;/p&gt;
&lt;p&gt;脚本如下：&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;mycode&quot;&gt;&lt;/p&gt;
&lt;h1&gt;!/usr/bin/env groovy&lt;/h1&gt;
&lt;p&gt;import java.net.*&lt;/p&gt;
&lt;p&gt;// settings
&lt;br  /&gt;INDEX_URL = &amp;ldquo;&lt;a href=&quot;http://localhost:9001/login&amp;quot;&quot;&gt;http://localhost:9001/login&amp;rdquo;&lt;/a&gt;
&lt;br  /&gt;APP_ROOT = &amp;ldquo;/path/to/app/root&amp;rdquo;
&lt;br  /&gt;SERVER_PID_FILE = APP_ROOT + &apos;/server.pid&apos;
&lt;br  /&gt;PLAY_CMD = &amp;ldquo;play&amp;rdquo;
&lt;br  /&gt;KEYWORDS = [&apos;name=&amp;ldquo;password&amp;rdquo;&apos;]&lt;/p&gt;
&lt;p&gt;println &amp;ldquo;Starting web monitor &amp;hellip;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;// check every 1min
&lt;br  /&gt;while (true) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println &quot;&quot;      
println &quot;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212; checking &amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&amp;amp;#8212;&quot;      
println &quot;&quot;      
try {      
    if (readUrl()) {      
        println &quot;Everything is fine&quot;      
    } else {      
        println &quot;There is something wrong&quot;      
        restartDB()      
        restartPlay()      
    }      
} catch (Exception e) {      
    println &quot;    exception: &quot; + e.toString().take(40)      
}      
println &quot;waiting for 1 min&quot;      
Thread.sleep(1000 * 60);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;boolean readUrl() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println &quot;Read data from ${INDEX_URL}&quot;

def input = null;     
try {      
    URL url = new URL(INDEX_URL)      
    def conn = url.openConnection()      
    conn.setConnectTimeout(5 * 1000) // 5s      
    conn.setReadTimeout(5 * 1000) // 5s, important      
    conn.connect();

    input = conn.getInputStream()     
    def content = input.getText(&quot;UTF-8&quot;)

    println &quot;    response has ${content.length()} chars&quot;

    for(String keyword: KEYWORDS) {     
        if(content.contains(keyword)) {      
            println &quot;    response contains keyword ${keyword}, valid&quot;      
            return true      
        }      
    }      
    println &quot;    response doesn&apos;t contain phone or email, invalid&quot;      
} catch (Exception e) {      
    println &quot;    exception: &quot; + e.toString().take(40)      
    return false      
} finally {      
    if (input != null) {      
        input.close()      
    }      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def restartPlay() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println &quot;Check play&quot;      
def pid = checkPlayIsRunning()      
println &quot;    pid: ${pid}&quot;

if (pid) {     
    println &quot;    try to kill the play process: ${pid}&quot;      
    execute(&quot;kill -9 ${pid}&quot;).waitFor()      
}

if (new File(SERVER_PID_FILE).isFile()) {     
    println &quot;    delete: ${SERVER_PID_FILE}&quot;      
    new File(SERVER_PID_FILE).delete()      
}

println &quot;    start play ...&quot;     
execute(&quot;${PLAY_CMD} start ${APP_ROOT} -%prod&quot;)      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def restartDB() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println &quot;Check DB&quot;      
println &quot;    check pg_ctl status&quot;      
def proc = execute(&quot;su - postgres -c &apos;pg_ctl status&apos;&quot;)      
proc.waitFor()

def out = proc.in.text     
println &quot;    response: ${out?.take(40)}&quot;      
if (!out.contains(&quot;server is running&quot;)) {      
    println &quot;    not running, pg_ctl start ...&quot;      
    execute(&quot;ru - postgres -c &apos;pg_ctl start&apos;&quot;)      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;String checkPlayIsRunning() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;println &quot;    check ps of play&quot;      
def proc = execute(&quot;ps -eaf | grep play&quot;)      
proc.waitFor()

def line = proc.in.text.readLines().find { it.contains(APP_ROOT) }     
println &quot;    matched line: ${line?.take(40)}&quot;

return line?.split(&quot;\\s+&quot;)?.getAt(1)     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def execute(String command) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&quot;sh&quot;, &quot;-c&quot;, command].execute()      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;该脚本运行起来后，就可以24小时不间断地监测网站了，我再也不用担心在睡梦中接到老师的问候电话了。&lt;/p&gt;
&lt;p&gt;对了别忘了先安装groovy，还要把该脚本设为可执行。&lt;/p&gt;
&lt;p&gt;如果把该脚本设为开机自动启动，则服务器重启也不怕了。如何设置，可参考我另一个文章：&lt;a href=&quot;http://freewind.me/blog/20121121/1114.html&quot;&gt;如何让linux开机就运行某个groovy脚本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#ff0000&quot;&gt;注意：上面的脚本已经修改，增强了read timeout，这个值非常重要。因为在运行时发现，如果网站卡住（可以连接，但不返回数据时），此脚本也会卡住。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何让linux开机就运行某个groovy脚本</title>
                <link>http://freewind.in/posts/1114-let-linux-run-a-groovy-shell-when-start-up</link>
                <pubDate>Wed, 21 Nov 2012 20:37:50 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1114</guid>
                <description><![CDATA[&lt;p&gt;看起来这是一个比较简单的问题，但我这么多年硬是不会。今天校友网又挂了，老师又给我留言，让我及时解决。&lt;/p&gt;
&lt;p&gt;于是花了几个小时，用groovy写了一个脚本，其作用就是每隔一分钟访问一次首页，如果连不上或者内容不对，就会依次检查数据库及网站服务，在需要的时候重启。只要把这个脚本跑起来，就不用担心了。&lt;/p&gt;
&lt;p&gt;不过如何让服务器重启后这个脚本也能自动运行呢？经过半天的摸索和十来次的重启，终于试验成功。&lt;/p&gt;
&lt;p&gt;首先，要装上groovy，并在/usr/local/bin下，把groovy链过去：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;cd /usr/local/bin&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;ln -s ~/dev/groovy/bin/groovy groovy&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的监控脚本位于：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/www/monitor.groovy&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在/etc/init.d下建立一个web_monitor的文件，内容如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;#!/bin/sh&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;#chkconfig:2345 80 05&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;groovy /www/monitor.groovy&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个文件大有文章。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一行表示使用sh来调用该脚本&lt;/li&gt;
&lt;li&gt;第二行用于chkconfig命令，设置了一些参数，这里有点复杂我也不太懂，不过大多数情况照这个写就可以了。&lt;/li&gt;
&lt;li&gt;第三行非常重要，我十几次重启都是因为它。如果不加上这个path，下面的groovy命令就找不到，自然就没有办法启动成功了&lt;/li&gt;
&lt;li&gt;最后一行调用我那个监控脚本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后要把这个文件加到启动列表里：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;chmod +x web_monitor&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;chkconfig -add web_monitor&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;chkconfig -list web_monitor&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有意外，就行了。然后reboot，看看它有没有运行成功&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play1学习: Play对controllers做了什么</title>
                <link>http://freewind.in/posts/1110-what-has-play1-done-to-controllers</link>
                <pubDate>Tue, 20 Nov 2012 15:44:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1110</guid>
                <description><![CDATA[&lt;p&gt;开始学习play框架，本篇作为一个引子。&lt;/p&gt;
&lt;p&gt;Play的一大特色是在编译期使用javassist对字节码进行增强，增加很多对用户透明的代码，以达到更简洁的使用效果。以controller为例，有一些事情在play中可以做到，而在普通的java中很难做到。&lt;/p&gt;
&lt;p&gt;看下面这段代码：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;package controllers;&lt;/p&gt;
&lt;p&gt;import play.&lt;em&gt;;
&lt;br  /&gt;import play.mvc.&lt;/em&gt;;
&lt;br  /&gt;import java.util.&lt;em&gt;;
&lt;br  /&gt;import models.&lt;/em&gt;;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Application extends Controller {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; index() {
    render();
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; hello(String name) {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt;(name==&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt; || name.trim().length()==0) {
        index();
    }
    String message = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;welcome!&quot;&amp;lt;/span&amp;gt;;
    render(name, message);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;在这段代码里，play可以通过代码增强，做到以下事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在hello这个action中，自动从request提交的参数中，找到名为name的key，将其值赋给参数name&lt;/li&gt;
&lt;li&gt;在hello中，当name为null或空时，直接调用index()跳转到index，而下面的render(name)不会被执行&lt;/li&gt;
&lt;li&gt;render(name)在把name的值传到模板的同时，也会以某种方式把&apos;name&apos;这个名传过去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几个功能可以让我们的代码更简化一点，并且它们能过常规的方法（比如反射等），是难以做到的。如果把这个hello翻译为springmvc代码，大约是这样的：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; hello(@Param(&lt;span class=&quot;str&quot;&gt;&amp;ldquo;name&amp;rdquo;&lt;/span&gt;) String name) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt;(name==&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt; || name.trim().length()==0) {
        redirectTo(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;/application/index&quot;&amp;lt;/span&amp;gt;);
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt;;
    }
    String message = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;welcome!&quot;&amp;lt;/span&amp;gt;;
    Map&amp;lt;String, String&amp;gt; data = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; HashMap&amp;lt;String,String&amp;gt;();
    data.put(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;message&quot;&amp;lt;/span&amp;gt;, message);
    render(data);
}```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;以上的代码为伪代码，因为我已记不清具体怎么写，不过不影响理解。可以看到对于第1点，需要一个注解并指定参数名为&quot;name&amp;rdquo;，第2点需要增加一个以字符串的形式写上&quot;index&amp;rdquo;，丧失了typesafe，不能利用重构及编译期查错，第3点需要手动指定参数名为name。&lt;/p&gt;
&lt;p&gt;看起来是很小的改进，不过controller如此常用，这些小小麻烦累积起来，也会让人心情不爽。相比起来，play的代码更加简洁清晰，同时如果不注意，甚至没有意识到play在后面做了手脚。&lt;/p&gt;
&lt;p&gt;Play到底对controller做了什么呢？我们可以通地反编译工具，将Application.class反编译为java代码，一目了解。这里推荐一个叫jd-gui的工具：&lt;a href=&quot;http://java.decompiler.free.fr/?q=jdgui&quot;&gt;http://java.decompiler.free.fr/?q=jdgui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是反编译之后的java代码：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;package controllers;&lt;/p&gt;
&lt;p&gt;import play.classloading.enhancers.ControllersEnhancer.ControllerInstrumentation;
&lt;br  /&gt;import play.classloading.enhancers.LocalvariablesNamesEnhancer.LocalVariablesNamesTracer;
&lt;br  /&gt;import play.mvc.Controller;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Application extends Controller {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; String[] $index0 = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; String[0];
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; String[] $hello1195259493 = {&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;name&quot;&amp;lt;/span&amp;gt;};

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; index() {
    Object localObject1;
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;try&amp;lt;/span&amp;gt; {
        LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.enter();
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (!ControllersEnhancer.ControllerInstrumentation.isActionCallAllowed()) {
            Controller.redirect(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;controllers.Application.index&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object[0]);
        } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;else&amp;lt;/span&amp;gt; {
            ControllersEnhancer.ControllerInstrumentation.stopActionCall();
            render(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object[0]);
        }
    } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;finally&amp;lt;/span&amp;gt; {
        localObject1 = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;;
        LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.exit();
    }
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; hello(String name) {
    Object localObject1;
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;try&amp;lt;/span&amp;gt; {
        LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.enter();
        LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.addVariable(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;name&quot;&amp;lt;/span&amp;gt;, name);
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (!ControllersEnhancer.ControllerInstrumentation.isActionCallAllowed()) {
            Controller.redirect(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;controllers.Application.hello&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object[]{name});
        } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;else&amp;lt;/span&amp;gt; {
            ControllersEnhancer.ControllerInstrumentation.stopActionCall();
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; ((name == &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;) || (name.trim().length() == 0)) {
                index();
            }
            String message = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;welcome!&quot;&amp;lt;/span&amp;gt;;
            LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.addVariable(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;message&quot;&amp;lt;/span&amp;gt;, message);
            render(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object[]{name, message});
        }
    } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;finally&amp;lt;/span&amp;gt; {
        localObject1 = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;;
        LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.exit();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;比我们自己写的代码长了几倍，看来play的确做了不少事情。这里简单解读一下（因本人水平有限，可能有误，欢迎指正）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先看到多了两个field:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; String[] $index0 = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; String[0];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; String[] $hello1195259493 = {&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;name&quot;&amp;lt;/span&amp;gt;};```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;它们的作用是记录下每一个action的参数名，以方便从request中取参数时，知道action有哪些参数。由于参数名的信息会在编译期被忽略，正常情况下是拿不到的。Play通过内嵌eclipse的javac并打开debug选项，保证在编译期各变量的原始名称不会改变（需求证）。不过这样的话，应该也可以通过method的反射取到名称，不一定非得建一些field保存。我估计是为了性能和方便性考虑。&lt;/p&gt;
&lt;p&gt;其规则为 $ + method.name + hashCodeOfParameters(method)&lt;/p&gt;
&lt;p&gt;如果方法没有参数，则后面直接加0。有参数的话，会根据参数类型计算出一个固定的hash值，以区分同名方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后是LocalvariablesNamesEnhancer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是用来把方法的参数以及各局部变量的名与值保存在一个map中。观察hello方法中的这几句：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.enter();
&lt;br  /&gt;LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.addVariable(&lt;span class=&quot;str&quot;&gt;&amp;ldquo;name&amp;rdquo;&lt;/span&gt;, name);
&lt;br  /&gt;LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.addVariable(&lt;span class=&quot;str&quot;&gt;&amp;ldquo;message&amp;rdquo;&lt;/span&gt;, message);
&lt;br  /&gt;LocalvariablesNamesEnhancer.LocalVariablesNamesTracer.exit();```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;它们把方法的参数以及各局部变量都保存起来，这样才可在向模板传值时忽略变量名。因为在render(&amp;hellip;)方法可，可以根据传入的值的hashcode，找到其对应的名字，再传给模板层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后是redirect：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面说到，调到一个action方法时，有可能会变成一个redirect。但这些action也应该可以当作普通的方法调用，是怎么做到的呢？看index中的代码：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (!ControllersEnhancer.ControllerInstrumentation.isActionCallAllowed()) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Controller.redirect(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;controllers.Application.index&quot;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;} &lt;span class=&quot;kwrd&quot;&gt;else&lt;/span&gt; {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ControllersEnhancer.ControllerInstrumentation.stopActionCall();
 render(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object[0]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;可以看到，每个action被调用时，会先调用自己是被当成action还是普通java方法，被其它代码调用。如果是被另一个action调用，就会变成redirect，否则按正常的方法调用。&lt;/p&gt;
&lt;p&gt;这里没有解释为什么在hello中调用index()的话，后面的代码不会再执行。这是因为每个render方法都会通过代码增强，抛出一个异常（需求证），这点在本例中没有体现。&lt;/p&gt;
&lt;p&gt;以上代码中还有一个localObject1没有提到，因为我目前也不知道它有什么用，先放在这里，等以后补充。&lt;/p&gt;
&lt;p&gt;除了这里提到的几点外，play还有很多类似的增强。如果希望能更好地使用play（以及避开某些因代码增强导致的陷阱），需要对这些多一些了解。在以后的学习中，我会陆续写一些笔记，感谢关注。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>play-groovy:离期望的playframework更近一步</title>
                <link>http://freewind.in/posts/1108-play-groovy-makes-playframework-closes-to-my-expectation</link>
                <pubDate>Fri, 16 Nov 2012 23:36:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1108</guid>
                <description><![CDATA[&lt;p&gt;这里所说的playframework是指play1，而不是play2。另外，本文中不考虑scala。&lt;/p&gt;
&lt;p&gt;Play1是一个很有创造力的java web框架，在很多方面离我的期待都很接近了。它通过各种字节码增强技术，大大简化了各种操作，使用起来让人感觉非常舒适。&lt;/p&gt;
&lt;p&gt;但它有一个无法克服的问题：必须使用java语言。这在很多时候都不太方便，比如缺少多行文本，字符串表达式，闭包等等，另外想在代码中直接拼json也很麻烦。&lt;/p&gt;
&lt;p&gt;为了解决这些问题，曾经我尝试过xtend，因为它在eclipse的帮助下，直接生成java源代码，与play集成在理论上没问题。我们可以在其它的目录中写xtend代码，让java源文件生成到app目录下，让play直接读取，这样就不需要额外写xtend的插件了。可惜由于xtend的不成熟，以及生成的java代码与其它库的习惯不同（field前加了一个下划线），使用起来各种不方便。虽然我很看好xtend即将推出的active annotation功能，但在目前的情况下，基本上是无法使用的。&lt;/p&gt;
&lt;p&gt;昨天突然看到了一个插件，可以让play支持groovy：&lt;a href=&quot;https://github.com/marekpiechut/play-groovy&quot;&gt;https://github.com/marekpiechut/play-groovy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该插件实现了groovy的编译器，并且处理好了hot-reload，使用起来跟java的感觉一致。目前只支持groovy 1.8，还不支持groovy 2.x&lt;/p&gt;
&lt;p&gt;经过我的简单尝试，感觉比较满意：hot-reload, 出错报告，与java代码共存，ebean插件等，都运行良好。也许深入使用后，还会发现其它的一些问题，不过目前来说，感觉很满意。&lt;/p&gt;
&lt;p&gt;我并没有专门去学习groovy语言，而是完全把它当作java来用，因为对于java的绝大部分语法，groovy都直接支持。看看我的groovy代码，基本上跟java一模一样：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Application extends Controller {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; index() {
    List&amp;lt;Question&amp;gt; questions = Question.find.all();
    render(questions)
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; askQuestion() {
    render()
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; createQuestion(String title, String content) {
    Question question = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Question()
    question.title = title
    question.content = content
    question.save()
    index()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;但我又可以在需要的时候，使用那些java没有提供的功能，比如：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; text() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    renderText(&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;&apos;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Hello, this
                is multi-line
                text&apos;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;&apos;&amp;lt;/span&amp;gt;)
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; strExpression() {
    String name = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Freewind&quot;&amp;lt;/span&amp;gt;
    renderText(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Hello, this is ${name}&quot;&amp;lt;/span&amp;gt;)
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; html() {
    renderHtml(&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;&apos;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;&amp;lt;h1&amp;gt;hello,html&amp;lt;/h1&amp;gt;&apos;&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;&apos;&amp;lt;/span&amp;gt;)
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; smallJson() {
    def res = [hello: &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;world&apos;&amp;lt;/span&amp;gt;,
            iam: &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;freewind&apos;&amp;lt;/span&amp;gt;]
    renderJSON(res)
}```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;还有我特别想要的拼复杂的json功能（如果前台使用一些js mvc框架，需要从后台取大量json数据）&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; json() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    def builder = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; groovy.json.JsonBuilder()
    def root = builder.people {
        person {
            firstName &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Guillame&apos;&amp;lt;/span&amp;gt;
            lastName &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Laforge&apos;&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (1 == 0) {
                address {
                    city &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Paris&apos;&amp;lt;/span&amp;gt;
                    country &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;France&apos;&amp;lt;/span&amp;gt;
                    zip 12345
                }
            }
            married &amp;lt;span class=&quot;kwrd&quot;&amp;gt;true&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;rem&quot;&amp;gt;// a list of values&amp;lt;/span&amp;gt;
            conferences &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;JavaOne&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;Gr8conf&apos;&amp;lt;/span&amp;gt;
        }
    }
    renderJSON(builder.toString())
}```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;这个json builder的语法，是不是很简洁？里面甚至还可以有业务逻辑。&lt;/p&gt;
&lt;p&gt;对于闭包之类的功能，可以在需要用的时候再去查文档。而上面这些简单而有用的功能，只需要看几眼文档就可以了，几乎没有学习成本。在编辑器的帮助下，如果我们按java的思路来写代码，错误检查、方法提示等功能，都可以运行的很好。&lt;/p&gt;
&lt;p&gt;我觉得这是一种很划算的做法：用很小很小的学习成本，带来较大的便利。在通常的情况下，尽量使用java语法，但当某些时候觉得特别不方便时，再看看groovy中有没有提供什么语法糖，能简化我们的代码，让代码看起来更整洁。&lt;/p&gt;
&lt;p&gt;写到这里，也许大家心里都有一个疑问：&lt;strong&gt;性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;groovy是一种动态语言，性能要比java差很多。但我觉得这不是个大问题，毕竟groovy那边有个grails，这么多年不是运行的好好的吗？如果还是不放心，还有一个好消息：groovy 2.x同时支持静态类型。只需要在代码中增加一个@TypeChecked注解，就可以将静态调用按静态方式编译代码，几乎跟java的性能一样。等该插件支持groovy 2.x时，就可以放心地使用了。&lt;/p&gt;
&lt;p&gt;等熟悉groovy后，还可以利用它的一些其它特性，进一步精简我们的代码。&lt;/p&gt;
&lt;p&gt;我觉得这个插件特别适合于那些喜欢play，不满java与scala的朋友使用。相比scala，groovy不论是学习成本还是一java之间的结合都要好得多。目前该插件还比较简单，版本号仅为0.1，可以预见在实际使用过程中会遇到一些问题，希望有兴趣的朋友可以一些完善它。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;groovy 2.x新特性：&lt;a href=&quot;http://fr.slideshare.net/glaforge/groovy-20-webinar&quot;&gt;http://fr.slideshare.net/glaforge/groovy-20-webinar&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;steven0lisa&lt;/h3&gt;
&lt;p&gt;解决了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在插件目录下执行mvn package，使groovy脚本编译成class。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.将target目录下的play-groovy.jar复制到插件的lib目录下，没有目录的话自行新建。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>动态编译java源代码</title>
                <link>http://freewind.in/posts/1105-compile-java-sourcecode-dynamically</link>
                <pubDate>Fri, 16 Nov 2012 11:39:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1105</guid>
                <description><![CDATA[&lt;p&gt;如何在运行时，动态将一个由java源代码组成的字符串编译为Java类？&lt;/p&gt;
&lt;p&gt;注意，全部的操作都需要在内存中完成，不能把字符串保存到磁盘上。&lt;/p&gt;
&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;package compiles;&lt;/p&gt;
&lt;p&gt;import java.lang.reflect.Method;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;/*&lt;em&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt; * User: Freewind&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt; * Blog: http://freewind.me&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt; * Date: 12-11-16&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;  &lt;/em&gt;/&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; CreateClassFromString {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; final String JAVA_SOURCE = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;public class Hello {&quot;&amp;lt;/span&amp;gt;
        + &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    public void say() {&quot;&amp;lt;/span&amp;gt;
        + &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;        System.out.println(\&quot;world!\&quot;);&quot;&amp;lt;/span&amp;gt;
        + &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    }&quot;&amp;lt;/span&amp;gt;
        + &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;}&quot;&amp;lt;/span&amp;gt;;

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; main(String[] args) throws Exception {
    Class dynaCls = compile(JAVA_SOURCE);
    Method say = dynaCls.getMethod(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;say&quot;&amp;lt;/span&amp;gt;);
    say.invoke(dynaCls.newInstance());

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// it will print &quot;world!&quot; on the console&amp;lt;/span&amp;gt;
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; Class compile(String source) {
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// compile the source to a class&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```&lt;/p&gt;
&lt;h2&gt;解决方案一：使用由Jdk1.6提供的JavaCompiler&lt;/h2&gt;
&lt;p&gt;在jdk1.6中，提供了一个JavaCompiler接口，它可以方便的将java源代码编译为字节码。&lt;/p&gt;
&lt;p&gt;思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过ToolProvider.getSystemJavaCompiler()得到系统javac&lt;/li&gt;
&lt;li&gt;通过compiler.getTask(&amp;hellip;)创建一个编译任务，需传入一些参数，如java源文件等&lt;/li&gt;
&lt;li&gt;调用task.call()，进行编译&lt;/li&gt;
&lt;li&gt;loadClass(&amp;hellip;)载入刚编译出来的类，进行操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;额外操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传入-g参数，使得生成的字节码不会改变变量名等&lt;/li&gt;
&lt;li&gt;两类互调：源代码一同传入getTask(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;调用第三方库中的代码。只要将第三方库的jar加入到项目的classpath中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;package compiles;&lt;/p&gt;
&lt;p&gt;import javax.tools.FileObject;
&lt;br  /&gt;import javax.tools.ForwardingJavaFileManager;
&lt;br  /&gt;import javax.tools.JavaCompiler;
&lt;br  /&gt;import javax.tools.JavaFileManager;
&lt;br  /&gt;import javax.tools.JavaFileObject;
&lt;br  /&gt;import javax.tools.SimpleJavaFileObject;
&lt;br  /&gt;import javax.tools.StandardJavaFileManager;
&lt;br  /&gt;import javax.tools.ToolProvider;
&lt;br  /&gt;import java.io.ByteArrayOutputStream;
&lt;br  /&gt;import java.io.IOException;
&lt;br  /&gt;import java.io.OutputStream;
&lt;br  /&gt;import java.net.URI;
&lt;br  /&gt;import java.security.SecureClassLoader;
&lt;br  /&gt;import java.util.ArrayList;
&lt;br  /&gt;import java.util.HashMap;
&lt;br  /&gt;import java.util.List;
&lt;br  /&gt;import java.util.Map;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; DynaCompTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; main(String[] args) throws Exception {
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Full name of the class that will be compiled.&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// If class should be in some package, fullName should contain it too (ex. &quot;testpackage.DynaClass&quot;)&amp;lt;/span&amp;gt;
    String fullName = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;DynaClass&quot;&amp;lt;/span&amp;gt;;

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Here we specify the source code of the class to be compiled&amp;lt;/span&amp;gt;
    StringBuilder src = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; StringBuilder();
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;public class DynaClass {\n&quot;&amp;lt;/span&amp;gt;);
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    public void setName(String name) {}\n&quot;&amp;lt;/span&amp;gt;);
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    public void invokeAnother() { System.out.println(new DynaClass1()); }\n&quot;&amp;lt;/span&amp;gt;);
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    public String toString() {\n&quot;&amp;lt;/span&amp;gt;);
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;        return \&quot;Hello, I am \&quot; + this.getClass().getSimpleName();\n&quot;&amp;lt;/span&amp;gt;);
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    }\n&quot;&amp;lt;/span&amp;gt;);
    src.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;}\n&quot;&amp;lt;/span&amp;gt;);

    String fullName1 = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;DynaClass1&quot;&amp;lt;/span&amp;gt;;
    StringBuilder src1 = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; StringBuilder();
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;public class DynaClass1 {\n&quot;&amp;lt;/span&amp;gt;);
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    public void invokeAnother() { System.out.println(new DynaClass()); }\n&quot;&amp;lt;/span&amp;gt;);
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    public String toString() {\n&quot;&amp;lt;/span&amp;gt;);
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;        org.apache.commons.lang.StringUtils.trim(\&quot; a \&quot;);\n&quot;&amp;lt;/span&amp;gt;);
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;        return \&quot;Hello, I am \&quot; + this.getClass().getSimpleName();\n&quot;&amp;lt;/span&amp;gt;);
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;    }\n&quot;&amp;lt;/span&amp;gt;);
    src1.append(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;}\n&quot;&amp;lt;/span&amp;gt;);

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// We get an instance of JavaCompiler. Then we create a file manager (our custom implementation of it)&amp;lt;/span&amp;gt;
    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    JavaFileManager fileManager = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; ClassFileManager(compiler.getStandardFileManager(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;));

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Dynamic compiling requires specifying&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// a list of &quot;files&quot; to compile. In our case this is a list containing one &quot;file&quot; which is in our case&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// our own implementation (see details below)&amp;lt;/span&amp;gt;
    List&amp;lt;JavaFileObject&amp;gt; jfiles = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; ArrayList&amp;lt;JavaFileObject&amp;gt;();
    jfiles.add(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; CharSequenceJavaFileObject(fullName, src));
    jfiles.add(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; CharSequenceJavaFileObject(fullName1, src1));

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// We specify a task to the compiler. Compiler should use our file manager and our list of &quot;files&quot;.&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Then we run the compilation with call()&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (compiler.getTask(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;, fileManager, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;, jfiles).call()) {
        &amp;lt;span class=&quot;rem&quot;&amp;gt;// Creating an instance of our compiled class and running its toString() method&amp;lt;/span&amp;gt;
        Object instance = fileManager.getClassLoader(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;).loadClass(fullName1).newInstance();
        System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(instance);
    } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;else&amp;lt;/span&amp;gt; {
        System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;### failed&quot;&amp;lt;/span&amp;gt;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; CharSequenceJavaFileObject extends SimpleJavaFileObject {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * CharSequence representing the source code to be compiled&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; CharSequence content;

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * This constructor will store the source code in the internal &amp;ldquo;content&amp;rdquo; variable and register it as a source code,&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * using a URI containing the class full name&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     &lt;em&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * @param className name of the public class in the source code&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * @param content   source code to compile&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     &lt;/em&gt;/&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; CharSequenceJavaFileObject(String className, CharSequence content) {
    super(URI.create(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;string:///&quot;&amp;lt;/span&amp;gt; + className.replace(&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;.&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;/&apos;&amp;lt;/span&amp;gt;) + Kind.SOURCE.extension), Kind.SOURCE);
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;this&amp;lt;/span&amp;gt;.content = content;
}

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Answers the CharSequence to be compiled. It will give the source code stored in variable &amp;ldquo;content&amp;rdquo;&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; CharSequence getCharContent(boolean ignoreEncodingErrors) {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; content;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; JavaClassObject extends SimpleJavaFileObject {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Byte code created by the compiler will be stored in this ByteArrayOutputStream&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * so that we can later get the byte array out of it and put it in the memory as an instance of our class.&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;protected&amp;lt;/span&amp;gt; final ByteArrayOutputStream bos = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; ByteArrayOutputStream();

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Registers the compiled class object under URI containing the class full name&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     &lt;em&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * @param name Full name of the compiled class&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * @param kind Kind of the data. It will be CLASS in our case&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     &lt;/em&gt;/&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; JavaClassObject(String name, Kind kind) {
    super(URI.create(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;string:///&quot;&amp;lt;/span&amp;gt; + name.replace(&amp;lt;span class=&quot;str&quot;&amp;gt;&apos;.&apos;&amp;lt;/span&amp;gt;, &amp;lt;span class=&quot;str&quot;&amp;gt;&apos;/&apos;&amp;lt;/span&amp;gt;) + kind.extension), kind);
}

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Will be used by our file manager to get the byte code that can be put into memory to instantiate our class&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     &lt;em&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * @return compiled byte code&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     &lt;/em&gt;/&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;byte&amp;lt;/span&amp;gt;[] getBytes() {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; bos.toByteArray();
}

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Will provide the compiler with an output stream that leads to our byte array.&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * This way the compiler will write everything into the byte array that we will instantiate later&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; OutputStream openOutputStream() throws IOException {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; bos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; ClassFileManager extends ForwardingJavaFileManager {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Instance of JavaClassObject that will store the compiled bytecode of our class&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; Map&amp;lt;String, JavaClassObject&amp;gt; map = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; HashMap&amp;lt;String, JavaClassObject&amp;gt;();

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Will initialize the manager with the specified standard java file manager&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; ClassFileManager(StandardJavaFileManager standardManager) {
    super(standardManager);
}

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Will be used by us to get the class loader for our compiled class.&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * It creates an anonymous class extending the SecureClassLoader which uses the byte code created by the compiler&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     * and stored in the JavaClassObject, and returns the Class for it&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; ClassLoader getClassLoader(Location location) {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; SecureClassLoader() {
        @Override
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;protected&amp;lt;/span&amp;gt; Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
            JavaClassObject jclassObject = map.get(name);
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;byte&amp;lt;/span&amp;gt;[] b = jclassObject.getBytes();
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; super.defineClass(name, jclassObject.getBytes(), 0, b.length);
        }
    };
}

&amp;lt;span class=&quot;rem&quot;&amp;gt;/**&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;rem&quot;&gt;     * Gives the compiler an instance of the JavaClassObject so that the compiler can write the byte code into it.&lt;/span&gt;
&lt;br  /&gt;&lt;span class=&quot;rem&quot;&gt;     */&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling)
        throws IOException {
    map.put(className, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; JavaClassObject(className, kind));
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; map.get(className);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play1中自定义helper类的技巧</title>
                <link>http://freewind.in/posts/1099-skills-to-define-helper-in-play1</link>
                <pubDate>Wed, 07 Nov 2012 13:07:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1099</guid>
                <description><![CDATA[&lt;p&gt;大家都知道，Play1的模板使用了groovy作为模板语言，并且不允许在模板中直接创建方法。这个限制非常不方便，因为我们经常需要在在页面中创建一些临时使用的工具方法。&lt;/p&gt;
&lt;p&gt;Play给出了两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义自己的JavaExtensions类&lt;/li&gt;
&lt;li&gt;在模板中以全路径方式调用方法，如&quot;org.apache.commons.StringUtils.trimToEmpty(mystr)&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法都不够轻量，这里介绍一种更方便的方法：在action中创建一个匿名的工具类实例，传给模板&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; show() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object h = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Object() {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; String trimToEmpty(Object obj) {
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt;(obj==&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt;) &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;&quot;&amp;lt;/span&amp;gt;;
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; obj.toString();
    }
}
render(h);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;style type=&quot;text /css&quot;&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }
&lt;br  /&gt;&lt;/style&gt;```&lt;/p&gt;
&lt;p&gt;在模板中就可以这样使用：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;h1&gt;Hello, ${h.trimToEmpty(name)};&lt;/h1&gt;&lt;style type=&quot;text /css&quot;&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }
&lt;br  /&gt;&lt;/style&gt;```&lt;/p&gt;
&lt;p&gt;对于临时使用的工具方法，这种方式非常适合。如果想在本controller范围或全局范围使用，只需要在合适的地方，创建一个action，使用play.mvc.Before，把它事先放入renderArgs中即可。&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;@Before
&lt;br  /&gt;&lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; prepareHelper() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Helper helper = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; Helper();
renderArgs.put(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;h&quot;&amp;lt;/span&amp;gt;, helper&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;green&lt;/h3&gt;
&lt;p&gt;顶版主，喜欢这样轻量的代码。play-app-base预定义了一些helper大家喜欢可以直接拿来用。参见：https://github.com/greenlaw110/play-app-base/tree/master/src/com/greenlaw110/utils&lt;/p&gt;
&lt;p&gt;补充一下，如果是所有的模版都打算使用这些helper的话，可以定义一个filter：&lt;/p&gt;
&lt;p&gt;public class HelperLoader extends Controller {
&lt;br  /&gt;@Before static void loadHelpers() {
&lt;br  /&gt;renderArgs.put(“h1″, …);
&lt;br  /&gt;renderArgs.put(“h2″, …);
&lt;br  /&gt;}
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;然后在其他Controller上用@With(HelperLoader.class)即可。&lt;/p&gt;
&lt;p&gt;如果用rythm模版引擎的话可以更简单一些：在app/rythm目录下创建一个文件__addon.src, 放入在模版中需要的helper即可：&lt;/p&gt;
&lt;p&gt;com.greenlaw110.utils.S s = com.greenlaw110.utils.S.instance;
&lt;br  /&gt;..&lt;/p&gt;
&lt;p&gt;不需要在任何地方声明@Before或者@With了&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Android界面制作中最重要最强大的武器: 9-patch</title>
                <link>http://freewind.in/posts/1095-android-9-patch</link>
                <pubDate>Fri, 02 Nov 2012 12:57:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1095</guid>
                <description><![CDATA[&lt;p&gt;这段时间做Android项目，其中感觉最头疼的一点就是界面的制作。面对设计师发过来的效果图，想要做出与之完全相符的效果，真是头疼万分。&lt;/p&gt;
&lt;p&gt;因为Android不像iphone那样，只需要面对一两种屏幕，所以大部分图片可直接截图使用，甚至绝对定位。而Android中，需要考虑到不同的屏幕大小以及dpi，直接使用原图图片基本上是没法使用的。&lt;/p&gt;
&lt;p&gt;之前由于刚刚使用android，只能使用笨办法。&lt;/p&gt;
&lt;p&gt;对于简单的，使用xml格式来描述效果。比如要在一张图片加一个圆角外边框，我使用以下代码来描述这样的一个边框：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;shape xmlns:android=&lt;span class=&quot;str&quot;&gt;&amp;ldquo;http://schemas.android.com/apk/res/android&amp;rdquo;&lt;/span&gt;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;stroke android:width=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;1dp&quot;&amp;lt;/span&amp;gt; android:color=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;#6D6866&quot;&amp;lt;/span&amp;gt;/&amp;gt;
&amp;lt;padding android:left=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;1dp&quot;&amp;lt;/span&amp;gt; android:top=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;1dp&quot;&amp;lt;/span&amp;gt; android:right=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;1dp&quot;&amp;lt;/span&amp;gt; android:bottom=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;1dp&quot;&amp;lt;/span&amp;gt;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/shape&gt;```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;过程很繁琐，因为需要手动取色，量边框宽度，padding距离等等，鼠标可得一个像素一个像素的移动，这个过程能把人的眼睛盯瞎。&lt;/p&gt;
&lt;p&gt;而对于一些难以模拟的效果，只好把图片切成一块一块的，然后在android繁杂无比的xml描述文件中，一点点拼起来。&lt;/p&gt;
&lt;p&gt;这两种方法都非常痛苦和低效，经常一个简单的页面都要做上一天，然后还要在不同的屏幕分辨率下，手动调整长度、边距等数据，让我真不想再做android了。&lt;/p&gt;
&lt;p&gt;直到前两天我发现了9-patch图片，才发现我之前的做法多么笨。关于9-patch，之前我也听说过，就是把一张图片分成三行三列的9宫格，在放大缩小的时候，四个角不变，其它部分伸缩。这样只要图片在设计时注意一下，出来的图片就可以轻松适应各种分辨率及大小，都有不错的显示效果。&lt;/p&gt;
&lt;p&gt;但因为html不支持这种图片方式，所以我一直没用过，不知道它到底能做到什么程度。经过两天的使用，发现它可以使用简单的步骤，就实现出一些复杂的效果，以前一天的工作量，现在可以在一两个小时能完成，大大提高了开发效率。它是android界面实现中，最重要最强大的武器，那“遁去的一”。&lt;/p&gt;
&lt;p&gt;9-patch又叫9-slice，下面以例子讲解一下。首先看一个圆色按钮：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-1.png&quot;&gt;&lt;img src=&quot;/user_images/1095-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果把它整个当作一个按钮的背景，则在缩放的过程中，会变形，很难看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-3.png&quot;&gt;&lt;img src=&quot;/user_images/1095-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细观察图片，发现变形难看的地方，主要是四个角。如果能在缩放过程中，保持4个角不变，应该会得到比较好的效果。可把它看作由下面三行三列组成：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-5.png&quot;&gt;&lt;img src=&quot;/user_images/1095-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样在变形时，如果保持4角不变，会产生以下效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-7.png&quot;&gt;&lt;img src=&quot;/user_images/1095-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相比前面的，效果要好很多吧。&lt;/p&gt;
&lt;p&gt;不光是简单的按钮，其它很多效果也可以使用9-patch实现。比如下面这个效果（只看边框）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-9.png&quot;&gt;&lt;img src=&quot;/user_images/1095-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它可以用两个9-pacth图片实现，分别为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-11.png&quot;&gt;&lt;img src=&quot;/user_images/1095-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/user_images/1095-13.png&quot;&gt;&lt;img src=&quot;/user_images/1095-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图片最外面的两条黑线先不管，后面会讲解。仔细看右图，发现上面有一条蓝线，正是前面图中间的分隔线。&lt;/p&gt;
&lt;p&gt;再看这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-15.png&quot;&gt;&lt;img src=&quot;/user_images/1095-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种很炫的图片，又有渐变，上面还有带阴影的分隔，照样一个9-patch图片搞定。&lt;/p&gt;
&lt;p&gt;还有带阴影的边框：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-17.png&quot;&gt;&lt;img src=&quot;/user_images/1095-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中间的颜色可忽略，关键是它四周淡淡的阴影。只要使用这个图片，就可以轻松的给各种大小的图片套上一个阴影边框。&lt;/p&gt;
&lt;p&gt;诸如此类，各种复杂的效果，都可以简单的用9-patch实现。&lt;/p&gt;
&lt;p&gt;不过也有一些效果不行，看下面这个图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-19.png&quot;&gt;&lt;img src=&quot;/user_images/1095-19.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它无法使用9-patch，因为在竖方向上，它没有办法分成三行。只能横向缩放。&lt;/p&gt;
&lt;p&gt;与设计师沟通后，把它变成了这样：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-21.png&quot;&gt;&lt;img src=&quot;/user_images/1095-21.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然风格变了，没前面的好看，不过这也是效果与开发难度之间平衡的结果。&lt;/p&gt;
&lt;p&gt;例子看完了，那么9-patch到底有哪些规定呢？看下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-23.png&quot;&gt;&lt;img src=&quot;/user_images/1095-23.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在一个原始图片的四周，可加上4条黑线。左与上，用来确定图片哪些部分是可缩放的。右与下，表示如果把该图片当作背景，那么里面哪些部区域是可填充的（相当于设了padding）。通常简单的情况，我们只需要画出左与上即可，因为右与下默认使用左与上的设置。&lt;/p&gt;
&lt;p&gt;在android中提供了一个专门画9-patch的工具，由swing写成，位于android-sdk/tools/draw9patch.bat。运行后界面如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-25.png&quot;&gt;&lt;img src=&quot;/user_images/1095-25.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;左边是打开的原始图片，右边是实时变形后的预览图，下面是各种选项。&lt;/p&gt;
&lt;p&gt;左边的图片，只有四条边是供我们画线的。如果把鼠标移到中间不可编辑的区域，会显示下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-27.png&quot;&gt;&lt;img src=&quot;/user_images/1095-27.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表示禁止画点。&lt;/p&gt;
&lt;p&gt;我们通常要做的，仅仅是在最左边和最上面的一像素宽的区域里，画出一条线，表示可缩放的区域：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-29.png&quot;&gt;&lt;img src=&quot;/user_images/1095-29.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到左与上那两条黑线了吗？画的过程比较痛苦，因为没有快捷键可一下子画好，鼠标歪一下中间就会漏很多点，只能一点点补。所以在制作图片时，要弄的小一点。&lt;/p&gt;
&lt;p&gt;想以直观的方式看缩放区域吗？勾选下面的&quot;show patches&amp;rdquo;，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-31.png&quot;&gt;&lt;img src=&quot;/user_images/1095-31.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到我上面那条边画得靠左了。从右边的实时预览区域，可看到会有不好看的变形：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-33.png&quot;&gt;&lt;img src=&quot;/user_images/1095-33.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这时可按住shift，再用鼠标点去错误的点：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-35.png&quot;&gt;&lt;img src=&quot;/user_images/1095-35.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;画好后保存，它会以.9.png的格式保存为图片，然后在android中当作普通图片使用即可，android会自动处理缩放时的变形。&lt;/p&gt;
&lt;p&gt;在前面的操作过程中，发现画线很不方便，因为经常漏掉一些点，出现像下面这样的图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-37.png&quot;&gt;&lt;img src=&quot;/user_images/1095-37.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是怎么回事，会不会有问题？android会怎么处理呢？&lt;/p&gt;
&lt;p&gt;不用担心，这实际上是超出我预期的一个强大功能：可指定多个缩放区域。正是这个功能，彻底打动了我。&lt;/p&gt;
&lt;p&gt;看下面这张图片：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-39.png&quot;&gt;&lt;img src=&quot;/user_images/1095-39.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我希望在缩放的过程中，数学不变，而它们之间的空白会变，怎么办呢？好办，按下面这种方式画出黑线：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-41.png&quot;&gt;&lt;img src=&quot;/user_images/1095-41.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再看变形后的效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-43.png&quot;&gt;&lt;img src=&quot;/user_images/1095-43.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/user_images/1095-45.png&quot;&gt;&lt;img src=&quot;/user_images/1095-45.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/user_images/1095-47.png&quot;&gt;&lt;img src=&quot;/user_images/1095-47.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然数字没变，而空白变了，厉害！&lt;/p&gt;
&lt;p&gt;这个功能对于这种情况很有用：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-49.png&quot;&gt;&lt;img src=&quot;/user_images/1095-49.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果把这个图片当作整体（包含上面的字），想让它适应多种大小的同时，字保持不变，知道怎么做了吧？&lt;/p&gt;
&lt;p&gt;这些基本功能已经非常强大了。之前需要在android的布局文件中，繁琐无比地描述、设置，而现在需要做的，仅仅是画几条线。&lt;/p&gt;
&lt;p&gt;另外发现除了可以画黑线外，还可以画layout，不过我还不清楚该功能有什么用，需要再研究一下。如果很重要的话，会补上来。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1095-51.png&quot;&gt;&lt;img src=&quot;/user_images/1095-51.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;补充资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://radleymarx.com/blog/simple-guide-to-9-patch/&quot;&gt;http://radleymarx.com/blog/simple-guide-to-9-patch/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;关于前面提到的layout: &lt;a href=&quot;http://stackoverflow.com/questions/11406521/android-9-patch-tool-what-is-the-new-layout-bounds-feature&quot;&gt;http://stackoverflow.com/questions/11406521/android-9-patch-tool-what-is-the-new-layout-bounds-feature&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Android步步惊心 之 asyncTask.class.newInstance()报错（修正版）</title>
                <link>http://freewind.in/posts/1038-android-asynctask-new-instance-errors</link>
                <pubDate>Wed, 31 Oct 2012 20:18:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1038</guid>
                <description><![CDATA[&lt;p&gt;自建了一个AsyncTask，内容不是重点，示例如下：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; MyTask extends AsyncTask&lt;Void, Integer, Void&gt; {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;protected&amp;lt;/span&amp;gt; Void doInBackground(Void... &amp;lt;span class=&quot;kwrd&quot;&amp;gt;params&amp;lt;/span&amp;gt;) {
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// do something&amp;lt;/span&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;&lt;/p&gt;
&lt;p&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;在代码中，由于会取消并重建该Task，所以写了一个Helper方法：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;  &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;T extends AsyncTask&gt; T createAsyncTask(T t, Class&lt;T&gt; cls) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (t == &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt; || t.isCancelled() || t.getStatus() == AsyncTask.Status.FINISHED) {
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;try&amp;lt;/span&amp;gt; {
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; cls.newInstance();
        } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;catch&amp;lt;/span&amp;gt; (Exception e) {
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;throw&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; RumtimeException(e);
        }
    }
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; t;
}```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是可在自己的代码中这么调用：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; MyTask mytask;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; MyTask getOrCreateMyTask() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mytask = Helper.createAsyncTask(mytask);
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; mytask;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```&lt;/p&gt;
&lt;p&gt;运行时发现经常出错，报这个错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.InstantiationException: MyTask
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错误位于return cls.newInstance()这一行。&lt;/p&gt;
&lt;p&gt;经过反复测试，发现第一次调用这行代码，正常返回一个MyTask实例，第二次再调用时，就会报错。而且错误信息只能得到cls.newInstance()出错，再往里就是native代码，没法调了。&lt;/p&gt;
&lt;p&gt;我开始以为是我的代码有问题，反复调试，查看AsyncTask的源代码，都没发现可疑之处。万般无奈之下，去掉了这个助手方法，而是直接写在getOrCreateMyTask()方法中：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; AsyncTask getOrCreateMyTask() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (mytask == &amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt; || mytask.isCancelled() || mytask.getStatus() == AsyncTask.Status.FINISHED) {
    mytask = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; MyTask();
}
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; mytask;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```&lt;/p&gt;
&lt;p&gt;不同之处在于，这次使用 new MyTask() 而不是 cls.newInstance()。再试，一切正常！再也没有出现那个错误了。&lt;/p&gt;
&lt;p&gt;然后，我又把MyTask换成了一个普通的类，使用cls.newInstance()一切正常。&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;实在没想到，连cls.newInstance()这样基本的方法，在android中都有可能出错。&lt;/strike&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修正：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非常抱歉，这完全不是android的错，而是我的错。&lt;/p&gt;
&lt;p&gt;之所以无法cls.newIntance()，是因为该MyTask是一个private inner类，在此情况下无法通过该方法创建。&lt;/p&gt;
&lt;p&gt;可以把它改为：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; MyTask extends AsyncTask&lt;Void, Integer, Void&gt; {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; MyTask() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; MyTask extends AsyncTask&lt;Void, Integer, Void&gt; {
&lt;br  /&gt;}```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;
&lt;br  /&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }&lt;/style&gt;&lt;/p&gt;
&lt;p&gt;由于这段时间开发android应用，遇到了太多莫名其妙的错误，所以遇到与自己所知不同的问题时，会首先想到是android有bug。以后要更加谨慎一些。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Android步步惊心 之 破碎的渐变色图片(png格式)</title>
                <link>http://freewind.in/posts/1037-android-broken-png-image</link>
                <pubDate>Tue, 30 Oct 2012 20:15:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">1037</guid>
                <description><![CDATA[&lt;p&gt;最初遇到此问题时，我以为是我那500元的廉价Android手机屏幕有问题，显示的颜色种类不够，导致一张渐变色的png图片，变成了条状：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1037-1.png&quot;&gt;&lt;img src=&quot;/user_images/1037-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一边暗自诅咒“便宜没好货”，一边打开了手机上的浏览器连到电脑上，查看该图片，没想到一切正常：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1037-3.png&quot;&gt;&lt;img src=&quot;/user_images/1037-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原始图片是什么样子呢？如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1037-5.png&quot;&gt;&lt;img src=&quot;/user_images/1037-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意看最右边的颜色要比左边深一点，平滑的渐变色。&lt;/p&gt;
&lt;p&gt;意料之中，又是意料之中，我又遇到了一个android bug。其实完全说bug也不对，这是android为了减少渲染图片的时间，默认这么处理的。但坑爹之处在于，你到是给个简单的设置让我们选择如何渲染啊。根据不完全统计，有以下这些方式可以解决这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strike&gt;在xml中，为图片创建一个xml格式的drawable，然后把dither设为true。&lt;/strike&gt; （经测试无效）2.  在java代码中，取得该图片，并设为true。（未测试）3.  &lt;strike&gt;getWindow().setFormat(PixelFormat.RGBA_8888);&lt;/strike&gt; （经测试无效）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出这还应该算是一个bug，不然怎么会有这么多五花八门的解决方案呢。&lt;/p&gt;
&lt;p&gt;最终成功的解决方法，相当之诡异：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;把该图片的透明度设为99%，重新保存。其它什么也不用动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;则一切正常。&lt;/p&gt;
&lt;p&gt;不能不承认，能想到此方法的人真是天才，这得经过多少次的推测与尝试，才能找到这个方法。据说它之所以能成功解决，是因为满足了两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;png图片中开启了alpha通道（透明）2.  至少有一个像素使用了该alpha通道&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;于是，干脆直接把整张图片直接设为99%，简单粗暴。反正人眼也是看不出那1%的透明度的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/1037-7.png&quot;&gt;&lt;img src=&quot;/user_images/1037-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;连正常显示一张图片的功能都能做得如此跌宕起伏，android，真有你的！&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/13137735/why-android-lose-image-quality-when-displaying-a-png-file/13138028#13138028&quot;&gt;Why android lose image quality when displaying a png file?&lt;/a&gt;2.  &lt;a href=&quot;http://stackoverflow.com/questions/4769885/androiddither-true-does-not-dither-whats-wrong&quot;&gt;android:dither=“true” does not dither, what&apos;s wrong?&lt;/a&gt;3.  &lt;a href=&quot;http://www.curious-creature.org/2010/12/08/bitmap-quality-banding-and-dithering/&quot;&gt;Bitmap quality, banding and dithering&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Android之残缺的神器：android-x86 + vmlite</title>
                <link>http://freewind.in/posts/977-android-good-tool-android-x86-vmlite</link>
                <pubDate>Thu, 18 Oct 2012 22:47:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">977</guid>
                <description><![CDATA[&lt;p&gt;Android应用的开发让人苦不堪言，于是找到了一些神器，残缺的神器。之所以残缺，是因为它们还不够完美，只能在大多数情况下有用。&lt;/p&gt;
&lt;p&gt;这里要介绍的，是 &lt;strong&gt;Android-x86 + vmlite&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android运行于手机等移动设备，使用的芯片与普通电脑的CPU不同，所以Android不能在电脑上运行。但是&lt;a href=&quot;http://www.android-x86.org/&quot;&gt;Android-x86&lt;/a&gt;这个国产项目，却可以让Android运行在电脑里。不过因为它也是一种操作系统，不能像普通软件一样安装，通常装在虚拟机如Virtual-Box中才能使用。它有什么用呢？&lt;/p&gt;
&lt;p&gt;我们在虚拟机中开一个Android后，它就像是一个普通的Android模拟器，我们在开发时可直接把项目部署上去运行。相对于Android模拟器的龟速，它就是一只不睡觉的兔子。相于对真机，它的速度也快上很多，而且可以自定义分辨率。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#cccccc&quot;&gt;广告：&lt;/font&gt;&lt;a href=&quot;http://www.vpnst.com/152.html&quot;&gt;&lt;font color=&quot;#cccccc&quot;&gt;本博主最爱的vpn，每年60元，每月10G流量，不限速。博主已使用一年多。&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google提供的Android模拟器，速度是非常慢的。启动慢，运行慢，上传代码也慢。如果是几M，上传时间还可接受，但当到了20M左右时，上传一次的时间都够你吃顿午饭了。我一直搞不明白，为什么Android的虚拟机效率如此之低，要知道我的电脑可是i7级别的，但仍然慢得想杀人。如果使用真机会快很多，20M的部署时间也能控制在30秒内，尚可接受。但是使用Android-X86，上传并启动应用的时间能在3秒左右完成，没错，3秒。&lt;/p&gt;
&lt;p&gt;但Android-x86提供的镜像文件，安装之后几乎没法使用。虽然能启动，但是鼠标不灵，几乎没法控制。virtual-box的增强包在Android-x86中无法安装，所以在虚拟机与母机之间切换鼠标时，还需要按切换键。尝试的结果让人非常沮丧，因为几乎没法使用。光定位鼠标的时间就大于使用真机的时间了，而且这种体验非常影响人的心情。&lt;/p&gt;
&lt;p&gt;正当我在放弃之时，在stackoverflow上的朋友的帮助下，发现了vmlite提供的修改版。vmlite是一个收费的虚拟机项目，但是作者提供了android-x86的修改版，完美地解决了上面提到的两个问题，使用起来非常舒适。&lt;/p&gt;
&lt;p&gt;Vmlite提供的修改版地址：&lt;a href=&quot;http://www.vmlite.com/index.php?option=com_content&amp;amp;view=article&amp;amp;id=69&amp;amp;Itemid=178&quot;&gt;http://www.vmlite.com/index.php?option=com_content&amp;amp;view=article&amp;amp;id=69&amp;amp;Itemid=178&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载后解压，里面有两个文件是我们要用的，一个是已经安装好Android的镜像文件 VMLite-Android-v4.0.4.vmdk，另一个是sdcard的镜像文件 sdcard.vmdk&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://my.hengtian.org/aff.php?aff=1312&quot;&gt;&lt;font color=&quot;#cccccc&quot;&gt;广告：由衡天小张提供的博客空间，快速稳定，售后也不错，相当满意&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先截一张图，这是在Virutal-Box中安装好之后的效果，里面是Android 2.3.x，屏幕分辨率设为480&amp;#215;800：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/977-1.png&quot;&gt;&lt;img src=&quot;/user_images/977-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装过程对于熟手来说不难，先装好Virtual-Box，再建一个虚拟机，再导入那两个镜像文件即可。对于新手可能还有些难度，可参照vmlite地址中的步骤。等我慢点再写一个完整的安装教程出来。&lt;/p&gt;
&lt;p&gt;但装好之后，默认的屏幕大小是800&amp;#215;600的，而且不可更改。这是因为它已经把这个分辨率写死在启动文件中了，就算我们手动使用VirtualBox提供的命令修改了镜像文件的分辨率，也不会起作用。解决这个问题比较麻烦，需要有一定linux能力的人才能操作，基本思路是在linux系统中，mount这个虚拟机文件，然后找到启动文件，修改里面的一个参数。&lt;/p&gt;
&lt;p&gt;具体步骤参看这个问题，很详细的解决过程：&lt;a href=&quot;http://stackoverflow.com/questions/12493599/how-to-change-the-screen-size-of-vmlite-android&quot;&gt;http://stackoverflow.com/questions/12493599/how-to-change-the-screen-size-of-vmlite-android&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>C#入门学习体验</title>
                <link>http://freewind.in/posts/966-learning-c-sharp</link>
                <pubDate>Wed, 01 Aug 2012 02:32:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">966</guid>
                <description><![CDATA[&lt;p&gt;为了向图形图像转型，我这些天开始学习C#。学习C#的主要原因有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有unsafe关键字，有指针，可自己管理内存，从而提高性能。在铁哥的测试中，使用unsafe写出来的算法，是c/c++同等程序的75%左右，相当不错2.  对图形图像支持比较好，比如wpf的卖点之一，就是提供新的图形图像api，不再依赖于GDI/GDI+，而是Direct3D，利用硬件优势3.  c#语言本身特性丰富，可快速实现UI4.  .net库也很丰富，快速实现非核心功能5.  很多硬件只支持windows，所以在windows平台下开发，当然也得选择对windows支持最好的语言6.  有铁哥的成功经验！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为我是从Java转过来的，对于MS语言总有种天然的不习惯。但在考查过其它的一些语言之后，觉得还是C#优势最大，所以只能硬着头皮上了。&lt;/p&gt;
&lt;p&gt;人们都说C#和Java很像，从Java转到C#会比较容易，一开始我也是这么想的。没想到C#的入门远比预想中的困难，主要有以下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C#已不是当年山寨Java的那个C#了，它现在有很多新的特性都是Java没有的，需要学习&lt;em&gt;   .Net与Java在文化与代码风格上对立严重，从一个转向另一个，心里比较抵触&lt;/em&gt;   .Net产品线比较长，需要花时间了解哪些是需要现在学习的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过近一个星期的时间，现在处于半入门的阶段，成果是用C#+WPF做出了一个简单的GUI程序：QQ群聊天记录合并工具。之前用scala做过，这次主要是用它来熟悉常用API和类库。说是半入门，是因为只用到了C#和WPF最基本的功能，Visual C#的IDE会用了，算不上真正的入门。与上周学习Flex相比，难度大很多。&lt;/p&gt;
&lt;h2&gt;飞速发展的C&lt;/h2&gt;
&lt;p&gt;作为有多年经验的Java开发者，我对C#真是羡慕嫉妒恨。Java这些年，在语言层面几乎没有进步，连最基本的多行文本和闭包（或者再简化一点：lambda）都迟迟没有提供。一个闭包搞了六七年还没出来，还能让人说什么呢。而C#在3.0时，就具备了明年发布的Java8的特性，而4.0/5.0还有很多吸引人的新特性，比如LINQ和await/defer。相比Java的爬行，C#开着跑车。在学习C#时，想着当年Java的辉煌，心情郁闷。&lt;/p&gt;
&lt;p&gt;C#在语法风格上，与Java相差很多，甚至是一大障碍。比如方法名首字母大写！大括号另起一行！！无时无刻让我在做心里斗争。首字母大写这没办法，好在代码格式化中，可以让括号不起新行，算是舒服了一些。&lt;/p&gt;
&lt;p&gt;C#中的新特性很多，我只是先简单浏览了一下，还没有详细看，也没有在代码中运用。感觉有一大堆东西要学。&lt;/p&gt;
&lt;p&gt;可使用免费的&lt;a href=&quot;http://download.microsoft.com/download/c/a/9/ca988e8a-c0ea-4813-88dc-c23a37ac2ac2/vcs_web.exe&quot;&gt;Visual C# 2010 express&lt;/a&gt;来开发，功能强大，中途会提醒注册，免费注册后就可一直使用。&lt;/p&gt;
&lt;h2&gt;WPF&lt;/h2&gt;
&lt;p&gt;我最开始想用WinForm来入门，它有点像Java中的Swing，使用代码方式来写GUI程序。后来发现了WPF，看了一下，决定用它：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对图形图像方面支持比WinForm好2.  与Flex相似的方式开发（xaml画界面，c#写逻辑），比较适合我口味3.  与SilverLight相似，可用来开发跨浏览器/平台的富客户端程序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;WPF在数据绑定上不太好用，与Flex相比差太远了，我在写代码时，宁愿在C#中绑定，也不愿意在xaml中写。这里可参考铁哥中的相关文章：&lt;a href=&quot;http://www.cnblogs.com/xiaotie/archive/2011/02/14/1953993.html&quot;&gt;WPF/Silverlight的数据绑定设计的真糟糕&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但总体来说，它还是.net中最适合我需求的东西，所以先学习它。有一本很好的书推荐，叫《深入浅出WPF》，绝对是WPF入门首选，可自行搜索下载，或买本支持作者。&lt;/p&gt;
&lt;h2&gt;Visual C#快捷键&lt;/h2&gt;
&lt;p&gt;从eclipse转来使用Visual C#，觉得十分不方便。特别是以前习惯的那些快捷键，现在都不能用了。&lt;/p&gt;
&lt;p&gt;下载这份&lt;a href=&quot;http://download.microsoft.com/download/e/7/9/e79cce22-b196-4b9f-9ea7-b1a21f5342e9/VCSharp_2005.zip&quot;&gt;快捷键手册&lt;/a&gt;，很有用。&lt;/p&gt;
&lt;p&gt;我常用的一些快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式化：Ctrl+E,D&lt;em&gt;   删除当前行：Ctrl+x。它有一点不太方便，因为它是剪切而不是删除，有时候会覆盖剪贴版中的内容&lt;/em&gt;   显示代码结构：Visual C#中没有eclipse的outline窗口，只能使用Ctrl+M,O，把当前文件中的代码折叠起来，显示骨架。好在习惯后也比较方便。&lt;em&gt;   展开结构：Ctrl+M,L&lt;/em&gt;   展开合闭当前结构：比如在一个方法或类上，按Ctrl+M,M，它只会把它展开或合闭&lt;em&gt;   变量名重构：Ctrl+R,R&lt;/em&gt;   导入类的引用：Ctrl+.*   在大括号之间跳跃：Ctrl+]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些想用但还没找到的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新开一行：相当于eclipse中的shift+enter&lt;em&gt;   在上面新开一行：相当于eclipse中的ctrl+enter&lt;/em&gt;   删除当前行：删除而不是剪切，ctrl+x有时候不合适&lt;em&gt;   当前行上移：相当于eclipse中的alt+上方向键&lt;/em&gt;   当前行下移：相当于eclipse中的alt+下方向键&lt;em&gt;   快速定位到下一个错误：相当于eclipse中的ctrl+.&lt;/em&gt;   快速移动到上下方法：相当于eclipse中的Ctrl+上下方向键&lt;em&gt;   快速定位到文件：相当于eclipse中的Ctrl+r&lt;/em&gt;   快速查找某个类：相当于eclipse中的Ctrl+t*   快速定位到当前文件中的方法、字段：相当于eclipse中的ctrl+o&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一些资源&lt;/h2&gt;
&lt;p&gt;写到这里居然觉得没什么可写的了，只好以一些资源作为结束。相比Java程序员，.Net有某些方面真是太幸福了。各种详细的API和文章，在msdn上应有尽有，中文、详细、权威。&lt;/p&gt;
&lt;p&gt;我最开始按Java的经验到处到处找资源、找代码，费力不讨好。最后发现只要上msdn基本就够了。这里推荐一些有用的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/67ef8sbd(v=vs.80)&quot;&gt;MSDN上的C# Programming Guide&lt;/a&gt; 简洁、权威，最适合有经验的程序员看，强烈推荐&lt;em&gt;   &lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/aa288436(v=vs.71).aspx&quot;&gt;MSDN上的C#教程&lt;/a&gt;&lt;/em&gt;   &lt;a href=&quot;http://www.linqpad.net/&quot;&gt;LINQPad&lt;/a&gt; 一个小工具，可直接运行C#代码，看结果。有时候想测试一些代码比较方便&lt;em&gt;   &lt;a href=&quot;http://www.codeplex.com&quot;&gt;http://www.codeplex.com&lt;/a&gt; 微软的开源项目网站，一般使用ms技术的项目会放在它上面。&lt;/em&gt;   &lt;a href=&quot;http://1code.codeplex.com/&quot;&gt;Microsoft All-In-One Code Framework Sample Browser&lt;/a&gt; 看起来很有用，但对初学者没什么用的工具。它可以搜索、浏览、下载&lt;a href=&quot;http://www.codeplex.com/&quot;&gt;http://www.codeplex.com/&lt;/a&gt;上的项目代码。说它没用是因为新手很难在一大堆项目中找到合适自己的。*   &lt;a href=&quot;http://download.microsoft.com/download/e/7/9/e79cce22-b196-4b9f-9ea7-b1a21f5342e9/VCSharp_2005.zip&quot;&gt;Visual C#快捷键手册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些常用碎页&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日期时间格式化符号：&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Play Framework(1/2)入门引导</title>
                <link>http://freewind.in/posts/965-guide-to-play1-play2</link>
                <pubDate>Sat, 28 Jul 2012 17:00:29 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">965</guid>
                <description><![CDATA[&lt;p&gt;为了方便群中的Play初学者们，写了一篇入门引导，以帮助初学者尽快了解Play。本文之前发在另一个网站，因为觉得有些不便，还是转到博客上。&lt;/p&gt;
&lt;p&gt;欢迎来到play的世界，在这里你将体验到与传统SSH开发网站不一样的感受。我将把我学习play的感受与经验分享给大家，希望能对大家（特别是初学者）有所帮助。&lt;/p&gt;
&lt;p&gt;Play是一个非常有创造力、让人眼前一亮的Java web开发框架。它把网站开发中常见的繁琐的任务，以各种突破常规的方式简化，“不要重复你自己”，让人在开发过程中有一种享受的感觉。使用Play实现功能，有时候简单地让人难以相信（对于长期使用SSH的人来说尤其明显）。&lt;/p&gt;
&lt;p&gt;在play的google group中，曾经有人说，当地要举办一次编程大赛，他将使用play参赛。每个参赛队可使用任何语言和框架，在6小时内实现指定的功能。结果他们胜利了，打败了Ruby on rails队。使用Play开发网站，在不使用各种第三方插件的情况下（Rails强项），开发效率与Rails在同一级别。&lt;/p&gt;
&lt;p&gt;这里将介绍一些最让我印象深刻的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改不用重启&lt;/strong&gt;：这是play最为吸引人的一点。修改任何java或模板代码，都不需要重启server，直接在浏览器中刷新即可看到最新效果。这曾是多少Javaer梦想的功能。结合livereload等工具，可以实现光标不离开编辑器就能实时看到最终页面效果的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;无状态&lt;/strong&gt;：Play是无状态的，不保存与客户端相关的数据，比如它的session是以加密方式保存在cookie中的。这意味着play程序拥有良好的扩展性，比如当访问压力过大时，可以简单地多启动几个play实例即可（使用不同端口+反向代理）。由传统的Servlet程序则需要考虑session同步等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码增强&lt;/strong&gt;：代码增强是Play的重点功能，也是它最富于创新力的地方。在play导入我们所写的java源代码时，会使用javassist这个工具，根据内置或第三方的插件的要求修改字节码，实现一些原本无法实现的功能。比如充血模型，生成getter/setter，根据参数名自动从request中取参数，根据参数名自动向template中设置参数等。我们可以省去很多不必要的代码和为因Java语言限制而存在的设计模式，写出简洁清晰的代码。由于“代码增强”的存在，使得play与众不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模板中方法调用与url的自动转换&lt;/strong&gt;：在play的模板中，需要与后台交互（比如跳转页面）时很少写url，因为我们可以直接调用相应的Action和参数，由Play根据routes文件中的定义生成相应的url。当url更改时，直接修改routes文件即可，不需要动模板文件。当我们写错（如方法名）时，play会自动提示编译错误。该功能让我们重构url时非常轻松。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对restful api的良好支持&lt;/strong&gt;：在routes文件中，通过简单的规则就可以定义出restful api的接口。通过在server端生成jsRoutes（包含了restful api的信息），在浏览器端可以方便地使用ajax与后台交互。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;内置基于netty的web服务器&lt;/strong&gt;：play内嵌了基于netty的高性能服务器，只需要一条命令即可运行起来，简单而强劲，推荐使用。如果因为服务器限制而必须使用传统的servlet服务器的话，可将play程序打包为war部署。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Play的版本&lt;/h2&gt;
&lt;p&gt;Play当前的版本有点乱，不同版本之间差别还相当大，这常常让初学者一头雾水。Play目前可分为三个版本，它们之间没有谁比谁好，只有谁比谁适合。大家可根据自己的实际情况来选择合适的版本来学习。&lt;/p&gt;
&lt;h4&gt;首先是Play的成名之作：Play1&lt;/h4&gt;
&lt;p&gt;Play1.x是成名之作。它是一个Java开发框架，使用python作为构建系统。内置了Jpa（Hibernate）和基于groovy的模板系统。它大量使用了代码增强，提供了大量魔术般的功能，以提高程序员的开发效率和代码的简洁性。它编译速度快，代码简洁，让人开发时非常享受。Play1当前最新版本为1.2.5，它是三者间最为成熟的一个版本，拥有大量成熟的第三方模块供使用。这里值得一提的是群友green开发了大量基于play1的优秀插件，如rythm/play-morphia等，进一步提高了play的性能及开发效率。虽然play1目前已处于维护状态，但如果你需要在近期开发传统的信息管理类网站，它仍然是最佳选择。&lt;/p&gt;
&lt;h4&gt;关于Play2&lt;/h4&gt;
&lt;p&gt;几个月前，Play1的开发者加入了typesafe.com，并且play作为其官方web框架。typesafe是一个力推scala的公司，所以新推出的play2，实际上是将scala作为第一开发语言的。比如play2中使用的新构建工具sbt，是scala的标准构建工具；play2中很多底层代码都是用scala写的，由Java来调用；play2的默认模板引擎，也是基于scala的。在play2中，处处可见scala的痕迹。但play2也同时提供了java api，以吸引广大的Java开发者。由于Scala与Java在语言特性与风格上的巨大差别，play2-scala与play2-java，在很多地方都不同。&lt;/p&gt;
&lt;p&gt;play2相对于play1，不是一次简单的版本升级，而是几乎重写了全部代码。Play2与Play1在很多方面都不同，不能通用。也许它本来就不该叫play2的，它与play1的区别，如同struts2与struts1的区别(struts2其实是由另一个叫webwork的框架改名而来)。Play开发团队从商业利益上的考虑作出的决定（以及某种程度的不负责任），曾经在play社区中引起激烈争论，大批play1用户表达了自己的不满和对play2的失望。&lt;/p&gt;
&lt;p&gt;Play2在开发风格上与Play1有所不同。如同typesafe公司名称所示，Play2在最大程度的利用编译器的检查，以求更加稳定可靠。在Play1中一些追求简洁的魔术代码，在Play2中取消了，相反要使用一些略显繁琐的代码来实现相同功能。同时因为scala相当慢的编译速度，让热修改后生效的时间大大延长，有时候难以忍受（在play1中1秒以内，play2中要5秒以上）。所以很多从play1转向play2的用户都非常不适应，拒绝转向play2。&lt;/p&gt;
&lt;p&gt;由于Play2的仓促推出，当前的2.0.2版不论在功能上还是稳定性都存在相当多的问题，插件生态系统也没有成熟（Play1的插件不能在Play2上使用）。所以当前直接在生产系统中使用它还是有一定风险的，最好再等几个月。&lt;/p&gt;
&lt;p&gt;不论如何，Play2是官方支持，目前所有的开发活动都基于它，它是未来的趋势。它重新组织的代码结构与API，相比1来说，也要精致很多。相信现在存在的各种问题在未来会慢慢解决，只是需要一段时间。&lt;/p&gt;
&lt;p&gt;Play2的卖点是并发，因为它底层使用了scala中的akka库，对于开发实时网站程序比较有优势。但对于传统的信息系统类网站，也许Play2很难达到Play1的程度。个人认为，对于以开发信息系统为主的团队，使用Play1在各方面来讲，都会是更好的选择。&lt;/p&gt;
&lt;p&gt;对于认为新版一定好于旧版，或敢于尝鲜而选择了Play2的朋友，马上要面临一个新的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是用Play2-Scala还是Play2-Java呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人认为，这个选择还是比较简单的。如果你是Scala程序员，来寻找Scala下的web框架，就选Play2-Scala。它比lift简单易学，容易上手。如果你是Java程序员，或者主要以Java项目为主，请选择Play2-Java。&lt;/p&gt;
&lt;p&gt;虽然Scala在宣传上总是以“更好的Java“来作为卖点，但它实际上是一门与Java相差非常大的语言。在语言风格上，Scala融合面向对象与函数式，强调数据的不变性，这都与Java不同。在难度上，Scala要比Java难很多，函数式编程和类型系统会让很多Java程序员止步，通常在六七年的编程经验后再学习Scala是比较靠谱的选择。&lt;/p&gt;
&lt;p&gt;另外，虽然两者都是JVM上的语言，但它们之间是有缝的，调用对方的库经常会遇到各种各样的问题。比如你想在Scala上使用java的jpa/ebean/morphia等，会非常麻烦。但scala自己又没有一个足够成熟好用的orm，这可能是阻止你使用Play2-Scala的一个重要原因。&lt;/p&gt;
&lt;p&gt;所以，还是如前面所说，Scala程序员选Play2-Scala，Java程序员选Play2-Java。&lt;/p&gt;
&lt;h5&gt;Play2-Scala&lt;/h5&gt;
&lt;p&gt;Play2-Scala相对于Scala上的另一个成熟web框架lift来说，优势在于简单易学、有typesafe官方支持，前途光明。同时对于以restful api作为主要目的的程序来说，Play2提供的routes相当好用。劣势在于不如lift成熟，生态系统不如lift。在某些时候，Play2的MVC不如Lift的View-First好用。&lt;/p&gt;
&lt;p&gt;Play2使用了sbt，底层是akka，模板层基于scala，orm是Play自己开发的一个叫anorm的持久层。anorm的特点抛弃orm，直接使用jdbc，使用预定义的parser把结果集转为对象。Anorm初看起来比较吸引人，但在实际使用过程中，异常繁琐。对数据库字段的一次修改，往往要牵扯到几个地方，动不动就出错，同时再加上scala奇慢无比的编译速度，极易让人心情烦躁。所以也有人尝试在play2中使用squerl，好在很容易集成。当然还是让我们期待typesafe正在开发的新orm:slick。&lt;/p&gt;
&lt;p&gt;对于Scala程序员来说，Play2-Scala是一个比较好的选择，不妨一试。&lt;/p&gt;
&lt;p&gt;注意，如果你使用Play2-Scala，想使用Play2中提供的JPA/Ebean时请小心。由于Play2在代码增强时，只增强Java代码，这将导致从Scala中调用它们时出现问题，所以最好选择scala中的orm。&lt;/p&gt;
&lt;h5&gt;Play2-Java&lt;/h5&gt;
&lt;p&gt;对于Java程序员来说，还是用Play2-Java比较顺手。虽然相比Play1要繁琐一些，但对于SSH等，还是要简洁很多。Play2中Java的api与Scala的api不在同一个包下，要注意不要引用错了。&lt;/p&gt;
&lt;p&gt;对于controller和action，Play2与play1的结构基本相同，依然采用静态方法，但需要返回一个Result。注意的是，Action中的参数，只能匹配在routes中的url定义中出现的参数，而不像play1那样，还能匹配任意query参数和post参数。&lt;/p&gt;
&lt;p&gt;Orm方面，同时提供了JPA(hibernate)和Ebean。我个人比较推荐Ebean，相对于hibernate，它的api更加简单，不易出错，因为它是用jdbc的思路。在官方下载包里有一份100多页的pdf文档，看完就差不多了，用起来麻烦绝对比hibernate少太多。我在Play1中就通过第三方的插件使用Ebean，效果很好。也许只有一种情况不能用它，因为它不支持sql server。&lt;/p&gt;
&lt;p&gt;Play2基于scala的模板层，对于Java开发者来说是不太方便的。两点原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scala的语法与Java不同，虽然在模板中已经尽量简化了，但难免还是会遇到一些不好下手的问题。2.  模板将被转化为Scala代码进行编译。如前文所说，Play2对于Scala代码不会进行增强，所以在模板中调用Java类可能会有问题。比如直接调用&lt;code&gt;@user.articles&lt;/code&gt;，它不会像在Java中那样被替换为&lt;code&gt;user.getArticles&lt;/code&gt;，而是直接调用&lt;code&gt;user.articles&lt;/code&gt;字段。由于代码增强通常是在getter/setter上进行的，所以这样可能拿不到数据。如果想解决此类lazy loading的问题，我们必须在model中使用传统的javabean方式显式声明getter/setter，然后在模板层中调用&lt;code&gt;@user.getArticles&lt;/code&gt;，相当繁琐。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以在Play2官方推出基于java的模板前，我推荐使用两个第三方模板插件。一是faster groovy template，二是japid，它们都已经支持Play2，且不会有上述问题（Japid待测）。&lt;/p&gt;
&lt;p&gt;另外，对于不喜欢Java语法但又不想用scala的同学，可尝试xtend。xtend代码要比Java舒服一些，而且直接生成java源代码，不存在编译等问题。&lt;/p&gt;
&lt;h2&gt;Play存在的问题&lt;/h2&gt;
&lt;p&gt;虽然Play在很多方面给我们带来的方便，但难免也会有一些问题需要注意，这里简单提一下。&lt;/p&gt;
&lt;h4&gt;Play1&lt;/h4&gt;
&lt;p&gt;Play1主要存在的问题有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;与某些第三方库结合使用时，必须写插件。比如morphia, ebean等。因为Play1需要对我们的Java源代码进行增强，而这些库也需要对字节码进行增强。如果不写插件处理classloader及字节码，会出现无法运行的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用javassist修改字节码比较繁琐易错。当Play用到一定程度，难免会需要写自己的插件，对字节码进行增强以实现特殊功能。但使用Javassist来修改字节码，还是一件比较容易出错的工作，经常要花大量的时间在调试上。特别写的插件需要先打包，才能在其它项目中使用，看到效果，非常费时。（如果有简洁方法请告诉我）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;停止开发，只维护。官方现在只开发Play2，对于Play1不再开发新功能，只维护。如果想要增加新功能，只能靠自己或第三方插件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Play2&lt;/h4&gt;
&lt;p&gt;Play2主要有以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目前不够成熟。不论是框架本身还是插件系统，都不太成熟。如果在大型项目中使用，必须自己实现很多功能，以及整合很多第三方库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用sbt作为构建系统。sbt用起来也相当繁琐，要花不少时间才能熟练使用。而且，如果想开发自己的构建插件，还需要学习scala和sbt那些变态的api。这对于Java程序员来说，难度实在太大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Play2-scala缺少一个好用的orm，Play2-java缺少一个好用的模板层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Play2在某些方面与Play1相比显得繁琐，让用惯Play1的人不易适应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scala缓慢的编译速度，常常让人难以忍受，要求用户的电脑配置比较高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Flex入门体验</title>
                <link>http://freewind.in/posts/963-learning-flex</link>
                <pubDate>Sat, 28 Jul 2012 02:07:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">963</guid>
                <description><![CDATA[&lt;p&gt;在铁哥的指引下，这几天我学习了Flex，在这里记录下这几天的入门体验，希望对Flex新手们有所帮助。由于是刚刚接触，某些地方理解可能不对，欢迎指正。&lt;/p&gt;
&lt;p&gt;在学习过程中，我发现对一个初学某种技术的新手来说，背景知识远比技术点的讲解更加重要。比如“为什么会有这个东西，那个东西有什么用，能做什么不能做什么，什么时候该用什么”，此类问题的讲述会帮助初学者在脑海中勾勒出新技术的全景，不易迷失于细节之中。&lt;/p&gt;
&lt;h2&gt;Flex简述&lt;/h2&gt;
&lt;p&gt;在说Flex前，首先说下Flash。我在大学时曾学过flash，做过一些简单的动画，后来就放下了，所以对于它的印象一直都是“做动画广告的小工具”。实际上经过这十来年的发展，Flash已经成为了一个和Jvm、.net类似的软件开发平台，它的功能已经相当强大，既可以开发应用程序，又可以做出复杂的游戏（比如一些大型网页游戏），拥有很高的开发效率和不错的性能。相信你的电脑经常会弹出“Flash升级”的提示吧？这是Flash在不断发展的信号。Flash与Jvm、.net相比在某些方面具有较大的优势，这里不详述，具体参见铁哥的《&lt;a href=&quot;http://www.cnblogs.com/xiaotie/archive/2011/10/05/2199234.html&quot;&gt;Flash: 涅磐与重生&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;Flex是Adobe推出的一个富客户端开发框架，核心是利用Mxml+ActionScript+Css快速开发出运行于Flash平台的应用程序。发布时既可以打包为swf格式，通过flash player运行于浏览器中；又可以打包为air格式，以桌面程序方式运行于air虚拟机中。Flex是开源的，由Apache管理。&lt;/p&gt;
&lt;p&gt;Flex的开发方式与网页开发非常相似，Mxml对应HTML，ActionScript对应JavaScript，Css还是那个Css（子集加修改）。我相信每一个开发过网站的人，都能非常容易地掌握Flex，并且（很可能）喜欢上它。&lt;/p&gt;
&lt;p&gt;对于Flex与Html5之争，这里不多说。我相信如果你使用过Flex和Html+Js框架开发过相似的程序，你一定会喜欢上Flex。我想起我前段时间学习的一个叫Angular的前端Js框架。这个由google推出，以提供双向绑定、自定义html标签和行为来扩展html功能为卖点的Js框架，深深打动了我。我觉得它是目前所有Js前端框架中最具创意、设计最好的（没有之一）。但在看了Flex的示例代码之后，我惊奇地发现它们两者如此相似，思路几乎完全相同。只是Flex在几年前就已经实现了，而angularjs直到最近才推出1.0版（当然，Angularjs出现晚的原因在于Js语言以及多浏览器支持，大大增加了实现难度）。&lt;/p&gt;
&lt;p&gt;我发现Flex内置了很多控件。布局、表单、标签页、菜单、树、图表等等，应有尽有。使用它们开发一些管理后台，是非常容易的事情。说到这里，我觉得Flex一个很好的方向，就是代替ExtJS来做企业信息管理系统。有很多公司采用ExtJS这种Js UI框架，个人认为这是自虐找抽的做法。我曾经在某公司做过一个ExtJs的项目，ExtJs的开发难度、调试，以及对不同浏览器的兼容，让我们整个小组都苦不堪言。由于整个产品线全部采用ExtJs开发，所以加班是整个开发部门每人每日必备。现在想来，如果公司使用的是Flex，大家都可以活得轻松很多。&lt;/p&gt;
&lt;p&gt;另外，由于Flash在图像处理方面具有一定的优势，甚至支持3D动画，所以使用Flex可以开发出一些功能比较强大的、与图像处理相关的程序。&lt;/p&gt;
&lt;h2&gt;Flex开发工具&lt;/h2&gt;
&lt;p&gt;Flex SDK是免费的，但Adobe提供的开发工具Flex Builder是收费的。Flex Builder后来改为Flash Builder，当前版本为4.6。它基于eclipse开发，提供了很好的代码提示、错误检查、调试重构、页面设计等功能，十分好用。如果你不想用破解，还有其它工具可用，如完全免费开源的&lt;a href=&quot;http://www.flashdevelop.org/&quot;&gt;FlashDevelop&lt;/a&gt;，甚至使用普通的文本编辑器都可以（因为mxml/ActionScript/Css都是文本格式）。当然作为初学者，建议使用Flex Builder，至少在试用期内可以帮助你掌握Flex。&lt;/p&gt;
&lt;p&gt;还有另一个叫Flex Catalyst的工具，也可以辅助Flex程序的开发，它的强项在于可视化。比如设计组件的外观、动画效果等，十分方便。但是该工具在今年4月停止开发，并入了Adobe Creative Suite 6 Master Collection这一软件套件中。这个套件出奇的庞大，里面包含了十几个软件，我也不清楚到底是哪个，猜测应该是合并到Flash Professional CS6中了。我想对于普通的富客户端程序开发，Flash Builder应该就够用了。&lt;/p&gt;
&lt;h2&gt;Flex中的两套UI库&lt;/h2&gt;
&lt;p&gt;Flex本身提供了两套UI库，一种是Flex3的mx库，一种是Flex4中的Spark库。这两套库是平行的，控件都很丰富，之所以要推Spark，是为了提供更好的换肤功能。因为在之前的mx库中，要修改一个组件的外观比较麻烦，只能通过CSS一点点修改，或者扩展源代码。而在Spark中，提出了“皮肤”的概念，可以在另一个mxml文件中，对某一个组件的外观进行全方位的定制。这样就可以利用其它的设计工具以可视化方式定义外观，或者直接采用第三方提供的皮肤库。&lt;/p&gt;
&lt;p&gt;这两套库可以只用其中一个，也可以两者混用。而且两者的控件都很丰富，对于新项目而言，采用Spark比较好，因为它既支持换肤，又专门针对移动平台开发了很多控件，未来adobe也会继续开发该库。据说mx中有少量控件还没有在Spark中实现，所以在极少数情况下，你需要用到mx库。&lt;/p&gt;
&lt;p&gt;由于这两套库的体积都比较大，对于开发一些简单的互联网上使用的组件，不太方便。比如你使用mx创建了一个最简单的项目，生成的swf文件也在200K以上。这对于国内的网速来说，还是很难接受的。所以有时候需要用到第三方小巧的UI库，比如铁哥的&lt;a href=&quot;https://github.com/xiaotie/RedCoral&quot;&gt;RedCoral&lt;/a&gt;（参考了&lt;a href=&quot;https://github.com/minimalcomps/minimalcomps&quot;&gt;minimalcomps&lt;/a&gt;），做简单的功能时，输出的swf文件只有几K。&lt;/p&gt;
&lt;h2&gt;学习资料&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一个软件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.adobe.com/devnet/flex/tourdeflex.html&quot;&gt;Tour De Flex&lt;/a&gt; 演示了Flex各个版本提供的控件，和重要知识点。大部分例子都可直接看到效果和源代码，学习Flex必备。大约30多M。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/963-1.png&quot;&gt;&lt;img src=&quot;/user_images/963-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几本书&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flex4权威指南&lt;/strong&gt; 详细讲解了Flex的开发过程及常用功能&lt;em&gt;   &lt;/em&gt;&lt;em&gt;Object-Oriented Action Script 3.0&lt;/em&gt;* 详细讲解了ActionScript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;几个视频&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XOTcwMTgyODg=.html&quot;&gt;Flash Catalyst and Flex 4: Part 1&lt;/a&gt;&lt;/a&gt;&lt;em&gt;   &lt;a href=&quot;http://v.youku.com/v_show/id_XOTcwMjA1NjQ=.html&quot;&gt;Flash Catalyst and Flex 4: Part 2&lt;/a&gt;&lt;/em&gt;   &lt;a href=&quot;http://www.youtube.com/watch?v=hII6AbGrWR8&quot;&gt;Adobe Flash Catalyst CS5 - My Top 5 Favorite Features&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一些网址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/skynet/archive/2011/05/28/2061078.html&quot;&gt;走在网页游戏开发的路上&lt;/a&gt; 有九章&lt;em&gt;   &lt;a href=&quot;http://www.cnblogs.com/xiaotie/category/227369.html&quot;&gt;铁哥Flash系列&lt;/a&gt;&lt;/em&gt;   &lt;a href=&quot;http://www.javaworld.com/javaworld/jw-02-2009/jw-02-actionscript1.html?page=1&quot;&gt;ActionScript for Java developers1&lt;/a&gt;，&lt;a href=&quot;http://www.javaworld.com/javaworld/jw-03-2009/jw-03-actionscript2.html&quot;&gt;2&lt;/a&gt; 如果是你Java程序员，一定不要错过这个&lt;em&gt;   &lt;a href=&quot;http://www.flexafterdark.com/&quot;&gt;FlexAfterDark&lt;/a&gt;&lt;/em&gt;   &lt;a href=&quot;http://understandingflex.com/&quot;&gt;Understanding Flex&lt;/a&gt;*   &lt;a href=&quot;http://www.9ria.com/&quot;&gt;天地会&lt;/a&gt; 国内ria论坛，看起来很热闹&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;源代码&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dlgsoftware.com/dataExplorer/dataExplorer.html&quot;&gt;World Data Explorer&lt;/a&gt;: &lt;a href=&quot;http://www.dlgsoftware.com/dataExplorer/srcview/index.html&quot;&gt;Source&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;QQ群：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flex技术交流社区 113973430*   本人的Flex热情交流群 245125585&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Flex的重点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;两个关键点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;事件&lt;/strong&gt; 事件的理解和处理非常重要，因为Flex是以事件驱动的，控件之间的交互都是通过事件触发。事件在Flex中无处不在，一定要掌握。可参考前面提到的书，以及《走在网页游戏开发的路上》相关章节。2.  &lt;strong&gt;绑定&lt;/strong&gt; 绑定是Flex中一个相当有用的功能。通过把某些属性设为Bindable，可以mxml（相当于视图）中引用它们。当这些属性的值变化了，视图也会自动更新。以前这些更新都是要在as类中手写的，现在在mxml中使用该特性，让我们的代码大大简化。在Flex4中，还增加了双向绑定：视图上的修改（比如在文本框中输入了内容）会自动更新相应的属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;其它需要注意的&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;this&lt;/strong&gt; ActionScript中的&lt;strong&gt;this&lt;/strong&gt;跟Java相似，跟js不同。在mxml文件中引用的this，都指向mxml的root，而不是某节点。所以要想对某个控件操作，只能使用event的currentTarget/target来取得引用。ActionScript中的this，都指向所在对象。参考&lt;a href=&quot;http://stackoverflow.com/questions/11646505/how-to-understand-this-keyword-in-flex&quot;&gt;How to understand “this” keyword in flex&lt;/a&gt;2.  &lt;strong&gt;线程&lt;/strong&gt; Flash底层是多线程的，但我们的代码运行于单线程环境中，这点跟&lt;a href=&quot;http://freewind.me/blog/20120516/926.html&quot;&gt;Nodejs的线程模型&lt;/a&gt;比较像（但因为没有深入Flex，不是很确定）。可参考：&lt;a href=&quot;http://stackoverflow.com/questions/675872/threads-in-flash-and-flex&quot;&gt;Threads in Flash and Flex&lt;/a&gt;，以及&lt;a href=&quot;http://blogs.adobe.com/aharui/2008/01/threads_in_actionscript_3.html&quot;&gt;Threads in Actionscript 3&lt;/a&gt;。所以我们在处理比较繁重的计算任务时，要想办法把它们分块，以防止阻塞UI。另外，这里有个小提示：&lt;em&gt;&lt;font size=&quot;3&quot;&gt;Update: As the commenter ardnarf1 points out, flash player 10 supports pixel bender kernels (programs) that can run as a filter, blend mode or a background job. A pixel bender kernel running as a background job (ShaderJob) runs on a true thread (rather than a PseudoThread) and is therefore faster. The only disadvantage here is that your background job must be programmable in pixel bender&apos;s language, Hydra.&lt;/font&gt;&lt;/em&gt;3.  &lt;strong&gt;Event.ENTER_FRAME&lt;/strong&gt; 在铁哥的RedCoral代中，经常会用到该事件，比如“addEventListener(Event.ENTER_FRAME, onInvalidate);”ENTER_FRAME应该是Flash动画中的一个概念，表示新的一帧到来了，为什么Flex也会用到它？Flex的默认帧频是24/秒（可设置），使用ENTER_FRAME事件，可以定时自动执行一些操作，如更新画面内容等（可参考&lt;a href=&quot;http://blog.csdn.net/xingfeng0501/article/details/7342728&quot;&gt;flex的enter_frame事件详解&lt;/a&gt;）。需要注意的是，在某些时候，帧频会瞬间到达1000（为了快速渲染某些内部组件，不是Bug），&lt;a href=&quot;http://blog.ityao.com/archives/594&quot;&gt;使用时需注意&lt;/a&gt;。另外，如果想执行一个定时任务，可使用Timer类，timer类的执行&lt;a href=&quot;http://varyall.iteye.com/blog/809043&quot;&gt;不会引发重绘&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;关于Mxml&lt;/h2&gt;
&lt;p&gt;Mxml是Flex中非常有创意的地方，使用与HTML类似的方式，来声明各种可视化与非可视化组件。比如下面这段代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;br  /&gt;&amp;lt;s:Application xmlns:fx=&amp;ldquo;&lt;a href=&quot;http://ns.adobe.com/mxml/2009&amp;quot;&quot;&gt;http://ns.adobe.com/mxml/2009&amp;rdquo;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;           xmlns:s=&quot;library://ns.adobe.com/flex/spark&quot;       
           xmlns:mx=&quot;library://ns.adobe.com/flex/mx&quot; minWidth=&quot;955&quot; minHeight=&quot;600&quot;&amp;gt;       
&amp;lt;s:HGroup&amp;gt;       
    &amp;lt;s:Label text=&quot;Hello, &quot; /&amp;gt;       
    &amp;lt;s:TextInput /&amp;gt;       
    &amp;lt;s:Button label=&quot;Go!&quot; /&amp;gt;       
&amp;lt;/s:HGroup&amp;gt;       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/s:Application&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它声明了一个Label，一个输入框和一个按钮。运行它可在浏览器中看到如下效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/963-3.png&quot;&gt;&lt;img src=&quot;/user_images/963-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;跟HTML是不是非常相似？&lt;/p&gt;
&lt;p&gt;上面的HGroup、Label、TextInput、Button实际上都是spark库中的几个类。在mxml文件中以标签方式声明它们，和使用ActionScript代码创建它们，效果是相似的，只是标签方式更清晰易懂。如果我们定义了一个继承于flash.display.Sprite的类（或者创建了一个mxml文件），则可以直接在mxml中以同样方式使用它。&lt;/p&gt;
&lt;p&gt;把mxml想像成可自行扩展的HTML，一切就明白了。&lt;/p&gt;
&lt;p&gt;Flash Builder对mxml提供了非常好的支持，如代码提示、查错等。&lt;/p&gt;
&lt;h2&gt;关于ActionScript&lt;/h2&gt;
&lt;p&gt;ActionScript是flash中使用的编程语言。它的前几版像JavaScript，但在ActionScript 3中，增加了面向对象、静态类型等，跟Java、C#等语言非常相似。相信一个Java/C#开发者，可快速掌握。由于在ActionScript中，function是一等公民，所以有时候要比Java方便很多。&lt;/p&gt;
&lt;p&gt;ActionScript既可嵌入到mxml中，又可放在一个单独的.as文件中。&lt;/p&gt;
&lt;p&gt;ActionScript在语法层面支持XML，并且由于mxml本身也是xml，所以在Flex程序中，前后台的交互使用XML更多一些，也相当方便。而在JavaScript中，Json是主流。&lt;/p&gt;
&lt;p&gt;ActionScript中即有静态类型，又有动态类型，既可使用编译器的检查功能，又能灵活处理一些动态数据，很好。&lt;/p&gt;
&lt;p&gt;Flash Builder对ActionScript（以及mxml）都可检查错误、代码提示，还可重构，与Js相比，实在是幸福太多了。&lt;/p&gt;
&lt;h2&gt;关于CSS&lt;/h2&gt;
&lt;p&gt;Flex支持CSS的子集，另外增加了一些自己特有的东西。使用方法与普通CSS相似，这里就不多说了。&lt;/p&gt;
&lt;h2&gt;关于换肤&lt;/h2&gt;
&lt;p&gt;Spark一大特点是换肤，即在一个mxml中，定义某组件的外观。这种“定义”，不像是CSS那样小打小闹，而是脱胎换骨。先看看一些效果（来自&lt;a href=&quot;http://www.scalenine.com&quot;&gt;http://www.scalenine.com&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/963-5.png&quot;&gt;&lt;img src=&quot;/user_images/963-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/963-7.png&quot;&gt;&lt;img src=&quot;/user_images/963-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/963-9.png&quot;&gt;&lt;img src=&quot;/user_images/963-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看出，spark能做出很多不同风格的漂亮皮肤出来。&lt;/p&gt;
&lt;p&gt;在看到皮肤文件时，我理解不了这皮肤到底是怎么定义的。皮肤文件是mxml文件，只是内容看起来很怪，有很多描述效果的标签，像是有很多层，但是，它们与组件之间到底有什么关系？！后来看了一些资料并提问，终于理解了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/11682596/how-to-understand-the-layers-of-flex-skin&quot;&gt;How to understand the layers of flex skin?&lt;/a&gt;*   &lt;a href=&quot;http://stackoverflow.com/questions/11685633/how-to-understand-the-id-attribute-of-flex-skin&quot;&gt;How to understand the “id” attribute of flex skin?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原来是这样：设计spark的组件，就像是用photoshop来设计，用到了层的概念。对于某一个组件，我可以使用很多层，每个层画上不同的内容，共同组成最终的效果。而每一个组件，都以属性的方式，将一些小部件开放给皮肤文件。在皮肤文件中，可以将某个效果的id属性指向它，就把该效果用到了它身上。由于这种灵活性，可以轻易实现出很炫很复杂的效果。需要注意的是，由于层有上下，上面的会挡住下面的，所以层的顺序很重要。在皮肤mxml文件中，前面的效果在底层，下面的效果会挡住前面的，这个顺序要记住。&lt;/p&gt;
&lt;p&gt;要实现复杂的效果，靠手写皮肤是一件非常痛苦的事情，这时可利用Flex catalyst（现在可能叫Flash CS）进行可视化设计，然后导出到Flash Builder中使用。Adobe的各软件之间的互通做得非常好，可充分利用每个软件的长处（所以要买更多的软件：）&lt;/p&gt;
&lt;h2&gt;关于states&lt;/h2&gt;
&lt;p&gt;Flex中，states是一个重要的概念。在mxml，states表示当前页面的多个不同状态。&lt;/p&gt;
&lt;p&gt;比如用户点了“登录”按钮，上面显示了几个输入框，再点“注册”按钮，又会显示一些不同的输入框。页面还是那个页面，但上面的元素变了。在html网站中，我们有两种方式来实现。一是制作多个不同的页面，点击后跳转，二是使用js来增删改某些元素。在mxml中，采用的是后一种方式。&lt;/p&gt;
&lt;p&gt;我刚刚看到这里时，感觉非常奇怪，因为不同的state，是通过对主状态的修改来实现的。比如AddChild，RemoveChild等。把currentState清空时，会回到主状态，系统会自动还原。这种方式与直接在ActionScript中改变视图元素的方式非常相似。我有点不太理解，是因为觉得这种方式太繁琐了，那么多控件，我怎么记得住。后来，在前面提到的视频中看到，人们在可视化工具中修改状态时，是直接在主状态上进行操作，如移动某元素、添加删除元素，而不是从头开始新做一个页面，那么这种方式就很自然了，因为程序可以记录下每一步操作。对于一个复杂的效果，我们很可能会利用可视化工具来实现，而不是手动编码。在这里再次感叹，Adobe不同工具之间的配合真是好。&lt;/p&gt;
&lt;p&gt;另外，皮肤中也有states的概念。比如一个按钮，它有“正常”“悬停”“按下”“抬起”等不同的状态，可对不同状态的按钮定制外观。&lt;/p&gt;
&lt;h2&gt;关于图像与3D&lt;/h2&gt;
&lt;p&gt;使用Flex可以实现一些与图像相关的操作，这些在html5中可能比较难以实现。看下91乐印的手机外壳3D预览：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/963-11.png&quot;&gt;&lt;img src=&quot;/user_images/963-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个3D的手机模型，上面的图片是我上传的。用鼠标在窗口上拖动，则可以从各个方向看到手机的样子，挺酷的。在TourDeFlex中，也有一个类似的例子。&lt;/p&gt;
&lt;p&gt;还有一个网站，上面用flash实现的很多3D怪兽，但网址找不到了，希望铁哥补充。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Xtend rocks！</title>
                <link>http://freewind.in/posts/949-xtend-rocks</link>
                <pubDate>Thu, 28 Jun 2012 23:01:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">949</guid>
                <description><![CDATA[&lt;p&gt;最近在做一个网站时大量使用了xtend，感觉非常好。今年5月推出的xtend 2.3，提供了很多很好（也很基础）的功能，比如定义property、把对property的引用转化为对getter/setter的引用等，再加上它已有的“扩展方法”和“闭包”，用起来就很舒服了。&lt;/p&gt;
&lt;p&gt;xtend号称java界的coffeescript。当我们写下xtend代码时，编译器会把它翻译成可读性很高的java源代码，注意是“源代码”，而不是“字节码”。相比jvm上的其它语言如scala等，这是一个巨大的优势：只要是用java的地方，都可以用xtend代替，而不需要处理额外的如编译等问题。这样对于我们来说，写下的是简洁清楚的xtend代码，而对系统或框架来说，它们看到的还是java源代码，皆大欢喜。&lt;/p&gt;
&lt;p&gt;正因为有了xtend，让我对一些java框架也不像之前那么排斥了，比如play2-java。play1中大量利用了annotation和javassist来突破java语法的限制，让我们编码时轻松一些，受到了广大java程序员的欢迎。而play2认为play1中魔术太多，去掉了一些魔术，但代码写起来要啰嗦一些。也因此，用play2的人都会半逼迫着去学习scala（或退回到play1），但scala与java库之间的不匹配，有时候会造成很多问题，让人很郁闷。同时因为scala语言本身的难度，用起来很坎坷，所以我一度对play2的未来充满了怀疑。&lt;/p&gt;
&lt;p&gt;但现在有了xtend，情况立马变得不同。使用xtend+play2-java，既能保持所有java的优势，又能让代码写起来不那么痛苦。以前需要用annotation来简化的操作，通过xtend定义一些DSL，写起来既简单又易调试。以前用得顺手的java库，现在继续能用，而且还更容易了。再加上xtend学习成本很低，几个小时就能掌握，这的确是相当大的吸引力。&lt;/p&gt;
&lt;p&gt;xtend中这几个功能相当好用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扩展方法：就像是给已有类增加了新方法，调用起来很流畅&lt;/li&gt;
&lt;li&gt;闭包：大大简化了代码，以前几行的，现在一行搞定&lt;/li&gt;
&lt;li&gt;Property：不再需要定义getter/setter，对property的调用也会转化为getter/setter。某些库或框架会对java类的getter/setter做增强，这对xtend来说完全不是问题（对scala就是问题）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;据说xtend现在正在实现一个很大的功能，叫annotation custom processing，类似于macro的功能。能让我们控制生成的java代码，实现一些更强大的功能。非常期待这个功能，不过不知道什么时候才会推出。&lt;/p&gt;
&lt;p&gt;现在xtend中还有这样的一些小问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;未提供代码格式化：连最基本的自动缩进都没有，有点麻烦&lt;/li&gt;
&lt;li&gt;不能自动导入类，必须手动一个个定位再导入&lt;/li&gt;
&lt;li&gt;有些地方的语法还能再简单一些：比如参数的默认值，并行赋值等&lt;/li&gt;
&lt;li&gt;错误提示不够智能&lt;/li&gt;
&lt;li&gt;偶尔生成的java代码有错误（但xtend本身又不提示）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过这些问题现在都能绕过，不是大问题。期待下一版的改进。&lt;/p&gt;
&lt;p&gt;最后的感言就是：学了scala一年多，但实际用在项目中有各种痛苦，效率提不上去，最后放弃。而xtend仅仅几个小时，就能让我感受到了效率的提高，非常感谢。Xtend才是真正的better java。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Dart一日游</title>
                <link>http://freewind.in/posts/945-one-day-on-dart</link>
                <pubDate>Sat, 26 May 2012 22:30:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">945</guid>
                <description><![CDATA[&lt;p&gt;昨天从nodejs站下车，正想往ruby方向走，突然在街角一不起眼处发现了一小屋Dart。Dart曾经了解过，是google开发的用于替代javascript的一门新语言。它的特点是：语法很像java/javascript，可同时运行于server端和client端。它的目标是，让人们可以更快速的开发出更高质量的web程序。&lt;/p&gt;
&lt;p&gt;但dart最开始为人们所知时，却是dart运行于客户端时，以生成的js代码巨大无比而闻名。不信看看这个hello world:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/1277224&quot;&gt;https://gist.github.com/1277224&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;短短的几行helloworld的dart代码，被编译成了17259行js代码，引得无数人围观，也打消了很多人尝试dart的念头。&lt;/p&gt;
&lt;p&gt;dart可以编译为js代码，并且采用了与其它语言不同的方式：它首先把所有的基本库转为js代码，不管用没用到，然后再把实际的dart代码转为js。之所以这样，是因为dart本身就定位于一个运行于dart vm的语言：在server端，有不知用什么语言编写的vm；在客户端，有用javascript编写的vm。这样有了vm的基础，再添加新功能就容易的多。&lt;/p&gt;
&lt;p&gt;如果是其它语言，肯定不会采用这种方式，但对于google来说，这是一石二鸟之计。因为google有chrome，以后可以直接在chrome上嵌入dart vm。这样做，一方面简化了Dart的工作量，另一方面也成了chrome吸引更多开发者的原因。&lt;/p&gt;
&lt;p&gt;幽灵同学发给我的what is dart的电子书，短短20页，介绍了一些dart的特性，比较吸引我，这放在后面再说。这里先介绍一个Dart最吸引我的特性：对json的无比良好的支持。&lt;/p&gt;
&lt;h2&gt;JSON&lt;/h2&gt;
&lt;p&gt;json现在越来越重要，一方面它是服务器端与浏览器端的首选通信格式，另一方面，如果使用如mongodb或couchdb这样的nosql数据库，更离不开json。如果能在语言层面支持json，会大大简化我们的工具。而dart不仅支持，还远超预期。&lt;/p&gt;
&lt;p&gt;首先dart中的各种内置类型，可以很好的表示json格式：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;&amp;#8220;language&amp;rdquo;: &amp;#8220;dart&amp;rdquo;,                                 // String&lt;/p&gt;
&lt;p&gt;&amp;#8220;targets&amp;rdquo;: [&amp;ldquo;dartium&amp;rdquo;,&amp;ldquo;javascript&amp;rdquo;],                // List&lt;/p&gt;
&lt;p&gt;&amp;#8220;website&amp;rdquo;: {                                        // Map&lt;/p&gt;
&lt;p&gt;&amp;#8220;homepage&amp;rdquo;: &amp;#8220;www.dartlang.org&amp;rdquo;,&lt;/p&gt;
&lt;p&gt;&amp;#8220;api&amp;rdquo;: &amp;#8220;api.dartlang.org&amp;rdquo;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上，它实际上是dart的一个map，里面的[]是dart的List，其它还有String,num和bool类型，正好与json一一对应。如果想把上面的这个json转为字符串，可以调用内置的json库中的方法：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;String jsonStr = JSON.stringify(jsonMap)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想把字符串变为map，可调用：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;span style=&quot;background-color: #ffffff;&quot;&gt;Map json = JSON.parse(str)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仅仅这样，还没什么让人激动的，因为javascript中不就是这么做的吗？&lt;/p&gt;
&lt;p&gt;别急，先介绍一下背景知识。Dart同时支持动静态类型。我们在开发时，可以打开静态类型检查，以帮助我们找到错误，在运行时，因为在客户端要运行于javascript之上，所以会以动态类型方式执行。首先看看利用JsonObject类来解析一个json字符串，注意编辑器的警告信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/945-1.png&quot;&gt;&lt;img src=&quot;/user_images/945-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，解析为JsonObject后，可以直接以data.language这样的动态方式来调用它的字段。但是因为JsonObject本身没有那些字符，编译器会提示警告信息：它们不是JsonObject的成员变量。&lt;/p&gt;
&lt;p&gt;下面是激动人心的地方。我们可以定义一些类，继承于JsonObject：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;interface LanguageWebsite extends JsonObject {&lt;/p&gt;
&lt;p&gt;String homepage;&lt;/p&gt;
&lt;p&gt;String api;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;interface Language extends JsonObject {&lt;/p&gt;
&lt;p&gt;String language;&lt;/p&gt;
&lt;p&gt;List&lt;String&gt; targets;&lt;/p&gt;
&lt;p&gt;LanguageWebsite website;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里定义了两个类，它们继承于JsonObject，并且添加了相应的属性。然后。。。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/945-3.png&quot;&gt;&lt;img src=&quot;/user_images/945-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细地看上面一段代码，警告不见了。而且，我们居然可以把一个父类赋给一个子类！！&lt;/p&gt;
&lt;p&gt;之前得到的还是一个类似于map的JsonObject，而现在得到的一个与json中每个字段都有对应属性的类的对象。从json向对象的转换，以这样完美无可挑剔的方式完成了。可以想到，使用这种方式，与其它系统（如mongodb）交互，根本不需要额外的orm框架，直接在语言级别就搞定了！这可以大大简化不同层之间用于数据交换的代码，真是太好了。&lt;/p&gt;
&lt;p&gt;（这是dart类型系统的一个独特的设计，因为我还没有深入，这里只好一笔带过，有兴趣者自行研究。）&lt;/p&gt;
&lt;h2&gt;其它特性&lt;/h2&gt;
&lt;p&gt;这里再看看dart的其它特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可选类型：即前面所说的动静态类型的结合。&lt;/li&gt;
&lt;li&gt;Snapshot：可以把代码当前的运行状态保存起来，供以后直接使用，这样就不需要从头开始执行代码了。有点像操作系统的“休眠”功能。&lt;/li&gt;
&lt;li&gt;Isolates：有点像actor，可用于异步编程。两个Isolate之间可以通过发送信息通信。通过该特性，dart可以利用多核。&lt;/li&gt;
&lt;li&gt;带有默认实现的接口：定义一个接口后，可以给它指定一个默认实现类。这样的话，可以用new MyInterface()的方式，直接获得某接口默认实现类的对象。和trait有点像？不过目前不支持mixin。&lt;/li&gt;
&lt;li&gt;泛型：为了满足动态需求，泛型的设计很简单，但也很有用。具体可参考相应文档。&lt;/li&gt;
&lt;li&gt;HTML库：内置可简化html操作的库，用于处理dom等&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;支持与示例&lt;/h2&gt;
&lt;p&gt;现在dart已经支持windows/linux/mac，在各种主流系统上运行。它同时提供了基于eclipse的编辑器dart editor，支持语法高亮、错误提示和方法补全（暂未提供代码格式化功能）。下载的dart editor中自带了一个叫dartium的浏览器，它就是chrome+dart vm，用于开发之用。&lt;/p&gt;
&lt;p&gt;打开dart editor，可以看到它提供了几个例子，其中第一个很炫。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/945-5.png&quot;&gt;&lt;img src=&quot;/user_images/945-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个可显示时分秒的表，运行于dartium的浏览器上，其炫处在于，每一秒数字变化时，用不到的小球会被弹出来，像一粒粒玻璃球弹在墙壁上地上，不停跳动。球与球之间相碰时，也会有同样的动作。这里来个大点的截图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/945-7.png&quot;&gt;&lt;img src=&quot;/user_images/945-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个程序运行于客户端，大约使用了500行dart代码，编译出来的js代码大约4473行（不包括vm）。&lt;/p&gt;
&lt;h2&gt;开发团队&lt;/h2&gt;
&lt;p&gt;这里来自slideshare.net上的某个幻灯片：&lt;a href=&quot;http://www.slideshare.net/yinhm/dart-intro&quot;&gt;http://www.slideshare.net/yinhm/dart-intro&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/945-9.png&quot;&gt;&lt;img src=&quot;/user_images/945-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可见团队阵容还是相当豪华的。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;项目地址：&lt;a href=&quot;http://code.google.com/p/dart/&quot;&gt;http://code.google.com/p/dart/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;邮件组：&lt;a href=&quot;https://groups.google.com/a/dartlang.org/group/misc/topics&quot;&gt;https://groups.google.com/a/dartlang.org/group/misc/topics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第三方库列表：&lt;a href=&quot;http://blog.dartwatch.com/p/community-dart-packages-and-examples.html&quot;&gt;http://blog.dartwatch.com/p/community-dart-packages-and-examples.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;一日游&lt;/h2&gt;
&lt;p&gt;我今天尝试使用dart来写一个简单的web后台程序，只需要简单的route/session/cookie，与mongodb交互。但在尝试过程中遇到了不少问题，比如dart文档比较缺乏，第三方库比较少，最基本的包管理功能还没有实现。想使用第三方库，必须手动把源代码下载下来，通过源代码直接调用。dart的社区也比较小，可能是因为现在开发团队正在努力实现核心功能，api变化较大，不适合发展社区。举例来说，今天下载的mongo-dart最新提交是前几天的，但却不能在最新的dart sdk上成功编译，是因为dart sdk上某些api已经发生了变化。现在的Dart给人的感觉相当低调，可能与此有关。&lt;/p&gt;
&lt;p&gt;总之在尝试过程中，发现遇到的困难比较多，最麻烦之处在于难以快速的找到解决方法，太浪费时间。如果现在使用dart来做项目，可以预见会经常被卡住。经过考虑之后，我打算暂不使用Dart，保持关注即可。等到一个成熟的包管理工具实现了，第三方库会发展起来之后，再使用dart会比较好。&lt;/p&gt;
&lt;p&gt;不过还是得说，我非常喜欢dart提供的各特色功能，相比nodejs，有着巨大的优势。我相信等dart发布1.0以后，一定会得到飞速的发展，到时候会吸引大批开发者转到dart下。google真是厉害，dart、golang、angularjs，都非常具有吸引力。&lt;/p&gt;
&lt;p&gt;最后在唐古拉山的推荐之下，我打算先试试golang，因为它现在已经比较成熟了，评价也比较好。看看它能否满足我的要求。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>止步于nodejs的异步</title>
                <link>http://freewind.in/posts/934-stopped-on-the-asynchrouse-of-nodejs</link>
                <pubDate>Sat, 26 May 2012 01:43:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">934</guid>
                <description><![CDATA[&lt;p&gt;学习nodejs一个月之后，终于还是败在了nodejs的异步编程模型上。&lt;/p&gt;
&lt;p&gt;我对nodejs的其它都还是比较满意的：活跃的社区，很多有创意的项目，node本身无比快速的启动，以及写js代码时那种虽然不踏实但相当放松的感觉，都让我很舒服。&lt;/p&gt;
&lt;p&gt;除了异步。&lt;/p&gt;
&lt;p&gt;nodejs的特点是“单线程、基于事件非阻塞”，对于各种耗时操作，比如IO/数据库之类，都通过异步api调用，传个回调进去。让node在后台通过其它线程处理，完了以后调用我们的回调函数，把错误或者数据传进来。这也可算是一件好事，因为我们的代码运行于单线程，不需要考虑线程竞争、同步的问题，但是带来的问题也是相当麻烦：每调用一次异步，就要多一次嵌套，代码复杂点，轻轻松松五六层。这还是小事，更麻烦的是，错误处理变麻烦了（不能用try-catch），算法逻辑分散了（东一块西一块），当需要考虑某些操作并行或顺序执行时，也非常难以控制。&lt;/p&gt;
&lt;p&gt;期间纠结了几次，实在不愿直面散乱的代码，想换到其它同步风格的语言。好在发现了两个比较好的工具，以为解决了我的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/caolan/async&quot;&gt;async&lt;/a&gt; 一个纯nodejs库，提供了控制流程和集合处理的方法，可以让我们大大减化操作&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Sage/streamlinejs&quot;&gt;streamlinejs&lt;/a&gt; 通过引入一个下划线作为callback的占位符，让我们以同步风格来调用异步代码，比async更简洁。缺点是需要手动转换为js代码，或者调用命令行时增加参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里只列出了两个，但我实际上试用了几乎所有能找到的模块（十几个最少）。所以目前市面上基本很难找到比它们两个更好的了。如果有的话，请向我推荐。&lt;/p&gt;
&lt;p&gt;这两个相比，我更加偏爱后者，因为它可以让我们的代码简洁到无法再简洁的程度。可读性非常高，并且与mocha的结合也很完美。我本以为可以安心地继续写nodejs了。&lt;/p&gt;
&lt;p&gt;然而今天在把之前用async写的一些代码转换为streamlinejs时，发现了一个严重的问题。有一些逻辑稍复杂的代码（先批量清空数据库，再指插入新数据），使用streamlinejs改写后，运行总不对。明明是想先清空后插入，不知怎么就变成先插入后清空了。其文档很简单，示例也少，找不到资料。想看一下转换后的js代码，相当复杂：&lt;a href=&quot;https://gist.github.com/2788457&quot;&gt;https://gist.github.com/2788457&lt;/a&gt;，如同经过混淆。想在代码中增加一些调试信息也不行，因为那个下划线的用法是定死的，不能先写一个自定义的callback再在里面调用下划线方法。&lt;/p&gt;
&lt;p&gt;经过5个小时的调试，我终于放弃了。回想这一个月的学习过程，太多的时间花在nodejs的异步风格的转变，以及各种模块之间的配合上。因为nodejs几乎所有的模块都沿袭了异步风格，如果想用同步库来做，经常会遇到各个模块之间的不兼容问题。&lt;/p&gt;
&lt;p&gt;在我决定离开nodejs之前，我还挣扎了一下，看了一眼ringojs。它是一个运行于jvm上的与nodejs相似的平台，使用rhino引擎来解释js代码，符合commonjs规范，并且是同步风格的。可惜的是，我想用的express和mongoose都是基于nodejs的，调用了大量的nodejs的api，不能直接在ringojs上运行。在ringojs上可以用java的库，但我实在不想用了。&lt;/p&gt;
&lt;p&gt;nodejs不可怕，可怕的是围绕它建立起来的6000多个模块。因为这一点，node-fibers和ringojs都不是它的对手，虽然它们写出来的代码会让人更舒服一些。&lt;/p&gt;
&lt;p&gt;下一步，先转向dart，不行再ruby。继续折腾。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Async详解之三：集合操作</title>
                <link>http://freewind.in/posts/933-async-3-collections</link>
                <pubDate>Fri, 18 May 2012 22:26:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">933</guid>
                <description><![CDATA[&lt;p&gt;Async提供了很多针对集合的函数，可以简化我们对集合进行异步操作时的步骤。如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;forEach：对集合中每个元素进行异步操作&lt;/li&gt;
&lt;li&gt;map：对集合中的每个元素通过异步操作得到另一个值，得到新的集合&lt;/li&gt;
&lt;li&gt;filter：对集合中元素使用异步操作进行筛选，得到符合条件的集合&lt;/li&gt;
&lt;li&gt;reject：与filter相似，只是判断条件时正好相反，得到剩下的元素的集合&lt;/li&gt;
&lt;li&gt;reduce：使用一个初始值同集合中每一个元素进行异步操作，最后得到一个唯一的结果&lt;/li&gt;
&lt;li&gt;detect：得到集合中满足条件的第一个数据&lt;/li&gt;
&lt;li&gt;sortBy：对集合中的数据进行异步操作，再根据值从小到大排序&lt;/li&gt;
&lt;li&gt;some/any：集合中是否有至少一个元素满足条件&lt;/li&gt;
&lt;li&gt;every/all：集合中是否每个元素都满足条件&lt;/li&gt;
&lt;li&gt;concat：对集合中的元素进行异步操作，将结果集合并成一个数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面一一解释：&lt;/p&gt;
&lt;h2&gt;1. forEach(arr, iterator(item, callback), callback(err))&lt;/h2&gt;
&lt;p&gt;如果想对同一个集合中的所有元素都执行同一个异步操作，可以利用forEach函数。注意该函数将重点放在“执行过程”上，忽略运行后产生的数据。如果需要结果，可使用map函数。&lt;/p&gt;
&lt;p&gt;根据执行的方式不同，forEach提供了三个版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合中所有元素并行执行&lt;/li&gt;
&lt;li&gt;一个一个顺序执行&lt;/li&gt;
&lt;li&gt;分批执行，同一批内并行，批与批之间按顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先看并行执行的例子，它比较简单，只是打印出传入的元素内容：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var arr = [{name:&apos;Jack&apos;, delay: 200},&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       {name:&apos;Mike&apos;, delay: 100},      
       {name:&apos;Freewind&apos;, delay: 300}];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;async.forEach(arr, function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos; + item.name);      
setTimeout(function(){      
    log(&apos;1.1 handle: &apos; + item.name);      
    callback();      
}, item.delay);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 err: &apos; + err);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它将打出如下结果：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;42.244&gt; 1.1 enter: Jack
&lt;br  /&gt;42.245&gt; 1.1 enter: Mike
&lt;br  /&gt;42.245&gt; 1.1 enter: Freewind
&lt;br  /&gt;42.350&gt; 1.1 handle: Mike
&lt;br  /&gt;42.445&gt; 1.1 handle: Jack
&lt;br  /&gt;42.554&gt; 1.1 handle: Freewind
&lt;br  /&gt;42.554&gt; 1.1 err: undefined&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最前面的数据是当前的时间值（秒.毫秒），从中可以看到各异步操作是并行执行的。&lt;/p&gt;
&lt;p&gt;如果想同步执行，需要使用forEachSeries函数，它与forEach的用法一模一样，只是执行时是一个一个来的。这里就不给例子了。&lt;/p&gt;
&lt;p&gt;当集合中元素很多，既不想一次全部并行操作，又不想一个一个按顺序来，可以使用forEachLimit函数。它可以设定一批处理几个，每一批内并行执行，批与批之间顺序执行。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.forEachLimit(arr, 2, function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.5 enter: &apos; + item.name);      
setTimeout(function(){      
    log(&apos;1.5 handle: &apos; + item.name);      
    callback(null, item.name);      
}, item.delay);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.5 err: &apos; + err);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;42.247&gt; 1.5 enter: Jack
&lt;br  /&gt;42.248&gt; 1.5 enter: Mike
&lt;br  /&gt;42.351&gt; 1.5 handle: Mike
&lt;br  /&gt;42.352&gt; 1.5 enter: Freewind
&lt;br  /&gt;42.461&gt; 1.5 handle: Jack
&lt;br  /&gt;42.664&gt; 1.5 handle: Freewind
&lt;br  /&gt;42.664&gt; 1.5 err: undefined&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到前两个是同时开始的，而第三个是等前两个都完成以后才开始的。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/forEach.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/forEach.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2. map(arr, iterator(item, callback), callback(err, results))&lt;/h2&gt;
&lt;p&gt;map的重点是转换，即把集合中的元素通过异步操作转为另一个对象，最后可以得到转换后的对象数组。它也提供了并行与顺序执行两种方式。&lt;/p&gt;
&lt;p&gt;这里给一个示例，给集合中的每个元素以异步方式增加!!!：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var arr = [{name:&apos;Jack&apos;, delay:200}, {name:&apos;Mike&apos;, delay: 100}, {name:&apos;Freewind&apos;, delay:300}, {name:&apos;Test&apos;, delay: 50}];&lt;/p&gt;
&lt;p&gt;async.map(arr, function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos; + item.name);      
setTimeout(function() {      
    log(&apos;1.1 handle: &apos; + item.name);      
    callback(null, item.name+&apos;!!!&apos;);      
}, item.delay);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err,results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 err: &apos;, err);      
log(&apos;1.1 results: &apos;, results);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;54.569&gt; 1.1 enter: Jack
&lt;br  /&gt;54.569&gt; 1.1 enter: Mike
&lt;br  /&gt;54.569&gt; 1.1 enter: Freewind
&lt;br  /&gt;54.569&gt; 1.1 enter: Test
&lt;br  /&gt;54.629&gt; 1.1 handle: Test
&lt;br  /&gt;54.679&gt; 1.1 handle: Mike
&lt;br  /&gt;54.789&gt; 1.1 handle: Jack
&lt;br  /&gt;54.879&gt; 1.1 handle: Freewind
&lt;br  /&gt;54.879&gt; 1.1 err:
&lt;br  /&gt;54.879&gt; 1.1 results: [ &apos;Jack!!!&apos;, &apos;Mike!!!&apos;, &apos;Freewind!!!&apos;, &apos;Test!!!&apos; ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，对各元素的操作是并行的，结果会汇总在一起交给最后的回调。&lt;/p&gt;
&lt;p&gt;如果想顺序执行，可使用mapSeries，它与map的用法一模一样。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/map.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/map.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3. filter(arr, iterator(item, callback(test)), callback(results))&lt;/h2&gt;
&lt;p&gt;使用异步操作对集合中的元素进行筛选。需要注意的是，iterator的callback只有一个参数，只能接收true或false。&lt;/p&gt;
&lt;p&gt;对于出错，该函数没有做出任何处理，直接由nodejs抛出。所以需要注意对Error的处理。&lt;/p&gt;
&lt;p&gt;提供了并行与顺序执行两种方式。&lt;/p&gt;
&lt;p&gt;并行示例，找到所有&gt;=3的元素：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.filter([1,2,3,4,5], function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos; + item);      
setTimeout(function() {      
    log(&apos;1.1 test: &apos; + item);      
    callback(item&amp;gt;=3);      
}, 200);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 results: &apos;, results);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;16.739&gt; 1.1 enter: 1
&lt;br  /&gt;16.749&gt; 1.1 enter: 2
&lt;br  /&gt;16.749&gt; 1.1 enter: 3
&lt;br  /&gt;16.749&gt; 1.1 enter: 4
&lt;br  /&gt;16.749&gt; 1.1 enter: 5
&lt;br  /&gt;16.749&gt; 1.3 enter: 1
&lt;br  /&gt;16.949&gt; 1.1 test: 1
&lt;br  /&gt;16.949&gt; 1.1 test: 2
&lt;br  /&gt;16.949&gt; 1.1 test: 3
&lt;br  /&gt;16.949&gt; 1.1 test: 4
&lt;br  /&gt;16.949&gt; 1.1 test: 5
&lt;br  /&gt;16.949&gt; 1.1 results: [ 3, 4, 5 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见找到了满足条件的所有元素。&lt;/p&gt;
&lt;p&gt;如果需要顺序执行，可以使用filterSeries函数，它的用法与filter一样。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/filter_reject.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/filter_reject.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4. reject(arr, iterator(item, callback(test)), callback(results))&lt;/h2&gt;
&lt;p&gt;reject与filter相似，只是行为正好相反。当条件为true时，它将丢弃相应的元素。它也提供了并行与顺序执行两种方式。&lt;/p&gt;
&lt;p&gt;并行示例，去掉所有&gt;=3的元素：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.reject([1,2,3,4,5], function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.4 enter: &apos; + item);      
setTimeout(function() {      
    log(&apos;1.4 test: &apos; + item);      
    callback(item&amp;gt;=3);      
}, 200);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.4 results: &apos;, results);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;31.359&gt; 1.4 enter: 1
&lt;br  /&gt;31.359&gt; 1.4 enter: 2
&lt;br  /&gt;31.359&gt; 1.4 enter: 3
&lt;br  /&gt;31.359&gt; 1.4 enter: 4
&lt;br  /&gt;31.359&gt; 1.4 enter: 5
&lt;br  /&gt;31.559&gt; 1.4 test: 1
&lt;br  /&gt;31.559&gt; 1.4 test: 2
&lt;br  /&gt;31.559&gt; 1.4 test: 3
&lt;br  /&gt;31.559&gt; 1.4 test: 4
&lt;br  /&gt;31.559&gt; 1.4 test: 5
&lt;br  /&gt;31.569&gt; 1.4 results: [ 1, 2 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想顺序执行，可使用rejectSeries，它与reject用法一样。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/filter_reject.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/filter_reject.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;5. reduce(arr, memo, iterator(memo,item,callback), callback(err,result))&lt;/h2&gt;
&lt;p&gt;Reduce可以让我们给定一个初始值，用它与集合中的每一个元素做运算，最后得到一个值。reduce从左向右来遍历元素，如果想从右向左，可使用reduceRight。&lt;/p&gt;
&lt;p&gt;这里给个例子，计算出100与某个集合中所有数之和：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var arr = [1,3,5];&lt;/p&gt;
&lt;p&gt;async.reduce(arr, 100, function(memo, item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos; + memo +&apos;, &apos; + item);      
setTimeout(function() {      
    callback(null, memo+item);      
}, 100);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;},function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 err: &apos;, err);      
log(&apos;1.1 result: &apos;, result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将打印出结果：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;28.789&gt; 1.1 enter: 100, 1
&lt;br  /&gt;28.889&gt; 1.1 enter: 101, 3
&lt;br  /&gt;28.999&gt; 1.1 enter: 104, 5
&lt;br  /&gt;29.109&gt; 1.1 err:
&lt;br  /&gt;29.109&gt; 1.1 result: 109&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是，async中的reduce，不是并行操作，而是对元素一个个顺序操作，所以当元素比较多时，性能会比较弱。如果想提高性能，可使用async.map函数，先并行得到集合中每个元素被处理之后的值，然后再使用Array.prototype.reduce函数处理，性能会快很多。&lt;/p&gt;
&lt;p&gt;对于这个例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.reduce(arr, 100, function(memo,item,callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.4 enter: &apos;+memo+&apos;,&apos;+item);      
t.inc(item, function(err,n) {      
    log(&apos;1.4 handle: &apos;,n);      
    callback(null, memo+n);      
});      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err,result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.4 err: &apos;, err);      
log(&apos;1.4 result: &apos;, result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它总耗时为0.62秒。如果换成map+array.reduce:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.map(arr, function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.5 enter: &apos;, item);      
t.inc(item, function(err,n){      
    log(&apos;1.5 handle: &apos;, n);      
    callback(null,n);      
});  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;},function(err, results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.5 err: &apos;, err);      
log(&apos;1.5 results: &apos;, results);      
var sum = results.reduce(function(memo, item) {      
    return memo + item;      
}, 100);      
log(&apos;1.5 sum: &apos;, sum);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;耗时为0.21秒。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/reduce.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/reduce.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6. detect(array, iterator(item,callback(test)), callback(result)&lt;/h2&gt;
&lt;p&gt;用于取得集合中满足条件的第一个元素。它分为并行与顺序执行两种方式，分别对应函数detect和detectSeries。&lt;/p&gt;
&lt;p&gt;并行示例，找到一个奇数：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var arr = [{value:1,delay:500},&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       {value:2,delay:200},      
       {value:3,delay:300}];      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;async.detect(arr, function(item,callback){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos;, item.value);      
setTimeout(function() {

    log(&apos;1.1 handle: &apos;, item.value);     
    callback(n%2===1);      
}, item.delay);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 result: &apos;, result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;09.928&gt; 1.1 enter: 1
&lt;br  /&gt;09.928&gt; 1.1 enter: 2
&lt;br  /&gt;09.928&gt; 1.1 enter: 3
&lt;br  /&gt;10.138&gt; 1.1 handle: 2
&lt;br  /&gt;10.228&gt; 1.1 handle: 3
&lt;br  /&gt;10.228&gt; 1.1 result: { value: 3, delay: 300 }
&lt;br  /&gt;10.438&gt; 1.1 handle: 1
&lt;br  /&gt;10.438&gt; 1.1 handle: 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见得到了最先执行完的那个奇数3.&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/detect.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/detect.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;7. sortBy(array, iterator(item,callback(err,result)), callback(err,results))&lt;/h2&gt;
&lt;p&gt;对集合内的元素进行排序，依据每个元素进行某异步操作后产生的值，从小到大排序。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var arr = [3,6,1];&lt;/p&gt;
&lt;p&gt;async.sortBy(arr, function(item, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {      
    callback(null,item);      
}, 200);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err,results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 err: &apos;, err);      
log(&apos;1.1 results: &apos;, results);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;26.562&gt; 1.1 err: null
&lt;br  /&gt;26.562&gt; 1.1 results: [ 1, 3, 6 ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到集合中的数据从小到大排好了序。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/sortBy.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/sortBy.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;8. some/any(arr, iterator(item,callback(test)), callback(result))&lt;/h2&gt;
&lt;p&gt;当集合中是否有至少一个元素满足条件时，最终callback得到的值为true，否则为false。它有一个别名叫any。&lt;/p&gt;
&lt;p&gt;判断集合中是否有元素小于等于3：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.some([1,2,3,6], function(item,callback){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos;,item);      
setTimeout(function(){      
    log(&apos;1.1 handle: &apos;,item);      
    callback(item&amp;lt;=3);      
},100);    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 result: &apos;, result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;36.165&gt; 1.1 enter: 1
&lt;br  /&gt;36.165&gt; 1.1 enter: 2
&lt;br  /&gt;36.165&gt; 1.1 enter: 3
&lt;br  /&gt;36.165&gt; 1.1 enter: 6
&lt;br  /&gt;36.275&gt; 1.1 handle: 1
&lt;br  /&gt;36.275&gt; 1.1 result: true
&lt;br  /&gt;36.275&gt; 1.1 handle: 2
&lt;br  /&gt;36.275&gt; 1.1 handle: 3
&lt;br  /&gt;36.275&gt; 1.1 handle: 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见的确得到了结果true。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/some.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/some.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;9. every/all(arr, iterator(item,callback), callback(result))&lt;/h2&gt;
&lt;p&gt;如果集合里每一个元素都满足条件，则传给最终回调的result为true，否则为false&lt;/p&gt;
&lt;p&gt;在下面的示例中，因为集合中每个元素都&amp;lt;=10，所以最终结果为true&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.every(arr, function(item,callback){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 enter: &apos;,item);      
setTimeout(function(){      
    log(&apos;1.1 handle: &apos;,item);      
    callback(item&amp;lt;=10);      
},100);    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 result: &apos;, result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;32.113&gt; 1.1 enter: 1
&lt;br  /&gt;32.123&gt; 1.1 enter: 2
&lt;br  /&gt;32.123&gt; 1.1 enter: 3
&lt;br  /&gt;32.123&gt; 1.1 enter: 6
&lt;br  /&gt;32.233&gt; 1.1 handle: 1
&lt;br  /&gt;32.233&gt; 1.1 handle: 2
&lt;br  /&gt;32.233&gt; 1.1 handle: 3
&lt;br  /&gt;32.233&gt; 1.1 handle: 6
&lt;br  /&gt;32.233&gt; 1.1 result: true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见最终结果为true&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/every.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/every.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;10. concat(arr, iterator(item,callback(err,result)), callback(err,result))&lt;/h2&gt;
&lt;p&gt;将合并多个异步操作的结果合并为一个数组。&lt;/p&gt;
&lt;p&gt;在下面的示例中，将集合中的每一个元素都加倍：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;async.concat([&apos;aa&apos;,&apos;bb&apos;], function(item,callback) {&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    setTimeout(function() {&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;        callback(null, [item, item]);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    }, 100);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;}, function(err, values) {&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    log(&apos;1.1 err: &apos;, err);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    log(&apos;1.1 values: &apos;, values);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;});&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;13.539&gt; 1.1 err:&lt;/p&gt;
&lt;p&gt;13.639&gt; 1.1 values: [ &apos;aa&apos;, &apos;aa&apos;, &apos;bb&apos;, &apos;bb&apos; ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印出来的是经过合并后的数组。&lt;/p&gt;
&lt;p&gt;更多详细示例：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/concat.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/concat.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于async的api解释到此为止，我将会在以后的项目中使用它。以后使用熟悉之后，再研究一下他的源代码，写一些心得。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Async详解之二：工具类</title>
                <link>http://freewind.in/posts/931-async-2-helpers</link>
                <pubDate>Fri, 18 May 2012 00:42:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">931</guid>
                <description><![CDATA[&lt;p&gt;相比“之一”，这一篇要简单很多，算是中场休息，为下半场的“集合处理”做准备。&lt;/p&gt;
&lt;p&gt;Async中提供了几个工具类，给我们提供一些小便利：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;memoize&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;unmemoize&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dir&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;noConflict&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;memoize(fn, [hasher])&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有一些方法比较耗时，且对于相同的输入总是有相同的输出。这时可以使用memoize给它加个缓存，对于相同的参数只计算一次，以后就直接从缓存中取结果用了。&lt;/p&gt;
&lt;p&gt;比如这里有一个很慢的函数：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var slow_fn = function(x, y, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;start working for: &apos; + x+&apos;,&apos;+y);      
t.wait(100);      
console.log(&apos;finished: &apos; + x+&apos;,&apos;+y);      
callback(null, &apos;im slow for: &apos;+x+&apos;,&apos;+y);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以用memoize生成一个新的带缓存的函数：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var fn = async.memoize(slow_fn);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;试试同样参数调用两次：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;fn(&apos;a&apos;,&apos;b&apos;, function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;// 直接得到之前计算好的值
&lt;br  /&gt;fn(&apos;a&apos;,&apos;b&apos;, function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意memoize的参数中还有一个hasher，它是做什么用的呢？它可以让我们自定义如果根据参数来判断是否从缓存中取。默认情况下，两次调用，只有参数完全一样的时候才会从缓存中取。这里我们使用hasher来改变规则。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var fn_hasher = async.memoize(slow_fn, function(x,y) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return x+y;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新定义的这个，将根据两个参数的和来判断。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;fn_hasher(&apos;cd&apos;,&apos;e&apos;, function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;fn_hasher(&apos;c&apos;,&apos;de&apos;, function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result); // 可以取得前面(&apos;cd&apos;,&apos;e&apos;)的计算结果      
                     // im show for: cd,e      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二次的调用，虽然参数跟第一次不一样，但是其和却一样，所以直接从缓存中拿到前次运行结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;unmemoize(fn)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;unmemoize的作用正好跟memoize相反，它可以把一个带缓存的函数再变回原样：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var fn2 = async.unmemoize(fn);
&lt;br  /&gt;console.log(&apos;unmemoized&apos;);&lt;/p&gt;
&lt;p&gt;fn2(&apos;a&apos;,&apos;b&apos;, function(err,result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过unmemoize后，再运行该函数就得重新运算了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;log(function, arguments)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;log用于快速执行某异步函数，并记录它的返回值。试验函数时很方便，不用写那些固定模式的代码。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var x = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this.name = &apos;Freewind&apos;;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;var hello = function(name, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {      
    callback(null, &apos;hello &apos; + name, &apos;nice to see you &apos; + name, x, {a:&apos;123&amp;amp;#8242;});      
}, 200);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;async.log(hello, &apos;world&apos;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;hello world
&lt;br  /&gt;nice to see you world
&lt;br  /&gt;[Function]
&lt;br  /&gt;{ a: &apos;123&amp;#8242; }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，它直接运行了该函数，并以每行一个参数的形式打印出了结果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dir(function, arguments)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该函数与log非常像，不同之处在于，它最终调用了console.dir，而log最终调用了console.log。&lt;/p&gt;
&lt;p&gt;看看使用dir打印的效果如何：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.dir(hello, &apos;world&apos;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&apos;hello world&apos;
&lt;br  /&gt;&apos;nice to see you world&apos;
&lt;br  /&gt;[Function]
&lt;br  /&gt;{ a: &apos;123&amp;#8242; }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仅仅是多了几个单引号。为了弄清楚dir存在的意义（什么情况下应该使用dir而不是log），我提了一个问题，参看：&lt;a href=&quot;http://stackoverflow.com/questions/10636866/whats-the-difference-between-async-log-and-async-dir&quot; title=&quot; http://stackoverflow.com/questions/10636866/whats-the-difference-between-async-log-and-async-dir&quot;&gt; http://stackoverflow.com/questions/10636866/whats-the-difference-between-async-log-and-async-dir&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;noConflict&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后是这个noConflict，它仅仅用于浏览器端，在nodejs中没用，这里无法演示。&lt;/p&gt;
&lt;p&gt;它的作用是：如果之前已经在全局域中定义了async变量，当导入本async.js时，会先把之前的async变量保存起来，然后覆盖它。用完之后，调用noConflict()方法，就会归还该值。同时返回async本身供换名使用。&lt;/p&gt;
&lt;p&gt;这里可以看一下它的实现代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;// global on the server, window in the browser
&lt;br  /&gt;var root = this,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;previous_async = root.async;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if (typeof module !== &apos;undefined&apos; &amp;amp;&amp;amp; module.exports) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module.exports = async;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;else {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root.async = async;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;async.noConflict = function () {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root.async = previous_async;      
return async;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，当处于nodejs或者commonjs环境中，它会执行module.exports=async，在其它情况下（通常为浏览器端）才会root.async=async，将async赋值给root。&lt;/p&gt;
&lt;p&gt;在浏览器中的用法如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;script type=&quot;text /javascript&quot; src=&quot;other_lib.js&quot;&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script type=&quot;text /javascript&quot; src=&quot;async.js&quot;&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;script type=&quot;text /javascript&quot;&gt;&lt;/p&gt;
&lt;p&gt;// code using async
&lt;br  /&gt;async.noConflict();
&lt;br  /&gt;// Code that uses other library&apos;s &apos;async&apos; can follow here.
&lt;br  /&gt;&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;明天继续async第三部分：集合&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Nodejs的单线程与异步的初步理解</title>
                <link>http://freewind.in/posts/926-understanding-about-the-single-thread-and-asynchronous-of-nodejs</link>
                <pubDate>Thu, 17 May 2012 00:46:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">926</guid>
                <description><![CDATA[&lt;p&gt;作为从Java转过来的程序员，我一直对nodejs的“单线程、异步非阻塞模型”不是很理解。本想先放着，等熟悉之后慢慢就知道了，没想到今天在学习async的&lt;code&gt;queue&lt;/code&gt;函数的时候卡住了，趁此机会好好学习一下。&lt;/p&gt;
&lt;h2&gt;一、卡住我的代码&lt;/h2&gt;
&lt;p&gt;卡住我的代码是这样的：&lt;/p&gt;
&lt;div&gt;

    var async = require(&apos;async&apos;);

    var pushTask = function(name) { 
        q.push(name, function(cb) { 
            console.log(&apos;running: &apos; + name); 
        }, function(err){ 
            console.log(&apos;finished: &apos; + name); 
        }); 
    }

    var wait = function(mils) { 
        var now = new Date; 
        while(new Date - now &lt;= mils) ; 
    }

    var q = async.queue(function(name, task, callback) { 
        console.log(&apos;processing task: &apos; + name); 
        task(callback); 
    }, 3);

    pushTask(&apos;t1&apos;); 
    pushTask(&apos;t2&apos;); 
    pushTask(&apos;t3&apos;); 
    pushTask(&apos;t4&apos;);

    wait(100); 
    console.log(&apos;waited 100ms&apos;);

    pushTask(&apos;t5&apos;); 
    pushTask(&apos;t6&apos;); 
    pushTask(&apos;t7&apos;); 
    pushTask(&apos;t8&apos;);

    wait(10000); 
    console.log(&apos;waited 1000ms&apos;);

    &lt;/div&gt;
&lt;pre&gt;&lt;code&gt;简单解释一下。async的queue是一个任务队列，在本例中设置了3个worker。我通过`pushTask`函数，向队列中放入多个任务。期间等待了两次，分别是100ms和1000ms。等待的目的是想让放入的任务先执行，queue不是异步的吗？

然而执行结果却让我意外：

waited 100ms 
waited 1000ms 
processing task: t1 
running: t1 
processing task: t2 
running: t2 
processing task: t3 
running: t3 
processing task: t4 
running: t4 
processing task: t5 
running: t5 
processing task: t6 
running: t6 
processing task: t7 
running: t7
processing task: t8
running: t8

可以看到，提交的任务都没有立即执行，而是让我白等了1100ms。这是怎么回事？我期望的输出是这样的：

processing task: t1 
running: t1 
processing task: t2 
running: t2 
processing task: t3 
running: t3 
processing task: t4 
running: t4
waited 100ms 
processing task: t5 
running: t5 
processing task: t6 
running: t6 
processing task: t7 
running: t7
processing task: t8
running: t8
waited 1000ms

为了解决这个问题，我与群中的几位朋友一起讨论，最终基本弄明白了这个问题，非常感谢他们的帮助。

## 二、Nodejs是单线程吗？

首先是这篇非常重要的文章：[http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb](http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb)

我们写下的js代码，是在单线程的环境中执行，但nodejs本身不是单线程的。如果我们在代码中调用了nodejs提供的异步api（如IO等），它们可能是通过底层的c(c++?)模块在另外的线程中完成。但对于我们自己的js代码来说，它们处于单线程中。因为异步函数执行完将结果通过回调函数传给我们的时候，我们的代码一次只能处理一个。

在这里用debuggable.com上的那个文章中的一段比喻来讲，非常容易理解。如下：

我们写的js代码就像是一个国王，而nodejs给国王提供了很多仆人。早上，一个仆人叫醒了国王，问他有什么需要。国王给他一份清单，上面列举了所有需要完成的任务，然后睡回笼觉去了。当国王回去睡觉之后，仆人才离开国王，拿着清单，给其它的仆人一个个布置任务。仆人们各自忙各自的去了，直到完成了自己的任务后，才回来把结果禀告给国王。国王一次只召见一个人，其它的人就在外面排着队等着。国王处理完这个结果后，可能给他布置一个新的任务，或者就直接让他走了，然后再召见下一个人。等所有的结果都处理完了，国王就继续睡觉去了。直接有新的仆人完成任务后过来找他。这就是国王的幸福生活。

这段话对于理解nodejs的运行方式非常重要。

在nodejs中，有一个队列（先进先出），保存着一个个待执行的任务。第一个任务就是我们写的js代码，它最先被执行（相当于国王给第一个仆人任务清单）。在它执行完以后（国王睡回笼觉去了），其它的任务才会加到队列上（相当于第一个仆人按照清单给其它仆人分配任务）。

在我最上面的代码中，我在提交任务时，两次wait，实际上相当于国王在给第一个仆人清单时，突然发呆，仆人只能老老实实地等着，而不会去布置任务。直到国王发了两次呆之后，才去睡觉（我们的代码运行到结尾），这时仆人才敢离开给其他人布置任务。

这就是为什么会先出现两个`waited 1xxms`，之后才出现任务被执行的信息的原因。

&amp;lt;div&amp;gt;

## 三、process.nextTick

&amp;lt;/div&amp;gt;

这篇文章也非常重要：[http://howtonode.org/understanding-process-next-tick](http://howtonode.org/understanding-process-next-tick &quot;http://howtonode.org/understanding-process-next-tick&quot;)

nodejs的单线程让群中有些朋友很不满，他们认为如果我们需要进行一些密集计算（比如`while(true)`这样的），岂不是把整个线程等卡死了？我在一些资料上看到，的确是有这个担心，所以nodejs不适合用来开发cpu密集运算的程序，而适合做那些IO操作比较多，但本身不需要计算太多的程序。因为IO操作通过都是通过异步由nodejs在其它线程中完成，所以不会影响到主线程。

但如果我们的程序中，难以避免地需要进行一些密集运算该怎么办？这时需要把计算分解为可递归的步骤，计算一步后，使用`process.nextTick`将下一步放在队列的最后，让nodejs有机会去处理那些已经在等待的任务。

这里举一个例子，来自前面提到的howtonode上的文章：

var http = require(&apos;http&apos;);

var wait = function(mils) { 
    var now = new Date; 
    while(new Date - now &amp;lt;= mils); 
};

function compute() { 
    // performs complicated calculations continuously 
    console.log(&apos;start computing&apos;); 
    wait(1000); 
    console.log(&apos;working for 1s, nexttick&apos;); 
    process.nextTick(compute); 
}

http.createServer(function(req, res) { 
    console.log(&apos;new request&apos;); 
     res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;}); 
     res.end(&apos;Hello World&apos;); 
}).listen(5000, &apos;127.0.0.1&apos;);

compute();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中compute是一个密集计算的函数，我们把它变为可递归的，每一步需要1秒（使用wait来代替密集运行）。执行完一次后，通过&lt;code&gt;process.nextTick&lt;/code&gt;把下一次的执行放在队列的尾部，转而去处理已经处于等待中的客户端请求。这样就可以同时兼顾两种任务，让它们都有机会执行。&lt;/p&gt;
&lt;p&gt;不过这种方式对于一个高访问量的网站来说还是不够，因为每步需要1s，这个时间还是太长了。这种情况需要采用其它的方式处理（以我目前刚入门的能力来看还不知道如何解决）。&lt;/p&gt;
&lt;p&gt;在群中讨论nextTick时，我们对它的处理产生了分歧。主要原因是由于文中的一句话：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In this model, instead of calling compute() recursively, we use process.nextTick() to delay the execution of compute() till the next tick of the event loop&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有的同学认为它是说“把某任务放在当前任务的下一个”，有的认为是放在队列的最尾，争轮不休。最后老雷同志贴上了nodejs的源代码，解决了这个问题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/926-1.png&quot;&gt;&lt;img src=&quot;/user_images/926-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从这几行代码中，我们可以看出很多信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nextTick的确是把某任务放在队列的最后（&lt;code&gt;array.push&lt;/code&gt;)2.  nodejs在执行任务时，会一次性把队列中所有任务都拿出来，依次执行3.  如果全部顺利完成，则删除刚才取出的所有任务，等待下一次执行4.  如果中途出错，则删除已经完成的任务和出错的任务，等待下次执行5.  如果第一个就出错，则throw error&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看来有时候找半天资料不如看一眼源代码。&lt;/p&gt;
&lt;h2&gt;四、注意事项&lt;/h2&gt;
&lt;p&gt;如前段所讲，我们在js代码中，一定要尽量避免如&lt;code&gt;while(true)&lt;/code&gt;这样的循环，或者密集计算。如果一定要这么做，则应该想办法把它分解为可重要执行的小块，通过&lt;code&gt;process.nextTick&lt;/code&gt;将它分散开，让所有的任务都有执行的机会。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;squallssck&lt;/h3&gt;
&lt;p&gt;整个文章讲的的很好,可你的解释还是有点不清楚的地方:&lt;/p&gt;
&lt;p&gt;之所以先wait了两次,原因是async其实把那些进queue的任务都process.nextTick()了,就是说放到了下一次event queue的循环里,也就是说现在的任务队列里没有这些任务,也不执行这些任务.等到下次loop才会开始做进queue得任务.&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Async详解之一：流程控制</title>
                <link>http://freewind.in/posts/917-async-1-control-the-flow</link>
                <pubDate>Tue, 15 May 2012 23:38:22 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">917</guid>
                <description><![CDATA[&lt;p&gt;为了适应异步编程，减少回调的嵌套，我尝试了很多库。最终觉得还是async最靠谱。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/caolan/async&quot; title=&quot;https://github.com/caolan/async&quot;&gt;https://github.com/caolan/async&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async的内容分为三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流程控制：简化十种常见流程的处理2.  集合处理：如何使用异步操作处理集合中的数据3.  工具类：几个常用的工具类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文介绍其中最简单最常用的流程控制部分。&lt;/p&gt;
&lt;p&gt;由于nodejs是异步编程模型，有一些在同步编程中很容易做到的事情，现在却变得很麻烦。Async的流程控制就是为了简化这些操作。&lt;/p&gt;
&lt;h2&gt;1. series(tasks, [callback]) （多个函数依次执行，之间没有数据交换）&lt;/h2&gt;
&lt;p&gt;有多个异步函数需要依次调用，一个完成之后才能执行下一个。各函数之间没有数据的交换，仅仅需要保证其执行顺序。这时可使用series。&lt;/p&gt;
&lt;p&gt;纯js代码：&lt;/p&gt;
&lt;div class=&quot;mycode&quot;&gt;

    step1(function(err, v1) {
      step2(function(err, v2) {
        step3(function(err, v3) {
           // do somethig with the err or values v1/v2/v3
        }
      }
    });

    &lt;/div&gt;
&lt;pre&gt;&lt;code&gt;从中可以看到这嵌套还是比较多深的，如果再多几步，会更深。在代码中忽略对了每一层err的处理，否则还都等加上 if(err) return callback(err)，那就更麻烦了。

对于这种情况，使用async来处理，就是这样的：

var async = require(&apos;async&apos;)
async.series([
   step1, step2, step3
], function(err, values) {
   // do somethig with the err or values v1/v2/v3
});

可以看到代码简洁了很多，而且自动处理每个回调中的错误。当然，这里只给出来最最简单的例子，在实际中，我们常会在每个step中执行一些操作，这时可写成：

var async = require(&apos;async&apos;)
async.series([
  function(cb) { step1(function(err,v1) {
     // do something with v1
     cb(err, v1);
  }),
  function(cb) { step2(...) },
  function(cb) { step3(...) }
], function(err, values) {
// do somethig with the err or values v1/v2/v3
});
&amp;lt;p&amp;gt;

该函数的详细解释为：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;依次执行一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。2.  如果任何一个函数向它的回调函数中传了一个error，则后面的函数都不会被执行，并且将会立刻会将该error以及已经执行了的函数的结果，传给series中最后那个callback。3.  当所有的函数执行完后（没有出错），则会把每个函数传给其回调函数的结果合并为一个数组，传给series最后的那个callback。4.  还可以json的形式来提供tasks。每一个属性都会被当作函数来执行，并且结果也会以json形式传给series最后的那个callback。这种方式可读性更高一些。&lt;/p&gt;
&lt;p&gt;具体例子可参考：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/series.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/series.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其代码中还包含了：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果中间某个函数出错，series函数如何处理2.  如果某个函数传给回调的值为undefined, null, {}, []等，series如何处理&lt;/p&gt;
&lt;p&gt;另外还需要注意的是：多个series调用之间是不分先后的，因为series本身也是异步调用。&lt;/p&gt;
&lt;h2&gt;2. parallel(tasks, [callback]) （多个函数并行执行）&lt;/h2&gt;
&lt;p&gt;并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。&lt;/p&gt;
&lt;p&gt;如果某个函数出错，则立刻将err和已经执行完的函数的结果值传给parallel最终的callback。其它未执行完的函数的值不会传到最终数据，但要占个位置。&lt;/p&gt;
&lt;p&gt;同时支持json形式的tasks，其最终callback的结果也为json形式。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;p&gt;async.parallel([&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function(cb) { t.fire(&apos;a400&apos;, cb, 400) }, 
function(cb) { t.fire(&apos;a200&apos;, cb, 200) }, 
function(cb) { t.fire(&apos;a300&apos;, cb, 300) } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;], function (err, results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 err: &apos;, err); // -&amp;gt; undefined 
log(&apos;1.1 results: &apos;, results); // -&amp;gt;[ &apos;a400&apos;, &apos;a200&apos;, &apos;a300&apos; ] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;中途出错的示例：&lt;/p&gt;
&lt;p&gt;async.parallel([&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function(cb) { log(&apos;1.2.1: &apos;, &apos;start&apos;); t.fire(&apos;a400&apos;, cb, 400) }, // 该函数的值不会传给最终callback，但要占个位置 
function(cb) { log(&apos;1.2.2: &apos;, &apos;start&apos;); t.err(&apos;e200&apos;, cb, 200) }, 
function(cb) { log(&apos;1.2.3: &apos;, &apos;start&apos;); t.fire(&apos;a100&apos;, cb, 100) } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;], function(err, results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.2 err: &apos;, err); // -&amp;gt; e200 
log(&apos;1.2 results: &apos;, results); // -&amp;gt; [ , undefined, &apos;a100&apos; ] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;以json形式传入tasks&lt;/p&gt;
&lt;p&gt;async.parallel({&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a: function(cb) { t.fire(&apos;a400&apos;, cb, 400) }, 
b: function(cb) { t.fire(&apos;c300&apos;, cb, 300) } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err, results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.3 err: &apos;, err); // -&amp;gt; undefined 
log(&apos;1.3 results: &apos;, results); // -&amp;gt; { b: &apos;c300&apos;, a: &apos;a400&apos; } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;更详细示例参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/parallel.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/parallel.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3. waterfall(tasks, [callback]) （多个函数依次执行，且前一个的输出为后一个的输入）&lt;/h2&gt;
&lt;p&gt;与seires相似，按顺序依次执行多个函数。不同之处，每一个函数产生的值，都将传给下一个函数。如果中途出错，后面的函数将不会被执行。错误信息以及之前产生的结果，将传给waterfall最终的callback。&lt;/p&gt;
&lt;p&gt;这个函数名为waterfall(瀑布)，可以想像瀑布从上到下，中途冲过一层层突起的石头。注意，该函数不支持json格式的tasks。&lt;/p&gt;
&lt;p&gt;async.waterfall([&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function(cb) { log(&apos;1.1.1: &apos;, &apos;start&apos;); cb(null, 3); }, 
function(n, cb) { log(&apos;1.1.2: &apos;,n); t.inc(n, cb); }, 
function(n, cb) { log(&apos;1.1.3: &apos;,n); t.fire(n*n, cb); } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;], function (err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1 err: &apos;, err); // -&amp;gt; null 
log(&apos;1.1 result: &apos;, result); // -&amp;gt; 16 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;更详细示例参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/waterfall.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/waterfall.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4. auto(tasks, [callback]) （多个函数有依赖关系，有的并行执行，有的依次执行）&lt;/h2&gt;
&lt;p&gt;用来处理有依赖关系的多个任务的执行。比如某些任务之间彼此独立，可以并行执行；但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。&lt;/p&gt;
&lt;p&gt;虽然我们可以使用async.parallel和async.series结合起来实现该功能，但如果任务之间关系复杂，则代码会相当复杂，以后如果想添加一个新任务，也会很麻烦。这时使用async.auto，则会事半功倍。&lt;/p&gt;
&lt;p&gt;如果有任务中途出错，则会把该错误传给最终callback，所有任务（包括已经执行完的）产生的数据将被忽略。&lt;/p&gt;
&lt;p&gt;这里假设我要写一个程序，它要完成以下几件事：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从某处取得数据2.  在硬盘上建立一个新的目录3.  将数据写入到目录下某文件4.  发送邮件，将文件以附件形式发送给其它人。&lt;/p&gt;
&lt;p&gt;分析该任务，可以知道1与2可以并行执行，3需要等1和2完成，4要等3完成。&lt;/p&gt;
&lt;p&gt;async.auto({&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getData: function (callback) { 
    setTimeout(function(){ 
        console.log(&apos;1.1: got data&apos;); 
        callback(); 
    }, 300); 
}, 
makeFolder: function (callback) { 
    setTimeout(function(){ 
        console.log(&apos;1.1: made folder&apos;); 
        callback(); 
    }, 200); 
}, 
writeFile: [&apos;getData&apos;, &apos;makeFolder&apos;, function(callback) { 
    setTimeout(function(){ 
        console.log(&apos;1.1: wrote file&apos;); 
        callback(null, &apos;myfile&apos;); 
    }, 300); 
}], 
emailFiles: [&apos;writeFile&apos;, function(callback, results) { 
    log(&apos;1.1: emailed file: &apos;, results.writeFile); // -&amp;gt; myfile 
    callback(null, results.writeFile); 
}] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, function(err, results) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;1.1: err: &apos;, err); // -&amp;gt; null 
log(&apos;1.1: results: &apos;, results); // -&amp;gt; { makeFolder: undefined, 
                                //      getData: undefined, 
                                //      writeFile: &apos;myfile&apos;, 
                                //      emailFiles: &apos;myfile&apos; } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;更多详细示例参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/auto.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/auto.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;5. whilst(test, fn, callback)（用可于异步调用的while）&lt;/h2&gt;
&lt;p&gt;相当于while，但其中的异步调用将在完成后才会进行下一次循环。举例如下：&lt;/p&gt;
&lt;p&gt;var count1 = 0;
&lt;br  /&gt;async.whilst(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function() { return count1 &amp;lt; 3 }, 
function(cb) { 
    log(&apos;1.1 count: &apos;, count1); 
    count1++; 
    setTimeout(cb, 1000); 
}, 
function(err) { 
    // 3s have passed 
    log(&apos;1.1 err: &apos;, err); // -&amp;gt; undefined 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;);&lt;/p&gt;
&lt;p&gt;它相当于：&lt;/p&gt;
&lt;p&gt;try {
&lt;br  /&gt;whilst(test) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fn(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;callback();
&lt;br  /&gt;} catch (err) {
&lt;br  /&gt;callback(err);
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;该函数的功能比较简单，条件变量通常定义在外面，可供每个函数访问。在循环中，异步调用时产生的值实际上被丢弃了，因为最后那个callback只能传入错误信息。&lt;/p&gt;
&lt;p&gt;另外，第二个函数fn需要能接受一个函数cb，这个cb最终必须被执行，用于表示出错或正常结束。&lt;/p&gt;
&lt;p&gt;更详细示例参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/whilst_until.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/whilst_until.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;6. until(test, fn, callback) （与while相似，但判断条件相反）&lt;/h2&gt;
&lt;p&gt;var count4 = 0;
&lt;br  /&gt;async.until(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function() { return count4&amp;gt;3 }, 
function(cb) { 
    log(&apos;1.4 count: &apos;, count4); 
    count4++; 
    setTimeout(cb, 200); 
}, 
function(err) { 
    // 4s have passed 
    log(&apos;1.4 err: &apos;,err); // -&amp;gt; undefined 
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;);&lt;/p&gt;
&lt;p&gt;当第一个函数条件为false时，继续执行第二个函数，否则跳出。&lt;/p&gt;
&lt;h2&gt;7. queue （可设定worker数量的队列）&lt;/h2&gt;
&lt;p&gt;queue相当于一个加强版的parallel，主要是限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。&lt;/p&gt;
&lt;p&gt;该函数有多个点可供回调，如worker用完时、无等候任务时、全部执行完时等。&lt;/p&gt;
&lt;p&gt;定义一个queue，其worker数量为2，并在任务执行时，记录一下日志：&lt;/p&gt;
&lt;p&gt;var q = async.queue(function(task, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;worker is processing task: &apos;, task.name); 
task.run(callback); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, 2);&lt;/p&gt;
&lt;p&gt;worker数量将用完时，会调用saturated函数：&lt;/p&gt;
&lt;p&gt;q.saturated = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;all workers to be used&apos;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;当最后一个任务交给worker执行时，会调用empty函数&lt;/p&gt;
&lt;p&gt;q.empty = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;no more tasks wating&apos;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;当所有任务都执行完时，会调用drain函数&lt;/p&gt;
&lt;p&gt;q.drain = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;all tasks have been processed&apos;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;放入多个任务，可一次放一个，或一次放多个&lt;/p&gt;
&lt;p&gt;q.push({name:&apos;t1&apos;, run: function(cb){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;t1 is running, waiting tasks: &apos;, q.length()); 
t.fire(&apos;t1&apos;, cb, 400); // 400ms后执行 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}}, function(err) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;t1 executed&apos;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;q.push([{name:&apos;t3&apos;, run: function(cb){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;t3 is running, waiting tasks: &apos;, q.length()); 
t.fire(&apos;t3&apos;, cb, 300); // 300ms后执行 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}},{name:&apos;t4&apos;, run: function(cb){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;t4 is running, waiting tasks: &apos;, q.length()); 
t.fire(&apos;t4&apos;, cb, 500); // 500ms后执行 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}}], function(err) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log(&apos;t3/4 executed&apos;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;更多详细示例参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/queue.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/queue.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;8. iterator(tasks) （将几个函数包装为iterator）&lt;/h2&gt;
&lt;p&gt;将一组函数包装成为一个iterator，可通过next()得到以下一个函数为起点的新的iterator。该函数通常由async在内部使用，但如果需要时，也可在我们的代码中使用它。&lt;/p&gt;
&lt;p&gt;var iter = async.iterator([&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function() { console.log(&apos;111&apos;) }, 
function() { console.log(&apos;222&apos;) }, 
function() { console.log(&apos;333&apos;) } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;]);
&lt;br  /&gt;console.log(iter());
&lt;br  /&gt;console.log(iter.next());&lt;/p&gt;
&lt;p&gt;直接调用()，会执行当前函数，并返回一个由下个函数为起点的新的iterator。调用next()，不会执行当前函数，直接返回由下个函数为起点的新iterator。&lt;/p&gt;
&lt;p&gt;对于同一个iterator，多次调用next()，不会影响自己。如果只剩下一个元素，调用next()会返回null。&lt;/p&gt;
&lt;p&gt;更详细示例参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/iterator.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/iterator.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;9. apply(function, arguments..) （给函数预绑定参数）&lt;/h2&gt;
&lt;p&gt;apply是一个非常好用的函数，可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。&lt;/p&gt;
&lt;p&gt;对于函数：&lt;/p&gt;
&lt;p&gt;function(callback) { t.inc(3, callback); }&lt;/p&gt;
&lt;p&gt;可以用apply改写为：&lt;/p&gt;
&lt;p&gt;async.apply(t.inc, 3);&lt;/p&gt;
&lt;p&gt;还可以给某些函数预设值，得到一个新函数：&lt;/p&gt;
&lt;p&gt;var log = async.apply(console.log, &amp;ldquo;&gt;&amp;ldquo;);
&lt;br  /&gt;log(&apos;hello&apos;);
&lt;br  /&gt;// &gt; hello&lt;/p&gt;
&lt;p&gt;更详细代码参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/apply.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/apply.js&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;10. nextTick(callback) （在nodejs与浏览器两边行为一致）&lt;/h2&gt;
&lt;p&gt;nextTick的作用与nodejs的nextTick一样，都是把某个函数调用放在队列的尾部。但在浏览器端，只能使用setTimeout(callback,0)，但这个方法有时候会让其它高优先级的任务插到前面去。&lt;/p&gt;
&lt;p&gt;所以提供了这个nextTick，让同样的代码在服务器端和浏览器端表现一致。&lt;/p&gt;
&lt;p&gt;var calls = [];
&lt;br  /&gt;async.nextTick(function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;calls.push(&apos;two&apos;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;calls.push(&apos;one&apos;);
&lt;br  /&gt;async.nextTick(function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(calls); // -&amp;gt; [ &apos;one&apos;, &apos;two&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更详细代码参见：&lt;a href=&quot;https://github.com/freewind/async_demo/blob/master/nextTick.js&quot;&gt;https://github.com/freewind/async_demo/blob/master/nextTick.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下一篇将放松一下，讲解一下async提供的一些工具类，最后才是对集合的并行处理。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Nodejs中如何给函数的部分参数预设值（部分应用函数）</title>
                <link>http://freewind.in/posts/913-partial-applied-function-in-nodejs</link>
                <pubDate>Tue, 15 May 2012 19:08:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">913</guid>
                <description><![CDATA[&lt;p&gt;在nodejs中，可以利用bind，实现对函数的部分参数预设值，得到一个新函数供以后使用。&lt;/p&gt;
&lt;p&gt;这个bind实际上是ecmascript5中新增的功能，这里举例说明。&lt;/p&gt;
&lt;p&gt;首先定义一个普通的函数：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;function add(a,b) { return a+b; }&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常的调用方式：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;add(1,3); // -&gt; 4&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;add(1,5); // -6&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用bind可以给add预设一些值，如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;var x = add.bind(null, 3);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;x(2);  // -&gt; 5&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;x(100) // -&gt; 103&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某些情况下会比较有用。&lt;/p&gt;
&lt;p&gt;其中bind的函数签名与call相很似，第一个参数(null)是准备调用该函数的对象，与参数无关，对于我们这个例子来说，就是null。后面的3，对应的是参数a。&lt;/p&gt;
&lt;p&gt;举个不为null的例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var obj = {
&lt;br  /&gt;method: function(name){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(name);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;};
&lt;br  /&gt;var x1 = obj.method.bind(obj);
&lt;br  /&gt;x1(&amp;ldquo;John&amp;rdquo;); // -&gt; John&lt;/p&gt;
&lt;p&gt;var x2 = obj.method.bind(obj, &amp;ldquo;Jack&amp;rdquo;);
&lt;br  /&gt;x2(); // -&gt; Jack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再来一个异步的例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var inc = function(n, cb) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {       
    cb(null, n+1);       
}, 1000);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;var x = inc.bind(null, 4);&lt;/p&gt;
&lt;p&gt;x(function(err,result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我为什么对这个特性很感兴趣呢？因为它可以简化我们的代码。&lt;/p&gt;
&lt;p&gt;先看这个例子（使用了async）：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var async = require(&apos;async&apos;);&lt;/p&gt;
&lt;p&gt;var inc = function add(n, cb) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {       
    cb(null, n+1);       
}, 200);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;async.series([&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function(cb) { inc(3,cb); },       
function(cb) { inc(8,cb); }       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;], function (err,result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中async.series的第一个参数，都要用一些function包在外面，感觉有点繁琐。如果利用bind，可写成：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;async.series([&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;inc.bind(null,3),       
inc.bind(null,8)       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;], function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简化了不少吧：）&lt;/p&gt;
&lt;p&gt;稍有遗憾的是，由于javascript的语言特性，如果函数中有多个参数，bind只能按顺序预设，不能跳过前面预设后面。比如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;add(a,b)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只能绑定a，或者(a,b)，但不能只绑定b。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;AlsoTang&lt;/h3&gt;
&lt;p&gt;https://gist.github.com/3745456&lt;/p&gt;
&lt;p&gt;这是一个更加准确的关于js中bind的示例。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Nodejs: 异步？！我要同步！！！</title>
                <link>http://freewind.in/posts/912-i-want-synchronous-in-nodejs</link>
                <pubDate>Mon, 14 May 2012 01:10:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">912</guid>
                <description><![CDATA[&lt;p&gt;Nodejs是一个事件驱动、异步非阻塞的Javascript平台。异步编程模型是它的主要特色，所以nodejs众多的第三方模块都提供了异步api。&lt;/p&gt;
&lt;p&gt;这种方式有很多优点，但在某些情况下，会造成以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码多层嵌套，难写难读2.  控制异步调用的先后顺序，很麻烦&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体如何这里就不多说了，相信每个使用过的人都深有感触，不然怎么会有那么多的模块存在的目的就是为了改善这一点呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://altjs.org/&quot;&gt;http://altjs.org/&lt;/a&gt; 见Synchronous to Asynchronous (CPS)一节2.  &lt;a href=&quot;https://github.com/joyent/node/wiki/modules#wiki-async-flow&quot;&gt;https://github.com/joyent/node/wiki/modules#wiki-async-flow&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些通过三种方式来实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过nodejs的本身设施实现，如async，q，node-seq，step等2.  通过语言扩展，定义一些特有的关键字如await等，如tamejs，jscex。可惜多了一步编译3.  通过node-fibers项目提供的纤程，如fibrous，common-node，streamline等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过近两天的查看与试用，我对其中几个比较感兴趣。我的标准是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;示例代码易读、易理解2.  在不同的环境中都能稳定运行（如mocha中）3.  能方便与已有模块的异步api一起使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面一一介绍。&lt;/p&gt;
&lt;h2&gt;Tamejs&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/maxtaco/tamejs&quot; title=&quot;https://github.com/maxtaco/tamejs&quot;&gt;https://github.com/maxtaco/tamejs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tamejs不是纯js，因为它增加了两个特有的东西：await/defer。通常把文件保存为.tjs，在运行前需要先编译为.js（也可以通过require某些库在运行期进行）。这里给一个代码示例：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;for (var i = 0; i &amp;lt; 10; i++) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;await { setTimeout (defer (), 100); }       
console.log (&quot;hello&quot;);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码看起来相当简洁，为了这个，我宁愿多一个编译步骤！&lt;/p&gt;
&lt;p&gt;看看它转换的js代码是什么样的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var tame = require(&apos;tamejs&apos;).runtime;
&lt;br  /&gt;var &lt;strong&gt;tame_defer_cb = null;
&lt;br  /&gt;var &lt;/strong&gt;tame_fn_0 = function (__tame_k) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tame.setActiveCb (__tame_defer_cb);       
var __tame_k_implicit = {};       
var i = 0;       
var __tame_fn_1 = function (__tame_k) {       
    tame.setActiveCb (__tame_defer_cb);       
    var __tame_fn_2 = function (__tame_k) {       
        tame.setActiveCb (__tame_defer_cb);       
        i ++       
        tame.callChain([__tame_fn_1, __tame_k]);       
        tame.setActiveCb (null);       
    };       
    __tame_k_implicit.k_break = __tame_k;       
    __tame_k_implicit.k_continue = function() { __tame_fn_2(__tame_k); };       
    if (i &amp;lt; 10) {       
        var __tame_fn_3 = function (__tame_k) {       
            tame.setActiveCb (__tame_defer_cb);       
            var __tame_fn_4 = function (__tame_k) {       
                tame.setActiveCb (__tame_defer_cb);       
                var __tame_defers = new tame.Deferrals (__tame_k);       
                var __tame_fn_5 = function (__tame_k) {       
                    tame.setActiveCb (__tame_defer_cb);       
                    setTimeout (       
                    __tame_defers.defer ( {       
                        parent_cb : __tame_defer_cb,       
                        line : 2,       
                        file : &quot;d.tjs&quot;       
                    } )       
                    , 100 ) ;       
                    tame.callChain([__tame_k]);       
                    tame.setActiveCb (null);       
                };       
                __tame_fn_5(tame.end);       
                __tame_defers._fulfill();       
                tame.setActiveCb (null);       
            };       
            var __tame_fn_6 = function (__tame_k) {       
                tame.setActiveCb (__tame_defer_cb);       
                console . log ( &quot;hello&quot; ) ;       
                tame.callChain([__tame_k]);       
                tame.setActiveCb (null);       
            };       
            tame.callChain([__tame_fn_4, __tame_fn_6, __tame_k]);       
            tame.setActiveCb (null);       
        };       
        tame.callChain([__tame_fn_3, __tame_fn_2, __tame_k]);       
    } else {       
        tame.callChain([__tame_k]);       
    }       
    tame.setActiveCb (null);       
};       
tame.callChain([__tame_fn_1, __tame_k]);       
tame.setActiveCb (null);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};
&lt;br  /&gt;__tame_fn_0 (tame.end);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来还是有点吓人的，不容易啊不容易。&lt;/p&gt;
&lt;p&gt;非常可惜的是，在mocha中无法正常使用。看下面这段代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;require(&apos;should&apos;);&lt;/p&gt;
&lt;p&gt;function inc(n, callback) {
&lt;br  /&gt;setTimeout(function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&apos;### inc: &apos; + n);       
callback(n+1);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}, 1000);
&lt;br  /&gt;};&lt;/p&gt;
&lt;p&gt;describe(&apos;test&apos;, function(){
&lt;br  /&gt;it(&apos;show ok with tamejs&apos;, function(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; console.log(&apos;### testing ...&apos;);       
 var result;       
 await { inc(1, defer(result)); }       
 console.log(&apos;result: &apos; + result);       
 result.should.equal(3);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});
&lt;br  /&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知为什么，提示测试通过，实际上inc函数完全没有运行。&lt;/p&gt;
&lt;p&gt;提了个bug: &lt;a href=&quot;https://github.com/maxtaco/tamejs/issues/30&quot;&gt;https://github.com/maxtaco/tamejs/issues/30&lt;/a&gt;，希望能早日解决。&lt;/p&gt;
&lt;h2&gt;Common Node&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/olegp/common-node&quot;&gt;https://github.com/olegp/common-node&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Common node基于node-fibers，提供了同步风格的代码，但在内部利用了纤程，不会阻塞主线程。既可以使用同步风格的代码，又不会影响性能，看起来很不错。&lt;/p&gt;
&lt;p&gt;这里有一个性能对比图，可见common-node的同步风格，对于性能的影响还是很小的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/912-1.png&quot;&gt;&lt;img src=&quot;/user_images/912-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;common-node的定位应该与node是相同的，但在编程风格上正好相反，它提倡使用“同步”。也因此，对于已有的异步api的模块，它不能很好地直接使用，需要专门为它提供一个修改版。从README中可以看到，目前已经有一些项目支持common-node。可惜相比nodejs庞大的模块库来说，还是可怜了，所以common-node的发展前景还是有些不明朗。&lt;/p&gt;
&lt;p&gt;当支持它的模块更多一些之后，也许会有更多人来尝试它的。&lt;/p&gt;
&lt;h2&gt;&lt;strike&gt;Fibrous&lt;/strike&gt;&lt;/h2&gt;
&lt;p&gt;(修改：在实际使用中，发现该库与很多其它的库有冲突，出现各种各样的错误，故不再推荐。现在使用async替代，见下段）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/goodeggs/fibrous&quot;&gt;https://github.com/goodeggs/fibrous&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fibrous将给每个对象增加一个sync和feature属性，给原有的各异步方法提供一个同步版。因为它也基于node-fibers，所以这个同步函数实际上将在一个纤程中执行，不会阻塞主线程。&lt;/p&gt;
&lt;p&gt;它的代码写起来比较简洁，看示例：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var fibrous = require(&apos;fibrous&apos;);
&lt;br  /&gt;var crypto = require(&apos;crypto&apos;);&lt;/p&gt;
&lt;p&gt;var random = fibrous(function(length) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var buf = crypto.sync.randomBytes(length);       
return buf.toString(&apos;hex&apos;);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;random(4,function(err, result) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(result);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们的代码被fibrous()包着，则可在内部调用其它对象的.sync中的某方法（该方法是原异步方法的同步版本），不需要传入回调函数，直接以返回值形式拿到。&lt;/p&gt;
&lt;p&gt;如果我们的代码没有被fibrous包着，则还得老老实实传回调。但这不是大问题，因为大多数情况下，我们都可以用fibrous包起来。&lt;/p&gt;
&lt;p&gt;再看看它与mocha结合使用：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;pre&gt;require(&apos;should&apos;);
&lt;br  /&gt;var fibrous = require(&apos;fibrous&apos;);&lt;/p&gt;
&lt;p&gt;function inc(n, callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setTimeout(function() {
    console.log(&apos;### inc: &apos; + n);
    callback(null, n+1);
}, 1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;describe(&apos;test&apos;, function(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;it(&apos;show ok with tamejs&apos;, fibrous(function(){
    var x = inc.sync.call(null, 5);
    console.log(&apos;x:&apos;+x);
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});```&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意it(&apos;..&apos;, fibrous(..))，可以直接把测试部分给包起来，内部就可以使用inc的sync版了。执行这个测试，将正确打印出：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;x:6&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用fibrous，虽然对js中的对象有些侵入（增加了sync和futrue属性），但是很多时候，可以让我们的代码更加简洁，这个代价是我完全可以承受的。我将在以后更多的情况下使用它，看看会不会有其它问题。&lt;/p&gt;
&lt;p&gt;暂时不用再纠结于异步同步的问题了，因为所有能试的方法我基本上都试了一遍，如果连fibrous也不行，那我也就只能放弃，强迫自己去写回调了。&lt;/p&gt;
&lt;h2&gt;&lt;/h2&gt;
&lt;h2&gt;Async&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/caolan/async&quot;&gt;https://github.com/caolan/async&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面说中了，fibrous在使用中，与很多库有冲突，无奈移除，只好再硬着头皮写嵌套。期间纠结得想换语言，直到用了async。&lt;/p&gt;
&lt;p&gt;async设计得巧妙又周到，考虑到了很多场景，能够很大程度上消除嵌套。比如说三种常见的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个异步函数并行执行，并且在全部执行完以后进行某个操作：parallel2.  多个异步函数依次执行，函数之间没有数据传递：series3.  多个异步函数嵌套执行，每个外层都要把数据传给内层：waterfall&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外还有7种：）&lt;/p&gt;
&lt;p&gt;还有一种常见场景，需要对一个数组中的每一个元素进行异步操作，这时又提供了十种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;forEach2.  map3.  filter4.  reject5.  reduce6.  detect7.  sortBy8.  some9.  every10.  concat&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详细的使用方法，我正在边学习边写示例，发到github上：&lt;a href=&quot;https://github.com/freewind/async_demo&quot;&gt;https://github.com/freewind/async_demo&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>JavaScript/NodeJs半月总结</title>
                <link>http://freewind.in/posts/907-javascript-nodejs-after-half-month</link>
                <pubDate>Sun, 13 May 2012 00:48:24 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">907</guid>
                <description><![CDATA[&lt;p&gt;刚看了一下群记录，从4月27日到今天，我转向Js已经有半个月了，特在此做一个小结。&lt;/p&gt;
&lt;p&gt;有这么几点感触特别深：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;就算像JavaScript这样一门有很多瑕疵的语言，只要有大批牛人进驻，照样可以光彩照人。虽然写Javascript代码本身让人感觉不太好，但是那些受好评的库用起来却舒服：API简洁易用、文档示例清晰易懂，值得称赞。&lt;/li&gt;
&lt;li&gt;轻量级，让人很放松。在Js中时刻可以体会到轻量级。语言本身灵活简单、编辑器要求低、程序启动迅速、不需要编译部署，让人感觉可以随时随手写代码，无比轻松。与Java相比，差别实在太大了。&lt;/li&gt;
&lt;li&gt;异步编程模型是一大难点，也是基于nodejs的程序的最常用风格。这让从Java转过来的我，十分不适应。这种由同步向异步的转变，难度不亚于从命令式向函数式风格的转变。之前的很多经验都用不了，以前写起来很清楚明了的代码，现在经常是一层套一层，让人无比郁闷。这是一个大门槛，看能不能跨过去。&lt;/li&gt;
&lt;li&gt;Js上有很多有创意的项目正在一一涌现。而且，Js现在已经慢慢成为一种新的开发平台，很多新语言都以它为目标平台。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总而言之，我走进了一个新的世界，以异步编程风格为主导、轻量级开发方式为特点的新世界。这是我没有料到的。我开始是因为angularjs框架、和json的原生支持这两个原因尝试JS的，但现在看来，要想学好Javascript，还有相当多的东西需要学习。&lt;/p&gt;
&lt;p&gt;这段时间发现了一些比较喜欢的项目：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器端mvc框架：angularjs&lt;/li&gt;
&lt;li&gt;服务器端基础平台：nodejs&lt;/li&gt;
&lt;li&gt;服务器端web框架：express&lt;/li&gt;
&lt;li&gt;基于mongodb的orm：mongoose&lt;/li&gt;
&lt;li&gt;单元测试框架：mocha&lt;/li&gt;
&lt;li&gt;小巧好用的减少callback嵌套的模块：async&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还有今天开始比较感兴趣的基于纤程、在异步模型上实现同步模型的一些项目，因为还没细看，不列出。&lt;/p&gt;
&lt;p&gt;我认为js的开发应该是同步异步结合，因为两者都有比较明显的适用情况。有时候你会觉得异步用起来很方便很自然，有时候又觉得同步很自然，所以不要强迫自己去在任何情况下都去拥抱异步。如果能通过一些项目或其它手段支持同步，将代码写得更简洁易读，岂不是更好？&lt;/p&gt;
&lt;p&gt;这段时间花在学习写单元测试的时间比较多（当然其中大部分时间是因为异步的原因，测试代码不好写，总算找个好点的解决方案），但是觉得很值得。自从在scala中使用了scalatest以后，我就明白了：人们是否喜欢写单元测试，在很大程度上是由“写测试的难度”和“写测试的舒适度”决定的。像我，在写java项目时，也不喜欢写测试，因为感觉很痛苦。但在scala项目中，不写测试自己都觉得缺少了乐趣。像Javascript这样的动态语言，如果没有单元测试作为保证，写出来的代码基本上没人敢用。同时，由于javascript的动态语言特性，只要有一个设计良好的测试框架，写测试也将会是一件容易且开心的事情。这些天终于写出了对mongoose的一些单元测试，总体感觉还不错，除了异步模型这块，代码嵌套得实在让人郁闷。&lt;/p&gt;
&lt;p&gt;如果我当年在学ruby on rails的时候，就能体会到这一点，我想我就不会半途而废了。当时觉得自己写出来的代码特别不踏实，总有种悬在半空的感觉，就是因为没有写测试。最后还是因为受不了这种感受，而转向了scala。&lt;/p&gt;
&lt;p&gt;另一件让我觉得欣喜的事情，就是Emacs。终于从笨重的eclipse中解脱出来，时刻能感受到emacs的轻盈与极好的扩展性。需要什么功能，只需要到网上一搜，把几行代码拷贝到.emacs文件中，一重启就有了。虽然快捷键很多，我还不怎么熟练，但我想它将会是一直陪伴我的好朋友，早在大学就应该学它了。&lt;/p&gt;
&lt;p&gt;我发现自己渐渐喜欢上了动态语言，这种轻松的感觉是以前在写java/scala代码时，从未有过的。我想我会继续学习Javascript，以后有机会再重拾ruby on rails。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用mocha给mongoose写单元测试</title>
                <link>http://freewind.in/posts/905-use-mocha-to-write-unit-tests-for-mongoose</link>
                <pubDate>Sat, 12 May 2012 16:21:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">905</guid>
                <description><![CDATA[&lt;p&gt;使用javascript写程序，我认为第一要务就是单元测试。所以当我把mongoose的简单例子跑通后，第一件事就是学着给它写单元测试。&lt;/p&gt;
&lt;h2&gt;Jasmine&lt;/h2&gt;
&lt;p&gt;首先尝试的是Jasmine：&lt;a href=&quot;http://pivotal.github.com/jasmine/&quot;&gt;http://pivotal.github.com/jasmine/&lt;/a&gt;，冲着它3k+的关注值去的。写简单的例子很容易，但涉及到mongoose时，遇到了两个麻烦的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在beforeEach中调用mongoose的一些异步方法（如connect, drop, insert等）相当不方便2.  没有beforeAll&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第1处不方便，是因为Jasmine提供了runs(), waits(), waitsFor()这三个方法来支持异步调用。其中在runs中调用异步方法，在waits中等待一定时间，或用waitsFor来检查一些条件来判断之前的异步方法是否完成。这种方式不方便之处就在于waitsFor中有时候不那么检查，所以通常要设一个局部变量来保存状态。如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;it(&apos;should dosomthing&apos;, function() {&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    var ok = false;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    doSomething(function(){&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;        ok = true;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    });&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    waitsFor( function() {&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;        return ok; &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    }, &apos;Do something&apos;, 2000};&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    // 继续执行下面的代码&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;});&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到代码中定义的ok感觉有点多余，代码有点繁琐。&lt;/p&gt;
&lt;p&gt;这几天为了找到一种看起来更简单一点的办法，我看了很多与同步异步相关的模块：&lt;a href=&quot;https://github.com/joyent/node/wiki/modules#wiki-async-flow&quot;&gt;https://github.com/joyent/node/wiki/modules#wiki-async-flow&lt;/a&gt;。虽然最终一个也没有用上，不过也算学习了基础知识，额外收获。（另外此处推荐由群友木木勇创建的一个Promise模块，简洁明了，代码不多，值得参考：&lt;a href=&quot;https://github.com/sail-sail/Promise&quot; title=&quot;https://github.com/sail-sail/Promise&quot;&gt;https://github.com/sail-sail/Promise&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;第2处是因为我想在所有测试前连接mongodb，所有测试后关闭连接，中间就不关闭了。但是Jasmine居然没有提供，而且有人还说“不用beforeAll可以让你的测试代码写得更好”。在这里可以看到一些讨论：&lt;a href=&quot;https://github.com/pivotal/jasmine/pull/56&quot;&gt;https://github.com/pivotal/jasmine/pull/56&lt;/a&gt;。从中可以看到有些人对于Jasmine相当不满，纷纷转到另一个测试框架：mocha.&lt;/p&gt;
&lt;h2&gt;Mocha&lt;/h2&gt;
&lt;p&gt;Mocha是由express的作者创建的，品质有保证：&lt;a href=&quot;http://visionmedia.github.com/mocha/&quot;&gt;http://visionmedia.github.com/mocha/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相比Jasmine，它有以下几个优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步方法的测试更容易（赞！）2.  支持before,after（即beforeAll/afterAll)3.  与nodejs结合更自然4.  测试报告更清晰明了（比如两个字符串不相等时，会分别用红色和绿色标出相异部分）5.  可使用多种风格的DSL，比如should/expect等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第1处，对于异步方法的测试，mocha提供了一个非常简单的方法：传入一个callback，只有它被调用，才会执行下一步。这里重写前面的例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;it(&apos;should dosomthing&apos;, function(done) {&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;  doSomething(done&lt;/font&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;// 下面的代码只有当done在doSomething中被异步调用之后才会运行&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;});&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一行代码就完成了？简单太多了吧。&lt;/p&gt;
&lt;p&gt;其它各处可参考官方文档，这里就不多说了。&lt;/p&gt;
&lt;h2&gt;Mongoose&lt;/h2&gt;
&lt;p&gt;mongoose这一块花了我很多时间，主要还是因为对于异步编程模块的不适应，老是搞不定那些异步调用。比如，我在initdb方法中，想做以下几件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接mongodb2.  删除数据库3.  插入多条记录&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些方法都是异步的，通过回调执行下一步。我不想写那么多的嵌套语句，希望能找到一种类似同步方法调用的方式来写代码，可惜到最后还是没有发现特别满意的。期间看到了很多方案，但都觉得对于代码可读性的改善不大，最终放弃，还是用了嵌套的方式。&lt;/p&gt;
&lt;p&gt;Mongoose提供了两种访问mongodb的方式，一种是通过它封装后的Model，一种是得到connnection对象使用底层的native driver。我在测试过程中，测试的对象是各Model相关方法，但验证时用到了native driver。这里不上代码不好说，先跳过。&lt;/p&gt;
&lt;h2&gt;Before/After/BeforeEach&lt;/h2&gt;
&lt;p&gt;我在项目中定义了多个Model，如User/Channel等，我想为每一个都准备单独的测试文件。如何让它们共享before/after/beforeEach方法呢？解决方法比较简单：定义一个单独的文件，把这些方法写在里面，然后在其它文件中require它。&lt;/p&gt;
&lt;p&gt;我写在一个db_globle.js中：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var helper = require(&apos;./helper&apos;);&lt;/p&gt;
&lt;p&gt;before(function(done){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helper.connect(function(){done();});       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;after(function(done) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helper.close(function(){done();});       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;beforeEach(function(done){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helper.initdb(function(){done();});       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在其它文件，如user.js中调用它：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;require(&apos;should&apos;);
&lt;br  /&gt;require(&apos;./db_global&apos;);
&lt;br  /&gt;var mongoose = require(&apos;mongoose&apos;);
&lt;br  /&gt;var helper = require(&apos;./helper&apos;);&lt;/p&gt;
&lt;p&gt;var models = require(&apos;../models&apos;);
&lt;br  /&gt;var User = models.User;&lt;/p&gt;
&lt;p&gt;describe(&apos;Users&apos;, function(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var users = helper.getConnection().collection(&apos;users&apos;);

it(&apos;can be created&apos;, function(done){      
    var user = new User({       
        email:&apos;xxx@xxx.com&apos;,       
        name: &apos;XXX&apos;,       
        salt: &apos;123&amp;amp;#8242;,       
        password: &apos;456&amp;amp;#8242;       
    });       
    user.save();

    users.find({email:&apos;xxx@xxx.com&apos;}, function(err, cursor){      
        cursor.toArray(function(err,docs) {       
            docs.should.have.lengthOf(1);       
            var u = docs[0];       
            u._id.should.not.be.null;       
            u.email.should.equal(&apos;xxx@xxx.com&apos;);       
            u.name.should.equal(&apos;XXX&apos;);       
            u.salt.should.equal(&apos;123&amp;amp;#8242;);       
            u.password.should.equal(&apos;456&amp;amp;#8242;);       
            done();       
        });       
    });       
});       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中的helper是一个自定义的辅助文件，它定义了操作mongodb的一些方法，大体如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var mongoose = require(&apos;mongoose&apos;);&lt;/p&gt;
&lt;p&gt;exports.DB = &apos;mongo://localhost/test&apos;;&lt;/p&gt;
&lt;p&gt;exports.connect = function(callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mongoose.connect(exports.DB, callback);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;exports.close = function(callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mongoose.connection.close(callback);       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;exports.getConnection = function() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return mongoose.connection;       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;exports.initdb = function(callback) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var conn = mongoose.connection;

// drop database      
conn.db.dropDatabase(function(err){       
    if(err) {       
        return callback(err);       
    }

    console.log(&apos;Database droped.&apos;);

    // insert users      
    conn.collection(&apos;users&apos;).insert([{       
        email: &apos;nowind_lee@qq.com&apos;,       
        name: &apos;Freewind&apos;,       
        salt: &apos;111&apos;,       
        password: &apos;123456&apos;       
    }], function(err, docs) {       
        // insert others       
    });       
});       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过几天的努力，终于成功的在mocha中成功地写model测试了：）虽然花了很多时间，但很值得。&lt;/p&gt;
&lt;h2&gt;相关问题&lt;/h2&gt;
&lt;p&gt;在此期间遇到了很多问题，非常感谢万能的stackoverflow和各位群友，特别是为了我的问题忙到半夜的木木勇，还有热心的sapjax。在这里把我提的相关问题汇集如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10561598/global-before-and-beforeeach-for-mocha&quot;&gt;Global &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;beforeEach&lt;/code&gt; for mocha?&lt;/a&gt;2.  &lt;a href=&quot;http://stackoverflow.com/questions/10560716/global-beforeeach-in-jasmine&quot;&gt;Global &lt;code&gt;beforeEach&lt;/code&gt; in jasmine?&lt;/a&gt;3.  &lt;a href=&quot;http://stackoverflow.com/questions/10554079/why-doesnt-the-2rd-function-run-in-this-javascripts-async-example&quot;&gt;Why doesn&apos;t the 2rd function run, in this javascript&apos;s async example?&lt;/a&gt;4.  &lt;a href=&quot;http://stackoverflow.com/questions/10551499/simplest-way-to-wait-some-asynchronous-tasks-complete-in-javascript&quot;&gt;Simplest way to wait some asynchronous tasks complete, in Javascript?&lt;/a&gt;5.  &lt;a href=&quot;http://stackoverflow.com/questions/10545087/how-to-use-module-q-to-refactoring-mongoose-code&quot;&gt;How to use module &lt;code&gt;q&lt;/code&gt; to refactoring mongoose code?&lt;/a&gt;6.  &lt;a href=&quot;http://stackoverflow.com/questions/10527394/how-to-test-a-method-in-jasmine-if-the-code-in-beforeeach-is-asynchronous&quot;&gt;How to test a method in Jasmine if the code in &lt;code&gt;beforeEach&lt;/code&gt; is asynchronous?&lt;/a&gt;7.  &lt;a href=&quot;http://stackoverflow.com/questions/10520715/how-to-let-the-inserting-to-be-synchronized-in-mongoose&quot;&gt;How to let the inserting to be synchronized, in mongoose?&lt;/a&gt;8.  &lt;a href=&quot;http://stackoverflow.com/questions/10520501/how-to-insert-a-doc-into-mongodb-using-mongoose-and-get-the-generated-id&quot;&gt;How to insert a doc into mongodb using mongoose and get the generated id?&lt;/a&gt;9.  &lt;a href=&quot;http://stackoverflow.com/questions/10519432/how-to-do-raw-mongodb-operations-in-mongoose&quot;&gt;How to do raw mongodb operations in mongoose?&lt;/a&gt;10.  &lt;a href=&quot;http://stackoverflow.com/questions/10518671/how-to-organize-the-code-if-i-want-to-initialize-database-before-each-tests&quot;&gt;How to organize the code if I want to initialize database before each tests?&lt;/a&gt;11.  &lt;a href=&quot;https://github.com/LearnBoost/mongoose/issues/907&quot;&gt;Can&apos;t drop a database in mongoose?&lt;/a&gt;12.  &lt;a href=&quot;https://gist.github.com/2660993&quot;&gt;我的问题&lt;/a&gt;，以及&lt;a href=&quot;https://github.com/sail-sail/Promise/blob/master/demo/dbTest.js&quot;&gt;木木勇的非嵌套方式初始化数据库代码&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Javascript中，为什么既有call又有apply</title>
                <link>http://freewind.in/posts/899-why-there-is-call-and-apply-in-javascript</link>
                <pubDate>Thu, 10 May 2012 21:47:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">899</guid>
                <description><![CDATA[&lt;p&gt;Javascript中，每个函数都有这两个方法，&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;，它们之间的区别很小：call中参数是直接写的，而apply中要放在一个数组（或跟数组很像但不同数组的对象）里。&lt;/p&gt;
&lt;p&gt;有关两者区别的更详细资料，请参考：&lt;a href=&quot;http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply&quot;&gt;http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里举个例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;function hello(name, message) {
&lt;br  /&gt;alert(name + &apos;: &apos; + message);
&lt;br  /&gt;};
&lt;br  /&gt;hello.call(null, &apos;Freewind&apos;, &apos;call&apos;);
&lt;br  /&gt;hello.apply(null, [&apos;Freewind&apos;, &apos;apply&apos;]);​​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行的结果是一模一样的。&lt;/p&gt;
&lt;p&gt;问题来了：&lt;strong&gt;既然两者之间的差别这么小，为什么要同时提供这两个函数？一个不够用吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是：&lt;strong&gt;apply是为arguments而生的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;arguments是函数中预定义的一个变量，它表示实际传递给该函数的参数。它不是数组，但是跟数组很像。看这个例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;function f(a,b,c) {
&lt;br  /&gt;alert(arguments.length + &amp;ldquo;: &quot; + join(arguments));
&lt;br  /&gt;}
&lt;br  /&gt;function join(args) {
&lt;br  /&gt;var s = &amp;ldquo;;
&lt;br  /&gt;for(i in args) {
&lt;br  /&gt;s += args[i] + &apos; &apos;;
&lt;br  /&gt;}
&lt;br  /&gt;return s;
&lt;br  /&gt;}
&lt;br  /&gt;f(10);
&lt;br  /&gt;f(10,20);
&lt;br  /&gt;f(10,20,30);
&lt;br  /&gt;f(10,20,30,40);
&lt;br  /&gt;​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见，arguments中的确保存了全部传入的参数，不管实际传入的参数是多还是少。&lt;/p&gt;
&lt;p&gt;如果我们想在一个函数中，把所有传入的参数，原封不动的转给另一个函数，只能靠apply了。如果你用call，就必须显式地把参数一个个写上去，但这是不可能的，因为你根本不能确定调用者到底传了多少个参数过来。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;function f1(a,b,c) { f2.apply(null, arguments); }
&lt;br  /&gt;function f2(a,b,c,d) { alert(a+&apos;,&apos;+b+&apos;,&apos;+c+&apos;,&apos;+d);}
&lt;br  /&gt;f1(&apos;11&amp;#8242;,&apos;22&amp;#8242;,&apos;33&amp;#8242;,&apos;44&amp;#8242;);​​​​​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那我们只要apply就够了，为什么还要call呢？答案是，call写起来更简洁明了。当参数确定时，使用call写起来更快更顺手（不用写那一对中括号了）。&lt;/p&gt;
&lt;p&gt;以上是我浅显的理解，欢迎补充&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Emacs学习笔记</title>
                <link>http://freewind.in/posts/896-notes-emacs</link>
                <pubDate>Wed, 09 May 2012 20:06:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">896</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;一、如何上下移动某行？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;(defun move-text-internal (arg)
&lt;br  /&gt;(cond&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;((and mark-active transient-mark-mode)       
 (if (&amp;gt; (point) (mark))       
        (exchange-point-and-mark))       
 (let ((column (current-column))       
          (text (delete-and-extract-region (point) (mark))))       
   (forward-line arg)       
   (move-to-column column t)       
   (set-mark (point))       
   (insert text)       
   (exchange-point-and-mark)       
   (setq deactivate-mark nil)))       
(t       
 (beginning-of-line)       
 (when (or (&amp;gt; arg 0) (not (bobp)))       
   (forward-line)       
   (when (or (&amp;lt; arg 0) (not (eobp)))       
        (transpose-lines arg))       
   (forward-line -1)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(defun move-text-down (arg)
&lt;br  /&gt;&amp;ldquo;Move region (transient-mark-mode active) or current line
&lt;br  /&gt;arg lines down.&amp;rdquo;
&lt;br  /&gt;(interactive &amp;ldquo;*p&amp;rdquo;)
&lt;br  /&gt;(move-text-internal arg))&lt;/p&gt;
&lt;p&gt;(defun move-text-up (arg)
&lt;br  /&gt;&amp;ldquo;Move region (transient-mark-mode active) or current line
&lt;br  /&gt;arg lines up.&amp;rdquo;
&lt;br  /&gt;(interactive &amp;ldquo;*p&amp;rdquo;)
&lt;br  /&gt;(move-text-internal (- arg)))&lt;/p&gt;
&lt;p&gt;(global-set-key [M-up] &apos;move-text-up)
&lt;br  /&gt;(global-set-key [M-down] &apos;move-text-down)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按alt+上下方向键即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、如何在当前行上面再开一行？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;C-a C-o&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者自定义：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;pre&gt;    ;; Behave like vi&apos;s O command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(defun open-previous-line (arg)
  &quot;Open a new line before the current one. 
 See also `newline-and-indent&apos;.&quot;
  (interactive &quot;p&quot;)
  (beginning-of-line)
  (open-line arg)
  (when newline-and-indent
    (indent-according-to-mode)))```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;pre&gt; (global-set-key [C-S-return] &apos;open-previous-line)&lt;code&gt;`
&amp;lt;br /&amp;gt;&amp;lt;pre&amp;gt;只需要按Ctrl+Shirt+enter即可。&lt;/code&gt;`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;三、如何快速在当前行下面新开一行，并且光标移到新行？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;C-e &lt;ret&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者自定义：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;pre&gt;    ;; Behave like vi&apos;s o command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(defun open-next-line (arg)
  &quot;Move to the next line and then opens a line.
See also `newline-and-indent&apos;.&quot;
  (interactive &quot;p&quot;)
  (end-of-line)
  (open-line arg)
  (next-line 1)
  (when newline-and-indent
    (indent-according-to-mode)))```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;pre&gt;    (global-set-key [S-return] &apos;open-next-line)&lt;code&gt;`
&amp;lt;br /&amp;gt;&amp;lt;pre&amp;gt;只要按ctrl+enter即可。&lt;/code&gt;`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;四、如何将当前行复制一遍，插入到新一行？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;C-a C-k C-k C-y C-y&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;五、当光标停在某个括号的一头时，如何让另一头高亮显示？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在.emacs中加入：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;(show-paren-mode 1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;六、当光标停在某个括号的一头，如何跳转到另一头？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、如何将下一行合并在当前行的结尾？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;C-e C-k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;八、如何让光标跳到下一个单词的第一个字母？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/896-1.png&quot;&gt;&lt;img src=&quot;/user_images/896-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;能否用一个快捷键，跳到User的U上？&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、如何快速调整当前行缩进？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/896-3.png&quot;&gt;&lt;img src=&quot;/user_images/896-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;能否用一个快捷键，就让当前行的缩进正常？&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;#c0504d&quot;&gt;&lt;strong&gt;通常情况下，直接按tab键&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十、连按三次esc.esc.esc才能取消命令，经常个数按错，有没有哪个快捷键只用按一次？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十一、在gui模式下，如何用快捷键让emacs窗口最大化？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十二、选中一些文字后，如何快速删除？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在.emacs中加入这段：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;(delete-selection-mode t)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就可以按ctrl-d, DEL, Backspace来删除选中的文字了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十三、如何快速格式化整个文件，并且保持光标位置不变？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常用：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;c-x h c-m-\&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;麻烦不说，光标还会跳到文件开头。在.emacs中加入以下代码，即可一键搞定：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(defun indent-current-buffer ()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    (interactive) 

    (indent-region (point-min) (point-max)))

(global-set-key (kbd &quot;C-S-f&quot;) &apos;indent-current-buffer)

**十四、如何只使用空格缩进？**

emacs默认情况下，同时使用tab和space进行缩进。有时候不太方便，比如把代码贴到stackoverflow上调整缩进。

这时要在.emacs中加入下句：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(setq-default indent-tabs-mode nil)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十五、如何在启动时不显示初学者教程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加入：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;;; Remove splash screen&lt;/p&gt;
&lt;p&gt;(setq inhibit-splash-screen t)&lt;/p&gt;
&lt;/blockquote&gt;
]]></description>
            </item>
        
            <item>
                <title>Express + Mongoose 极简入门</title>
                <link>http://freewind.in/posts/891-guide-express-mongoose</link>
                <pubDate>Mon, 07 May 2012 21:38:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">891</guid>
                <description><![CDATA[&lt;p&gt;今天尝试使用express + mongoose，构建了一个简单的Hello world，实现以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义mongodb使用的Schema，一个User&lt;/li&gt;
&lt;li&gt;访问/输出Hello world&lt;/li&gt;
&lt;li&gt;访问/init向mongodb插入初始化数据&lt;/li&gt;
&lt;li&gt;访问/users从mongodb中取数据，并以json方式发送到浏览器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各功能都是极简单的试用，没有用到复杂的功能，但也有一定的参考价值，希望对大家有所帮助。&lt;/p&gt;
&lt;p&gt;本次使用到的模块如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mongoose&lt;a href=&quot;http://mongoosejs.com/&quot;&gt;http://mongoosejs.com/&lt;/a&gt;一个在nodejs中使用的对mongodb进行建模的工具，可以定义一些Schema（定义每个doc里的字段名、类型、初始值、验证条件等），增删改查等，功能比较贴心。&lt;/li&gt;
&lt;li&gt;express&lt;a href=&quot;http://expressjs.com&quot;&gt;http://expressjs.com&lt;/a&gt;nodejs环境中的web framework，提供了比nodejs的原始api高一级的抽象，方便进行web编程，如router、request/response的处理等，有很多基于它的模块或框架&lt;/li&gt;
&lt;li&gt;express-mongoose&lt;a href=&quot;https://github.com/LearnBoost/express-mongoose&quot;&gt;https://github.com/LearnBoost/express-mongoose&lt;/a&gt;让express中的某些方法，如res.send等，支持mongoose返回的查询，减少嵌套&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在开始之前，先在项目目录的根目录下安装各模块：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;npm install mongoose&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;npm install express&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;npm install express-mongoose&lt;/font&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;
&lt;br  /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目代码放在这里，可供参考：&lt;a href=&quot;https://github.com/freewind/express-mongoose-demo&quot;&gt;https://github.com/freewind/express-mongoose-demo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、使用express创建一个Hello, world&lt;/h2&gt;
&lt;p&gt;创建一个app.js，内容如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var express = require(&amp;ldquo;express&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;var app = express.createServer();&lt;/p&gt;
&lt;p&gt;app.get(&apos;/&apos;, function(req, res) {
&lt;br  /&gt;res.send(&apos;Hello, world&apos;);
&lt;br  /&gt;});&lt;/p&gt;
&lt;p&gt;app.listen(3000);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;短短几行代码，创建了一个app server。它监听于端口3000，并且访问/时，会向客户端发送Hello world.&lt;/p&gt;
&lt;h2&gt;二、试用/&lt;/h2&gt;
&lt;p&gt;启动该程序：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;node app.js&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果没有提示错误，说明启动成功。&lt;/p&gt;
&lt;p&gt;打开浏览器，访问：&lt;a href=&quot;http://localhost:3000&quot;&gt;http://localhost:3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/891-1.png&quot;&gt;&lt;img src=&quot;/user_images/891-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;三、定义Models&lt;/h2&gt;
&lt;p&gt;创建一个models.js，用于定义程序中使用的model（主要是Schema）。内容如下：

&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var mongoose = require(&apos;mongoose&apos;);

var Schema = mongoose.Schema;

// Define User schema       
var _User = new Schema({        
    email : String,        
    name : String,        
    salt : String,        
    password : String        
});

// export them       
exports.User = mongoose.model(&apos;User&apos;, _User);        

&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里定义了两个Schema，一个User。为了简便好认，我在Schema前面加了一个下划线，当然你也可以使用其它命名，如UserSchema等。&lt;/p&gt;
&lt;p&gt;在定义Schema时，还可以设一些默认值、验证什么的，但这里先忽略，毕竟是极简试用。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;mongoose.model(&apos;User&apos;, _User);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一句中，第一个参数相当重要，它是给User这个schema，定义了一个名字。其它地方如果想使用这个model，可以这样：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;var User = mongoose.model(&apos;User&apos;)&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但在这里，我们直接把它放在exports里了，更方便：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;exports.User = mongoose.model(&apos;User&apos;, _User);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;四、/init&lt;/h2&gt;
&lt;p&gt;现在要把models.js导入到app.js中，并且定义一个/init，访问它时将会向数据库中插入一些数据。代码如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;var express = require(&amp;ldquo;express&amp;rdquo;);
&lt;br  /&gt;var mongoose = require(&apos;mongoose&apos;);&lt;/p&gt;
&lt;p&gt;var models = require(&apos;./models&apos;);&lt;/p&gt;
&lt;p&gt;var User = models.User;&lt;/p&gt;
&lt;p&gt;mongoose.connect(&apos;mongodb://localhost/express-mongoose-demo&apos;);&lt;/p&gt;
&lt;p&gt;var app = express.createServer();&lt;/p&gt;
&lt;p&gt;// init data. Use &amp;ldquo;get&amp;rdquo; to simplify
&lt;br  /&gt;app.get(&apos;/init&apos;, function(req, res) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var user = new User({      
    email : &apos;nowind_lee@qq.com&apos;,      
    name : &apos;Freewind&apos;      
});      
user.save();      
res.send(&apos;Data inited&apos;);      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;app.listen(3000);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先导入了mongoose模块，以前之前定义的models.js。然后将models.User取出来供下面使用。&lt;/p&gt;
&lt;p&gt;下面这句话用于连接mongodb，这里使用express-mongoose-demo&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;mongoose.connect(&apos;mongodb://localhost/express-mongoose-demo&apos;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着定义/init，为了演示方便起见，这里使用http get，可直接在浏览器中访问该url。如果在真实程序中，应该使用app.post(&apos;/init&apos;, &amp;hellip;)&lt;/p&gt;
&lt;p&gt;打开浏览器，访问：&lt;a href=&quot;http://localhost:3000/init&quot;&gt;http://localhost:3000/init&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/891-3.png&quot;&gt;&lt;img src=&quot;/user_images/891-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提示数据已经初始化。使用mongodb的控制台，查询结果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/891-5.png&quot;&gt;&lt;img src=&quot;/user_images/891-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到数据的确已经插入到mongodb中了。&lt;/p&gt;
&lt;h2&gt;五、/users&lt;/h2&gt;
&lt;p&gt;接着实现/users，查询User数据，并以json格式返回到浏览器端。代码很简单，如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;app.get(&apos;/users&apos;, function(req, res) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User.find(function(err, doc) {      
    res.json(doc);      
});      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开浏览器，访问&lt;a href=&quot;http://localhost:3000/users&quot;&gt;http://localhost:3000/users&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/891-7.png&quot;&gt;&lt;img src=&quot;/user_images/891-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然看到json数据过来了。&lt;/p&gt;
&lt;p&gt;但看看这段代码，里面有两个嵌套。如果数据再复杂一些的话，可能嵌套更多，就不易读了。能不能想办法让它简化一点呢？&lt;/p&gt;
&lt;p&gt;下面就该express-mongoose出场了。&lt;/p&gt;
&lt;h2&gt;六、express-mongoose&lt;/h2&gt;
&lt;p&gt;express-mongoose项目就是为了简化express和mongoose。首先导入它：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;require(&apos;express-mongoose&apos;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后将/users方法改写成：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;app.get(&apos;/users&apos;, function(req, res) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.send(User.find());      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看这里，直接用res.send就直接发送了，不用传回调函数了，代码简单了很多。&lt;/p&gt;
&lt;p&gt;重启app.js，再访问：&lt;a href=&quot;http://localhost:3000/users&quot;&gt;http://localhost:3000/users&lt;/a&gt;，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/891-9.png&quot;&gt;&lt;img src=&quot;/user_images/891-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然效果一样。&lt;/p&gt;
&lt;p&gt;如果去掉express-mongoose，会是什么效果呢？让我们先去掉：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;require(&apos;express-mongoose&apos;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再访问：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/891-11.png&quot;&gt;&lt;img src=&quot;/user_images/891-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在返回的就是User.find()这个query的值，而不是查询结果。&lt;/p&gt;
&lt;p&gt;今天就到这里，以后将慢慢加入更多的功能。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Towerjs与Railwayjs对比与试用</title>
                <link>http://freewind.in/posts/878-towerjs-railwayjs-comparasion</link>
                <pubDate>Sat, 05 May 2012 23:56:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">878</guid>
                <description><![CDATA[&lt;p&gt;在js后端框架中，towerjs与railwayjs是两个仿ror的全栈框架。两者在github上的关注度很相似，都在800左右，不相上下。&lt;/p&gt;
&lt;p&gt;关于功能的对比，在stackoverflow上发现了一个汇总：&lt;a href=&quot;http://stackoverflow.com/questions/9897017/railwayjs-vs-towerjs&quot;&gt;http://stackoverflow.com/questions/9897017/railwayjs-vs-towerjs&lt;/a&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt; &lt;/th&gt;
&lt;th&gt;RailwayJS&lt;/th&gt;
&lt;th&gt;Tower.js&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;First commit&lt;/td&gt;
&lt;td&gt;Jan 2011&lt;/td&gt;
&lt;td&gt;Oct 2011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rails&lt;/td&gt;
&lt;td&gt;2.3.x&lt;/td&gt;
&lt;td&gt;3.x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;&gt;= 0.4.x&lt;/td&gt;
&lt;td&gt;&gt;= 0.4.x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Client&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Template agnostic&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default engine&lt;/td&gt;
&lt;td&gt;EJS&lt;/td&gt;
&lt;td&gt;CoffeeKup&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Database agnostic&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default datastore&lt;/td&gt;
&lt;td&gt;MongoDB&lt;/td&gt;
&lt;td&gt;MongoDB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Model validations&lt;/td&gt;
&lt;td&gt;validatesPresenceOf(&apos;email&apos;)&lt;/td&gt;
&lt;td&gt;validates(&apos;email&apos;, presence: true)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Query scopes&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Chainable scopes&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Param parsing&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Controllers&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resource controllers&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;File naming&lt;/td&gt;
&lt;td&gt;users_controller.js&lt;/td&gt;
&lt;td&gt;usersController.coffee&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vm.runInCustomContext&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Asset pipeline&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Asset compression&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Routing&lt;/td&gt;
&lt;td&gt;map.resources(&apos;posts&apos;)&lt;/td&gt;
&lt;td&gt;@resources &apos;posts&apos;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nested routes&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generated url helpers&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generators&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Command-line api&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REPL (console)&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CoffeeScript console&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Asset cache method&lt;/td&gt;
&lt;td&gt;timestamp&lt;/td&gt;
&lt;td&gt;md5 hash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Production asset path&lt;/td&gt;
&lt;td&gt;/app.css*123123123&lt;/td&gt;
&lt;td&gt;/app-859c828c89288hc8918741.css&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Preferred Language&lt;/td&gt;
&lt;td&gt;JavaScript&lt;/td&gt;
&lt;td&gt;CoffeeScript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CoffeeScript support&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Internationalization&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Heroku support&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;String case&lt;/td&gt;
&lt;td&gt;snake_case&lt;/td&gt;
&lt;td&gt;camelCase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Form builder&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Semantic form builder&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Table builer&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;File watcher API&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Live-reload assets&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Test suite&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generators for tests&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Twitter Bootstrap&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTML5 Boilerplate&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从上表可以看出，两者之间的主要差别在于风格。例如railwayjs仿的是ror2.x，而towerjs仿的是ror3.x。变量名风格、习惯使用纯js还是coffee等，都将会是人们选择时的一个考量。这里分别对两者进行一个简单的试用，取得第一感受。&lt;/p&gt;
&lt;h2&gt;Railwayjs&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://railwayjs.com/&quot;&gt;http://railwayjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网首页截图，典型的Bootstrap风格：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/878-1.png&quot;&gt;&lt;img src=&quot;/user_images/878-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Railswayjs的试用非常顺利，在win7 x64下也能顺利安装。&lt;/p&gt;
&lt;p&gt;&lt;div class=&quot;mycode&quot;&gt;
&lt;br  /&gt;&lt;div class=&quot;mycode&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo npm install railway -g
&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

生成一个blog项目：

railway init blog &amp;amp;&amp;amp; cd blog
    npm install -l
    railway generate crud post title content
    railway server 8888
    open [http://127.0.0.1:8888/posts](http://127.0.0.1:8888/posts)

在开发模式下，它默认使用了redis这个内存数据库，不用安装，直接启动，异常方便。

打开浏览器，访问[http://127.0.0.1:8888/posts](http://127.0.0.1:8888/posts)，页面如下：

[![image](/user_images/878-3.png &quot;image&quot;)](/user_images/878-3.png) 

创建一个Post:

[![image](/user_images/878-5.png &quot;image&quot;)](/user_images/878-5.png) 



创建后，回到列表页：

[![image](/user_images/878-7.png &quot;image&quot;)](/user_images/878-7.png) 

查看其中一个：

[![image](/user_images/878-9.png &quot;image&quot;)](/user_images/878-9.png) 

删除：

[![image](/user_images/878-11.png &quot;image&quot;)](/user_images/878-11.png) 

在访问过程中，控制台会显示出请求信息：

[![image](/user_images/878-13.png &quot;image&quot;)](/user_images/878-13.png) 

总之，页面精美，操作流畅，考虑周到，赞一个。

具体的代码不贴了，请直接上官网看。

## TowerJs

官网：[http://towerjs.org/](http://towerjs.org/)

首页截图，看起来也比较素雅：

[![image](/user_images/878-15.png &quot;image&quot;)](/user_images/878-15.png) 

Towerjs的试用过程比较坎坷。首先在windows下安装，有一些依赖的模块安装不上，可能还不支持windows。只好打开虚拟机，启动centos6.x，开始安装。

&amp;lt;div class=&quot;mycode&quot;&amp;gt;
npm install tower -g
&amp;lt;/div&amp;gt;

然后生成一个试用网站：

tower new app
cd app
tower generate scaffold Post title:string body:text belongsTo:user
tower generate scaffold User email:string firstName:string lastName:string hasMany:posts

也很顺利地生成了很多文件。

启动：

sudo chmod +x server.js
sudo node server.js

此时会提示一些第三方模块没有安装上，运行cake命令时，也会有类似提示。于是得分别安装：

sudo npm install coffee-script

sudo npm install forever

需要注意的是，不能加-g，必须把模块们都装在当前目录下（生成node_modules），否则还会提示找不到模块。这一点困扰了我半天才解决。

然后再次运行：

node server.js

会提示连不上数据库。原来towerjs默认使用了mongodb，我们必须先安装mongodb。

到mongodb官网下载最新的mongodb源代码：[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)

下载后解压，可以看到其中的bin目录，已经包含了可执行的各文件。

sudo mkdir /data/db
sudo chown `id -u` /data/db
cd /mondodb-xxxx/bin
./mongod

如果一切正常，会提示成功。再次启动towerjs生成的app，如果一切正常，会提示如下信息：

[Sat, 05 May 2012 15:38:00 GMT] INFO Tower development server listening on port 3000

在浏览器中访问：[http://localhost:3000](http://localhost:3000)，出现如下页面：

[![image](/user_images/878-17.png &quot;image&quot;)](/user_images/878-17.png) 

什么情况？怎么这么丑？！

打开firebug:

[![image](/user_images/878-19.png &quot;image&quot;)](/user_images/878-19.png)

居然有这么多文件找不到？打开资源浏览器，发现对应的less文件存在：

[![image](/user_images/878-21.png &quot;image&quot;)](/user_images/878-21.png)

看来需要手动把它们转为.css。

按照官网首页提示，输入：

cake assets:compile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示：&lt;code&gt;No such task: assets:compile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;奇怪，看一下任务列表：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/878-23.png&quot;&gt;&lt;img src=&quot;/user_images/878-23.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;哪有编译任务？！实在进行不下去了。&lt;/p&gt;
&lt;p&gt;试下添加User:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/878-25.png&quot;&gt;&lt;img src=&quot;/user_images/878-25.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文显示正常：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/878-27.png&quot;&gt;&lt;img src=&quot;/user_images/878-27.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;试用到此结束，不能不说有些失望。安装过程复杂，也不能提供开箱即用的数据库，文档与实际命令有差异，无法编译资源文件，导致最终页面相当丑。&lt;/p&gt;
&lt;p&gt;与railwayjs的试用体验相差甚远。railwayjs一共只花了十分钟，而towerjs花了一个多小时。&lt;/p&gt;
&lt;p&gt;所以在这两者之间，我将选择基于Railwayjs开发。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Couchdb+kanso试用</title>
                <link>http://freewind.in/posts/848-try-couchdb-kanso</link>
                <pubDate>Fri, 04 May 2012 18:36:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">848</guid>
                <description><![CDATA[&lt;p&gt;Couchdb中有一个强大的特性，可以把html/css/js等直接嵌入到couchdb中，将couchdb变成webserver+database。Kanso号称couchdb的npm，它可以帮我们做这些事，并且一些主要功能都比较成熟了，相比couchapp更胜一筹。&lt;/p&gt;
&lt;p&gt;couchdb的这个功能非常吸引我，我的目标就是前台使用angularjs，后台使用couchdb干所有事。&lt;/p&gt;
&lt;p&gt;我花了几天时间来熟悉couchdb的操作以及kanso提供的功能，期间参考了：&lt;a href=&quot;https://github.com/petebacondarwin/questionnaire-angular&quot;&gt;https://github.com/petebacondarwin/questionnaire-angular&lt;/a&gt;。开始一直比较顺利，直到遇到了用户权限问题。&lt;/p&gt;
&lt;p&gt;用户权限问题，是指couchdb提供了http restful的api以供客户端对数据库、文档进行CRUD。如果我们直接通过浏览器端进行操作，如何对用户的权限进行检查与限制呢？虽然couchdb也内置了一些简单的验证方案，但粒度太大，无法细化。&lt;/p&gt;
&lt;p&gt;比如couchdb提供了三种不同的用户：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库读取者：可以读取某个数据库中的所有数据，但不能修改&lt;/li&gt;
&lt;li&gt;数据库管理员：可以读取及修改某个数据库中所有数据&lt;/li&gt;
&lt;li&gt;超级管理员：对所有数据库拥有管理权限&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这里可以看到，一个用户至少拥有某数据库&lt;strong&gt;全部数据&lt;/strong&gt;的&lt;strong&gt;读取&lt;/strong&gt;权限，这就意味着不同用户之间没有秘密可言了。目前没有发现有什么简单的方法可实现更细粒度的控制方法。虽然couchdb正在努力改善，但相信短期内不会有好消息。&lt;/p&gt;
&lt;p&gt;那么couchdb的这种方式，岂不是完全无用了？也不是，在某些场合还是可用。因为couchdb可以设置某用户只能读取某个数据库的数据，这样可以为每个用户设置一个单独的数据库，将不同用户之间的数据完全隔开。这种方式对于那些用户之间数据比较独立的程序，比如手机上的通讯录管理等有意义。以我目前的认识，“库”对于couchdb是一个轻量级的概念，有点像其它数据库中的“表”，所以每个用户一个库也是可以接受的。&lt;/p&gt;
&lt;p&gt;不过对于通常的网站，这种方式局限性太大。还是得使用传统的做法，在数据库与浏览器端js之间，加一个web层。数据库只能与web层交互，web层只能与浏览器端交互。web层向浏览器端暴露一些接口，并且对浏览器端的请求进行验证。虽然这种方法成熟好用，但意味着我还需要写一个web层，数据之间的交互也多了一次。&lt;/p&gt;
&lt;p&gt;希望落空，下面将研究一下，如何使用express+couchdb或者express+mongodb。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Couchdb+angularjs安装与试用</title>
                <link>http://freewind.in/posts/846-try-couchdb-angularjs</link>
                <pubDate>Wed, 02 May 2012 01:40:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">846</guid>
                <description><![CDATA[&lt;p&gt;对于我正在寻找的基于js的快速开发方案，我今天尝试了一下couchdb+angularjs。&lt;/p&gt;
&lt;p&gt;Couchdb是这几天让我觉得很振奋的一个项目。它与mongodb类似，是一个基于文档的nosql数据库，但不同的是，mongodb专注于大数量文档的存储，而couchdb的每一处设计，都紧扣&quot;WEB&amp;rdquo;。比如它内置的restful api，可允许客户端通过http直接操作数据库；数据采用json格式，与js程序交互时非常直接；对于数据的分发同步有很好的解决方案，可以让一个web程序offline。然而最让我眼前一亮的是，通过某些工具（如couchdb, kanso），可以把html/css/js等文件，直接嵌入到couchdb中，这时的couchdb又成了一个web server！&lt;/p&gt;
&lt;p&gt;嵌入到couchdb中的js，可以通过某些回调，对数据进行处理，对访问进行控制。我以前还担心，完全开放了restful api的couchdb，如何保证客户端的访问在权限的控制之内，现在终于心安一些（还没有深入，不能完全心安）。这一处创新是我非常喜欢的，因为对于开放了restful api的数据库来说，额外的web层，似乎有点多余（就像是一层代理，把api再包装一下再对外）。现在好了，直接放数据库里，多省事。&lt;/p&gt;
&lt;p&gt;可以想像，对于需求不是很复杂的信息管理系统，前台直接用js mvc+ui框架，通过restful api接口与couchdb直接交互，某些逻辑可以写在前台，重要操作写在couchdb中的js里，就可以快速地实现功能。当需求更复杂一些时，可以考虑某些web框架，如node.js+express等等。&lt;/p&gt;
&lt;p&gt;虽然感觉这套东西不错，但是一下子这么多新东西，让我无从下手。在slideshare.net上看了不少演示，有一些概念了，但还是觉得很虚。于是我在angularjs的google group中问到，哪里有基于angularjs+couchdb的开源代码可供参考，让我倍受感动的是Peter告诉我他正在写的一个示例，以及详细的安装试用说明：&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!topic/angular/S5bAfaY1qP4&quot;&gt;https://groups.google.com/forum/?fromgroups#!topic/angular/S5bAfaY1qP4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目的地址为：&lt;a href=&quot;https://github.com/petebacondarwin/questionnaire-angular&quot;&gt;https://github.com/petebacondarwin/questionnaire-angular&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Angularjs的google group的确是一个好地方，再一次感谢这些热心的朋友们。&lt;/p&gt;
&lt;p&gt;我花了近一天的时间，在windows下与linux下这个示例。Linux成功了，windows下失败在最后一步，应该是kanso的一个bug：&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!topic/kanso/O-2dpLNTTn0&quot;&gt;https://groups.google.com/forum/?fromgroups#!topic/kanso/O-2dpLNTTn0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里先解释一下提到的一些词：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;angularjs&lt;/strong&gt; 一个浏览器端的mvc框架，双向绑定、router、directive、filter、以及对测试的良好支持，深深打动了我，是让我尝试转向js平台的最直接原因2.  &lt;strong&gt;couchdb &lt;/strong&gt;一个基于文档的Nosql数据库，提供了很多web友好的功能，基于erlang开发3.  &lt;strong&gt;nodejs&lt;/strong&gt; 让js运行于服务器端，它打开了js走向服务器端的大门4.  &lt;strong&gt;npm&lt;/strong&gt; Nodejs Package Manager，nodejs的包管理器，可以方便地安装管理第三方插件5.  &lt;strong&gt;express &lt;/strong&gt;一个轻量级的web开发框架，目前在nodejs世界应该是最为人知的6.  &lt;strong&gt;kanso&lt;/strong&gt; 一个couchdb工具，可以把我们编写的js/css/html等文件，打包后放入couchdb，实现couchdb+web server合体功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先看一下最终效果，再讲安装中遇到的问题及一些要点：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-1.png&quot;&gt;&lt;img src=&quot;/user_images/846-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我也不知道naire这个词是什么意思，但估计这是一个“病人问卷调查”程序。首页显示一些调查问卷的名字，我们可以点击一个答题。这里点第一个：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-3.png&quot;&gt;&lt;img src=&quot;/user_images/846-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点右边的Start开始，要先写资料及时间：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-5.png&quot;&gt;&lt;img src=&quot;/user_images/846-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意第一个空，有下划线表示可以填写（并且只能输入数字），中间还有横线隔开。这里用到了angularjs中的自定义directive组件的功能。下面是选择日期，看样子应该是jquery-ui的日期控件。&lt;/p&gt;
&lt;p&gt;填好后，右边出现Next按钮，点击它，开始答题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-7.png&quot;&gt;&lt;img src=&quot;/user_images/846-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于每个问题，它下方都会有几个答案供选。直接点击其中一个，出现Next，进入下一题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-9.png&quot;&gt;&lt;img src=&quot;/user_images/846-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;全部答完后，出现汇总页，可查看并修改答案：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-11.png&quot;&gt;&lt;img src=&quot;/user_images/846-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意此处，第一行的数据，与后面几个明显不同。如果是使用传统数据库，它们应该在不同的表中，而couchdb中是怎么处理的呢？（下回分解）&lt;/p&gt;
&lt;p&gt;确认无误后，点击右上角的submit，提交过去：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/846-13.png&quot;&gt;&lt;img src=&quot;/user_images/846-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再点左边的按钮，回到了首页。&lt;/p&gt;
&lt;p&gt;整体流程清楚了，其中“下一题”的流程，以及不同结构问答的处理（如有的是选择，有的是填空，答案个数不同），是亮点，值得好好研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装要点记录&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nodejs一定要装0.6.6，不能装最新版。因为kanso只支持到0.6.6，得迁就它。2.  在linux上安装couchdb的时候，不要使用source安装，因为实在太麻烦。使用yum install couchdb，先安装一个旧版本用着。参考我另一个文章：&lt;a href=&quot;http://freewind.me/blog/20120501/831.html&quot;&gt;http://freewind.me/blog/20120501/831.html&lt;/a&gt;3.  在安装某些nodejs的包时（如kanso），如果不是root，需要在前面加sudo，如sudo npm install kanso -g。但它会提示找不到&quot;sudo npm&quot;命令，参考&lt;a href=&quot;http://stackoverflow.com/a/5062718/342235&quot; title=&quot;http://stackoverflow.com/a/5062718/342235&quot;&gt;http://stackoverflow.com/a/5062718/342235&lt;/a&gt;解决4.  kanso在windows上运行push命令时，会报错（路径处理问题）。该问题应该会很快解决&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;改日再好好研究代码，希望有人能一起研究，人多力量大。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何在centos 6.2上安装couchdb?</title>
                <link>http://freewind.in/posts/831-how-to-install-couchdb-on-centos-6.2</link>
                <pubDate>Tue, 01 May 2012 20:58:29 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">831</guid>
                <description><![CDATA[&lt;p&gt;Couchdb: &lt;a href=&quot;http://couchdb.apache.org/&quot;&gt;http://couchdb.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首页的Download中，提供了Source供安装，没想到在linux上安装起来麻烦无比，要先安装一大堆各种各样的依赖，我折腾了近两个小时也没搞定。&lt;/p&gt;
&lt;p&gt;我的linux是centos 6.2，直接：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;yum install couchdb&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会报找不到该包，我以为只能能过源代码安装呢。后来发现，只要把EPEL库添加到yum中，就可以直接通过该命令安装了。&lt;/p&gt;
&lt;p&gt;打开该页：&lt;a href=&quot;http://mirrors.sohu.com/fedora-epel/6/i386/repoview/epel-release.html&quot;&gt;http://mirrors.sohu.com/fedora-epel/6/i386/repoview/epel-release.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可看到有一个： epel-release-6.5.noarch的链接，这就是我们需要安装的。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;$ &lt;/font&gt;wget &lt;a href=&quot;http://mirrors.sohu.com/fedora-epel/6/i386/epel-release-6-5.noarch.rpm&quot; title=&quot;http://mirrors.sohu.com/fedora-epel/6/i386/epel-release-6-5.noarch.rpm&quot;&gt;http://mirrors.sohu.com/fedora-epel/6/i386/epel-release-6-5.noarch.rpm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;$ sudo rpm -install epel-release-6-5.noarch.rpm&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即可。如果需要重装，加上&lt;code&gt;-force&lt;/code&gt;参数即可。&lt;/p&gt;
&lt;p&gt;提示成功后：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;$ sudo yum makecache&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;$ sudo install couchdb&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会提示一大堆依赖文件，一共有几十M。输入y下载并安装。&lt;/p&gt;
&lt;p&gt;安装完成后，可以修改其配置文件：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;vi /etc/couchdb/local.in&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如文档最大尺寸、端口、地址、验证、日志、vhosts设置以及管理员密码等。&lt;/p&gt;
&lt;p&gt;启动：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;sudo service couchdb start&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;linux重启时自动启动：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;sudo chkconfig -level 345 couchdb on&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;验证是否启动成功：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;curl &lt;a href=&quot;http://locahost:5984&quot;&gt;http://locahost:5984&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果返回如:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;{&amp;ldquo;couchdb&amp;rdquo;:&amp;ldquo;Welcome&amp;rdquo;,&amp;ldquo;version&amp;rdquo;:&amp;ldquo;1.0.3&amp;rdquo;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的json，则说明成功。这里安装的版本是1.0.3，当前官网最新版本是1.2，先将就着用吧。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Node.js与cloud9小试</title>
                <link>http://freewind.in/posts/793-try-nodejs-cloud9</link>
                <pubDate>Sat, 28 Apr 2012 19:22:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">793</guid>
                <description><![CDATA[&lt;p&gt;Node.js使用了google提供的性能强劲的v8引擎，让我们真正可以使用js在服务器端编程。使用它写简单的web程序异常简单，而且它特有的基于事件回调的处理方式，拥有很高的吞吐量。&lt;/p&gt;
&lt;p&gt;推荐一本叫《Node.js入门》的电子书，由国人翻译，质量很高，是极好的入门材料。其使用的代码位于：&lt;a href=&quot;https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application&quot; title=&quot;https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application&quot;&gt;https://github.com/ManuelKiessling/NodeBeginnerBook/tree/master/code/application&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我本在win7 x64下，安装nodejs没有问题，但是某些第三方模块不支持windows，所以最好在其它系统如linux下使用node.js。我安装了一个linux的虚拟机，专门用于学习node.js。&lt;/p&gt;
&lt;p&gt;这么麻烦？我机器很慢的，装虚拟机跑不动，我不会用linux。。。&lt;/p&gt;
&lt;p&gt;好吧，试试cloud9。&lt;/p&gt;
&lt;p&gt;当然还有很多其他类似的在线编程环境，直接支持node.js，还有基于浏览器的编程器，还有git，还能直接运行，还免费。这么好的事情，还不去试试？&lt;/p&gt;
&lt;p&gt;cloud9的网址是&lt;a href=&quot;http://c9.io&quot;&gt;http://c9.io&lt;/a&gt;，对于开源项目免费，可支持将github.com和bitbucket.org中的代码库clone过来。直接在线编辑，运行，提交至代码库，非常完美。&lt;/p&gt;
&lt;p&gt;上个图看看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/793-1.png&quot;&gt;&lt;img src=&quot;/user_images/793-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;怎么样，像模像样吧？项目管理、语法高亮、debug，甚至还有Deploy可发布到第三方server。使用起来的感觉，跟本地的IDE，几乎没有差别。&lt;/p&gt;
&lt;p&gt;点个debug试试：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/793-3.png&quot;&gt;&lt;img src=&quot;/user_images/793-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到提示信息，Server has started，说明成功启动，访问它提供的链接：&lt;a href=&quot;http://testnodejs.freewind.c9.io/&quot; title=&quot;http://testnodejs.freewind.c9.io/&quot;&gt;http://testnodejs.freewind.c9.io/&lt;/a&gt;即可看到如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/793-5.png&quot;&gt;&lt;img src=&quot;/user_images/793-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完美。&lt;/p&gt;
&lt;p&gt;这意味着什么？意味着我们的电脑只要能上网，有个浏览器，就能直接编程了！还有什么比这更惬意的事？&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Jump to Javascript world (1)</title>
                <link>http://freewind.in/posts/784-jump-to-javascript-world-1</link>
                <pubDate>Sat, 28 Apr 2012 17:15:51 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">784</guid>
                <description><![CDATA[&lt;p&gt;Web开发真是日新月异，不断有新东西出来，js时代快到来了。&lt;/p&gt;
&lt;p&gt;在了解了angularjs的强大与灵活之后，我对平时勤学苦练的java web框架突然有种难以言说的失落，因为我发现，这两个世界在web开发方面有着难以逾越的鸿沟。&lt;/p&gt;
&lt;p&gt;就算java在后台如何稳定高效，但对前台都有些无可奈何，必须借助一些js库（如jquery等）来才能增强表现力。然而这前后台之间的配合却是很难如人意：后台开发，如同一台巨型钢铁机器，坚固稳定，但却笨重。前台用jquery，却如同打补丁一样，把一块块破布缝在一起。如果是简单的动态（如局部刷新等），还能勉励撑过去，稍复杂的就会扯出一个个大口子，只能再找一块更大的破布往上缝。&lt;/p&gt;
&lt;p&gt;我曾经想使用play+jquery来做一个todolist，折腾很久都没弄出来。后来发现了backbone，眼前一亮，但还是稍嫌复杂。&lt;/p&gt;
&lt;p&gt;最后发现了angularjs，原来可以这么轻松。视频为证：&lt;a href=&quot;http://www.youtube.com/watch?v=WuiHuZq_cg4&amp;amp;feature=related&quot; title=&quot;http://www.youtube.com/watch?v=WuiHuZq_cg4&amp;amp;feature=related&quot;&gt;http://www.youtube.com/watch?v=WuiHuZq_cg4&amp;amp;feature=related&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我本来还是舍不得离开熟悉的java平台，前台angularjs，后台java，通过restful api交互，岂不也是很好？&lt;/p&gt;
&lt;p&gt;可惜的是，发现play的route与angularjs的$resource之间有点不太匹配，虽然可以设计成restful api，但play那边仅能通过uri+http method来转向action，把querystring和header之类都忽略了，而这两者常被js前端框架使用。我在设计angularjs与前台交互的过程中，费尽脑筋，都觉得相当别扭。&lt;/p&gt;
&lt;p&gt;最后心一横，干脆后台也用js(node.js)，数据库搞个document based的key-value，数据传输全部直接json，省了多少事。&lt;/p&gt;
&lt;p&gt;browser &lt;==&gt; web &lt;==&gt; database&lt;/p&gt;
&lt;p&gt;没错，全部json，全部js，世界和平统一。&lt;/p&gt;
&lt;p&gt;Let’s jump to the javascript world ~&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>AutoHotkey小试</title>
                <link>http://freewind.in/posts/783-try-autohotkey</link>
                <pubDate>Tue, 24 Apr 2012 23:07:23 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">783</guid>
                <description><![CDATA[&lt;p&gt;今天尝试了一下auto hotkey这个工具，可以方便地定义一些快捷键，实现某些方便操作。&lt;/p&gt;
&lt;p&gt;比如在xtend中，它用了两个奇怪的符号«»在文本中引用xtend代码。它们在xtend的编辑器中很好输入，直接按ctrl+shift+,即可。但在其它地方怎么输呢？&lt;/p&gt;
&lt;p&gt;方法是这样的，按alt+171和alt+187，够麻烦的。&lt;/p&gt;
&lt;p&gt;所以我定义了一个auto hotkey的脚本，来实现同样功能。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;^+,::
&lt;br  /&gt;sendinput, «»
&lt;br  /&gt;sendinput, {Left}
&lt;br  /&gt;return&lt;/p&gt;
&lt;p&gt;^+.::
&lt;br  /&gt;sendinput, »
&lt;br  /&gt;return&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，还想实现这个功能：当我在eclipse中按了ctrl+s时，会自动刷新浏览器。思路时，先找到firefox/chrome/ie等，激活它们的窗口，发送刷新命令，然后再切回到eclipse。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;$^s::                                       ; only capture actual keystrokes
&lt;br  /&gt;SetTitleMatchMode, 2                        ; match anywhere in the title
&lt;br  /&gt;IfWinActive, Eclipse                        ; find Sublime Text
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Send ^s                                 ; send save command       
IfWinExist, Mozilla Firefox             ; find firefox       
{       
    WinActivate                         ; use the window found above       
    Send ^r                             ; send browser refresh       
    WinActivate, Eclipse                ; get back to Sublime Text       
}       
IfWinExist, Google Chrome               ; find Chrome       
{       
    WinActivate                         ; use the window found above       
    Send ^r                             ; send browser refresh       
    WinActivate, Eclipse                ; get back to Sublime Text       
}       
IfWinExist, Internet Explorer            ; find IE       
{       
    WinActivate                         ; use the window found above       
    Send ^r                             ; send browser refresh       
    WinActivate, Eclipse                ; get back to Sublime Text       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;else
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Send ^s                                 ; send save command       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;return&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;#666666&quot;&gt;&lt;/font&gt;
&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>尝试使用Xtend开发网站</title>
                <link>http://freewind.in/posts/779-try-to-use-xtend-to-dev-website</link>
                <pubDate>Tue, 24 Apr 2012 22:54:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">779</guid>
                <description><![CDATA[&lt;p&gt;以一些高性能的模板引擎为例：play2的scala模板，play1的rythm/japid，无不是首先把模板转为scala或java类，然后再调用其中某方法来得到最终文本。特别是play2的scala模板，转为scala类后，直接在controller代码中调用该类的render方法。&lt;/p&gt;
&lt;p&gt;既然如此，何不直接在源代码中写view? 连翻译的步骤都省了，所见即所得。&lt;/p&gt;
&lt;p&gt;然而在java中不可能，因为它没有多行文本。scala中直接支持xml语法，但在其中嵌入scala代码时不是很方便，格式化时也会把xml格式弄得很糟。&lt;/p&gt;
&lt;p&gt;而Xtend的内置的模板很好用，充分考虑到这些情况，所以我尝试使用xtend直接写view层。&lt;/p&gt;
&lt;p&gt;首先看在基类Layout.xtend中定义的main()方法，它定义了整体结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/779-1.png&quot;&gt;&lt;img src=&quot;/user_images/779-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中的headImports，是定义同文件中另一个方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/779-3.png&quot;&gt;&lt;img src=&quot;/user_images/779-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;子类中如果想填充body部分，可如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/779-5.png&quot;&gt;&lt;img src=&quot;/user_images/779-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意，调用main方法时，最后一个参数使用了闭包语法，方便把大块内容单独放置。&lt;/p&gt;
&lt;p&gt;代码中有很多被«»包围的代码，它是嵌入的xtend代码。&lt;/p&gt;
&lt;p&gt;整体来说，一眼看去，还比较清楚。&lt;/p&gt;
&lt;p&gt;换用Amateras HTML editor打开Layout.xtend，有惊喜：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/779-7.png&quot;&gt;&lt;img src=&quot;/user_images/779-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;html代码高亮，看起来更有感觉了。此时在内部输入html代码，甚至还有提示！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/779-9.png&quot;&gt;&lt;img src=&quot;/user_images/779-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可惜不是每段html用它打开都是这样，如果字符串中的html内容较少的话，可能连语法高亮都没有。&lt;/p&gt;
&lt;p&gt;提了个request: &lt;a href=&quot;https://bugs.eclipse.org/bugs/show_bug.cgi?id=377382&quot;&gt;https://bugs.eclipse.org/bugs/show_bug.cgi?id=377382&lt;/a&gt;，希望能在editor中增加html/json/xml等的高亮显示，不知何时会实现。&lt;/p&gt;
&lt;p&gt;这是花了两天时间搞出来的示例：&lt;a href=&quot;https://github.com/freewind/webtend&quot; title=&quot;https://github.com/freewind/webtend&quot;&gt;https://github.com/freewind/webtend&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整体基于servlet，自己做了一些封装，增加了route，算是一个简单mvc框架。在eclipse中使用了run-jetty-run插件，直接引用bin中的.class，提供http访问，很方便很快。再配合dcevm，来提供hot-swap。&lt;/p&gt;
&lt;p&gt;初看起来，这是一套非常简洁明了的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将Action和View写在一个Xtend类中，直接在源代码中写HTML2.  在Action类上使用自定义的Route注解标明路径3.  一个Servlet类做入口，在debug模式下，每个请求到来时，都读取一遍全部的标注了Route的类，以找到新增的类4.  orm使用了Ebean5.  使用dcevm实现hot-swap6.  使用livereload自动刷新浏览器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但在使用中，因为某些库、工具支持不够好，有些地方不太爽：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在写View时，首先两种编辑器的切换麻烦；二是写html时压力很大，总觉得是在写xtend代码，怕输错引起编译错误。在尝试过程中，总感觉到急躁。2.  不知是Dcevm不够成熟，还是run-jetty-run没配好，有时候修改了代码，却没有生效，让我总在猜测是代码写得有问题还是工具有问题，最终不断重启run-jetty-run3.  当我修改了代码时，livereload会马上触发浏览器刷新操作，但这时jetty还没有拿到编译后的代码，页面上显示的还是之前的内容。必须再次手动刷新浏览器才能看到效果，livereload完全没起作用。4.  Xtend的editor支持不够好，离java还有些距离&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后放弃，因为感觉不舒服，也许需要等到这些工具比较成熟时，才适合采用这种方式。&lt;/p&gt;
&lt;p&gt;最后要说的是：Xtend的google group比较热心，我每次提问，都会有人很快给出帮助。感谢。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用Python实现“信息更新上传工具”(5) — Python+PySide打包成绿色版</title>
                <link>http://freewind.in/posts/767-use-python-to-write-a-tool-to-upload-data-5</link>
                <pubDate>Mon, 20 Feb 2012 22:59:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">767</guid>
                <description><![CDATA[&lt;p&gt;使用PySide写了一个简单的GUI程序，可以在安装了python和QT的环境中正常运行，那么，能否把它打包成绿色版，在没有安装python和qt的环境中运行呢？如果可以，文件一共有多少呢？&lt;/p&gt;
&lt;p&gt;经过尝试，终于成功，文件大小为23.2M，列表如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PySide.QtCore.pyd
&lt;br  /&gt;PySide.QtGui.pyd
&lt;br  /&gt;QtCore4.dll
&lt;br  /&gt;QtGui4.dll
&lt;br  /&gt;_hashlib.pyd
&lt;br  /&gt;bz2.pyd
&lt;br  /&gt;library.zip
&lt;br  /&gt;main.exe
&lt;br  /&gt;pyside-python2.7.dll
&lt;br  /&gt;python27.dll
&lt;br  /&gt;select.pyd
&lt;br  /&gt;shiboken-python2.7.dll
&lt;br  /&gt;unicodedata.pyd
&lt;br  /&gt;w9xpopen.exe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面的main.exe是我写的main.py转换后的文件，其它的，python27.dll是python库，QtGui4.dll和QtCore4.dll是Qt4里的库，PySide.QtCore.pyd和PySide.QtGui.pyd是PySide的库，还有其它的一些，总之，现在可以在一台普通的winxp上运行了。效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/767-1.png&quot;&gt;&lt;img src=&quot;/user_images/767-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然功能还比较简单，而且后来还有一个黑色的cmd窗口，但是起码证明这种方式是可行的。而且把它们打成一个zip包之后，大小不到10M，也在可以接受的范围内。&lt;/p&gt;
&lt;p&gt;非常开心：）&lt;/p&gt;
&lt;h2&gt;打包方法&lt;/h2&gt;
&lt;p&gt;忘了说，使用的是一个叫py2exe的程序搞定的，官网：&lt;a href=&quot;http://www.py2exe.org/&quot;&gt;http://www.py2exe.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用法见：&lt;a href=&quot;http://www.py2exe.org/&quot;&gt;http://www.py2exe.org/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先保证所写的python程序可以正常执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装py2exe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;写一个setup.py文件，放到要打包的程序的同级，内容如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;&lt;p&gt;from distutils.core import setup
&lt;br  /&gt;import py2exe&lt;/p&gt;
&lt;p&gt;setup(console=[&apos;hello.py&apos;])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中的hello.py就是要打包的文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;python setup.py py2exe&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;期间如果提示说找不到msvcp90.dll这个文件，可以从别处找一个，放到python27/DLLs目录下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一切正常，则会在当前目录下生成一个dist目录，里面包含了所有需要的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把dist目录拷贝到一台没有安装python/qt的电脑上，看是否能正常运行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>使用Python实现“信息更新上传工具”(4)</title>
                <link>http://freewind.in/posts/764-use-python-to-write-a-tool-to-upload-data-4</link>
                <pubDate>Mon, 20 Feb 2012 22:49:27 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">764</guid>
                <description><![CDATA[&lt;h2&gt;1. PyCharm&lt;/h2&gt;
&lt;p&gt;在用PyCharm编写PySide代码的时候，发现提示功能很弱。不论是方法还是参数，都几乎没用提示。选中一个方法后，想跳到它的源代码，也做不到。&lt;/p&gt;
&lt;p&gt;我一开始以为自己的设置有问题，或者PyCharm不够强，想找一个更强大的工具，毕竟没有提示的话，只能靠看文档或者猜，太累了。但我把PySide的代码下载下来之后，发现有点不对劲，因为里面没多少py文件，cpp和xml倒是很多。PySide不是让Python使用QT的库吗，怎么没有Python代码呢？&lt;/p&gt;
&lt;p&gt;打开安装到Python中的PySide，看到了一大堆的.pyc和.pyd，就是没有.py。其中有一个QtGui.pyd有6M多，很可疑。经过研究，发现原来PySide本身本不是用Python写的，而是在xml中定义了很多类与方法的接口，再用工具转成.pyd文件。这里可能不准确，但原理差不多，总之我们看到不Python源代码，PyCharm也没有办法进行提示了。&lt;/p&gt;
&lt;p&gt;听说有一些IDE可以提示PyQt的方法（PySide的api跟PyQt基本一致），比如Eric之类，但我试用了一下，没找到该功能，而且使用方法很不习惯，还是回到了PyCharm了。&lt;/p&gt;
&lt;p&gt;看来只有多看文档多背API了。&lt;/p&gt;
&lt;p&gt;参见：&lt;a href=&quot;http://stackoverflow.com/questions/9358897/what-can-i-do-to-let-pycharm-find-the-source-of-pyside&quot;&gt;http://stackoverflow.com/questions/9358897/what-can-i-do-to-let-pycharm-find-the-source-of-pyside&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2. PyDev&lt;/h2&gt;
&lt;p&gt;听说PyDev可以导入一个.api文件，就能很好的支持PyQt4了，非常向往，于是安装了PyDev。&lt;/p&gt;
&lt;p&gt;装好后试用，发现对于PySide的提示，要比PyCharm好一点。例如，如果import语句是这样的话：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;from PySide.QtGui import *&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就可以在生成一个QLabel后，在提示中找到resize方法。而在这PyCharm中做不到。&lt;/p&gt;
&lt;p&gt;然后，我按照这个文档的提示，去添加那个*.api：&lt;a href=&quot;http://pydev.org/manual_101_interpreter.html&quot;&gt;http://pydev.org/manual_101_interpreter.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我想，只要能装上PyQt4的api，我只需要把文件里的PyQt4改成PySide，应该也能对PySide进行提示了。然后可惜的是，不论我怎么试，提示都不生效，连PyQt4的都没有。&lt;/p&gt;
&lt;p&gt;一怒之下，还是用PyCharm，不差你那两个提示。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Python中的is</title>
                <link>http://freewind.in/posts/762-the-is-in-python</link>
                <pubDate>Mon, 20 Feb 2012 21:21:22 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">762</guid>
                <description><![CDATA[&lt;p&gt;话说发现一个奇怪的问题，我还以为找到了IDLE的bug，兴奋不已，原来是已经讨论过千百遍的问题。&lt;/p&gt;
&lt;p&gt;事情是这样的。在IDLE下运行这段代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;a = &amp;ldquo;aaa&amp;rdquo;
&lt;br  /&gt;b = &amp;ldquo;aaa&amp;rdquo;
&lt;br  /&gt;print a is b&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print a == b&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print &amp;ldquo;%s , %s&amp;rdquo; % (id(a), id(b))&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;43872224 , 43872224

都是True，挺正常的。但是一旦字符串里有了个空格：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;x = &amp;ldquo;x x&amp;rdquo;
&lt;br  /&gt;y = &amp;ldquo;x x&amp;rdquo;
&lt;br  /&gt;print x is y&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print x == y&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;print &amp;ldquo;%s , %s&amp;rdquo; % (id(x), id(y))&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;43872008 , 43872128

就变成False了。
把这些代码打到PyCharm里，却都是True，这是怎么回事呢？难道是IDLE的BUG?
经过在群里的讨论和stackoverflow上的提问与搜索，发现原来python只保证-5到256之间的整数，用is比较会返回true，其它情况下的行为没有规定。不同的编辑器可以有不同的实现，我们不能依赖它去判断，而应该用id(x)这个方法。
那我们应该什么时候使用is呢？在与python提供的内置对象进行比较时，可以用它，比如：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;if a is None:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    pass&amp;lt;/font&amp;gt;
更多讨论参考：
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9361341/compare-two-same-strings-but-get-different-results-in-idle&quot;&gt;http://stackoverflow.com/questions/9361341/compare-two-same-strings-but-get-different-results-in-idle&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用Python实现“信息更新上传工具”(3)</title>
                <link>http://freewind.in/posts/745-use-python-to-write-a-tool-to-upload-data-3</link>
                <pubDate>Mon, 20 Feb 2012 14:29:17 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">745</guid>
                <description><![CDATA[&lt;h2&gt;1. 代码中有中文，运行时提示错误：&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;SyntaxError: Non-ASCII character &apos;\xe7&amp;#8242; in file c:/test/main.py on line 14, but no encoding declared; see &lt;a href=&quot;http://www.python.org/peps/pep-0263.html&quot;&gt;http://www.python.org/peps/pep-0263.html&lt;/a&gt; for details&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要在文件最前面加上一行注释，指明字符集：&lt;/p&gt;
&lt;blockquote&gt;&lt;h1&gt;&amp;#8212; encoding: UTF-8 -&lt;/h1&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. 代码中的中文在GUI上显示为乱码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-1.png&quot;&gt;&lt;img src=&quot;/user_images/745-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种情况，需要在字符串前面加上一个u:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-3.png&quot;&gt;&lt;img src=&quot;/user_images/745-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3. 如何设置窗口的大小&lt;/h2&gt;
&lt;p&gt;我一直在找怎样在初始化一个窗口时，指定width/height，但是找了好久也没找到。最后在群友的帮助下，发现只能使用resize(width, height)这个方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-5.png&quot;&gt;&lt;img src=&quot;/user_images/745-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;４.如何让窗口居中&lt;/h2&gt;
&lt;p&gt;默认窗口的打开位置是在屏幕的左上方（但又不在角上），如何让它默认居中呢？&lt;/p&gt;
&lt;p&gt;只找到一个麻烦的方法来实现这个功能：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def center(self):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qr = self.frameGeometry()       
cp = gui.QDesktopWidget().availableGeometry().center()       
qr.moveCenter(cp)       
self.move(qr.topLeft())       
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道有没有更好的办法，见&lt;a href=&quot;http://stackoverflow.com/questions/9357944/how-to-make-a-widget-in-the-center-of-the-screen-in-pyside-pyqt&quot;&gt;stackoverflow上的提问&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;5. 如何添加菜单&lt;/h2&gt;
&lt;p&gt;显示在菜单栏上的菜单叫Menu，下拉出来的叫Action。&lt;/p&gt;
&lt;p&gt;先看这个效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-7.png&quot;&gt;&lt;img src=&quot;/user_images/745-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应的代码如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def createMenus(self):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self.loginMenu = self.menuBar().addMenu(u&quot;登录&quot;)      
self.loginMenu.addAction(gui.QAction(u&quot;登录&quot;, self, statusTip=u&quot;登录到数组网(shuzu.org)&quot;, triggered=self.login))

self.dataMenu = self.menuBar().addMenu(u&quot;数据&quot;)     
self.dataMenu.addAction(gui.QAction(u&quot;下载数据&quot;, self, statusTip=u&quot;从服务器下载数据&quot;, triggered=self.downloadData))      
self.dataMenu.addAction(gui.QAction(u&quot;上传数据&quot;, self, statusTip=u&quot;将新增或修改的数据上传到服务器&quot;, triggered=self.uploadData))      
self.dataMenu.addAction(gui.QAction(u&quot;导入数据&quot;, self, statusTip=u&quot;将QQ聊天记录导出文件(Mht格式）数据导入进来&quot;, triggered=self.importData))      
self.dataMenu.addAction(gui.QAction(u&quot;重置数据&quot;, self, statusTip=u&quot;取消所有本地导入或修改&quot;, triggered=self.resetData))      
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中triggered对应的是类中定义的其它方法，在菜单被点击时调用。&lt;/p&gt;
&lt;h2&gt;6. 如何在中间区域增加一个表格&lt;/h2&gt;
&lt;p&gt;如果仅仅生成一个QTableWidget对象，效果将成杯具：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-9.png&quot;&gt;&lt;img src=&quot;/user_images/745-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;应该这么做。首先生成一个QTableWidget：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def createTable(self):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;self.table = gui.QTableWidget(10, 4)      
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;再把它放到一个layout里，赋给一个没什么用的widget，最后设为central widget：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def layout(self):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mainLayout = gui.QVBoxLayout()      
mainLayout.addWidget(self.table)      
dummy = gui.QWidget()      
dummy.setLayout(mainLayout)      
self.setCentralWidget(dummy)      
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-11.png&quot;&gt;&lt;img src=&quot;/user_images/745-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;7. 设置表头&lt;/h2&gt;
&lt;p&gt;表头是几个数字，把它换成其它文字：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;self.table.setHorizontalHeaderLabels([u&quot;日期&amp;rdquo;, u&quot;时间&amp;rdquo;, u&quot;用户&amp;rdquo;, u&quot;内容&amp;rdquo;])&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-13.png&quot;&gt;&lt;img src=&quot;/user_images/745-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;8. 设置表格与外面之间的边距&lt;/h2&gt;
&lt;p&gt;为了突出效果，设个比较大的：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;mainLayout.setContentsMargins(25, 25, 25, 25)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-15.png&quot;&gt;&lt;img src=&quot;/user_images/745-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实际上设的是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;mainLayout.setContentsMargins(5, 5, 5, 5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;9. 如何设置某列的宽度&lt;/h2&gt;
&lt;p&gt;默认各列是等宽的，如何让“内容”那一列宽一些呢？&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;self.table.setColumnWidth(3, 500)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/745-17.png&quot;&gt;&lt;img src=&quot;/user_images/745-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;10. 如何向表中插入数据&lt;/h2&gt;
&lt;p&gt;这个与我预想的不同，我以为可以方便的table.insertRow([&amp;ldquo;aaa&amp;rdquo;,&amp;ldquo;bbb&amp;rdquo;])，可惜要这么做：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;row = self.table.rowCount()
&lt;br  /&gt;self.table.insertRow(row)
&lt;br  /&gt;self.table.setItem(row, 0, gui.QTableWidgetItem(&amp;ldquo;aaa&amp;rdquo;))
&lt;br  /&gt;self.table.setItem(row, 1, gui.QTableWidgetItem(&amp;ldquo;bbb&amp;rdquo;))
&lt;br  /&gt;self.table.setItem(row, 2, gui.QTableWidgetItem(&amp;ldquo;ccc&amp;rdquo;))
&lt;br  /&gt;self.table.setItem(row, 3, gui.QTableWidgetItem(&amp;ldquo;ddd&amp;rdquo;))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先插入一行，再依次给每个单元格里设置数据，有点麻烦&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用Python实现“信息更新上传工具”(2)</title>
                <link>http://freewind.in/posts/738-use-python-to-write-a-tool-to-upload-data-2</link>
                <pubDate>Mon, 20 Feb 2012 14:15:09 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">738</guid>
                <description><![CDATA[&lt;h2&gt;1. Python 2 vs. Python 3&lt;/h2&gt;
&lt;p&gt;首先要到python.org上下载python，遇到一个难题：下载Python2还是Python3? 

两者之间的语法有不同，不能兼容。经过简单地搜索，决定使用python2，原因很简单：很多python库只支持python2.x，而python的威力就体现在它强大的库上。

马上又遇到一个新的选择：是下载32位还是64位？我用的win7是64位的。最后决定还是下载32位的，因为有一些库只支持32位。

最后下载了python2.x的最新版2.7.2

&lt;/p&gt;
&lt;h2&gt;2. 编辑器&lt;/h2&gt;
&lt;p&gt;鉴于idea用得比较舒服，自然想在idea下写python。但是安装完python插件后，发现它依赖的某几个插件没有提供了，意味着我们不能继续在idea的社区版里使用python了。只好转用Intellij提供的PyCharm，话说这一点Intenllij做的有点不厚道，为了自己的商业产品阉割社区版的功能。&lt;/p&gt;
&lt;p&gt;PyCharm也还算好用，基本功能都有了，但在方法提示上，似乎还有所欠缺。&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;/p&gt;
&lt;h2&gt;3. Python +Tkinter&lt;/h2&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Python中自带了Tkinter这个GUI库。Tkinter是对TCL/TK提供的GUI库的包装，用起来相当简单，但是功能比较弱，界面一般。&lt;/p&gt;
&lt;p&gt;看个Hello,world:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/738-1.png&quot;&gt;&lt;img src=&quot;/user_images/738-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其代码相当简单：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;from Tkinter import *&lt;/p&gt;
&lt;p&gt;root = Tk()
&lt;br  /&gt;label = Label(root, text=&amp;ldquo;Hello, world!&amp;ldquo;)
&lt;br  /&gt;label.pack()
&lt;br  /&gt;root.mainloop()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我本想就使用Tkinter来做，但是很快发现它提供的组件比较少，比如&lt;a href=&quot;http://stackoverflow.com/questions/9348264/can-tkinter-created-an-application-with-tables&quot;&gt;Table等，还需要第三方的库&lt;/a&gt;，考虑到以后不要重新返工，还是使用其它的比较靠谱。&lt;/p&gt;
&lt;p&gt;&lt;div&gt;&lt;/p&gt;
&lt;h2&gt;4. Python + QT&lt;/h2&gt;
&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;QT功能强大，文档非富，还有大公司支持，非常值得一试。它还提供了一个LGPL的License比较好。关于Python的binding，有一个老牌的PyQT，可惜是GPL+商业授权，只好放弃。好在QT自己也提供了一个新的LGPL的binding，叫PySide，它的API与PyQt相似，甚至可直接把PyQt的示例拿过来用。看了一下它提供的例子，效果非常满意：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/738-3.png&quot;&gt;&lt;img src=&quot;/user_images/738-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没错，写的是PyQt Examples，但是实际上是在PySide下运行，里面的例子效果很不错。我需要的Table在这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/738-5.png&quot;&gt;&lt;img src=&quot;/user_images/738-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里是一个PySide的Hello,world:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;import sys
&lt;br  /&gt;import PySide
&lt;br  /&gt;from PySide.QtCore import *
&lt;br  /&gt;from PySide .QtGui import *&lt;/p&gt;
&lt;p&gt;app = QApplication(sys.argv)
&lt;br  /&gt;label = QLabel(&amp;ldquo;Hello, world&amp;rdquo;)
&lt;br  /&gt;label.show()&lt;/p&gt;
&lt;p&gt;app.exec_()
&lt;br  /&gt;sys.exit()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出代码非常简单，跟Tkinter很像，很喜欢。&lt;/p&gt;
&lt;p&gt;现在唯一担心的就是，将Python+PySide+QT打包之后的绿色版软件体积有多大，光那个Qt的dll好像就8M多。这个等这两天试验一下，如果体积太大的话，就改用Python+wxWidgets吧。&lt;/p&gt;
&lt;h2&gt;5. Python + wxWidgets&lt;/h2&gt;
&lt;p&gt;这个binding叫wxpython，官网是&lt;a href=&quot;http://wxpython.org&quot;&gt;http://wxpython.org&lt;/a&gt;，它跟wxWidgets一样，也有LGPL的授权。&lt;/p&gt;
&lt;p&gt;代码也比较简单，看下面这个Hello, world:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;import wx&lt;/p&gt;
&lt;p&gt;app = wx.App(False)
&lt;br  /&gt;frame = wx.Frame(None, wx.ID_ANY, &amp;ldquo;Hello World&amp;rdquo;)
&lt;br  /&gt;frame.Show(True)
&lt;br  /&gt;app.MainLoop()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我十分不习惯的是方法名是大写的，感觉很别扭。wxWidgets与QT比较相似，但是没有那么好的运气被大公司收购，所以还是先尝试QT吧。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用Python实现“信息更新上传工具”(1)</title>
                <link>http://freewind.in/posts/731-use-python-to-write-a-tool-to-upload-data-1</link>
                <pubDate>Sun, 19 Feb 2012 22:47:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">731</guid>
                <description><![CDATA[&lt;p&gt;我正在动手做一个技术群网站，其中有一个功能，可以把QQ群里的聊天记录上传到网站上，以方便查看搜索。同时因为每个人的聊天记录都可能是不完整的，所以我打算提供一个功能：可以让不同的人上传记录，将信息合并在一起，组成一个完整的记录。开始没打算做什么工具，直接在网站上搞定，但是很快发现了一个大问题：QQ只能导出全部聊天记录，而不能分时段导出。一个大点的记录就有几十M，每次上传这么多，岂不是要人命？最终决定做一个GUI工具，可以在本地导入数据，最后将新增的数据上传到服务器上，这样让操作简单很多。&lt;/p&gt;
&lt;p&gt;该工具的功能有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入网站上注册的用户名和密码，登录&lt;/li&gt;
&lt;li&gt;获取用户加入的所有组，让用户选择一个处理&lt;/li&gt;
&lt;li&gt;下载该组已有的全部信息（只下载文本，以减少数据量）&lt;/li&gt;
&lt;li&gt;导入QQ聊天记录文件&lt;/li&gt;
&lt;li&gt;自动判断，以找出“新增的”和“修改的”&lt;/li&gt;
&lt;li&gt;上传“新增和修改”的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我应该用什么语言和工具来实现呢？&lt;/p&gt;
&lt;h2&gt;1. Java&lt;/h2&gt;
&lt;p&gt;对于我来说，Java是第一考虑的语言。虽然有必须安装JVM的不便，我还是打算先用swing来做。在Swing Builder的帮助下，界面很快画出来了，但是在表格的处理上遇到了很多麻烦。比如我想调整表格列的宽度，对着例子调了半天也没调好。在认真看完table相关的文档后，我不得不承认，swing真是太复杂了。拿table这块来说，一个table，有TableModel，有ColumnModel，还有什么View，代码繁琐，让人无比头大。上网看了一下，果然发现很多人都在抱怨说swing的设计在现在来说已经相当落伍了，落伍与否我不是很关心，但是编写起来太繁琐，就让人无法忍受了。

&lt;/p&gt;
&lt;p&gt;GUI是Java的弱项，也是我的弱项。我一直想学一门能脱离JVM的语言来编写GUI程序，所以打算以此为机会，学习一门新的技术。&lt;/p&gt;
&lt;h2&gt;2. C/C++&lt;/h2&gt;
&lt;p&gt;我一直想重新拾起c，再学学c++，毕竟做GUI程序，c++可谓是最常见的选择，我们常用的各软件基本上都是用C++做出来的。我先看了一本“用实例学习C语言”的书，发现C语言太底层了，大部分的代码都用来实现一些最基本的功能，真正用来实现功能的代码反而不多，开发效率很低，对于开发非系统程序并不是一个好选择。而C++，在某论坛中看到一些很多人对它的吐槽，说没有十年都不能算掌握c++。它功能强大，性能很好，但里面有太多的陷阱，不是短时间内能学好的。虽然买了本《C++ GUI QT4 编程》，看起来不难，但估计一旦深入，就会头疼了。经过考虑，我想还是先放过它吧。&lt;/p&gt;
&lt;h2&gt;3. Python&lt;/h2&gt;
&lt;p&gt;最后想到了Python，觉得它才是最适合我的，赶紧捡起来。QT/wxWidgets都提供了Python的绑定，我们可以用Python来调用它们的库，编写GUI程序。同时python是跨平台的，而且可以与程序打包在一起，这表示可以弄成绿色版的，客户端不用安装什么。现在唯一的担心就是，打包后的程序会比较大。我打算先使用QT，如果打包后的程序在20M以内，就可接受，否则要换用wxWidgets，或者其它的了。

今天开始用Python来实现该工具，同时记录下开发过程中遇到的问题。
&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala中Iterator的比较</title>
                <link>http://freewind.in/posts/728-how-to-compare-iterator-in-scala</link>
                <pubDate>Sat, 11 Feb 2012 21:58:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">728</guid>
                <description><![CDATA[&lt;p&gt;这是老猪布置的作业：在scala中，如何比较两个iterator是否相等。&lt;/p&gt;
&lt;p&gt;Scala中的Iterator，可用来依次取下一个数据。比如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;scala&gt; val it = List(&amp;ldquo;aaa&amp;rdquo;,&amp;ldquo;bbb&amp;rdquo;,&amp;ldquo;ccc&amp;rdquo;).iterator
&lt;br  /&gt;it: Iterator[java.lang.String] = non-empty iterator&lt;/p&gt;
&lt;p&gt;scala&gt; it.next
&lt;br  /&gt;res1: java.lang.String = aaa&lt;/p&gt;
&lt;p&gt;scala&gt; it.next
&lt;br  /&gt;res2: java.lang.String = bbb&lt;/p&gt;
&lt;p&gt;scala&gt; it.next
&lt;br  /&gt;res3: java.lang.String = ccc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它有一个特点，叫TraversableOnce，就像单行道，只能向前走，不能回头。甚至像size这样的方法，一旦调用，iterator内部指针就跑到最尾，不能再用只能丢了。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;scala&gt; val it = List(&amp;ldquo;aaa&amp;rdquo;,&amp;ldquo;bbb&amp;rdquo;,&amp;ldquo;ccc&amp;rdquo;).iterator
&lt;br  /&gt;it: Iterator[java.lang.String] = non-empty iterator&lt;/p&gt;
&lt;p&gt;scala&gt; it.size
&lt;br  /&gt;res4: Int = 3&lt;/p&gt;
&lt;p&gt;scala&gt; it.next
&lt;br  /&gt;java.util.NoSuchElementException: next on empty iterator&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    at scala.collection.Iterator$$anon$3.next(Iterator.scala:28)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以在比较两个iterator时，必须考虑这一点。&lt;/p&gt;
&lt;p&gt;是否可以直接通过==来比较？比如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;it1 == it2&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案是不行。不知道Iterator的equals方法内部是如何实现的，但是对于两个相等的Iterators，它返回的是false&lt;/p&gt;
&lt;p&gt;目前只想到三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Iterator本身提供的sameElements方法，用来比较两个iterator是否相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把它们转为集合，如it.toList，再比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手动遍历两个Iterator，依次比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;object IteratorCmp {&lt;/p&gt;
&lt;p&gt;def compare1(it1: Iterator[String], it2: Iterator[String]): Boolean = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;it1.toList == it2.toList       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def compare2(it1: Iterator[String], it2: Iterator[String]): Boolean = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;it1 sameElements it2       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def compare3(it1: Iterator[String], it2: Iterator[String]): Boolean = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (it1.hasNext) {       
  if (!it2.hasNext) return false       
  if (it1.next != it2.next) {       
    return false       
  }       
}       
return !it2.hasNext       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def main(args: Array[String]) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val list1 = List(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;, &quot;fff&quot;, &quot;ggg&quot;, &quot;hhh&quot;)       
val list2 = List(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;, &quot;fff&quot;, &quot;ggg&quot;, &quot;hhh&quot;)       
val list3 = List(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;, &quot;fff&quot;, &quot;ggg&quot;)       
val list4 = List(&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;, &quot;eee&quot;, &quot;fff&quot;, &quot;ggg&quot;, &quot;hhh&quot;, &quot;iii&quot;)

test(compare1(list1.iterator, list2.iterator))      
test(compare2(list1.iterator, list2.iterator))       
test(compare3(list1.iterator, list2.iterator))

test(compare1(list1.iterator, list3.iterator))      
test(compare2(list1.iterator, list3.iterator))       
test(compare3(list1.iterator, list3.iterator))

test(compare1(list1.iterator, list4.iterator))      
test(compare2(list1.iterator, list4.iterator))       
test(compare3(list1.iterator, list4.iterator))       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;def test(runnable: =&gt; Boolean) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var result = false       
val start = System.nanoTime       
for (i &amp;lt;- 1 to 100000) {       
  result = runnable       
}       
val end = System.nanoTime       
println(result + &quot; ==&amp;gt; Cost: &quot; + (end - start) / 1000000.0 + &quot; ms&quot;)       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;true ==&gt; Cost: 150.555308 ms
&lt;br  /&gt;true ==&gt; Cost: 96.055434 ms
&lt;br  /&gt;true ==&gt; Cost: 90.490901 ms
&lt;br  /&gt;false ==&gt; Cost: 124.912105 ms
&lt;br  /&gt;false ==&gt; Cost: 82.382677 ms
&lt;br  /&gt;false ==&gt; Cost: 86.721566 ms
&lt;br  /&gt;false ==&gt; Cost: 136.254817 ms
&lt;br  /&gt;false ==&gt; Cost: 92.202501 ms
&lt;br  /&gt;false ==&gt; Cost: 88.270367 ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，toList的方法用的时间最长，其它两种差不多。&lt;/p&gt;
&lt;p&gt;不知道有没有其它更好的方法来比较，欢迎推荐：）&lt;/p&gt;
&lt;p&gt;注：老猪最后给出了一种更加函数式风格的代码，如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def eq_?[T](i1: Iterator[T], i2: Iterator[T]) = !i1.exists{e =&gt;
&lt;br  /&gt;!i2.hasNext || e != i2.next || (!i1.hasNext &amp;amp;&amp;amp; i2.hasNext)
&lt;br  /&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中没有用while等，代码更加紧凑流畅。&lt;/p&gt;
&lt;p&gt;另外发现sameElements的实现，与我的代码比较相似，只是看起来更加清楚简洁一些：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def sameElements(that: Iterator[_]): Boolean = {
&lt;br  /&gt;while (hasNext &amp;amp;&amp;amp; that.hasNext)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (next != that.next)       
  return false       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;!hasNext &amp;amp;&amp;amp; !that.hasNext
&lt;br  /&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过在性能上，我的第三种方法，在大多数情况下是最快的，因为里面的第一个return，能让代码更快的返回。&lt;/p&gt;
&lt;p&gt;最后感谢老猪的指导。&lt;/p&gt;
&lt;p&gt;更新：在stackoverflow.com上提了问，见：&lt;a href=&quot;http://stackoverflow.com/questions/9240936/how-to-compare-two-iterators-in-scala&quot;&gt;http://stackoverflow.com/questions/9240936/how-to-compare-two-iterators-in-scala&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有网友给出了其它的写法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用zip&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;def compare(it1:Iterator[String], it2:Iterator[String]) = {
&amp;lt;br /&amp;gt;it1.zip(it2).forall(x =&amp;gt; x._1 == x._2) &amp;amp;&amp;amp;
&amp;lt;br /&amp;gt;(it1.length == it2.length)
&amp;lt;br /&amp;gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;2. 使用递归&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;def compare(it1:Iterator[String], it2:Iterator[String]) : Boolean = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  (it1 hasNext, it2 hasNext) match{
    case (true, true) =&amp;gt; (it1.next == it2.next) &amp;amp;&amp;amp; compare(it1, it2)
    case (false, false) =&amp;gt; true
    case _ =&amp;gt; false
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;pre&gt;```&lt;/p&gt;
&lt;/blockquote&gt;
]]></description>
            </item>
        
            <item>
                <title>base标签解决了模板系统与静态页面生成的难题</title>
                <link>http://freewind.in/posts/727-use-base-tag-to-solve-the-problem-of-generating-static-pages-from-templates</link>
                <pubDate>Sat, 11 Feb 2012 14:09:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">727</guid>
                <description><![CDATA[&lt;p&gt;网站群项目中，有一个重要的功能点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户通过我们提供的一些jsp标签，自己制作页面模板&lt;/li&gt;
&lt;li&gt;系统根据用户制作的模板，生成静态化网站，可上传到任一http服务器供浏览&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里有一个难题：页面中引用的图片、css/js等资源文件的路径难以处理&lt;/p&gt;
&lt;p&gt;具体来说有以下几点：&lt;/p&gt;
&lt;p&gt;一、用户制作模板页面时，使用dreamweaver。为了能够实时看到效果，页面在引用图片等资源文件时，是以相对路径来取值。这里假定目录结构为：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;index.html&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;category.html&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;article.html&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/images/&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/js/&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/css/&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/others/&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，各html模板页面，都处于根目录下，之间为平级结构。各资源文件根据种类不同，放在不同的目录下。所以在html中引用它们的时候，一般都是写成：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;img src=&quot;images /1.jpg&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;div style=&quot;background:url(images /theme/top.gif)&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从中可见，不论是在html标签中，css定义中，甚至是js中，都是直接使用如&quot;images/??&amp;ldquo;这样直接以&quot;images&quot;开头的相对路径方式来引用的。这种方式可以让dreamweaver找到正确的资源文件，正常显示。&lt;/p&gt;
&lt;p&gt;二、系统在生成静态网站时，为了提供友好的url格式，各模板页面对应的url层次可能不再是平级，某些页面就不能正确的找到资源文件了&lt;/p&gt;
&lt;p&gt;假设该站点中的某些url如下所示：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;首页：      &lt;a href=&quot;http://xxx.com/jsj/index.html&quot;&gt;http://xxx.com/jsj/index.html&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;栏目页：  &lt;a href=&quot;http://xxx.com/jsj/categories/news/index.html&quot;&gt;http://xxx.com/jsj/categories/news/index.html&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;文章页：  &lt;a href=&quot;http://xxx.com/jsj/categories/news/11111.html&quot;&gt;http://xxx.com/jsj/categories/news/11111.html&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从中可以看出，代表栏目与文章的url，它们比首页多了两层。如果现在它们已经是静态化的网站，则其目录结构应该为：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;index.html&lt;/p&gt;
&lt;p&gt;/categories/news/index.html&lt;/p&gt;
&lt;p&gt;/categories/news/11111.html&lt;/p&gt;
&lt;p&gt;/images/&lt;/p&gt;
&lt;p&gt;/js/&lt;/p&gt;
&lt;p&gt;/css/&lt;/p&gt;
&lt;p&gt;/others/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们在生成静态页面时，没有手动对其引用的图片地址进行处理，那么&amp;rdquo;/categories/news/index.html&quot;与&amp;rdquo;/categories/news/11111.html&quot;都无法找到正确的图片或其它资源了。因为资源文件都在根目录下，而它们只会在自己所在的目录中去寻找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、让用户写模板时，在资源文件路径前增加一些可供后台处理的标记，例如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;img src=&quot;${urlPrefix} /images/1.jpg&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在生成静态网站时，在后台根据url的不同，生成不同的urlPrefix来填充，以生成正确的url。&lt;/p&gt;
&lt;p&gt;这种方法在解决问题的时候，带来了一个更大的问题：用户在使用dreamweaver做页面时，无法实时看到效果！因为不论是图片，还是css/js文件，加了${urlPrefix}的路径dreamweaver都无法识别，所以没法看到效果。这是无法接受的。所以这种方法不可行。&lt;/p&gt;
&lt;p&gt;二、重新定义模板目录结构，让它满足生成的url之间的层次关系。对于此处的例子来说，应该是这样：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;index.html&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/&lt;em&gt;level1&lt;/em&gt;/&lt;em&gt;level2&lt;/em&gt;/category.html&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/&lt;em&gt;level1&lt;/em&gt;/&lt;em&gt;level2&lt;/em&gt;/article.html&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/images/&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/js/&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/css/&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;/others/&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到&quot;category.html&quot;与&quot;article.html&quot;两个模板文件，现在都处于第三层，它们与资源文件之间的关系，跟最终生成的url的关系是一样的。这样，在做模板的过程中，如果想引用一个图片，就会写成：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;img src=&quot;.. /../images/1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样生成的静态页面，也可以找到正确的图片。看起来不错，但是有一个小问题和一个大问题。&lt;/p&gt;
&lt;p&gt;小问题是，如果有一天，url的层次结构变了，比如，现在是&lt;a href=&quot;http://xxx.com/categories/news/index.html&quot;&gt;http://xxx.com/categories/news/index.html&lt;/a&gt;，以后变成了&lt;a href=&quot;http://xxx.com/news/index.html&quot;&gt;http://xxx.com/news/index.html&lt;/a&gt;，怎么办？我们必须手动把所有的模板文件中的&amp;rdquo;../../&amp;ldquo;改为&amp;rdquo;../&amp;ldquo;，这个工作量相当大，而且很容易出错。&lt;/p&gt;
&lt;p&gt;大问题是：我们还提供了一个&quot;import&quot;标签，让模板可以包含另一个模板，以达到重用。&lt;/p&gt;
&lt;p&gt;假设我们现在把导航栏的代码，放在一个叫_navigator.html的文件中，供其它页面引用。这个文件本身，也用到了一些图片：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;img src=&quot;images /1.jpg&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它放在根目录下，其它模板都引用了它。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;index.html:                 &lt;cms:import page=&quot;_navigator.html&quot;  /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;catetgory.html:           &lt;cms:import page=&quot;.. /../_navigator.html&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;index.html:                &lt;cms:import page=&quot;.. /../_navigator.html&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在最终生成的页面中，只有index.html上的导航栏显示正常，category与article都不正常。因为_navigator.html被包含进去后，其引用的图片路径最终都是&lt;img src=&quot;images /1.jpg&quot; /&gt;，对于处于第三层的category与article来说，都不正确。&lt;/p&gt;
&lt;p&gt;这个问题，导致该方案完全不可行。除非不让用import标签。&lt;/p&gt;
&lt;p&gt;三、不对用户模板进行任何限制，而在生成静态页面时，由后台修改各引用路径&lt;/p&gt;
&lt;p&gt;即在生成静态页面时，将category.html所引用的所有资源文件，都修改为&amp;rdquo;../../images/1.jpg&quot;这样，不管它之间是怎么引用的。&lt;/p&gt;
&lt;p&gt;初看时，觉得虽然麻烦点，但是应该还可能实现，因为我们有强大的Jsoup来处理html数据。但真做起来，很快发现行不通，因为实在太麻烦了，还有很多地方无法考虑。&lt;/p&gt;
&lt;p&gt;用户可以在很多地方引用到资源文件，比如像img标签里，style属性里，页面内的css定义中，单独的css文件中，引用的js文件中，甚至js中还可以用拼字符串的形式去引用某文件。这样算下来，我们根本没有办法去正确修改所有的路径，难度实在太大，完全不可行。&lt;/p&gt;
&lt;p&gt;四、使用base标签&lt;/p&gt;
&lt;p&gt;html中有一个base标签，可以让当前页面所有以相对路径方式引用的资源，都以base的href属性中指定的uri作为基准（如果没有base，则以当前页面的uri作为基准）。其使用方法如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;html&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;  &lt;head&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;    &lt;base href=[http: //xxx.com/jsj/](http://xxx.com/jsj/)&quot;&gt;&lt;/base&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;  &lt;/head&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;/html&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，由于IE的bug，光写&lt;base&gt;在IE下是可能出错的，必须在后面加一个&lt;/base&gt;，或者写成&lt;base href=&quot;xxx&quot;  /&gt;这样的形式。&lt;/p&gt;
&lt;p&gt;有了这个base标签，我们可以按照三的思路，但不用修改每一个资源路径，直接修改其base标签的href值即可。比如，首先规定，用户的html模板必须放在根目录下，这样它们引用的资源文件路径实际上都是相对于根目录。然后，在生成的html页面中，把每一页的base，都改为根目录路径（或者首页的访问地址）即可。&lt;/p&gt;
&lt;p&gt;比如，当首页路径为&lt;a href=&quot;http://xxx.com/jsj/index.html&quot;&gt;http://xxx.com/jsj/index.html&lt;/a&gt;时，即可在所有的html页面中都使用以下base:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;base href=&quot;[http: //xxx.com/jsj/index.html](http://xxx.com/jsj/index.html)&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不论最终它们的url有多少层，全都一视同仁，问题解决。&lt;/p&gt;
&lt;p&gt;但马上发现新的问题：页面中的base值写死了，如果我们这些静态页面放在其它服务器上url改变了，或者拷到本地以文件形式查看，怎么办？肯定路径有误。&lt;/p&gt;
&lt;p&gt;好在经过测试，发现base的href中，还支持这样写法:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;base href=&quot;.. /../&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的话，我们只需要在生成页面时，根据url的层级来确定它与首页之间相差几层。如果是首页，将其base改为：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;base href=&quot;.&quot;  /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是第三级，则：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;base href=&quot;.. /../&quot; /&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样，不论是把生成的静态网站放到别的服务器，或者别的url下，或者本地硬盘，都可以正常显示！&lt;/p&gt;
&lt;p&gt;正在高兴，又发现了一个大问题：只有firefox和chrome支持这种相对路径，IE全部都不支持！&lt;/p&gt;
&lt;p&gt;根据w3c的标准，base的href必须是一个“绝对路径的uri”。看来这次IE倒是坚定的支持了标准，可惜这标准用起来太不方便了。&lt;/p&gt;
&lt;p&gt;这下怎么办？IE是必须要支持的浏览器，难道要再换一种解决方案吗？我实在找不到更好的做法了。&lt;/p&gt;
&lt;p&gt;最终，在stackoverflow上提问，有网友提出我们可使用javascript来取得当前的绝对路径，并替换掉base中的相对路径。经测试可行。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9237654/how-to-let-ie-support-html-base-tag-with-relative-href-like-base-href/9237783#9237783&quot;&gt;http://stackoverflow.com/questions/9237654/how-to-let-ie-support-html-base-tag-with-relative-href-like-base-href/9237783#9237783&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网友&lt;a href=&quot;http://stackoverflow.com/users/1164491/cheery&quot;&gt;Cheery&lt;/a&gt;给出一些代码，但是看起来有点太复杂了，特别是那些短变量名，让人看得郁闷。于是我写了一个简单些的代码，经过简单测试没有问题：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;html&gt;
&lt;br  /&gt;&lt;head&gt;
&lt;br  /&gt;&lt;base href=&quot;.. /&quot;&gt;&lt;/base&gt;
&lt;br  /&gt;&lt;!-[if IE]&gt;
&lt;br  /&gt;&lt;script type=&quot;text /javascript&quot;&gt;
&lt;br  /&gt;var baseTag = document.getElementsByTagName(&apos;base&apos;)[0];
&lt;br  /&gt;var loc = location.href;
&lt;br  /&gt;if(baseTag.href.indexOf(&apos;../&apos;)==0 &amp;amp;&amp;amp; loc.replace(&apos;://&apos;, &amp;ldquo;).indexOf(&apos;/&apos;)&gt;0) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseTag.href= location.href.replace(/[/][^/]*$/,&quot;/&quot;) + baseTag.href;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;&lt;/script&gt;
&lt;br  /&gt;&lt;![endif]-&gt;
&lt;br  /&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;
&lt;br  /&gt;&lt;img src=&quot;images /1.jpg&quot; /&gt;
&lt;br  /&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，base中的href还是相对路径，但是在IE下时，将根据当前的url对它进行处理。比如当前为&lt;a href=&quot;http://xxx.com/jsj/categories/news/index.html&quot;&gt;http://xxx.com/jsj/categories/news/index.html&lt;/a&gt;，处理后的base就变为：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&lt;base href=[http: //xxx.com/jsj/categories/news/../](http://xxx.com/jsj/categories/news/../)&gt;&lt;/base&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接以本地文件方式访问该页面，也可以正常显示！现在不论是哪个浏览器，在哪里访问，都正常了。至此问题解决。&lt;/p&gt;
&lt;p&gt;注：据说IE6在其它某些时候，对于base的处理还有些问题。但现在先不考虑这么多，发现问题时再改进。毕竟虽然麻烦，但是我们可以使用js来修复。&lt;/p&gt;
&lt;p&gt;参看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://notes.minty.org/cgi-bin/wiki.pl?Fixing_Base_Href_Javascript_Document.Location_For_Internet_Explorer&quot;&gt;http://notes.minty.org/cgi-bin/wiki.pl?Fixing_Base_Href_Javascript_Document.Location_For_Internet_Explorer&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>如何快速删除postgresql数据库所有的表</title>
                <link>http://freewind.in/posts/726-how-to-delete-all-tables-fast-in-postgresql</link>
                <pubDate>Sun, 05 Feb 2012 16:42:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">726</guid>
                <description><![CDATA[&lt;p&gt;在postgesql中建立一个函数：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;CREATE OR REPLACE FUNCTION truncate_tables(username IN VARCHAR) RETURNS void AS $$
&lt;br  /&gt;DECLARE&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;statements CURSOR FOR      
    SELECT tablename FROM pg_tables      
    WHERE tableowner = username AND schemaname = &apos;public&apos;;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BEGIN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FOR stmt IN statements LOOP      
    EXECUTE &apos;TRUNCATE TABLE &apos; || quote_ident(stmt.tablename) || &apos; CASCADE;&apos;;      
END LOOP;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;END;
&lt;br  /&gt;$$ LANGUAGE plpgsql;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后调用：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;select truncate_tables(&apos;username&apos;)&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;p&gt;可以在单元测试中使用这个方法用于初始化，很方便&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play2下载与安装</title>
                <link>http://freewind.in/posts/724-how-to-download-and-install-play2</link>
                <pubDate>Mon, 30 Jan 2012 06:58:13 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">724</guid>
                <description><![CDATA[&lt;p&gt;这本来不应该成为一个问题，但是因为play2现在还处于beta阶段，有些地方不完善，所以想要“开始”都会遇到一些问题。&lt;/p&gt;
&lt;p&gt;除了直接从play官网下载已经打包好的70多M的解压包外，还可以直接从github上下载源代码并编译。后者的好处时，可以随时通过git获取最新的代码，不需要再下载那么大的解压包。&lt;/p&gt;
&lt;p&gt;但下载后，直接运行play，会报一些“找不到xxx库”这样的错误。几经搜索，终于找到正确的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、下载源代码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;git clone &lt;a href=&quot;https://github.com/playframework/Play20.git&quot; title=&quot;https://github.com/playframework/Play20.git&quot;&gt;https://github.com/playframework/Play20.git&lt;/a&gt; -depth=0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后一个参数是不要下载提交的历史记录，速度快一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、build&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;cd Play20&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;cd framework&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;build publish-local&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时play就会自动下载所需要的各jar并构建了。下载时间比较长，要等几十分钟。&lt;/p&gt;
&lt;p&gt;下载完后，将自动开始编译源代码，如果一切顺利，最后将看到[success]这样的提示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Play&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到play2根目录下，运行&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;play&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将提示正常的信息：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;E:\java\Play20&gt;play
&lt;br  /&gt;Getting play console_2.9.1 2.0-RC1-SNAPSHOT &amp;hellip;
&lt;br  /&gt;:: retrieving :: org.scala-tools.sbt#boot-app&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    confs: [default]      
    5 artifacts copied, 0 already retrieved (5560kB/40ms)      
   _            _      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt; &lt;/em&gt;&lt;em&gt; | | &lt;/em&gt;&lt;em&gt; &lt;/em&gt; &lt;em&gt;  &lt;/em&gt;| |
&lt;br  /&gt;| &apos;&lt;em&gt; \| |/ &lt;/em&gt;&apos; | || |&lt;em&gt;|
&lt;br  /&gt;|  &lt;/em&gt;&lt;em&gt;/|&lt;/em&gt;|_&lt;strong&gt;&lt;em&gt;|_&lt;/em&gt; (&lt;em&gt;)
&lt;br  /&gt;|&lt;/em&gt;|            |&lt;/strong&gt;/&lt;/p&gt;
&lt;p&gt;play! 2.0-RC1-SNAPSHOT, &lt;a href=&quot;http://www.playframework.org&quot;&gt;http://www.playframework.org&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表明一切正常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、将play加入到环境变量path中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、运行示例程序&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;cd samples\scala\zentasks&lt;/p&gt;
&lt;p&gt;play run&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后访问&lt;a href=&quot;http://localhost:9000&quot;&gt;http://localhost:9000&lt;/a&gt;即可看到效果。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Vaadin不方便之处</title>
                <link>http://freewind.in/posts/715-the-inconvenience-of-vaadin</link>
                <pubDate>Sun, 08 Jan 2012 20:07:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">715</guid>
                <description><![CDATA[&lt;p&gt;这也许是Java程序的通病：当代码复杂时，可读性不高。特别是这种与布局相关的代码，使用java完全看不出来组件之间的上下级关系，看着非常累。&lt;/p&gt;
&lt;p&gt;不信的话，看这官方提供的例子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/715-1.png&quot;&gt;&lt;img src=&quot;/user_images/715-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所有的代码都是一块一块的，在同一个层级上排列下来，从代码中很难想像出页面的效果。当代码长一点之后，看起来真是非常痛苦。&lt;/p&gt;
&lt;p&gt;对于布局，最好的方式是像html标签那样，互相嵌套，像树一样清晰。解决方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供可视化设计工具&lt;/li&gt;
&lt;li&gt;用其它语言写一套DSL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;一、可视化设计器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vaadin的eclipse插件中真的提供了一个可视化的设计工具。可在新建文件时选择“Vaadin Composite”即可打开一个可“Design“的页面，效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/715-3.png&quot;&gt;&lt;img src=&quot;/user_images/715-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计器XulRunner的支持，需要先到&lt;a href=&quot;https://developer.mozilla.org/en/XULRunner_1.9_Release_Notes&quot;&gt;https://developer.mozilla.org/en/XULRunner_1.9_Release_Notes&lt;/a&gt;处下载XulRunner，然后还得注册一下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;xulrunner -register-global&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计器看起来还是比较酷的，但是用起来还是不够流畅。首先反应有点慢，拖动起来总觉得很费力，修改属性不太方便。另外，要想快速画出一个满意的布局，还得先好好了解Vaadin的代码用法。试用了一下，感觉短期内掌握有点困难。与Extjs提供的Ext-Designer相比，略差一些。&lt;/p&gt;
&lt;p&gt;它将生成对应的Java代码，在生成的属性或方法上都会加上一个@AutoGenerated注解。然后在它的基础上进行一些修改。&lt;/p&gt;
&lt;p&gt;我感觉这个设计器用用处不大。拖的不爽影响心情，最终还要直面惨淡的Java代码，始终逃不过。所以希望能走第二条路，设计一套DSL，用代码方式直接控制布局。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Scala-wrappers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vaadin有一个Add-on叫scal-wrappers，能让代码嵌套，看起来清楚一些。项目地址在：&lt;a href=&quot;https://github.com/henrikerola/scala-wrappers&quot;&gt;https://github.com/henrikerola/scala-wrappers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给个它自带的例子：&lt;/p&gt;
&lt;p&gt;new GridLayout(columns = 2, rows = 1, width = 560 px, spacing = true,  margin = true, caption = &amp;ldquo;Labels&amp;rdquo;, style = Reindeer.LAYOUT_WHITE) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add(new HtmlLabel(&quot;Header Style (&amp;lt;code&amp;gt;Reindeer.LABEL_H1&amp;lt;/code&amp;gt;)&quot;))    
add(new H1(&quot;Lorem Ipsum&quot;))    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以看到其中的嵌套关系，比之前要清晰一些。&lt;/p&gt;
&lt;p&gt;但是还不够，我希望能写成这样：&lt;/p&gt;
&lt;p&gt;GridLayout(columns = 2, rows = 1, width = 560 px, spacing = true, margin = true, caption = &amp;ldquo;Labels&amp;rdquo;, style = Reindeer.LAYOUT_WHITE) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HtmlLabel(&quot;Header Style (&amp;lt;code&amp;gt;Reindeer.LABEL_H1&amp;lt;/code&amp;gt;)&quot;)    
H1(&quot;Lorem Ipsum&quot;)    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;即可前面的add和new也去掉，这样看起来干扰更少一些。&lt;/p&gt;
&lt;p&gt;这个工作得等我慢慢开始做。有一套好用的DSL，才能提高开发效率。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Xtend试用中发现的各问题</title>
                <link>http://freewind.in/posts/706-problems-found-when-trying-xtend</link>
                <pubDate>Sat, 07 Jan 2012 15:31:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">706</guid>
                <description><![CDATA[&lt;p&gt;今天试用了一下xtend，发现问题多多，记录如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、不支持数组，官方说使用newArrayList()代替&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、生成的java代码不够优化&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;42 + 21&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成的java代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;int _operator_plus = IntegerExtensions.operator_plus(((Integer)42), ((Integer)21));&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;三、不支持char literal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何表示&apos;a&apos;,&apos;\n&apos;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、«和» 怎么方便输入（非eclipse环境）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在eclipse中，可以按&quot;ctrl+shift+,&amp;ldquo;输入« ，按&quot;ctrl+shift+.&amp;ldquo;输入»，但在非eclipse环境中怎么办呢？难怪一定要开着eclipse才能工作？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、集合的语法不友好&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/706-1.png&quot;&gt;&lt;img src=&quot;/user_images/706-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看这里的map和list，是不是让人头晕&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、field不支持类型推断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在方法中可以直接写&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;val x = &amp;ldquo;abc&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但声明field时，必须指明类型：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;String x = &amp;ldquo;abc&amp;rdquo;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;七、遍历一个list时，怎么既得到item又得到index&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java中可以：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;for(int i =0;i&lt;list.size(); i++) {&lt; /font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;String item = list.get(i);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;System.out.println(i + &amp;ldquo;: &quot; + item);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;}&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在xtend中不知道怎么做，因为我们只能：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;for(String item: list) { &amp;hellip; }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;list.forEach [ item | &amp;hellip; ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Index在哪儿？&lt;/p&gt;
&lt;p&gt;最后我写成这样，容易嘛我：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def &amp;lt;T&amp;gt; forEach(Iterable&amp;lt;T&amp;gt; iter, (T, int) =&amp;gt; Object handler)  {    
    val i = new AtomicInteger(0);     
    iter.forEach (item | handler.apply(item, i.getAndAdd(1)))     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;连AtomicInteger都用上了，其实就是想找个可以放int的容器而已&lt;/p&gt;
&lt;p&gt;附上唐古拉山写的，我怎么就忘了直接用for呢？&lt;/p&gt;
&lt;p&gt;&lt;pre&gt;&lt;/p&gt;
&lt;p&gt;def static &lt;T&gt; eachWithIndex(Iterable&lt;T&gt; list, (T, int) =&gt; Object  block){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var index = 0

for(e : list){

    block.apply(e, index) 

    index = index + 1

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**八、不支持内部类**

为了改进这个forEach，我想在方法中定义一个int container，没想到也不支持：

[![image](/user_images/706-3.png &quot;image&quot;)](/user_images/706-3.png)

好吧，我放在外层，还是报错：

[![image](/user_images/706-5.png &quot;image&quot;)](/user_images/706-5.png)

加个static试试？一样的错：

[![image](/user_images/706-7.png &quot;image&quot;)](/user_images/706-7.png)

难道我要为了这个只用一次的类，专门声明一个顶层的类？

**九、不支持代码格式化**

这个功能都没有，真让人郁闷啊。老是要手动调整，真麻烦

**十、不支持自动寻找并导入类**

输入了没有import的类名，按Ctrl+Shift+O没反应，必须手动加上import

**十一、代码提示反应慢**

有时候需要近十秒，比scala的编辑器还慢

**十二、不支持断点、调试**

该功能还正在开发中

经过今天的试用，我认为当前xtend的成熟度还未达到“可用”，不宜在项目中采用。不论是编辑器的支持，还是语言本身的特性，都还有很多需要完善的地方。但对于它已经提出的各种特性，以及直接转换为java源文件的做法，我觉得还是很不错的，但还需要时间。一个成熟好用的语言，果然是得靠时间堆出来。Xtend与scala相比，还差很远。

另一个让我失望的地方在于，xtend曾经说他们的卖点是“良好的编辑器支持”，但是实际上还差很远，不说跟java比，连scala都比不过。
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Vaadin学习笔记(1)</title>
                <link>http://freewind.in/posts/697-notes-vaadin-1</link>
                <pubDate>Sat, 07 Jan 2012 11:23:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">697</guid>
                <description><![CDATA[&lt;p&gt;如同Extjs这样的工具对于做管理后台是非常必要的。管理后台使用人数少，操作多，交互性很强，对控件的功能要求较高。又因为大多是内网操作，所以较大的js库也不是问题。所以像Extjs这样的库，可以很好的满足这样的需求。&lt;/p&gt;
&lt;p&gt;我在寻找一个Extjs的替代品，既能产生功能强大且美观的页面效果，又不必手写Javascript。最后找到了Vaadin，其官网是 &lt;a href=&quot;http://www.vaadin.com&quot;&gt;http://www.vaadin.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Vaadin内部使用了gwt，但提供了一套现代感比较强、比较华丽的主题，控件也很多。通过其官方演示页面就能看到：&lt;a href=&quot;http://demo.vaadin.com/sampler&quot;&gt;http://demo.vaadin.com/sampler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如gwt一样，vaadin也是在后台写java代码，自动生成对应的js代码供浏览器调用。这样的好处是相当明显的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们只需要写Java代码，可以利用编辑器的强大功能以及Java本身的语法特性2.  容易生成可复用的组件，因为我们在写Java，可以封装、继承3.  调试比较容易，可以像调试普通Java代码那样设置断点，单步调试4.  对于同样难度的较复杂的功能，使用Java写比用Javascipt要容易很多，所以可以实现一些较复杂的功能。参看vaadin在线设计器的效果：&lt;a href=&quot;http://demo.vaadin.com/visualdesigner-nightly&quot;&gt;http://demo.vaadin.com/visualdesigner-nightly&lt;/a&gt;5.  可以利用其它语言如scala、xtend等，减化代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vaadin还提供了一个Eclipse插件，以可视化的方式来设计界面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、基本运行方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vaadin程序运行于servlet容器。首先要有一个类继承于com.vaadin.Application，它是程序的入口。例如这个例子：&lt;/p&gt;
&lt;p&gt;import com.vaadin.Application;
&lt;br  /&gt;import com.vaadin.ui.*;&lt;/p&gt;
&lt;p&gt;public class TestvaadinApplication extends Application {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override     
public void init() {     
    Window mainWindow = new Window(&quot;Testvaadin Application&quot;);     
    Label label = new Label(&quot;Hello Vaadin user&quot;);     
    mainWindow.addComponent(label);     
    setMainWindow(mainWindow);     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;它实际上是一个servlet，我们需要在web.xml中定义：&lt;/p&gt;
&lt;p&gt;&lt;servlet&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;TestvaadinApplication&amp;lt;/servlet-name&amp;gt;     
&amp;lt;servlet-class&amp;gt;com.vaadin.terminal.gwt.server.ApplicationServlet&amp;lt;/servlet-class&amp;gt;     
&amp;lt;init-param&amp;gt;     
    &amp;lt;description&amp;gt;Front&amp;lt;/description&amp;gt;     
    &amp;lt;param-name&amp;gt;application&amp;lt;/param-name&amp;gt;     
    &amp;lt;param-value&amp;gt;com.example.testvaadin.TestvaadinApplication&amp;lt;/param-value&amp;gt;     
&amp;lt;/init-param&amp;gt;     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/servlet&gt;
&lt;br  /&gt;&lt;servlet-mapping&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;TestvaadinApplication&amp;lt;/servlet-name&amp;gt;     
&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/servlet-mapping&gt;&lt;/p&gt;
&lt;p&gt;然后在浏览器中访问 &lt;a href=&quot;http://localhost:8080/myapp&quot;&gt;http://localhost:8080/myapp&lt;/a&gt; 即可看到这样的内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/697-1.png&quot;&gt;&lt;img src=&quot;/user_images/697-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、修改后代码后如何生效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我以debug方式运行tomcat，按说只要没有修改类结构，所做的修改应该能马上热部署。&lt;/p&gt;
&lt;p&gt;但奇怪的是，我修改了java代码中一个Label上的文本后，刷新页面，却没有看到任何变化。打开一个新的浏览器访问该页面，却可以看到修改后的内容。这是怎么回事？在vaadin论坛上看到不少人问这个问题，终于弄明白，原来vaadin把很多东西都保存在session中，包括页面上的这些组件的内容等。当修改代码后，虽然后台代码变了，但是保存在session中的内容并没有变，所以只能在新窗口中看到修改变化。&lt;/p&gt;
&lt;p&gt;对于这种情况，除了重启tomcat外，还可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在原url后加上?restartApplication，回车即可2.  在原url后加上?debug，可以打开如下的调试窗口，点击其中的&quot;Restart app&quot;按钮即可&lt;a href=&quot;/user_images/697-3.png&quot;&gt;&lt;img src=&quot;/user_images/697-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然有些不方便，但考虑到vaadin必须以某种方式实现stateful，也只能这样了。好在第二种方法还可以接受，因为那个窗口可以一直存在，不用每次都输入?deubg。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、如何分开前后台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果程序中有几个独立的入口，比如前台和后台分开，通过不同的url访问，应该怎么做？&lt;/p&gt;
&lt;p&gt;可以在程序中为每个入口定义一个类，继承于Application。因为它就相当于一个servet，我们只需要在web.xml中分别定义对应的映射关系即可。&lt;/p&gt;
&lt;p&gt;例如，我们让用户在浏览器中输入/admins时，访问管理后台的页面，怎么做？&lt;/p&gt;
&lt;p&gt;再定义一个类（我这里是用xtend写的）：&lt;/p&gt;
&lt;p&gt;class AdminApplication extends Application {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;override init() {     
    val mainWindow = new Window(&quot;管理平台&quot;);     
    val label = new Label(&quot;你好管理员&quot;);     
    mainWindow.addComponent(label);     
    setMainWindow(mainWindow);     
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;web.xml中也要有相应增加：&lt;/p&gt;
&lt;p&gt;&lt;servlet&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;AdminApplication&amp;lt;/servlet-name&amp;gt;     
&amp;lt;servlet-class&amp;gt;com.vaadin.terminal.gwt.server.ApplicationServlet&amp;lt;/servlet-class&amp;gt;     
&amp;lt;init-param&amp;gt;     
    &amp;lt;description&amp;gt;Admin Panel&amp;lt;/description&amp;gt;     
    &amp;lt;param-name&amp;gt;application&amp;lt;/param-name&amp;gt;     
    &amp;lt;param-value&amp;gt;com.example.testvaadin.AdminApplication&amp;lt;/param-value&amp;gt;     
&amp;lt;/init-param&amp;gt;     
&amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/servlet&gt;
&lt;br  /&gt;&lt;servlet-mapping&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;AdminApplication&amp;lt;/servlet-name&amp;gt;     
&amp;lt;url-pattern&amp;gt;/admins/*&amp;lt;/url-pattern&amp;gt;     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/servlet-mapping&gt;&lt;/p&gt;
&lt;p&gt;重启tomcat后访问：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/697-5.png&quot;&gt;&lt;img src=&quot;/user_images/697-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/697-7.png&quot;&gt;&lt;img src=&quot;/user_images/697-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意url的变化。&lt;/p&gt;
&lt;p&gt;需要注意的是，一定要保证该路径/VAADIN会被vaadin处理。先看一下firebug的记录：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/697-9.png&quot;&gt;&lt;img src=&quot;/user_images/697-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原来vaadin去取那些组件资源时，要访问/VAADIN。所以如果在web.xml中，没有把根目录映射到某个继承于com.vaadin.Application的类时，需要增加类似于下面这样的映射关系：&lt;/p&gt;
&lt;p&gt;&lt;servlet-mapping&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;servlet-name&amp;gt;AdminApplication&amp;lt;/servlet-name&amp;gt;    
&amp;lt;url-pattern&amp;gt;/VAADIN/*&amp;lt;/url-pattern&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/servlet-mapping&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、最简单的页面需要下载多少K资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/697-11.png&quot;&gt;&lt;img src=&quot;/user_images/697-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于一个最简单的页面，需要下载800多K的资源。其中样式表144.5K，而js文件为686.4K，个头还不小。所以只能用于管理后台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、如何与其它框架结合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前所说，vaadin这样的大个头只适合做管理后台，对于前台，还得要用传统的css方案解决。这样必然需要使用另一种框架与vaadin结合。&lt;/p&gt;
&lt;p&gt;如果是springmvc这样的mvc框架比较简单，因为它也是基于servlet，只需要在web.xml中再定义一个入口即可。&lt;/p&gt;
&lt;p&gt;如果是play，因为它默认不是基于servlet的，所以只能分开开发，然后将play的程序打包为war，再将两者合并在一起，修改web.xml，丢在tomcat下。这种方式理论上可行，但是还需要实际测试才行。&lt;/p&gt;
&lt;p&gt;还有一种方式就是，将前后台完全分开，写成两个独立的应用，放在tomcat中。然后将对首页的访问重定向至某一个应用。&lt;/p&gt;
&lt;p&gt;最后的方法是，两个程序完全分开，也不需要都放在tomcat下。在前面用nginx这样的前端通过反向代理，将前后台的请求分别映射到两个应用上。&lt;/p&gt;
&lt;p&gt;这些方法最简单的还是第一种。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Extjs使用感受</title>
                <link>http://freewind.in/posts/682-experience-of-extjs</link>
                <pubDate>Sat, 07 Jan 2012 10:04:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">682</guid>
                <description><![CDATA[&lt;p&gt;在公司做项目时，后台管理页面都是用extjs来写的。这个过程很痛苦，因为手写js代码很容易出错，经常因为写错一个字母标点、少写一个参数，效果死活出不来，还抛一些奇怪的错误。这不能怪我们不细心，因为实在是太容易出错了。调试的过程异常痛苦，因为基本上得靠肉眼一行行地检查，无法发挥机器的优势，一卡就是一两小时。&lt;/p&gt;
&lt;p&gt;这个感觉，在只看Ext那华丽的Demo，或者在动手写代码之前，是很难感受到的。我刚接手这个项目，看到公司其它产品华丽的界面时，在群里还欣喜地跟大家说，“使用Ext做出来的界面真好看，功能真强大”。当时刘松说，他们之前用Ext做项目时，调试过程太痛苦了，后来再也不想碰Ext或类似的js gui框架。我还奇怪，有这么多的Demo可供参考，这么多产品都用它做出来了，还会遇到那么多的问题吗？&lt;/p&gt;
&lt;p&gt;现在果真体会到了。使用Ext做项目，靠的就是经验、记性和眼力，以及时间。Ext中的定义的一个类，初始化参数常常有几十个，传入不同的参数就可以得到不同的效果，不同的参数进行组合又能得到另外的效果。而这些参数只能查文档，编辑器是给不了提示的。但总不能每用到一个类就要去查文档吧，所以要牢记每一个参数和用法，才能加快开发速度，这时要靠记性。在输入参数的过程中，如果参数名里不小心输错一个字母，不会报错，但效果就是出不来，因为那个参数实际上被忽略了。这时只能靠一个个单词去看，跟文档对比，才能找到错误原因，这时要靠眼力。Ext的一些组件（特别是老版本，如我们公司使用的2.x版）在不同的浏览器下会有不同的显示效果，比如fieldstet在IE下正常，在firefox下里面东西全被隐藏了。所以我们还得知道如果去绕开这些bug，这要靠经验。每当遇到一个新bug，或者死活查不出原因的时候，那就只能靠时间去耗了。&lt;/p&gt;
&lt;p&gt;所以，使用Ext，在你在熟读其源代码并且累积了大量的使用经验之前，基本上可当成是体力活，因为可以让机器帮我们完成的事情太少了。&lt;/p&gt;
&lt;p&gt;还有更麻烦的。&lt;/p&gt;
&lt;p&gt;Ext本身是希望以一种面向对象的方式来开发和使用，以实现组件化。但是因为Javascript语言本身的语言特性，这一点在实际使用过程中比较痛苦。在Javascript中，一个function中的this指代的对象实际上是不确定的，它默认是调用者，还可由fun.call与fun.apply的第一个参数决定。所以当你在一个函数中使用this.xxx()这样的方法时要非常小心，因为如果这个函数在其它地方被调用，它很可能就出错了。在写Ext代码时，很多功能都是通过回调函数来实现的，如果在里面调用了外层的某个方法，经常会报错“xx方法未定义”，原因就是this指向的对象错了。&lt;/p&gt;
&lt;p&gt;要解决这个问题，有三种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Ext提供的scope参数，把外层的this赋过去；&lt;/li&gt;
&lt;li&gt;在外层定义一个变量，如var self = this，在里面直接使用self来引用外层对象&lt;/li&gt;
&lt;li&gt;都使用全局变量，直接引用，丢开面向对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种方式都有各自的局限性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一种，每个需要回调的地方，如listeners等，都需要加一个scope:this，很繁琐；当在回调函数中还需要回调，有三四层的时候，那就可怕了，光这些scope就能把人看晕。&lt;/li&gt;
&lt;li&gt;第二种，我们经常是以json的方法去传参数，但有时候没有机会去定义var self=this，或者要在多个地方定义var self。而且在代码中看到self时，还得去找到底它是在哪个地方被定义的，才知道程序到底在调用谁的方法，麻烦。&lt;/li&gt;
&lt;li&gt;第三种，写出来的代码没有条理性，本来是有嵌套关系的，都成了平级，有时候还会发生命名冲突，读起来费劲。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我刚接手项目时，看到里面使用的某些js文件，里面的代码都是用第三种方式写出来的。在阅读的过程中非常痛苦，对了理解那几千行的代码，我花了几天时间才看懂。所以我模仿Ext本身的写法，把一些功能按类的方式组织在一起，看起来清楚多了。我要求几个同事在写Ext的过程中，也按这种方式来写。但是不久就发现，这样实在太容易出错了，随便写两句代码就会报一个“某某方法没定义”的错误，很麻烦。然后改成了第二种，但情况并未好转多少，总在为在哪儿定义var self而发愁。最后又回到了第三种，完全放弃了复用，大家都靠记忆力来写吧。&lt;/p&gt;
&lt;p&gt;在Javascript中按面向对象方式来写代码，是件吃力不讨好的事情。这跟Javascript的语言特性有关。曾经jquery有一个竞争对手叫mootools，它按面向对象的方式来设计api，对于我们Javaer似乎比较有吸引力。但是最终结果大家都知道吧，jquery全胜。&lt;/p&gt;
&lt;p&gt;所以在Ext中，最好的方式就是先写一些通用性的代码，把参数定义好，放在一个地方当作模板，用的时候把它拷过去改改。只有在需要定义一些小的复用性很高的组件时，才有必要按Ext的方法，构造一个类出来，注册到Ext中。其它时候怎么舒服怎么写吧。&lt;/p&gt;
&lt;p&gt;正是因为这个原因，使用Ext做项目时，要写很多重复代码。哪怕是非常相似的功能，也很难复用，所以开发效率并没有随着项目的积累而提高，反而还会增加维护量。我们在Java或者其它语言中累积到的设计经验，在这里用不上；我们没有好用的工具来帮助我们减少错误；我们会变成Ext的“熟练工”，适应它，而不是掌控它。&lt;/p&gt;
&lt;p&gt;所以对于一个缺少Ext资深熟练工的团队，使用Ext是一件风险很大的事情，因为我们没有办法预估它到底要花多少时间，人品值是一个重要因素。一个功能，如果一切顺利，也许一两天就搞定，但是，也很可能花上一周。在制定工作计划的时候，经理只会按照最顺利的情况来给你预定时间。如果你对项目经理说，“做这个功能需要8个小时，因为可能会遇到一些问题卡住”，项目经理会怎么想呢？“这么简单的功能，就画几个界面，也要8个小时？3个小时都够了。出错那怪你自己不细心，自己加班补吧”。&lt;/p&gt;
&lt;p&gt;所以用Ext做项目很累，直到你忍受不了而离职，或者熬成熟练工。&lt;/p&gt;
&lt;p&gt;所以我打算彻底抛弃Ext，远离dojo&lt;font style=&quot;background-color: #ffffff&quot;&gt;/qooxdoo，也许vaadin/gwt才是正确的道路。&lt;/font&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Ext 2.x中各种bug、解决方案与经验记录</title>
                <link>http://freewind.in/posts/678-bugs-solutions-experience-about-ext-2</link>
                <pubDate>Tue, 03 Jan 2012 21:32:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">678</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;一、ComboBox在submit时，无法传出正确的值？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是一个典型的combo示例：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xtype: &apos;combo&apos;,       
anchor: &apos;95%&apos;,       
fieldLabel: &apos;发布文章前是否需要审核&apos;,       
name: &apos;articlesNeedCheck&apos;,       
displayField: &apos;text&apos;,       
valueField: &apos;value&apos;,       
mode: &apos;local&apos;,       
value: -1,       
triggerAction: &apos;all&apos;,       
store: new Ext.data.SimpleStore({       
     fields: [&apos;value&apos;, &apos;text&apos;],       
     data: [       
         [&apos;-1&apos;, &apos;沿用上级设置&apos;],       
         [&apos;1&apos;, &apos;需要&apos;],       
         [&apos;0&apos;, &apos;不需要&apos;]

     ]      
 })       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;展示效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/678-1.png&quot;&gt;&lt;img src=&quot;/user_images/678-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们在定义中已经指明displayField是text，即显示中文那一列；valueField是value，对应是-1,0,1那一列。但奇怪的是，提交到后台的值是竟然是中文！也就是说，下面这一行参数似乎没起作用：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;valueField: ‘value’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我反复尝试也找不到原因，真让人无比郁闷。最后在网上找到答案。原来当ComboBox与SimpleStore一起用的时候，还需要指定一个叫hiddenName的值，与隐藏的那列对应，才能正确传值。&lt;/p&gt;
&lt;p&gt;对于上例来说，就是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;hiddenName: ‘articlesNeedCheck’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加上去，就正常了。但在文档中根本没有强调，谁能想到还需要指定这个值？我翻看了其他同事写的代码，他们遇到类似问题的时候，居然因为一个combobox而手动将form中所有字段的值全部一个个取出来向后台发送，这真是浪费生命。&lt;/p&gt;
&lt;p&gt;在写ext的过程中，我不知道因为这样的问题浪费了多少时间，经常一卡就一两个小时。我还是倾向于像GWT那样，在后台写java代码在前台生成js代码的解决方案。如果直接用js写，没有编译期的提示与查错，太容易出问题了，调试也非常困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、file类型的input，在firefox下引发的Security Error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是错误截图，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/678-3.png&quot;&gt;&lt;img src=&quot;/user_images/678-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/678-5.png&quot;&gt;&lt;img src=&quot;/user_images/678-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相似你很难这些信息中找到错误原因。我也是花了几个小时的调试，才发现问题就在下面这段代码中：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xtype: &apos;textfield&apos;,    
name: &apos;frontImage&apos;,    
id: &apos;frontImage&apos;,    
anchor: &apos;100%&apos;,    
value: &apos;TODO&apos;,    
inputType: &apos;file&apos;,    
fieldLabel: &apos;引导图片&apos;,    
hideLabel: true    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这段代码在IE下一切正常，但在firefox下会出现“Security Code”。&lt;/p&gt;
&lt;p&gt;错误的原因在于“value:&apos;TODO&apos;“，因为firefox不允许对file类型的input进行赋值。只是这错误提示，实在太让人无从下手了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、combo，如果id与hiddenName同名，则界面异常并且无法选择下拉条中的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看截图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/678-7.png&quot;&gt;&lt;img src=&quot;/user_images/678-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个下拉条跟其它的不一样，长度超出了边缘并且弹出来的下拉条很短，更要命的是选不上，选了以后输入框里还是空白。&lt;/p&gt;
&lt;p&gt;又是经常一翻痛苦排查，发现原因竟然是因为id跟hiddenName同名了。&lt;/p&gt;
&lt;p&gt;看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         {   
           xtype: &apos;combo&apos;,    
           hiddenName: &apos;allowComment&apos;,    
          &amp;lt;font color=&quot;#ff0000&quot;&amp;gt; id: &apos;allowComment&apos;,     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/font&gt;               anchor: &apos;100%&apos;,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;           fieldLabel: &apos;启用评论&apos;,    
           triggerAction: &apos;all&apos;,    
           displayField: &apos;text&apos;,    
           valueField: &apos;value&apos;,    
           mode: &apos;local&apos;,    
           store: new Ext.data.SimpleStore({    
               fields: [&apos;value&apos;, &apos;text&apos;],    
               data: [    
                   [&apos;-1&apos;, &apos;沿用上级评论设置&apos;],    
                   [&apos;1&apos;, &apos;启用评论&apos;],    
                   [&apos;0&apos;, &apos;禁止评论&apos;]    
               ]    
           }    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要把红色部分改个名字才行。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Extjs2.2 在IE9下的BUG修复</title>
                <link>http://freewind.in/posts/674-fix-bug-about-extjs2.2-on-ie9</link>
                <pubDate>Fri, 30 Dec 2011 21:12:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">674</guid>
                <description><![CDATA[&lt;p&gt;今天使用Extjs2.2写了一个例子，在IE9下显示不正常，表现为要么页面上完全空白，要么用鼠标拖动窗口时，窗口没办法停下来，一直跟着鼠标跑。在控制台上报这个错误：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;错误: 对象不支持“createContextualFragment”属性或方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过搜索，发现也有其它人报这个问题。&lt;/p&gt;
&lt;p&gt;Extjs2.2版本比较老，那个时候IE9还没出来，而且IE系列总喜欢出点什么奇怪的问题。&lt;/p&gt;
&lt;p&gt;图就不截了，这里贴个解决方法。出处见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/netProphET/revolution/commit/f3ec1708965aa82f8f9e824bc6b5b5d054e1193d&quot;&gt;https://github.com/netProphET/revolution/commit/f3ec1708965aa82f8f9e824bc6b5b5d054e1193d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;if ((typeof Range !== &amp;ldquo;undefined&amp;rdquo;) &amp;amp;&amp;amp; !Range.prototype.createContextualFragment) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Range.prototype.createContextualFragment = function(html) {       
    var frag = document.createDocumentFragment(), div = document.createElement(&quot;div&quot;);       
    frag.appendChild(div);       
    div.outerHTML = html;       
    return frag;       
};       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要在html页面的最前面把这段代码加上，就一切正常了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>windows7 x64上安装oracle11g过程</title>
                <link>http://freewind.in/posts/635-install-oracle11g-on-windows-x64</link>
                <pubDate>Sun, 25 Dec 2011 14:03:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">635</guid>
                <description><![CDATA[&lt;p&gt;为了在windows 7 x64上安装oracle，折腾了两天，下载了几次文件，都提示各种错误，如操作系统不支持等。最后终于成功，特记录下来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、下载最新的oralce11gR2，只有该版本才支持windows7 x64。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前的版本包括11G，在安装时都会提示操作系统不支持。虽然可通过设置让它不要验证操作系统，但对于新手来说，还是有点难度。&lt;/p&gt;
&lt;p&gt;下载后可得到两个文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;win64_11gR2_database_1of2.zip&lt;/li&gt;
&lt;li&gt;win64_11gR2_database_2of2.zip&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一共2G。解压在一起，得到一个database目录。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-635&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;二、保证该database的路径中没有中文，最好也不要有空格，否则安装时会出错&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、运行setup.exe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-1.png&quot;&gt;&lt;img src=&quot;/user_images/635-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第1步，让填电子邮件，因为我是安装在本机用于开发，所以没必要写。去掉“我希望通过…接收安全通知”前的勾&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-3.png&quot;&gt;&lt;img src=&quot;/user_images/635-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第2步，选择安装哪些，默认选中第一个&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-5.png&quot;&gt;&lt;img src=&quot;/user_images/635-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第3步：选择是桌面类还是服务器类，选前者&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-7.png&quot;&gt;&lt;img src=&quot;/user_images/635-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第4步：路径及参数设置&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-9.png&quot;&gt;&lt;img src=&quot;/user_images/635-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为我填的密码为system，太简单了，oracle提示我是否改为复杂的密码。直接选否。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-11.png&quot;&gt;&lt;img src=&quot;/user_images/635-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第5步：检查环境是否满足要求&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-13.png&quot;&gt;&lt;img src=&quot;/user_images/635-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第6步：显示前面填写的信息的汇总，供确认&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-15.png&quot;&gt;&lt;img src=&quot;/user_images/635-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第7步：开始安装，大约要五到十分钟。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-17.png&quot;&gt;&lt;img src=&quot;/user_images/635-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中途防火墙会提示，选择“允许访问”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-19.png&quot;&gt;&lt;img src=&quot;/user_images/635-19.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建数据库等最后的操作，需要十几分钟&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-21.png&quot;&gt;&lt;img src=&quot;/user_images/635-21.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;经过漫长的等待，终于提示以下的信息，说明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-23.png&quot;&gt;&lt;img src=&quot;/user_images/635-23.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-25.png&quot;&gt;&lt;img src=&quot;/user_images/635-25.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、新建数据库实例&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开“数据库配置助手”：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-27.png&quot;&gt;&lt;img src=&quot;/user_images/635-27.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-29.png&quot;&gt;&lt;img src=&quot;/user_images/635-29.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击下一步：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-31.png&quot;&gt;&lt;img src=&quot;/user_images/635-31.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;默认选择第一个即可：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-33.png&quot;&gt;&lt;img src=&quot;/user_images/635-33.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输入数据库名，SID会自动输入，也可修改：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-35.png&quot;&gt;&lt;img src=&quot;/user_images/635-35.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-37.png&quot;&gt;&lt;img src=&quot;/user_images/635-37.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;偷懒，所有用户使用同一口令：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-39.png&quot;&gt;&lt;img src=&quot;/user_images/635-39.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-41.png&quot;&gt;&lt;img src=&quot;/user_images/635-41.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为仅用来开发，所以去掉了“快速恢复区”：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-43.png&quot;&gt;&lt;img src=&quot;/user_images/635-43.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-45.png&quot;&gt;&lt;img src=&quot;/user_images/635-45.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内存默认为3G多，太大了，调小一点：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-47.png&quot;&gt;&lt;img src=&quot;/user_images/635-47.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;字符集默认为GBK，改为UTF8：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-49.png&quot;&gt;&lt;img src=&quot;/user_images/635-49.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-51.png&quot;&gt;&lt;img src=&quot;/user_images/635-51.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-53.png&quot;&gt;&lt;img src=&quot;/user_images/635-53.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-55.png&quot;&gt;&lt;img src=&quot;/user_images/635-55.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“确定”后，又是漫长的等待：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/635-57.png&quot;&gt;&lt;img src=&quot;/user_images/635-57.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Hibernate使用注意事项</title>
                <link>http://freewind.in/posts/612-notice-when-using-hibernate</link>
                <pubDate>Tue, 20 Dec 2011 00:45:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">612</guid>
                <description><![CDATA[&lt;p&gt;因为公司项目需要，无奈还是使用上了Hibernate。我一向认为Hibernate是一个高难度的的框架，原理复杂、问题多多，稍不注意就被卡住，所以一向避而远之。但是因为公司的项目要同时支持Oracle和SqlServer，除了jdbc,与mybatis，能担此重任的也只有hibernate了，最后还是用上了它。当前的版本是3.6.x。&lt;/p&gt;
&lt;p&gt;一、使用Annotation还是hbm.xml&lt;/p&gt;
&lt;p&gt;使用Annotation很爽，除了一点：列定义的注释信息，在生成数据表时会丢失。因为公司之前的项目都是先生成数据表，列名都是拼音首字母，所以注释显得非常重要。为了保持这一传统，我采用了曲线救国的方式：先使用hibernate tools的ant任务，从annotation生成xml，再写一个工具类，从annotation中读取注释添加到xml中，再通过ant任务，从xml生成数据表。这样注释信息就能成功地加到数据库里去了。&lt;/p&gt;
&lt;p&gt;开始表之间的结构比较简单时，这一方法没有问题。直到有一天，我使用了@Inheritance来定义带有继承关系的类，生成的xml中缺少@DiscriminatorColumn字义的字段！这意味着生成的表结构不正确，导致后来插入数据总是出错。我搜索很久没有找到答案，左右为难：难道要放弃Annotation，改用手写的xml吗？工作量可不小，而且很不直观。&lt;/p&gt;
&lt;p&gt;这个问题还是没有解决，但是最后我决定不管它了：因为使用另一个ant任务，可以直接将annotation生成正确的数据表。虽然没有了注释信息，有点可惜，但是一来说不定这个功能以后会加上，二来当我们基于类而不是数据表来做功能时，数据表中的注释已经基本不重要了。&lt;/p&gt;
&lt;p&gt;hibernate tools提供了多种方式的转换：annotation &lt;-&gt; hbm.xml &lt;-&gt; 数据表，可惜步骤越多越容易出现信息丢失的情况。&lt;/p&gt;
&lt;p&gt;最后的结论是：annotation或者hbm.xml，在一开始时就选一种用下去，不要为了解决其中的一个问题把它转换为另一种，因为可能又引发其它的问题。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Javascript UI–qooxdoo</title>
                <link>http://freewind.in/posts/611-javascript-ui-qooxdoo</link>
                <pubDate>Wed, 14 Dec 2011 21:47:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">611</guid>
                <description><![CDATA[&lt;p&gt;一、网址&lt;/p&gt;
&lt;p&gt;首页：&lt;a href=&quot;http://qooxdoo.org/&quot;&gt;http://qooxdoo.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Demo：&lt;a href=&quot;http://qooxdoo.org/demo&quot;&gt;http://qooxdoo.org/demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Download：&lt;a href=&quot;http://qooxdoo.org/download&quot;&gt;http://qooxdoo.org/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;API：&lt;a href=&quot;http://demo.qooxdoo.org/current/apiviewer/&quot;&gt;http://demo.qooxdoo.org/current/apiviewer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二、截图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-1.png&quot;&gt;&lt;img src=&quot;/user_images/611-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、License&lt;/p&gt;
&lt;p&gt;双授权：LGPL和EPL，不错&lt;/p&gt;
&lt;p&gt;四、组件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Table：可排序，移动列，隐藏列，拖动窗口，直接编辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-3.png&quot;&gt;&lt;img src=&quot;/user_images/611-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Form：下拉列表，Date picker, Split Button, 菜单式按钮，表单验证等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-5.png&quot;&gt;&lt;img src=&quot;/user_images/611-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Virtual List：类似QQ联系人的虚拟List，可分组，可显示丰富信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-7.png&quot;&gt;&lt;img src=&quot;/user_images/611-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Data Binding：将数据与视图绑定，数据变了，视图自动变化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-9.png&quot;&gt;&lt;img src=&quot;/user_images/611-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tree：可展开，可多选，可多列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-11.png&quot;&gt;&lt;img src=&quot;/user_images/611-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Theming&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Languages：支持多语言快速切换，各种格式会自动变化&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-13.png&quot;&gt;&lt;img src=&quot;/user_images/611-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Drag &amp;amp; Drop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-15.png&quot;&gt;&lt;img src=&quot;/user_images/611-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Html Editor：基本功能有了，但图片上传等没有提供&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-17.png&quot;&gt;&lt;img src=&quot;/user_images/611-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Layout：支持多种布局&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/611-19.png&quot;&gt;&lt;img src=&quot;/user_images/611-19.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;五、支持的浏览器&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;六、在不同浏览器下的表现&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;七、总结&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Hibernate与Jpa的关系，终于弄懂</title>
                <link>http://freewind.in/posts/588-the-relationship-between-hibernate-and-jpa</link>
                <pubDate>Tue, 29 Nov 2011 15:46:14 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">588</guid>
                <description><![CDATA[&lt;p&gt;我知道Jpa是一种规范，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。&lt;/p&gt;
&lt;p&gt;在play中定义Model时，使用的是jpa的annotations，比如javax.persistence.Entity, Table, Column, OneToMany等等。但它们提供的功能基础，有时候想定义的更细一些，难免会用到Hibernate本身的annotation。我当时想，jpa这么弱还要用它干什么，为什么不直接使用hibernate的？反正我又不会换成别的实现。&lt;/p&gt;
&lt;p&gt;因为我很快决定不再使用hibernate，这个问题就一直放下了。直到我现在在新公司，做项目要用到Hibernate。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-588&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我想抛开jpa，直接使用hibernate的注解来定义Model，很快发现了几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jpa中有Entity, Table，hibernate中也有，但是内容不同&lt;/li&gt;
&lt;li&gt;jpa中有Column,OneToMany等，Hibernate中没有，也没有替代品&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我原以为hibernate对jpa的支持，是另提供了一套专用于jpa的注解，但现在看起来似乎不是。一些重要的注解如Column, OneToMany等，hibernate没有提供，这说明jpa的注解已经是hibernate的核心，hibernate只提供了一些补充，而不是两套注解。要是这样，hibernate对jpa的支持还真够足量，我们要使用hibernate注解就必定要使用jpa。&lt;/p&gt;
&lt;p&gt;实际情况是不是这样？在被群里(Scala交流群132569382)的朋友鄙视一番却没有给出满意答案的时候，我又想起了万能的stackoverflow，上去提了两个问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8306742/if-i-want-to-use-hibernate-with-annotation-do-i-have-to-use-javax-persistence&quot;&gt;http://stackoverflow.com/questions/8306742/if-i-want-to-use-hibernate-with-annotation-do-i-have-to-use-javax-persistence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8306793/why-jpa-and-hibernate-both-have-entity-and-table-annotations&quot;&gt;http://stackoverflow.com/questions/8306793/why-jpa-and-hibernate-both-have-entity-and-table-annotations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个是问如果想用hibernate注解，是不是一定会用到jpa的。网友的回答：“是。如果hibernate认为jpa的注解够用，就直接用。否则会弄一个自己的出来作为补充”&lt;/p&gt;
&lt;p&gt;第二个是问，jpa和hibernate都提供了Entity，我们应该用哪个，还是说可以两个一起用？网友回答说“Hibernate的Entity是继承了jpa的，所以如果觉得jpa的不够用，直接使用hibernate的即可”。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>升级windows 7 64位</title>
                <link>http://freewind.in/posts/584-upgrade-to-windows7-x64</link>
                <pubDate>Sun, 20 Nov 2011 10:43:41 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">584</guid>
                <description><![CDATA[&lt;p&gt;为了利用大内存，让scala和xtend插件流畅一些，终于决定使用64位的windows7了。之前使用的windows xp是32位的，只能用到3G多内存，每个jvm也只能分配几百M，对于scala插件来说，实在是太少了（它的推荐配置是1.5G）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先想到的是用U盘安装，之前我装xp和linux都是这么做的，比较方便。下载了微软的windows 7 USB DVD Tool，和一个3G多的win7 iso，制作了一个安装U盘。但是发现无法启动，换用其它类似软件重做，也都无法启动。在网上搜索后得知，我们无法在32位系统中制作64位win7的启动盘。&lt;/p&gt;
&lt;p&gt;一筹莫展，准备去买张光盘时，突然发现一个叫NT6 hdd installer的工具，可以让我们直接在硬盘上安装。做法也非常简单：直接把iso解压到一个分区的根目录下，运行NT6进行一些简单设置后重启，菜单中就多了一个启动项。使用它启动后，就自动安装win7了！一共花了大约30分钟，安装完成，再装驱动。

装好后，我在想以前的程序是否还能使用呢？试了一些，大部分没问题，只有一些如QQ之类的大软件，无法运行。于是重新下载安装。

&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-584&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**二、激活**

win7提示我在三天内完成激活。我在网上搜索了很多激活码，试过都没用。最后发现了一个叫win7 validation的程序，非常好用。点“激活”按钮后，等了大约三分钟，提示激活完成。重启后再点验证，提示激活成功。

**三、移动主目录**

win7的主目录在C:\Users，所有与用户相关的程序都保存在那里。为了ghost方便，我想把它转到D盘。

win7中提供了目录的链接功能，就像是linux中的文件链接，在win xp中是没有的。具体做法就是，首先把C:\Users目录完全拷贝到D:\Users，再删除C:\Users，最后再以指向D:\Usres的链接的方式建立C:\Users。这样，我们对C:\Users的所有操作，实际上都是在D:\Users中进行的。

我是按照这篇文章做的：[http://www.win7china.com/html/4975.html](http://www.win7china.com/html/4975.html)

可惜最后果然出现了“无法删除C:\Users”目录的错误，其中有一些文件一直在占用中。试了很多方法，最终解决：在启动时按F8，进行调试模式，才能将C:\Users完全删除。此时有可能看到其它驱动器的盘符乱了，但没关系，我们还是创建一个到D:\Users的链接，正常启动后就没问题了。

**四、感受**

最开始的时候，觉得win7太花了看得眼睛疼。但是试用了一天后，发现这个系统真的非常值得使用。很多细节上的改进，让使用起来感觉很舒服顺手。64位系统对大内存的支持，使得某些程序运行更快一些。还有一点，微软为了推win7，很多程序对win7的支持要比xp好很多。比如我现在写博客用的live writer，就比xp版的漂亮好用很多。
&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>公司基础架构培训有感</title>
                <link>http://freewind.in/posts/579-the-feeling-about-the-traing-of-basic-project-of-company</link>
                <pubDate>Tue, 15 Nov 2011 23:22:59 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">579</guid>
                <description><![CDATA[&lt;p&gt;今天下午，公司组织了培训，讲解最近开发出来的一套基础系统的功能，我学到不少，有些感触。&lt;/p&gt;
&lt;p&gt;我们部门是做学校的各种管理系统，有些功能每个系统都需要。而这套基础系统，就是为它们提供一个通用的基础功能，比如学生、老师、院系等基础信息表的定义，权限角色功能，通过配置生成数据表的增删改查功能，自定义菜单，自定义表单，以及自定义报表。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-579&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;在演示过程中，看到通过一些简单的配置，就可以完成一些看起来比较复杂的功能（特别是数据表增删改查、自定义表单、报表），开发效率真的很高，让我有种惊叹的感觉。功能方面考虑得很细致，提供了相当多的选项供配置，比较灵活。在易用性方面也做得不错，简单讲解就能知道怎么用了。另外，通过添加菜单的方式，也可很容易的将新系统嵌入到这套系统中，浑然一体，这种方式值得肯定。&lt;/p&gt;
&lt;p&gt;我之前没有做过像这样通用性比较强的产品，因为自己做的那些小东西，每个都不一样，除了用户注册登录，没什么能通用的。今天看了这套系统，感觉像这种做信息管理系统的公司，的确应该开发出一套类似的通用基础系统。开发新产品时，以插件方式利用这些功能，可大大节省开发时间。&lt;/p&gt;
&lt;p&gt;这种做法，是以性能换方便。在配置过程中，可以看到很多功能，都要外联到很多数据表，可能一个操作要查询十来次数据库，在性能上不会很好。如果以最优化的方式来写，可能一两次查询就能完成，但没法通用。这种做法，对于基础系统来说，却是非常合适的，因为它都是一些后台操作，可能就管理员偶尔上来维护一下，多个几十次查询，也不会对系统造成什么影响，而带来的通用性和可定制性，非常方便，值得。&lt;/p&gt;
&lt;p&gt;唯一有些不满意的地方是，之前看过代码，里面不少地方比较乱。似乎每个人都各写各的，互不干涉，也互不要求，只要能跑起来就行。格式化没做，大量未使用的导入，注释也很乱，很多代码都可优化，单元测试也没有。所以这套基础系统，看起来不错，但感觉很脆弱，今天演示时多次出现的500错误就在提醒这一点。虽然看着不错，但是用起来，还是会感觉挺担心的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Eclipse的egit插件，无法向github上传代码？</title>
                <link>http://freewind.in/posts/578-cannot-push-code-to-github-with-egit-of-eclipse</link>
                <pubDate>Mon, 14 Nov 2011 22:13:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">578</guid>
                <description><![CDATA[&lt;p&gt;今天使用eclipse时，遇到一个奇怪的问题。我首先通过命令行，导入了一个具有读写权限的项目：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;git clone &lt;a href=&quot;mailto:git@github.com:linqing/ebb.git&quot;&gt;git@github.com:linqing/ebb.git&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在它的基础上创建了一个eclipse项目。修改了代码之后，通过eclipse的egit插件提交，总是提示Auth fail，试遍了所有密码都一样。仔细检查了egit相关的配置，都没有发现问题。&lt;/p&gt;
&lt;p&gt;可是通过命令行是没有问题的，这是怎么回事？&lt;/p&gt;
&lt;p&gt;好在有万能的stackoverflow，经过搜索，发现了这个问题，看来不只我一个人遇到：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3601805/auth-problem-with-egit-and-github&quot;&gt;http://stackoverflow.com/questions/3601805/auth-problem-with-egit-and-github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&quot;more-578&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;原来，通过ssh向github提交时，需要配置密钥文件，但这个选项却没有放在egit中，而是在&amp;rdquo;&lt;em&gt;&lt;strong&gt;Window &gt; Preferences &gt; Network Connections &gt; SSH2&amp;rdquo;&lt;/strong&gt;这个偏僻的角落里。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/578-1.png&quot;&gt;&lt;img src=&quot;/user_images/578-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关键在于这个ssh2 home，之前的值是另一个目录，里面没有密钥文件。&lt;/p&gt;
&lt;p&gt;看看那个目录里有什么？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/578-3.png&quot;&gt;&lt;img src=&quot;/user_images/578-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关键就在于id_rsa这个文件，这是私钥。在Key Management中，将它导入：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/578-5.png&quot;&gt;&lt;img src=&quot;/user_images/578-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后再试试提交，成功。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Eclipse的新语言Xtend的极简试用</title>
                <link>http://freewind.in/posts/571-try-xtend-of-eclipse</link>
                <pubDate>Wed, 09 Nov 2011 22:12:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">571</guid>
                <description><![CDATA[&lt;p&gt;一直盼着Idea的新语言kotlin，久久没有动静，没想到它的对手Eclipse居然突然发布了一个新语言，叫Xtend&lt;/p&gt;
&lt;p&gt;网址在：&lt;a href=&quot;http://www.eclipse.org/Xtext/xtend/&quot;&gt;http://www.eclipse.org/Xtext/xtend/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BUG提交地址：&lt;a href=&quot;https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF&amp;amp;component=Xtext&amp;amp;version=2.1.0&amp;amp;short_desc=%5BXtend%5D&quot;&gt;https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF&amp;amp;component=Xtext&amp;amp;version=2.1.0&amp;amp;short_desc=%5BXtend%5D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装时需要通过Eclpise的Market，直接搜索xtend就能找到。&lt;/p&gt;
&lt;p&gt;Xtend是在Xtext的基础上发展出来的。这个Xtext，是Eclipse提供的一种可用来设计DSL的工具，卖点是Eclipse对它提供了非常好的编辑器支持，如语法高亮、自动提示、重构等等，用它设计出来的DSL在eclipse中看起来就像是一种新语言一样，比较有新引力。我当时在想，不知道能不能用它来设计一些复杂的语言，像Scala之类。没想到几个月过去了，居然抛出了一个Xtend的语言。&lt;/p&gt;
&lt;p&gt;Xtend是对Java的一些小小改进，提供了一些Javaer一直想要却迟迟不来的，比如多行文本、文本内嵌表达式、闭包等等。Xtend的编译器将把Xtend编译为可读性很好的Java源代码，注意，是源代码！而不是如scala, groovy那样生成字节码。它相对于Java，就如同coffeescript相对于javascript。&lt;/p&gt;
&lt;p&gt;这对于我来说，是很有吸引力的。因为我将scala与java一起使用时，有时候调用java并不方便，并且还必须使用scala自己的编译器，IDE的支持也不太好。而Xtend直接被编译为java源代码，它就相当于一个智能的代码生成器，有时候很方便：比如在play中，我直接写xtend，eclipse会把它编译为Java。由于Play还是可以看到Java代码，所以不需要担心classloader之类的问题，可直接使用。&lt;/p&gt;
&lt;p&gt;说到这里，其实我在play中，早已经使用了类似的生成器，比如写haml由工具生成html，写less由工具生成css，这次如果能写xtend生成java，那真是全了。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-571&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;怀着激动的心情与漫长的安装，终于把xtend装好了，新建了一个内置的xtend教学项目，看看代码的截图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/571-1.png&quot;&gt;&lt;img src=&quot;/user_images/571-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看起来不错，很有Java的感觉。语法像、配色像，但有一些增强的功能，比如图中的多行文本以及字符串中的内嵌表达式，很爽吧！再来个闭包：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/571-3.png&quot;&gt;&lt;img src=&quot;/user_images/571-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还没看来及细看，马上发现了问题：太卡了！太卡了！太卡了！太卡了！太卡了！太卡了！&lt;/p&gt;
&lt;p&gt;稍稍修改一下代码，保存一下，就会出现如下等待框：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/571-5.png&quot;&gt;&lt;img src=&quot;/user_images/571-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你随便改点东西，然后快速按两次保存，这个对话会卡住超过10秒钟！在此期间什么也不能操作，只能干等！&lt;/p&gt;
&lt;p&gt;我的电脑是三年前买的，配置为：AMD Athlon X2 4000+，内存4G，操作系统windows xp。运行Java还是比较流畅的，但跑不起xtend。&lt;/p&gt;
&lt;p&gt;为了Xtend（也为了Scala），终于决定升级电脑了。花了1000块钱，现在的配置如下：AMD X3 445，内存8G。由于Windows xp是32位系统，无法给eclipse分配大内存（例如scala插件要求1.5G，但最多只能分750M），于是安装了64位的windows 7，64位的Java和Eclipse。经过一天的折腾，效果很明显：现在运行xtend基本上很流畅，只是在极少数情况会出现一个一闪而过的等待窗，感觉好多了。&lt;/p&gt;
&lt;p&gt;我想使用xtend来写play代码，很快发现了一个严重问题：xtend目前不支持static方法！由于play中，所有的action都是static的，这意味着无法在play中用xtend。好在官方消息，会在近期增加static支持（大约一个月以后），那只能再等等了。&lt;/p&gt;
&lt;p&gt;尽管如此，还是期待它能好好发展，到时候左手Xtend，右手Kotlin，胸前Scala，威武！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>lift.ebb 1.ViewAllCategories的总结与问题</title>
                <link>http://freewind.in/posts/561-lift-ebb-viewallcategories-summaries-and-problems</link>
                <pubDate>Mon, 07 Nov 2011 17:39:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">561</guid>
                <description><![CDATA[&lt;p&gt;Ebb的第一个use case，是view all categories，即查看所有的论坛组。先看看usebb的首页是什么样的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/561-1.png&quot;&gt;&lt;img src=&quot;/user_images/561-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再看我现在做成的样子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/561-3.png&quot;&gt;&lt;img src=&quot;/user_images/561-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然样子有点丑，但是好歹数据已经从数据库里取出来了。最关键的是，对lift的恐惧感大大减小，隐约开始理解它的运行方式了。&lt;/p&gt;
&lt;p&gt;这是在教主的领导之下，使用他的rup开发方式，实现的第一个use case。我本打算先看几天的lift，差不多熟悉了再动手，但是教主说，让我直接在他的ebb代码基础上做，先照葫芦画瓢，做出功能后，再想着改进和学习。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-561&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、现在的liftweb (lift2.4m4) 只支持到2.9.0.1（以及2.8.1)，不支持最新的2.9.1。这个项目，使用的是2.8.1&lt;/p&gt;
&lt;p&gt;二、liftweb使用的还是sbt 0.7.x，而不是最新的0.10.x。这个项目，使用的是0.7.5&lt;/p&gt;
&lt;p&gt;三、配合jrebel，可以将修改代码生效的时间由10秒左右，减小到4秒。&lt;/p&gt;
&lt;p&gt;四、如何在lift中使用jrebel，将另写一篇文章&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于lift的理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我用过很多mvc类框架及wicket/tapestry这样的非mvc，但初看lift代码时，还是觉得摸不着头。因为在lift的代码中，有很多奇怪的符号及独特的渲染方式：类似jquery的css selector替换。&lt;/p&gt;
&lt;p&gt;lift里面东西很多，这次只接触到snippet，所以只总结这一点。&lt;/p&gt;
&lt;p&gt;在mvc中，请求一个页面的流程是这样的：一个请求到来后，首先被router获取。它根据一定的规则，将它转发给某个controller中的某个方法(action)。在action中，可以取得request中的参数，然后根据需求，调用其它的类或方法，得到所需数据，传给view。view使用这些数据，渲染出最终的html，发给浏览器。可以看到，在这里controller是老大，它负责取数据，丢给view小弟处理。&lt;/p&gt;
&lt;p&gt;在lift中，是反过来的。当请求到来后，首先找到的是view。比如我请求&lt;a href=&quot;http://localhost/abc.html&quot;&gt;http://localhost/abc.html&lt;/a&gt;，它会首先在webapp下找到abc.html这个文件。abc.html是一个正常且完整的html，不同之处在于，它里面有一些html标签，及奇怪的class属性（见后面的例子）。这些class实际上是一些声明，告诉lift如何处理、替换或填充这部分模板。lift将调用对应的snippet类（也可以看作是Component），改变模板内容，变成最终的html。可见这里，view是老大，它根据自己的模板内容，召唤snippet小弟过来给自己化妆打扮。所以lift这种方式，叫做View-first。&lt;/p&gt;
&lt;p&gt;见这个html页面index.html&lt;/p&gt;
&lt;blockquote&gt;&lt;div id=&quot;main&quot; class=&quot;**&lt;font color=&quot;#ff0000&quot;&gt;lift:surround?with=default;at=content&lt;/font&gt;**&quot;&gt;      
  &lt;h1&gt;bbs&lt;/h1&gt;      
  &lt;!- cat_header -&gt;      
  &lt;table class=&quot;**&lt;font color=&quot;#ff0000&quot;&gt;lift:ForumSnippet.forumlist&lt;/font&gt;** maintable&quot;&gt;

    &lt;tr class=&quot;t-cat_header&quot;&gt;     
      &lt;td colspan=&quot;5&quot; class=&quot;forumcat&quot;&gt;&lt;a href=&quot;{cat_url}&quot; name=&quot;{cat_anchor}&quot; rel=&quot;nofollow&quot;&gt;&amp;raquo;&lt;/a&gt; &lt;span name=&quot;cat_name&quot;&gt;{cat_name}&lt;/span&gt;&lt;/td&gt;      
    &lt;/tr&gt;      
    &lt;tr&gt;      
      &lt;th class=&quot;icon&quot;&gt;&lt;/th&gt;      
      &lt;th&gt;{l_Forum}&lt;/th&gt;      
      &lt;th class=&quot;count&quot;&gt;{l_Topics}&lt;/th&gt;      
      &lt;th class=&quot;count&quot;&gt;{l_Posts}&lt;/th&gt;      
      &lt;th class=&quot;lastpostinfo&quot;&gt;{l_LatestPost}&lt;/th&gt;      
    &lt;/tr&gt; 

    &lt;!- forum -&gt;     
    &lt;tr class=&quot;t-forum&quot;&gt;      
      &lt;td class=&quot;icon&quot;&gt;&lt;img src=&quot;{img_dir}{forum_icon}&quot; alt=&quot;{forum_status}&quot; /&gt;&lt;/td&gt;      
      &lt;td&gt;      
          &lt;div class=&quot;forumname&quot;&gt;{forum_name}&lt;/div&gt;      
          &lt;div class=&quot;forumdescr&quot;&gt;{forum_descr}&lt;/div&gt;      
      &lt;/td&gt;      
      &lt;td class=&quot;count&quot;&gt;&lt;div class=&quot;total_topics&quot;&gt;{total_topics}&lt;/div&gt;&lt;/td&gt;      
      &lt;td class=&quot;count&quot;&gt;&lt;div class=&quot;total_posts&quot;&gt;{total_posts}&lt;/div&gt;&lt;/td&gt;      
      &lt;td class=&quot;lastpostinfo&quot;&gt;      
          &lt;div class=&quot;latest_post&quot;&gt;      
              &lt;a href=&quot;??????&quot;&gt;&lt;span name=&quot;latest_post&quot;&gt;{latest_post}&lt;/span&gt;&lt;/a&gt;      
          &lt;/div&gt;      
          &lt;div class=&quot;by_author&quot;&gt;By:       
              &lt;a href=&quot;??????&quot;&gt;&lt;span name=&quot;by_author&quot;&gt;{by_author}&lt;/span&gt;&lt;/a&gt;      
          &lt;/div&gt;      
          &lt;div class=&quot;on_date&quot;&gt;On: &lt;span name=&quot;on_date&quot;&gt;{on_date}&lt;/span&gt;&lt;/div&gt;      
      &lt;/td&gt;      
    &lt;/tr&gt;      
  &lt;/table&gt;      
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先直接用浏览器打开这个文件，看是什么样子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/561-5.png&quot;&gt;&lt;img src=&quot;/user_images/561-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可见的确是一个很像“模板”的html页面。为什么经过lift渲染之后，会变成这样呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/561-7.png&quot;&gt;&lt;img src=&quot;/user_images/561-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关键就在于代码中那两处红色的class。&lt;/p&gt;
&lt;p&gt;１、&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;lift:surround?with=default;at=content&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话是告诉lift，先找到templates-hidden/&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;default&lt;/font&gt;&lt;/strong&gt;.html这个布局文件，然后用index.html的内容，替换default.html中的&lt;lift:bind name=&quot;**&lt;font color=&quot;#ff0000&quot;&gt;content&lt;/font&gt;**&amp;rdquo; /&gt;。&lt;/p&gt;
&lt;p&gt;templates-hidden/default.html内容如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;html xmlns=&quot;[http: //www.w3.org/1999/xhtml&quot;](http://www.w3.org/1999/xhtml&quot;) xmlns:lift=&quot;[http://liftweb.net/&quot;](http://liftweb.net/&quot;)&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&amp;gt;      
&amp;lt;meta name=&quot;description&quot; content=&quot;&quot; /&amp;gt;      
&amp;lt;meta name=&quot;keywords&quot; content=&quot;&quot; /&amp;gt;      
&amp;lt;title&amp;gt;kkkk&amp;lt;/title&amp;gt;      
&amp;lt;script id=&quot;jquery&quot; src=&quot;/classpath/jquery.js&quot; type=&quot;text/javascript&quot;/&amp;gt;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**&amp;lt;font color=&quot;#ff0000&quot;&amp;gt;&amp;lt;lift:bind name=&quot;content&quot; /&amp;gt;         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/font&gt;**  &lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看index.html最终生成的html源代码，里面的确用到了default.html中的代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/561-9.png&quot;&gt;&lt;img src=&quot;/user_images/561-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;２、&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;lift:ForumSnippet.forumlist&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话告诉lift，使用code.snippet.&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;ForumSnippet.forumlist&lt;/font&gt;&lt;/strong&gt;()方法来处理其所在的table标签（及内部标签）。ForumSnippet是什么样子呢？见下面代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;object ForumSnippet {
&lt;br  /&gt;def forumlist: CssSel =&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;*****&quot; **&amp;lt;font color=&quot;#800080&quot;&amp;gt;#&amp;gt;&amp;lt;/font&amp;gt;** (for (cat &amp;lt;- cats) yield {      
  &quot;**&amp;lt;font color=&quot;#ff8040&quot;&amp;gt;.t-cat_header&amp;lt;/font&amp;gt;**&quot; #&amp;gt; (&quot;@cat_name&quot; #&amp;gt; cat.name) &amp;amp;      
  &quot;**&amp;lt;font color=&quot;#ff8000&quot;&amp;gt;.t-forum&amp;lt;/font&amp;gt;**&quot; #&amp;gt; ( for {      
      f &amp;lt;- cat.forums      
      lastTopic &amp;lt;- topics.lookup(f.last_topic_id)      
  } yield {      

    val lastPost = posts.lookup(lastTopic.last_post_id).get      
    val lastPoster = members.lookup(lastPost.poster_id).get      
    val lastTopicTitle = (if(lastTopic.count_replies&amp;gt;1) &quot;Re: &quot; else &quot;&quot;) + lastTopic.topic_title 

    &quot;**&amp;lt;font color=&quot;#ff8000&quot;&amp;gt;.forumname *&amp;lt;/font&amp;gt;**&quot; #&amp;gt; f.name &amp;amp;      

    &quot;.forumdescr *&quot; #&amp;gt; f.descr &amp;amp;     
    &quot;.total_topics&quot; #&amp;gt; f.topics &amp;amp;      
    &quot;.total_posts&quot; #&amp;gt; f.posts &amp;amp;      
    &quot;.latest_post *&quot; #&amp;gt; (&quot;@latest_post&quot; #&amp;gt; lastTopicTitle) &amp;amp;      
    &quot;.by_author *&quot; #&amp;gt; (&quot;@by_author&quot; #&amp;gt; {lastPoster.name}) &amp;amp;      
    &quot;.on_date *&quot; #&amp;gt; (&quot;@on_date&quot; #&amp;gt; new SimpleDateFormat().format(lastPost.post_time)) 

  })     
})      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段代码中，有很多奇怪的符号。但如果你使用过jquery的话，可能就会猜到：它首先将html模板（即&lt;table&gt;xxx&lt;/table&gt;这一段）解析为一个xml树，然后使用css selector定位到对应的节点，最后使用实际数据去替换内容。&lt;/p&gt;
&lt;p&gt;首先需要了解的是紫色的&lt;strong&gt;&lt;font color=&quot;#800080&quot;&gt;#&gt;&lt;/font&gt;&lt;/strong&gt;符号，它在代码中大量使用，意思是replacedWith，即用后面的数据替换左边对应的节点内容。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&amp;ldquo;.forumdescr *&amp;rdquo; #&gt; f.descr&lt;/p&gt;
&lt;p&gt;左边是css selector，&amp;ldquo;.forumdescr&quot;表示class=&amp;ldquo;.forumdescr&quot;节点，&amp;ldquo;.forumdescr .aaa&quot;表示&amp;rdquo;.forumdesc&quot;下的所有&amp;rdquo;.aaa&quot;节点，&amp;ldquo;.forumdescr *&amp;ldquo;表示&amp;rdquo;.forumdescr&quot;下的所有节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句代码表示将&amp;rdquo;.forumdescr&quot;下的所有内容替换为f.descr。&lt;/p&gt;
&lt;p&gt;每行最后的&lt;code&gt;&amp;amp;&lt;/code&gt;，表示将多个操作连接起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何替换属性？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;&amp;ldquo;.forumname [href]&amp;rdquo; #&gt; &lt;a href=&quot;http://google.com&quot;&gt;http://google.com&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
]]></description>
            </item>
        
            <item>
                <title>UseBB在windows下的安装</title>
                <link>http://freewind.in/posts/548-install-usebb-on-windows</link>
                <pubDate>Sat, 05 Nov 2011 21:45:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">548</guid>
                <description><![CDATA[&lt;p&gt;我接受了林教主的委托，现在开始尝试使用liftweb+squeryl+mysql来实现一个scala版的usebb。教主要求其做的与原版usebb一模一样，重点考察squerl的使用，填上技术上的坑。&lt;/p&gt;
&lt;p&gt;我的scala一直半生不熟，这也算是一个激励我重学scala的机会。我个人对liftweb不太感冒，总觉得它有点复杂，比不上play2的简洁。可惜play2现在远未成熟，liftweb还是最为稳妥的选择。另外，群里几位老大都很推荐liftweb，说它做网站代码很简洁，我也想尝试一下，看看跟play的开发效率相比谁高谁低。再就是squeryl了，在scala的世界了，它可能算是比较知名的orm，我曾经简单试用过，没达到期望。也好，趁此机会好好用用，说不定有意外惊喜。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-548&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;开工第一件事，下载安装usebb.net。&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;http://usebb.net&quot;&gt;http://usebb.net&lt;/a&gt;。我下载了zip包，在windows上安装。&lt;/p&gt;
&lt;p&gt;我使用一个叫APMServ5.2.6的php集成环境，十分方便且免费。它把php、apache、mysql什么的，都弄在一起了，启动时只需要运行它提供的一个GUI程序即可。&lt;/p&gt;
&lt;p&gt;安装过程很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把usebb解压缩，放在APMServ5.2.6\www\htdocs\ubb目录下&lt;/li&gt;
&lt;li&gt;直接以文件方式打开ubb/docs/index.html，它是安装教程，可参考&lt;/li&gt;
&lt;li&gt;将ubb/config.php-dist改名为config.php&lt;/li&gt;
&lt;li&gt;在浏览器中打开&lt;a href=&quot;http://localhost/ubb/install/install.php&quot;&gt;http://localhost/ubb/install/install.php&lt;/a&gt;开始安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时发现500错误。且不论打开任何php文件或者html文件，都是这个错误，真奇怪。&lt;/p&gt;
&lt;p&gt;一点点排查，发现在ubb目录下有一个.htaccess文件，里面定义了很多url rewrite的规则。可能是APMServ中的配置不对，导致rewrite无法正常工作而出错。最终解决办法是删除（或改名）这个.htaccess，就可以看到正常的安装页面了。&lt;/p&gt;
&lt;p&gt;我需要先在mysql中新建一个数据库，然后在安装页面上填写相关的配置信息，如数据库名，用户，密码等。需要注意的是，管理员的密码必须是字母与数字混合，并且长度在6位以上，不然总提示错误（错误信息不太明显，看了半天才发现）。&lt;/p&gt;
&lt;p&gt;所有信息无误的话，点击下一步，就安装好了。这时会要求我们要把install目录删除或改名，否则打开首页时会提示安全问题，不能继续运行。&lt;/p&gt;
&lt;p&gt;再次打开首页&lt;a href=&quot;http://localhost/ubb&quot;&gt;http://localhost/ubb&lt;/a&gt;，看到了论坛的首页，一切正常。之前删除了.htaccess，所以url看起来不太好看，不过不影响正常使用。&lt;/p&gt;
&lt;p&gt;截个图，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/548-1.png&quot;&gt;&lt;img src=&quot;/user_images/548-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>读写锁ReentrantReadWriteLock的疑问</title>
                <link>http://freewind.in/posts/543-question-about-reentrantreadwriteLock</link>
                <pubDate>Mon, 31 Oct 2011 22:12:28 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">543</guid>
                <description><![CDATA[&lt;p&gt;Jdk5中的concurrent包中有一个ReadWriteLock接口以及它的实现（ReentrantReadWriteLock）。通过这个名字，以及它提供的两个方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;readLock()&lt;/li&gt;
&lt;li&gt;writeLock()&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以猜测，它提供了两个锁，一个用来写入，一个用来读取。因为读取不改变数据，可假设读取锁可同时被多个线程持有；而写入锁只能被一个线程持有，因为写入将改变数据。&lt;/p&gt;
&lt;p&gt;由于该类的文档写得异常难懂，所以这里用代码来测试。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-543&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;一、读取锁可同时被多个线程持有&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class ReadLockCanBeHoldByMultiThreadTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {     
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();      
    final ReadLock readLock = lock.readLock();      
    for (int i = 0; i &amp;lt; 3; i++) {      
        new Thread() {      
            public void run() {      
                readLock.lock();      
                System.out.println(Thread.currentThread().getName() + &quot; holds the read lock&quot;);      
                try {      
                    Thread.sleep(3000);      
                } catch (InterruptedException e) {      
                    e.printStackTrace();      
                }      
                System.out.println(Thread.currentThread().getName() + &quot; exits&quot;);      
            };      
        }.start();      
    }      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Thread-0 holds the read lock
&lt;br  /&gt;Thread-2 holds the read lock
&lt;br  /&gt;Thread-1 holds the read lock
&lt;br  /&gt;Thread-0 exits
&lt;br  /&gt;Thread-1 exits
&lt;br  /&gt;Thread-2 exits&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见读取锁的确可同时被多个线程持有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、写入锁不可同时被多个线程持有&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class WriteLockCannotBeHeldByMultiThreads {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {     
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();      
    final WriteLock writeLock = lock.writeLock();      
    for (int i = 0; i &amp;lt; 3; i++) {      
        new Thread() {      
            public void run() {      
                writeLock.lock();      
                System.out.println(Thread.currentThread().getName() + &quot; holds the read lock&quot;);      
                try {      
                    Thread.sleep(3000);      
                } catch (InterruptedException e) {      
                    e.printStackTrace();      
                }      
                writeLock.unlock();      
                System.out.println(Thread.currentThread().getName() + &quot; exits&quot;);      
            };      
        }.start();      
    }      
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Thread-0 holds the read lock
&lt;br  /&gt;Thread-0 exits
&lt;br  /&gt;Thread-1 holds the read lock
&lt;br  /&gt;Thread-1 exits
&lt;br  /&gt;Thread-2 holds the read lock
&lt;br  /&gt;Thread-2 exits&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见写入锁必须在释放后，才能被另一个线程拿到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、写入锁与读取锁不可同时被不同线程持有&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class ReadWriteLockCannotBeHeldAtTheSameTime {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {     
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();      
    final ReadLock readLock = lock.readLock();      
    final WriteLock writeLock = lock.writeLock(); 

    new Thread() {     
        public void run() {      
            readLock.lock();      
            System.out.println(Thread.currentThread().getName() + &quot; holds the read lock&quot;);      
            try {      
                Thread.sleep(3000);      
            } catch (InterruptedException e) {      
                e.printStackTrace();      
            }      
            readLock.unlock();      
            System.out.println(Thread.currentThread().getName() + &quot; released the read lock&quot;);      
        };      
    }.start(); 

    // let the first thread have enough time to hold the read lock     
    Thread.sleep(1000); 

    new Thread() {     
        public void run() {      
            writeLock.lock();      
            System.out.println(Thread.currentThread().getName() + &quot; holds the write lock&quot;);      
            try {      
                Thread.sleep(3000);      
            } catch (InterruptedException e) {      
                e.printStackTrace();      
            }      
            writeLock.unlock();      
            System.out.println(Thread.currentThread().getName() + &quot; released the write lock&quot;);      
        };      
    }.start(); 

}     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Thread-0 holds the read lock
&lt;br  /&gt;Thread-0 released the read lock
&lt;br  /&gt;Thread-1 holds the write lock
&lt;br  /&gt;Thread-1 released the write lock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见读取写被一线程持有后，其它线程必须等它释放后，才能拿到写入锁。反过来也一样，如果写入锁被拿了，读取锁也就拿不到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、某线程拿到写入锁后，还能再拿读取锁&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class AThreadCanHoldWriteAndReadLock {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {      
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();      
    final ReadLock readLock = lock.readLock();      
    final WriteLock writeLock = lock.writeLock();      
    writeLock.lock();      
    System.out.println(&quot;Hold the write lock&quot;);      
    readLock.lock();      
    System.out.println(&quot;Hold the read lock&quot;);      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font style=&quot;background-color: #ffffff&quot;&gt;输出：&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Hold the write lock
&lt;br  /&gt;Hold the read lock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;五、反过来不行，拿到读取锁后，就拿不到写入锁了&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class AThreadCannotHoldReadAndWriteLock {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {      
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();      
    final ReadLock readLock = lock.readLock();      
    final WriteLock writeLock = lock.writeLock();      
    readLock.lock();      
    System.out.println(&quot;Hold the read lock&quot;);      
    writeLock.lock();      
    System.out.println(&quot;Hold the write lock&quot;);      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Hold the read lock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序永远卡在这里了，因为拿不到写入锁而陷入等待。&lt;/p&gt;
&lt;p&gt;（待续）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>synchronized与lock，哪个效率更高</title>
                <link>http://freewind.in/posts/542-which-has-better-performance-synchronized-and-lock</link>
                <pubDate>Mon, 31 Oct 2011 21:26:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">542</guid>
                <description><![CDATA[&lt;p&gt;Java在一开始就提供了synchronized关键字，用于多线程之间的同步。它使用简便，不会出现拿锁之后不归还的情况，可以避免一些编程错误。&lt;/p&gt;
&lt;p&gt;而jdk5时提供的concurrent包里，有一个Lock接口以及它的实现类：ReentrantLock。这个类提供了更灵活的控制以及更强大的功能。&lt;/p&gt;
&lt;p&gt;如果单从性能方面考虑，两个哪个更高效呢？&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-542&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先是单线程的加锁情况，见以下代码：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;import java.util.concurrent.locks.Lock;
&lt;br  /&gt;import java.util.concurrent.locks.ReentrantLock;&lt;/p&gt;
&lt;p&gt;public class SynLockTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {      
    long value = 0;       
    int MAX = 10000000;       
    Lock lock = new ReentrantLock();       
    long start = System.nanoTime();       
    for (int i = 0; i &amp;lt; MAX; i++) {       
        synchronized (new Object()) {       
            value = value + 1;       
        }       
    }       
    long end = System.nanoTime();       
    System.out.println(&quot;synchronized cost: &quot; + (end - start)/1000000 + &quot;ms&quot;); 

    start = System.nanoTime();      
    for (int i = 0; i &amp;lt; MAX; i++) {       
        lock.lock();       
        try {       
            value = value + 1;       
        } finally {       
            lock.unlock();       
        }       
    }       
    end = System.nanoTime();       
    System.out.println(&quot;lock cost: &quot; + (end - start) + &quot;ns&quot;);       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;synchronized cost: 405ms
&lt;br  /&gt;lock cost: 479ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见Lock的运行时间比synchronized略大。可以推测java编译器为synchronized做了特别优化。&lt;/p&gt;
&lt;p&gt;再考虑多线程情况：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class SynLockTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static class SynRunner implements Runnable {      
    private long v = 0; 

    @Override      
    public synchronized void run() {       
        v = v + 1;       
    }       
} 

static class LockRunner implements Runnable {      
    private ReentrantLock lock = new ReentrantLock();       
    private long v = 0; 

    @Override      
    public void run() {       
        lock.lock();       
        try {       
            v = v + 1;       
        } finally {       
            lock.unlock();       
        }       
    } 

} 

static class Tester {      
    private AtomicLong runCount = new AtomicLong(0);       
    private AtomicLong start = new AtomicLong();       
    private AtomicLong end = new AtomicLong(); 

    public Tester(final Runnable runner, int threadCount) {      
        final ExecutorService pool = Executors.newFixedThreadPool(threadCount);       
        Runnable task = new Runnable() {       
            @Override       
            public void run() {       
                while (true) {       
                    runner.run();      
                    long count = runCount.incrementAndGet();       
                    if (count == 1) {       
                        start.set(System.nanoTime());       
                    } else if (count &amp;gt;= 10000000) {       
                        if (count == 10000000) {       
                            end.set(System.nanoTime());       
                            System.out.println(runner.getClass().getSimpleName() + &quot;, cost: &quot;       
                                    + (end.longValue() - start.longValue())/1000000 + &quot;ms&quot;);                            }       
                            pool.shutdown();       
                        return;       
                    }       
                }       
            }       
        };       
        for (int i = 0; i &amp;lt; threadCount; i++) {       
            pool.submit(task);       
        }       
    }       
} 

public static void main(String[] args) {      
    new Tester(new SynRunner(), 1);       
    new Tester(new LockRunner(), 1);       
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在测试不同线程下的表现（时间单位ms）：&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;600&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;10&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;50&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;100&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;500&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;1000&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;5000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;synchronized&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;542&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;4894&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;4667&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;4700&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;5151&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;5156&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;5178&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;lock&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;838&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;1211&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;821&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;847&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;851&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;1211&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;1241&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到，在多线程环境并存在大量竞争的情况下，synchronized的用时迅速上升，而lock却依然保存不变或增加很少。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>大列表对于GC的影响</title>
                <link>http://freewind.in/posts/539-big-list-and-gc</link>
                <pubDate>Mon, 31 Oct 2011 11:49:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">539</guid>
                <description><![CDATA[&lt;p&gt;程序中有一个大列表，里面保存了300,000个长期存活的对象，不会被GC清除。那么，这些对象会不会对GC造成影响？比如，让每次GC都花费很多的时间？&lt;/p&gt;
&lt;p&gt;因为GC时需要检查对所有对象的引用，所以我担心检查太多的对象，需要花很多时间。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-539&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;写一个测试程序：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class ListAddGc {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {     
    List&amp;lt;Long&amp;gt; list = new ArrayList&amp;lt;Long&amp;gt;(300000);      
    for (int i = 0; i &amp;lt; 300000; i++) {      
        long start = System.nanoTime();      
        list.add(start);      
        long end = System.nanoTime();      
        long cost = end - start;      
    }      
    while (true) {      
        new String(&quot;abc&quot;);      
    }      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该程序持有一个300000元素的list，然后通过不断生成新的String来触发GC操作。结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;[GC 281K-&gt;146K(15872K), 0.0028494 secs]
&lt;br  /&gt;[Full GC 146K-&gt;146K(15872K), 0.0096386 secs]
&lt;br  /&gt;[GC 43689K-&gt;43598K(55000K), 0.0258150 secs]
&lt;br  /&gt;[GC 48078K-&gt;43897K(55000K), 0.0048889 secs]
&lt;br  /&gt;[GC 48377K-&gt;43897K(55000K), 0.0017662 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003661 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003503 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0000992 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003927 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003651 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003592 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003760 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0001119 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0004512 secs]
&lt;br  /&gt;[GC 63929K-&gt;43897K(72536K), 0.0003288 secs]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见每次普通GC花费的时间极小，可以忽略。通过观察后面的数据，发现很少发生Full GC。&lt;/p&gt;
&lt;p&gt;于是我打开jvisualvm，通过它提供的“执行GC”按钮来触发Full GC。显示如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;[Full GC 16199K-&gt;740K(72536K), 0.0374200 secs]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用大约37ms。考虑到jvisualvm的影响，不使用jvisualvm，而修改代码，主动触发GC。代码如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;for (int i = 0;; i++) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new String(&quot;abc&quot;);      
if (i % 1000 == 0) {      
    System.gc();      
}      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;[Full GC 43960K-&gt;146K(55000K), 0.0133591 secs]
&lt;br  /&gt;[Full GC 551K-&gt;146K(72536K), 0.0114220 secs]
&lt;br  /&gt;[Full GC 520K-&gt;146K(66904K), 0.0114949 secs]
&lt;br  /&gt;[Full GC 406K-&gt;146K(46508K), 0.0112917 secs]
&lt;br  /&gt;[Full GC 237K-&gt;146K(15936K), 0.0114735 secs]
&lt;br  /&gt;[Full GC 237K-&gt;146K(15936K), 0.0104386 secs]
&lt;br  /&gt;[Full GC 237K-&gt;146K(15936K), 0.0107348 secs]
&lt;br  /&gt;[Full GC 237K-&gt;146K(15936K), 0.0120792 secs]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见每次Full GC使用的时间约为10ms，可接触。考虑到只要设置了足够的Xmx，Full GC并不会经常发生。所以我认识使用一个大列表拥有对象，并不会对GC造成多大影响。&lt;/p&gt;
&lt;p&gt;更多的讨论见我在stackoverflow上的提问：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7949591/if-there-is-a-list-holding-300-000-objects-all-the-time-will-gc-have-a-bad-perf&quot;&gt;http://stackoverflow.com/questions/7949591/if-there-is-a-list-holding-300-000-objects-all-the-time-will-gc-have-a-bad-perf&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>ArrayList.add在扩容时花费的时间</title>
                <link>http://freewind.in/posts/538-the-time-spent-on-expansion-of-arraylist-add</link>
                <pubDate>Mon, 31 Oct 2011 10:51:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">538</guid>
                <description><![CDATA[&lt;p&gt;ArrayList内部由一个数组来持有数据，其长度固定。当add的数据超过了当前数组长度，ArrayList会生成一个长度为原有1.5倍的新数组，把旧数据拷贝过去。该操作发生的可能性比较小，但它花费的时间较多。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-538&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;具体有多少呢？写代码测试：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class ListAddPerf {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {      
    List&amp;lt;Long&amp;gt; list = new ArrayList&amp;lt;Long&amp;gt;();       
    for (int i = 0;; i++) {       
        long start = System.nanoTime();       
        list.add(start);       
        long end = System.nanoTime();       
        long cost = end - start;       
        if (cost &amp;gt; 1000000) {       
            System.out.println(&quot;Index: &quot; + i + &quot;, Cost: &quot; + cost + &quot;ns&quot; + &quot; = &quot; + cost / 1000000 + &quot;ms&quot;);       
        }       
    }       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该代码从0开始，向ArrayList中加入元素并计时，如果超过1ms，则显示出来。测试结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Index: 132385, Cost: 14285668ns = 14ms
&lt;br  /&gt;Index: 198578, Cost: 1236917ns = 1ms
&lt;br  /&gt;Index: 285095, Cost: 18650207ns = 18ms
&lt;br  /&gt;Index: 297868, Cost: 2062708ns = 2ms
&lt;br  /&gt;Index: 446803, Cost: 23438783ns = 23ms
&lt;br  /&gt;Index: 561806, Cost: 94347099ns = 94ms
&lt;br  /&gt;Index: 670205, Cost: 4009072ns = 4ms
&lt;br  /&gt;Index: 834672, Cost: 37478150ns = 37ms
&lt;br  /&gt;Index: 1005308, Cost: 141769921ns = 141ms
&lt;br  /&gt;Index: 1500690, Cost: 54481688ns = 54ms
&lt;br  /&gt;Index: 1507963, Cost: 9182793ns = 9ms
&lt;br  /&gt;Index: 1807569, Cost: 264185533ns = 264ms
&lt;br  /&gt;Index: 2261945, Cost: 14390365ns = 14ms
&lt;br  /&gt;Index: 2573063, Cost: 111484680ns = 111ms
&lt;br  /&gt;Index: 3392918, Cost: 514175775ns = 514ms
&lt;br  /&gt;Index: 4170442, Cost: 1168867ns = 1ms
&lt;br  /&gt;Index: 4958990, Cost: 175187890ns = 175ms
&lt;br  /&gt;Index: 5089378, Cost: 31229200ns = 31ms
&lt;br  /&gt;Index: 5888911, Cost: 1039109580ns = 1039ms
&lt;br  /&gt;Index: 7634068, Cost: 200057398ns = 200ms
&lt;br  /&gt;Index: 9248161, Cost: 1136859792ns = 1136ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，在一千万次调用中，仅仅发生了20次左右，但每次花的时间都不少，特别是到后来甚至超过1s。（运行此程序时，我没有填写Xmx参数，所以后来可能发生较多的full gc）&lt;/p&gt;
&lt;p&gt;如果我们对于每一次写入的性能都很看重，此时应该考虑一下是否能接受这些偶发的较慢操作。&lt;/p&gt;
&lt;p&gt;如果在创建ArrayList时指定了初始容量（此时设为1000000），发现扩容操作更少了，结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Index: 280890, Cost: 26529072ns = 26ms
&lt;br  /&gt;Index: 567492, Cost: 36645133ns = 36ms
&lt;br  /&gt;Index: 854138, Cost: 157540178ns = 157ms
&lt;br  /&gt;Index: 3050324, Cost: 237405247ns = 237ms
&lt;br  /&gt;Index: 5278473, Cost: 749483129ns = 749ms
&lt;br  /&gt;Index: 5280609, Cost: 2085053ns = 2ms
&lt;br  /&gt;Index: 8046708, Cost: 2094405ns = 2ms
&lt;br  /&gt;Index: 8232630, Cost: 1026309ns = 1ms
&lt;br  /&gt;Index: 8341925, Cost: 2187398ns = 2ms
&lt;br  /&gt;Index: 9486066, Cost: 1958284549ns = 1958ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只发生了几次略大的延时，性能比前面略好，但它会始终占用较大的内存，需要权衡。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>ArrayList与LinkedList的适用情形</title>
                <link>http://freewind.in/posts/536-when-to-use-arraylist-and-linkedlist</link>
                <pubDate>Mon, 31 Oct 2011 01:31:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">536</guid>
                <description><![CDATA[&lt;p&gt;ArrayList是我们用的最多的List类，但它有一个同胞兄弟叫LinkedList，我们有时候需要考虑到底应该使用哪个。&lt;/p&gt;
&lt;p&gt;首先可以确定的是，在大多数情况下我们最好使用ArrayList。只有在需要大量删除的时候，才需要考虑LinkedList。&lt;/p&gt;
&lt;p&gt;ArrayList在内部用数组来保持数据。当add时，发现不够用，会生成一个新的数组，其长度是原来的1.5倍，然后把数据都拷贝过去。当remove时，每次都会生成一个新数组，拷贝过去。所以最耗时的操作是remove，而add和get，都是很快的。&lt;/p&gt;
&lt;p&gt;LinkedList在内部使用双向链接实现。每一个元素都有一个Entry对象，保持着前一个和后一个Entry。每一次插入都需要生成一个新的Entry对象，比ArrayList多占用很多内存，但速度较快；get时，需要从头一个个遍历元素，也比较慢；最快的操作就是remove了，因为它仅仅需要删除一个Entry，把它前后的Entry指针改一下即可。&lt;/p&gt;
&lt;p&gt;所以ArrayList与LinkedList是正好相反且互补的。只有当我们需要经常删除List中的数据时，才需要考虑使用LinkedList，其它时候，使用ArrayList有最好的性能。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-536&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;使用以下代码测试：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class ListPerfTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static int INIT_COUNT = 1000000;     
private static int TEST_COUNT = 10000;      
private static long data = System.currentTimeMillis(); 

public static void main(String[] args) {     
    List&amp;lt;Long&amp;gt; arrayList = new ArrayList&amp;lt;Long&amp;gt;();      
    for (int i = 0; i &amp;lt; INIT_COUNT; i++) {      
        arrayList.add(data);      
    } 

    testListAdd(arrayList);     
    testListRemove(arrayList);      
    testListGet(arrayList);      
    testListSize(arrayList); 

    List&amp;lt;Long&amp;gt; linkedList = new LinkedList&amp;lt;Long&amp;gt;();     
    for (int i = 0; i &amp;lt; INIT_COUNT; i++) {      
        linkedList.add(data);      
    }      
    testListAdd(linkedList);      
    testListRemove(linkedList);      
    testListGet(linkedList);      
    testListSize(linkedList); 

} 

private static void testListAdd(List&amp;lt;Long&amp;gt; list) {     
    long start = System.nanoTime();      
    for (int i = 0; i &amp;lt; TEST_COUNT; i++) {      
        list.add(data);      
    }      
    long end = System.nanoTime();      
    System.out.println(list.getClass().getSimpleName() + &quot;, init items: &quot; + INIT_COUNT + &quot;, added &quot; + TEST_COUNT      
            + &quot; items, cost: &quot; + (end - start) / 1000000 + &quot;ms&quot;);      
} 

private static void testListRemove(List&amp;lt;Long&amp;gt; list) {     
    long start = System.nanoTime();      
    for (int i = 0; i &amp;lt; TEST_COUNT; i++) {      
        list.remove(data);      
    }      
    long end = System.nanoTime();      
    System.out.println(list.getClass().getSimpleName() + &quot;, init items: &quot; + INIT_COUNT + &quot;, removed &quot; + TEST_COUNT      
            + &quot; items, cost: &quot; + (end - start) / 1000000 + &quot;ms&quot;);      
} 

private static void testListGet(List&amp;lt;Long&amp;gt; list) {     
    long start = System.nanoTime();      
    for (int i = 0; i &amp;lt; TEST_COUNT; i++) {      
        list.get(INIT_COUNT / 2);      
    }      
    long end = System.nanoTime();      
    System.out.println(list.getClass().getSimpleName() + &quot;, init items: &quot; + INIT_COUNT + &quot;, got &quot; + TEST_COUNT      
            + &quot; items, cost: &quot; + (end - start) / 1000000 + &quot;ms&quot;);      
} 

private static void testListSize(List&amp;lt;Long&amp;gt; list) {     
    long start = System.nanoTime();      
    for (int i = 0; i &amp;lt; TEST_COUNT; i++) {      
        list.size();      
    }      
    long end = System.nanoTime();      
    System.out.println(list.getClass().getSimpleName() + &quot;, init items: &quot; + INIT_COUNT + &quot;, sized &quot; + TEST_COUNT      
            + &quot; items, cost: &quot; + (end - start) / 1000000 + &quot;ms&quot;);      
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试次数固定为10000，比较在不同的数据量下，各函数的运行时间（单位ms）：&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;600&quot; border=&quot;1&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;100&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1000&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;10000&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;100000&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;**ArrayList**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;add&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;147&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;remove&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;56&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;65&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;183&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1944&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;25447&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;get&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;size&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;**LinkedList**&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;add&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;remove&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;2&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;get&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;4&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;11&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;408&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;12517&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;200504&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;size&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;0&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中ArrayList.add在最后那个147ms，可能只是因为运气比较差，正好遇到一次数组扩容，否则大多数情况下，只需要1ms。&lt;/p&gt;
&lt;p&gt;从上图可以看出，ArrayList的remove很花时间，而LinkedList的get很花时间，再考虑到LinkedList要使用更多的内存，我们就可以判断在什么情况下使用哪个类了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>内存中有一队列，一线程写，多线程读，如何高效实现</title>
                <link>http://freewind.in/posts/535-how-to-effectively-read-write-a-list-in-memory</link>
                <pubDate>Mon, 31 Oct 2011 00:19:21 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">535</guid>
                <description><![CDATA[&lt;p&gt;内存中有一个长度不固定的队列（或其它数据结构），一线程不断写入，多个线程实时读取（只读不移除）。如何在队列中已写入大量对象的情况下，依然能让读取线程最快读到写入的新数据？&lt;/p&gt;
&lt;p&gt;具体一些，有如下要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写入线程将向该队列写入大量对象，如50万个以上，每个对象2K左右2.  读线程可在任何时间开始读取，并可从任意一个索引开始3.  读线程读取时，必须一个接一个，中间不能间隔4.  当读线程读完所有数据后，要等待写线程写入新数据，再读取5.  重要要求：读线程&lt;strong&gt;尽可能快&lt;/strong&gt;地读取到写入的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该队列必须线程安全2.  所有操作必须考虑在大数据量的情况下性能表现3.  写线程：在队列尾部高效写入4.  读线程：可从任意索引开始，所以必须能快速根据索引定位5.  读线程：可高效取得下一个对象（根据索引定位，或iterator之类）6.  当读线程读完数据后，如何等待写入7.  写入线程写入后，如何通知读线程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先想到的是jdk5中加入的并发库中的&lt;strike&gt;BlockingQueue&lt;/strike&gt;，但很快否定，因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能根据索引定位元素2.  仅offer和take有阻塞功能，但我们不能使用其take，所以利用不到该优势&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;考虑List：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ArrayList：备选，需考虑线程安全2.  &lt;strike&gt;LinkedList&lt;/strike&gt;：不需要删除的时候，性能比ArrayList差&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>jvisualvm的profiler分析对synchronized的影响</title>
                <link>http://freewind.in/posts/534-jvisualvm-profiler-impacts-synchronized</link>
                <pubDate>Sat, 29 Oct 2011 12:50:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">534</guid>
                <description><![CDATA[&lt;p&gt;昨天运行MDF程序时，使用jsivualvm进行分析。开始发现各线程未出现阻塞状态，但当点击了Profiler项的CPU性能分析之后，线程出现了明显且持续的阻塞。&lt;/p&gt;
&lt;p&gt;因为Profiler的CPU分析需要计算每个方法的调用次数以及运行的时间，所以在内部会进行大量的工作。它会不会导致无synchronized的代码出现阻塞？或者加剧阻塞机率？这里写代码测试一下。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-534&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、完全不会阻塞的多线程程序&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;import java.util.concurrent.atomic.AtomicLong;&lt;/p&gt;
&lt;p&gt;public class NoSynTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {      
    // 让jvivualvm有足够的时间做准备工作       
    Thread.sleep(5000); 

    final AtomicLong count = new AtomicLong(0);      
    for (int i = 0; i &amp;lt; 2; i++) {       
        new Thread() {       
            public void run() {       
                while(true) {       
                    count.incrementAndGet();       
                }       
            };       
        }.start();       
    }       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jvisualvm在开启了Profiler之后的线程图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/534-1.png&quot;&gt;&lt;img src=&quot;/user_images/534-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此处的Thread-7和Thread-6就是工作线程，可以看出，全为绿色，表示正常运行。&lt;/p&gt;
&lt;p&gt;二、&lt;strong&gt;有synchronized的多线程程序，不开Profiler&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class SynTest {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {      
    // 让jvivualvm有足够的时间做准备工作       
    Thread.sleep(5000); 

    final AtomicLong count = new AtomicLong(0);      
    for (int i = 0; i &amp;lt; 2; i++) {       
        new Thread() {       
            public void run() {       
                while(true) {       
                    synchronized (count) {       
                        count.incrementAndGet();       
                    }       
                }       
            };       
        }.start();       
    }       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没开Profiler时的线程状态：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/534-3.png&quot;&gt;&lt;img src=&quot;/user_images/534-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、&lt;strong&gt;有synchronized的多线程程序，开Profiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/534-5.png&quot;&gt;&lt;img src=&quot;/user_images/534-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与二对比，可以看到仍然有阻塞现象，但并无“加剧”表现。&lt;/p&gt;
&lt;p&gt;注：此处测试比较麻烦，因为当程序运行时，jvisualvm反应很慢，一次简单测试要等十五分钟以上，甚至一直卡住无反应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、拿MDF程序测试，不开Profiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/534-7.png&quot;&gt;&lt;img src=&quot;/user_images/534-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到完全没有阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、开Profiler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/534-9.png&quot;&gt;&lt;img src=&quot;/user_images/534-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，的确有阻塞现象发生。说明jvivualvm的确可加剧阻塞的产生。而在第二步第三步的测试中，都出现了阻塞，可能是因为代码写得比较容易产生阻塞，所以在平时状态下也会出现。&lt;/p&gt;
&lt;p&gt;但是如何修改代码，才能模拟出MDF的这种状态不太容易，所以不继续深究。因为已经可以得出结论：&lt;strong&gt;jvisualvm不会无中生有产生阻塞，但会加剧阻塞的产生&lt;/strong&gt;。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在linux上安装postgresql详解</title>
                <link>http://freewind.in/posts/515-install-postgresql-on-windows</link>
                <pubDate>Fri, 28 Oct 2011 21:11:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">515</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;下载及安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入源代码下载页面:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://www.postgresql.org/ftp/source/&quot;&gt;http://www.postgresql.org/ftp/source/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我选择的是v8.4.8:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;wget &lt;a href=&quot;http://wwwmaster.postgresql.org/redir/418/h/source/v8.4.8/postgresql-8.4.8.tar.gz&quot; title=&quot;http://wwwmaster.postgresql.org/redir/418/h/source/v8.4.8/postgresql-8.4.8.tar.gz&quot;&gt;http://wwwmaster.postgresql.org/redir/418/h/source/v8.4.8/postgresql-8.4.8.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;tar xzvf postgresql-8.4.8.tar.gz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用默认参数configure&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;cd postgresql-8.4.8
&lt;br  /&gt;./configure&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span id=&quot;more-515&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;如果提示找不到readline，但readline已经安装，说明缺少了readline-devel。其它错误类似。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;yum install readline-devel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译安装，过程漫长&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动安装到了/usr/local/pgsql下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增加postgresql专用用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;posgresql为安全考虑，不允许以root用户运行，必须为它建立对应的用户和组&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;useradd postgres&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将自动建立对应的组(postgres)&lt;/p&gt;
&lt;p&gt;为其配置环境变量：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;vim ~postgres/.bash_profile&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在最后加上&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;PGLIB=/usr/local/pgsql/lib
&lt;br  /&gt;PGDATA=$HOME/data
&lt;br  /&gt;PATH=$PATH:/usr/local/pgsql/bin
&lt;br  /&gt;MANPATH=$MANPATH:/usr/local/pgsql/man
&lt;br  /&gt;export PGLIB PGDATA PATH MANPATH&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;建立数据目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先切换用户&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;su – postgres&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立数据目录&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;mkdir data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;初始化目录数据&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;cd data
&lt;br  /&gt;initdb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将出现如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-1.png&quot;&gt;&lt;img src=&quot;/user_images/515-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;启动postgresql&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;posgtres -D /home/postgres/data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果出现类似下面的提示，就说明安装成功&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;LOG:  database system was shut down at 2011-10-28 08:22:40 CST
&lt;br  /&gt;LOG:  database system is ready to accept connections
&lt;br  /&gt;LOG:  autovacuum launcher started&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按ctrl+c停止，使用以下命令，以后台服务方式启动&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;pg_ctl start&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会出现一些提示信息。按回车，将出现命令提示符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用命令行连接数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建数据库mydb&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;p&gt;$createdb mydb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;连接数据库&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;$psql mydb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作数据库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-3.png&quot;&gt;&lt;img src=&quot;/user_images/515-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明现在的数据库可以正常运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;允许远程连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;postgresql因为安全方面的考虑，默认情况下只接受本机的连接。为了管理的方便，我们需要开通远程连接。&lt;/p&gt;
&lt;p&gt;修改data/postgresql.conf，增加：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-5.png&quot;&gt;&lt;img src=&quot;/user_images/515-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改监听端口：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-7.png&quot;&gt;&lt;img src=&quot;/user_images/515-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改data/pg_hba.conf，增加md5那一行：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-9.png&quot;&gt;&lt;img src=&quot;/user_images/515-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后重启posgtres。&lt;/p&gt;
&lt;p&gt;修改配置后马上生效不重启：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;pg_ctl reload&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;给postgres设置密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，postgresql数据库中的超级用户postgres密码为空，导致无法远程登录。我们必须先给它设个密码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-11.png&quot;&gt;&lt;img src=&quot;/user_images/515-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样，postgres的密码也是postgres了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在windows上安装管理程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://get.enterprisedb.com/postgresql/postgresql-8.4.8-1-windows-binaries.zip&quot;&gt;http://get.enterprisedb.com/postgresql/postgresql-8.4.8-1-windows-binaries.zip&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载后解压，运行其中的pgAdmin III程序，如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-13.png&quot;&gt;&lt;img src=&quot;/user_images/515-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;确定后，如果没错误，就会连上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/515-15.png&quot;&gt;&lt;img src=&quot;/user_images/515-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把postgres服务设为自动启动
&lt;br  /&gt;进入postgresql的源代码解压目录&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;cp contrib/start-scripts/linux /etc/init.d/postgresql
&lt;br  /&gt;chmod a+x /etc/init.d/postgresql
&lt;br  /&gt;chkconfig –add /etc/init.d/postgresql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在postgresql中创建用户，并设置数据库&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;create database ttt owner ttt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样就设置了一个数据库叫ttt，并且它的拥有者是一个叫ttt的用户。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在同一台电脑上运行的socket server和client之间传数据，最大速度为多少？</title>
                <link>http://freewind.in/posts/497-max-speed-of-transfering-data-from-socket-server-and-client-on-one-computer</link>
                <pubDate>Wed, 26 Oct 2011 23:20:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">497</guid>
                <description><![CDATA[&lt;p&gt;我对于Java的socket性能，其实一直都没有一个数值上的概念。比如，写一个最简单的socket server和client，它们什么也不做，就是server不断向client发数据，client收到后就丢弃，只计数算速度。&lt;/p&gt;
&lt;p&gt;那么速度应该是多少呢？&lt;/p&gt;
&lt;p&gt;注意，如果server和client在同一台电脑上，其速度不受网卡限制，因为数据不经过网卡，直接在内存中复制。没有了IO等待，测试的就是Java socket的性能。&lt;/p&gt;
&lt;p&gt;在我的电脑上，最大值为170MBytes/s。我的电脑配置：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;AMD Athlon X2 4000+
&lt;br  /&gt;4G DDR2 667 Ram
&lt;br  /&gt;500G Seagate 7200转&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;朋友的电脑比我要好一些，大约是200MBytes/s。这个速度还是让人觉得不够快，毕竟是内存操作。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-497&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;我在stackoverflow上提了问：&lt;a href=&quot;http://stackoverflow.com/questions/7903013/the-speed-of-socket-is-120mb-s-on-a-computer-is-it-normal&quot;&gt;http://stackoverflow.com/questions/7903013/the-speed-of-socket-is-120mb-s-on-a-computer-is-it-normal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中一位牛人的测试结果是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Read 25,586,204,672 bytes, speed: 5,245 MB/s
&lt;br  /&gt;Read 53,219,426,304 bytes, speed: 5,317 MB/s
&lt;br  /&gt;Read 85,018,968,064 bytes, speed: 5,416 MB/s
&lt;br  /&gt;Read 117,786,968,064 bytes, speed: 5,476 MB/s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你没有看错，5GBytes/s，是我的30倍。他贴出了自己的电脑配置：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I am using an ASUS Maximus IV, i7 2700K at 4.6 GHz, 16 GB of 1600 MHz DDR3, OCZ Vertex 3 240GB SSD, with Centos 5.7.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这配置真让我羡慕：顶级的CPU、内存，还有固态硬盘！&lt;/p&gt;
&lt;p&gt;注：今天终于了解了内存后面的667是什么意思，原来是频率，即667MHz。它与内存带宽的关系是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;内存带宽=频率*内存位宽/8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是双通道内存，则位宽为128，单通道为64。所以DDR2 667的带宽为：667*128/8=10672MBytes=10.4GBytes&lt;/p&gt;
&lt;p&gt;但这里引申出来一个问题：DDR2 667的内存的带宽已经这么大，够用了，那么我换成更高频率的内存，CPU不变，对我的程序速度是不是没有任何帮助？&lt;/p&gt;
&lt;p&gt;自如说内存的频率跟CPU是配套的，电脑城装电脑的小弟们才需要知道这些。我觉得我还应该补补这方面的课，因为我对主频外频什么的，一直都不太明白。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>证券转发程序的程序调优记录</title>
                <link>http://freewind.in/posts/495-record-of-optmizating-a-security-program</link>
                <pubDate>Tue, 25 Oct 2011 01:30:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">495</guid>
                <description><![CDATA[&lt;p&gt;这些天一直在想办法优化证券转发程序的性能。&lt;/p&gt;
&lt;p&gt;终于跑起了Simulator和MDF程序，并使用jvisualvm检查了一下线程的运行情况，发现一切都挺正常的。&lt;/p&gt;
&lt;p&gt;这可找不到下手的地方了。于是决定从头开始，一点点猜测一点点验证。&lt;/p&gt;
&lt;p&gt;首先是我的电脑配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpu：AMD Athlon X2 4000+&lt;em&gt;   内存：4G&lt;/em&gt;   操作系统：windows xp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我一步步地猜想和测试：&lt;/p&gt;
&lt;p&gt;一、&lt;strong&gt;单机使用Socket来发送和接收数据，最大速度能达到多少呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-495&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;我用socket写了一个最简单的Server和Client程序。Server不断向Client发送，每次10K。Client收到后直接丢弃，只计算收到的字节的数据，打印出来。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;Server.java&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class SimpleServer {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {       
    ServerSocket server = new ServerSocket(6666);       
    Socket socket = server.accept();       
    OutputStream output = socket.getOutputStream(); 

    byte[] bytes = new byte[32 * 1024]; // 32K      
    while (true) {       
        output.write(bytes);       
    }       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Client.java&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;public class SimpleClient {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {       
    Socket socket = new Socket(&quot;127.0.0.1&quot;, 6666);       
    InputStream input = socket.getInputStream();       
    long total = 0;       
    long start = System.currentTimeMillis(); 

    byte[] bytes = new byte[32 * 1024]; // 32K      
    for (int i = 1;; i++) {       
        total += input.read(bytes);       
        if (i % 1000000 == 0) {       
            long cost = System.currentTimeMillis() - start;       
            System.out.printf(&quot;Read %,d bytes, speed: %,d MB/s%n&quot;, total, total / cost / 1000);       
        }       
    }       
}       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行之后，发现速度稳定在&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;170MBytes/s&lt;/font&gt;&lt;/strong&gt;。注意此处在计算时除以1000而不是1024来简化，对结果影响不大。&lt;/p&gt;
&lt;p&gt;由于在本机运行，数据不经过网卡，都是直接在内存中复制的，所以速度很快。因为此时没有网卡和网络的影响，cpu与内存占了主要因素，所以可见我的电脑的处理能力极限是这么多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、两台电脑间用百兆网卡连接，之间最大传输速度是多少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我用一根专用的网线将两台电脑连接起来。两台电脑的网卡都是100Mbits，没有路由器的损耗，可以认为两台电脑间的速度就是100Mbits/s。&lt;/p&gt;
&lt;p&gt;然后在一台电脑上运行Server，另一台运行Client，实际速度为&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;10.xMbytes/s&lt;/font&gt;&lt;/strong&gt;。这个结果可认为完全用满了带宽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、在公司生产环境中进行以上两个测试，结果如何&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器1（8核Cpu，2.2GHz； 8G内存，146G硬盘（15000转）），速度：2800MB/s&lt;/p&gt;
&lt;p&gt;服务器2（双核Cpu，2.4GHz；4G内存，73G硬盘（10000转）），速度：1800MB/s&lt;/p&gt;
&lt;p&gt;从服务器1到服务器2，速度：55MB/s，千兆网卡&lt;/p&gt;
&lt;p&gt;看来公司的服务器，配置还不错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、Simulator的最大发送速度是多少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我使用“一”中的Client在本机接收Simulator的数据（不经过网卡），以测试其性能，大约&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;22MB/s&lt;/font&gt;&lt;/strong&gt;。因为Simulator的数据是实时从文件中读取的，而硬盘的读取速度差不多20多M，所以Simulator的性能应该还是不错的。如果预先把数据都放在内存中，可能速度会更高一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、测试MDF的接收性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MDF分为两个部分，一是接收，把数据保存在内存中，二是发送，把数据转发给客户端。这里先测试接收。&lt;/p&gt;
&lt;p&gt;我在一台电脑上放simulator，另一个放MDF，测试结果还不错，能达到10MB/s。看来接收端没有性能问题。（注：测试时一定要把log4j的Console去掉，不去的话，只有3M多）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、测试MDF的发送性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MDF的发送有点不太好测，这跟其内部实现有关。MDF接收的数据，并不是完全保存在内存中，而是只保存最近的5000条。之所以这样，一是因为当时开发时使用的是32位机，jvm中的Xmx最大只能设不到1G，如果把数据都放在内存中，可能不够。所以默认情况下，MDF只保存最近的5000条以快速发送（大多数时候够用），如果中途有新机加入取数据，则会从数据库中读取。&lt;/p&gt;
&lt;p&gt;但在测试时发现，很难把握好时间让MDF刚好用到内存中的数据。这是因为，如果开了simulator，会对MDF有影响。但不开simulator，则发送时只能从数据库中取数据。怎么测都得读数据库。测试结果为&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;6MB/s&lt;/font&gt;&lt;/strong&gt;，没有用完带宽。使用jvisualvm进行监测，发现占用时间最多的函数是从数据库中读取数据。&lt;/p&gt;
&lt;p&gt;如果修改MDF的设置，让它保存最近400000条呢？这样就不需要从数据库中读了（因为当时信息总量为30多万条）。&lt;/p&gt;
&lt;p&gt;测试结果为&lt;strong&gt;&lt;font color=&quot;#ff0000&quot;&gt;7MB/s&lt;/font&gt;&lt;/strong&gt;左右。虽然比读数据库好一些，但还是没有用完带宽，为什么？&lt;/p&gt;
&lt;p&gt;使用jvisualvm监测，发现的确没有从数据库读取数据。另外，发现在发送信息的过程中，很多与Message类相关的方法被调用了很多次，如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/495-1.png&quot;&gt;&lt;img src=&quot;/user_images/495-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些方法是否可以简化？直接把信息简化为二进制数组放在内存中，而不要使用一些InnerBytes之类给它套上？&lt;/p&gt;
&lt;p&gt;另外，在线程图页面，也发现了不少“阻塞”的线程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/495-3.png&quot;&gt;&lt;img src=&quot;/user_images/495-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然可以相信图中这么多红色是因为jvisualvm的Profiler抽样监测加大了阻塞的机率，但可以推测，在高并发状态下阻塞情况也会比较容易发生。可能正是因为它而导致发送速度变慢。现在从内存列表中取数据时，的确有一些synchronized操作。&lt;/p&gt;
&lt;p&gt;我们需要先修改代码，把所有数据放入内存之后，再优化这里的synchronized。&lt;/p&gt;
&lt;p&gt;至此，需要对MDF进行比较大的修改，才能继续测，一时半会儿改不完。改天再继续测。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>为什么用System.nanoTime()测量代码，却得到负值？</title>
                <link>http://freewind.in/posts/491-why-get-a-negative-value-to-use-system-nanotime</link>
                <pubDate>Sun, 23 Oct 2011 20:50:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">491</guid>
                <description><![CDATA[&lt;p&gt;从之前的几篇日志中，我知道应该使用System.nanoTime()来测量代码的运行时间，会比较准确。但是我在使用过程中发现，有时候居然得到了负值，怎么回事？&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    while (true) {
        long start = System.nanoTime();
        for (int i = 0; i &amp;lt; 10000; i++)
            ;
        long end = System.nanoTime();
        long cost = end - start;
        if (cost &amp;lt; 0) {
            System.out.println(&quot;start: &quot; + start + &quot;, end: &quot; + end + &quot;, cost: &quot; + cost);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到了如下的结果：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;start: 34571588742886, end: 34571585695366, cost: -3047520
&lt;br  /&gt;start: 34571590239323, end: 34571586847711, cost: -3391612
&lt;br  /&gt;start: 34571651240343, end: 34571648928369, cost: -2311974
&lt;br  /&gt;start: 34571684937094, end: 34571681543134, cost: -3393960
&lt;br  /&gt;start: 34571791867954, end: 34571788878081, cost: -2989873
&lt;br  /&gt;start: 34571838733068, end: 34571835464021, cost: -3269047
&lt;br  /&gt;start: 34571869993665, end: 34571866950949, cost: -3042716
&lt;br  /&gt;start: 34571963747021, end: 34571960656216, cost: -3090805
&lt;br  /&gt;start: 34571965020545, end: 34571961637608, cost: -3382937
&lt;br  /&gt;start: 34572010616580, end: 34572007613257, cost: -3003323&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么，居然有负值？！这让人怎么去测量代码运行时间啊。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：windows xp sp3&lt;/li&gt;
&lt;li&gt;Java: jdk1.6u27&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终在万能的stackoverflow上得到了答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7866206/why-i-get-a-negative-elapsed-time-using-system-nanotime&quot;&gt;http://stackoverflow.com/questions/7866206/why-i-get-a-negative-elapsed-time-using-system-nanotime&lt;/a&gt;*   &lt;a href=&quot;http://stackoverflow.com/questions/510462/is-system-nanotime-completely-useless&quot;&gt;http://stackoverflow.com/questions/510462/is-system-nanotime-completely-useless&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其原因是在多核机器上，每个核的启动时间不完全一致。在我的例子中，大约相差3ms。其它的操作系统会自己修正这个时间差，而windows xp比较笨。所以会有这个问题。&lt;/p&gt;
&lt;p&gt;另外据网友们在各平台上的测试，目前只发现windows xp有这个问题。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>利用jvisualvm检测程序死锁</title>
                <link>http://freewind.in/posts/482-use-jvisualvm-to-find-deadlocks</link>
                <pubDate>Sun, 23 Oct 2011 13:25:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">482</guid>
                <description><![CDATA[&lt;p&gt;刚才在群里介绍了JVisualVM的功能，sungod问：&amp;ldquo;它能检测到线程死锁吗&amp;rdquo;&lt;/p&gt;
&lt;p&gt;所以我专门写了一个简单的死锁程序，看看jvisualvm的反应。&lt;/p&gt;
&lt;p&gt;这里我考虑的是一种简单的死锁情况：线程1拿到了a的锁，准备拿b的锁；同时线程2拿到了b的锁，准备拿a的锁。两个线程谁也不让，把自己的既得利益抓得紧紧的，然后会抢对方的。于是僵持不下，程序就死锁了。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-482&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package test;

public class DeadLock {

    public static void main(String[] args) {
        final Object a = new Object();
        final Object b = new Object();

        new Thread() {
            @Override
            public void run() {
                try {
                    synchronized (a) {
                        System.out.println(&quot;Thread 1 got the lock of a&quot;);
                        Thread.sleep(1000);
                        System.out.println(&quot;Thread 1 was trying to get the lock of b&quot;);
                        synchronized (b) {
                            System.out.println(&quot;Thread 1 win&quot;);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();
        new Thread() {
            @Override
            public void run() {
                try {
                    synchronized (b) {
                        System.out.println(&quot;Thread 2 got the lock of b&quot;);
                        Thread.sleep(1000);
                        System.out.println(&quot;Thread 2 was trying to get the lock of a&quot;);
                        synchronized (a) {
                            System.out.println(&quot;Thread 2 win&quot;);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序打印出以下内容：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Thread 1 got the lock of a
&lt;br  /&gt;Thread 2 got the lock of b
&lt;br  /&gt;Thread 1 was trying to get the lock of b
&lt;br  /&gt;Thread 2 was trying to get the lock of a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后就卡住了。&lt;/p&gt;
&lt;p&gt;现在打开jvisualvm，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/482-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Thread1与2两个都处于&quot;监视&quot;状态。&lt;/p&gt;
&lt;p&gt;点一下&quot;线程Dump&quot;按钮，找到Thread1与2的信息，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/482-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从中可以得知，两者都处于&quot;Blocked&quot;状态，并且知道阻塞在哪一行代码上。&lt;/p&gt;
&lt;p&gt;我在jvisualvm中没有找到明确说明两者都处于&quot;死锁&quot;状态的文字，但从线程图中，我们可以很轻易地找到这种可疑特征：两个（或多个）线程长期同时处于&quot;监视（被阻塞）&amp;ldquo;状态，说明它们很可能出现了死锁，应当认真分析其代码。&lt;/p&gt;
&lt;p&gt;我想这对于我们检查死锁也是非常有帮助的。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>利用jdk自带的强悍工具jvisualvm检测多线程的竞争</title>
                <link>http://freewind.in/posts/479-use-jdk-builtin-jvisualvm-to-check-multithread-competition</link>
                <pubDate>Sun, 23 Oct 2011 12:55:01 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">479</guid>
                <description><![CDATA[&lt;p&gt;我有一个程序，里面有大量的synchronized关键字。我怀疑它们导致的多线程竞争影响了程序的性能。但不知道如何去检测，总不能只凭自己的猜测就去修改它们，万一改到最后发现不是它们的问题，岂不浪费了。&lt;/p&gt;
&lt;p&gt;用什么工具来测试呢？我以前用过jprofiler，那个虽然功能强大，但不是免费的。于是我在万能的stackoverflow上提了个问题，聆听神人的教诲。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7858730/how-to-know-how-much-time-cost-by-synchronized-code-in-java&quot;&gt;http://stackoverflow.com/questions/7858730/how-to-know-how-much-time-cost-by-synchronized-code-in-java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然，很快有人提供了一个很强大的免费工具：JDK6自带的jvisualvm。&lt;/p&gt;
&lt;p&gt;这个东西我以前听过说，但一直没有用过。看到它提供的截图中可以看到各线程的运行状态，所以准备试一下。这里记录一下使用过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1。启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行输入jvisualvm。如果jdk安装正确的话(6.x以上版本），就会看到如下的一个窗口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;看起来相当简洁，不像是很强大的样子。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-479&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;2。运行一个Java程序IncTestN，jvisualvm会自动找到它&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.右键点击它，&amp;ldquo;打开&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到它有很多标签页，可以让我们监测程序的各种数据。默认没有这么多，我其实安装了一些jvisualvm的插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4。查看jvm参数及系统属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5。查看cpu、内存、类、线程的统计数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;注意，右边第一个还可以查看PermGen。对于scala程序，因为它产生了大量的类定义，所以PermGen有可能会不足，可通过该选项查看PermGen，适当调整：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，对于本程序来说，PermGen还是比较充分的，无须调整。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6。查看各线程运行情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是重点，我们需要知道各线程的运行情况，特别是否被synchronized阻塞了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;注意右下角，有四个状态说明，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运行(Running)：我们最喜欢的状态。说明该线程正在执行代码，没有问题。&lt;/li&gt;
&lt;li&gt;休眠(Sleeping)：调用了Thread.sleep后的状态，说明线程正停在某个Thread.sleep处&lt;/li&gt;
&lt;li&gt;等待(Wait)：手动调用了wait方法，或者某些IO操作，在阻塞中等待数据。&lt;/li&gt;
&lt;li&gt;监视(Monitor)：这里就是我想找的问题了。它表示线程想执行一段synchronized中的代码，但是发现已经有其它线程正在执行，自己被block了，只能无奈地等待。如果这种状态多，说明程序需要好好优化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面的这个图可以看到，下面多个线程都处于&quot;监视&quot;状态。多个线程都卡在了独木桥的一头过不去，干不了活干着急呢。&lt;/p&gt;
&lt;p&gt;当然这个程序是我专门设计成这样的，存在着严重的性能问题，需要好好优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7。查看各线程的统计数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们需要一些统计数据，比如某个线程总共运行了多少时间，&amp;ldquo;运行&quot;状态有多久（或百分比），休眠、等待、监视有多久，则需要用到&quot;表&quot;这一页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从中可以看到这个悲催的程序，几分所有的时间都用在了synchronized的阻塞上了。只有百分之零点几的时间在运行中，效率可真低啊。&lt;/p&gt;
&lt;p&gt;还可以使用图表方式来看这些数据，得到更直观的体验：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8。查看各方法的运行时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想不想程序中到底是哪些方法一直在运行？可使用&quot;抽样器&quot;功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们需要先点击上面的&quot;CPU&quot;按钮，它才会开始统计，下面的数据会慢慢多起来。从上图可以看出，程序一直在运行SynIncer.inc()方法，它占用了所有方法执行总时间的99.8%。如果我们想提高程序性能，则需要重点优化它，让它运行得更快。&lt;/p&gt;
&lt;p&gt;还想知道方法被调用的次数？使用&quot;Profiler&quot;页中的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;它与抽样器很像，但是最后多了一个&quot;调用次数&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9。查看哪些对象占用了最多的内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当出现了内存不足的错误时，想不想知道到底是哪些对象把内存都占用了？这时需要使用&quot;抽样器&quot;的&quot;内存&quot;检测功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从表中可以看出当前最多的是哪些对象，它们有多少个，用了多少个字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10。安装更多插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jvisualvm还在线提供了很多插件，提供了更多的功能。我们可以通过&quot;工具&amp;rdquo;-&gt;&amp;ldquo;插件&amp;rdquo;，找到并安装它们。推荐全装，比如我就安装了全部（当前有16个）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安装重启后，再找到某个程序节点，就会发现有更多的标签页可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11。查看MBeans&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MBeans可以将程序中的某些信息暴露给外部。有一些库在设计时，就考虑到了这一点。如果我们不满足于前面那些基础信息，可以在这里看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由于当前程序没有使用到提供MBeans信息的库，所以看不到什么多少有用的信息。如果你使用了某些数据库连接池（提供了MBeans功能的），可以在这里看到池里的一些信息，还可以通过&quot;Operations&quot;标签页，对程序数据进行一些修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12。查看gc情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;垃圾回收是我们不能忽略的一个地方。我们可以通过&quot;Visual GC&quot;页，查看到非常详细的垃圾回收情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以说，这个功能提供的信息真是非常地详尽，连两个小Eden的情况也实时地表现出来了。不过要看懂这些数据，还是需要先到网上看看讲解Java垃圾回收的文章，了解其内部原理才行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13。更多更详细的监测内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tracer页提供了更多的监测内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到程序中遍布探针，让我们实时了解到各处的运行情况。先选中感兴趣的内容，然后点击&quot;Start&quot;按钮即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/479-16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这一块比较专业，普通开发人员可能都不知道这些数据到底有什么用。但专业人士可能会觉得会很需要它们。&lt;/p&gt;
&lt;p&gt;JvisualVM的大部分功能都已经演示完了，我想它的功能的确很强大，在我们平时的开发中会非常有用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如果synchronized中有IO操作，多线程并不会提高性能</title>
                <link>http://freewind.in/posts/460-multithread-wont-get-better-performance-if-there-are-io-operations-in-synchronized-code</link>
                <pubDate>Sat, 22 Oct 2011 23:17:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">460</guid>
                <description><![CDATA[&lt;p&gt;在之前的文章&amp;rdquo;&lt;a href=&quot;http://freewind.me/blog/20111022/458.html&quot;&gt;原子操作与synchronized在多线程环境下的性能差别&lt;/a&gt;&amp;#8220;中，发现在2个线程与50个线程情况下，程序运行时间并没有什么差别。我考虑的原因是，因为我synchronized中的代码都很简单，所以线程间竞争的机会并不大。&lt;/p&gt;
&lt;p&gt;林教主让我在代码中增加一些sleep(1)，来模拟IO操作。于是有了以下的代码：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-460&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IncTestN {

        public static int MAX_COUNT = 5000;
        public static int THREADS = 50;

        interface Incer {
                long inc() throws Exception;
        }

        static class AtomIncer implements Incer {
                private AtomicLong atom = new AtomicLong();

                @Override
                public long inc() throws Exception {
                        long v = atom.incrementAndGet();
                        Thread.sleep(1);
                        return v;
                }
        }

        static class SynIncer implements Incer {
                private long syn = 0;

                @Override
                public synchronized long inc() throws Exception {
                        syn += 1;
                        Thread.sleep(1);
                        return syn;
                }
        }

        static class Tester {
                ExecutorService pool = Executors.newFixedThreadPool(THREADS);
                Incer incer;
                final AtomicLong start = new AtomicLong(0);
                final AtomicLong end = new AtomicLong(0);

                public Tester(Incer incer) {
                        this.incer = incer;
                }

                public long test() throws InterruptedException {
                        Callable&amp;lt;Void&amp;gt; task = new Callable&amp;lt;Void&amp;gt;() {
                                @Override
                                public Void call() throws Exception {
                                        while (true) {
                                                long v = incer.inc();
                                                if (v == 1) {
                                                        start.set(System.nanoTime());
                                                } else if (v == MAX_COUNT) {
                                                        end.set(System.nanoTime());
                                                        break;
                                                } else if (v &amp;gt; MAX_COUNT) {
                                                        break;
                                                }
                                        }
                                        return null;
                                }
                        };
                        List&amp;lt;Callable&amp;lt;Void&amp;gt;&amp;gt; list = new ArrayList&amp;lt;Callable&amp;lt;Void&amp;gt;&amp;gt;();
                        for (int i = 0; i &amp;lt; THREADS; i++) {
                                list.add(task);
                        }
                        pool.invokeAll(list);
                        long cost = (end.longValue() - start.longValue()) / 1000000;
                        pool.shutdownNow();
                        return cost;
                }
        }

        public static void main(String[] args) throws Exception {
                long atomCost = new Tester(new AtomIncer()).test();
                System.out.println(&quot;Atom cost: &quot; + atomCost + &quot;ms&quot;);

                long synCost = new Tester(new SynIncer()).test();
                System.out.println(&quot;Synchronized cost: &quot; + synCost + &quot;ms&quot;);
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这段代码，与那篇文章中的代码，并没有大的不同，只不过每个inc()方法中增加了一个Thread.sleep(1)，模拟一个IO操作。同时将inc的max值改为5000，不然会等死。&lt;/p&gt;
&lt;p&gt;现在再运行程序，得到结果如下：&lt;/p&gt;
&lt;table width=&quot;350&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;线程数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;atom&lt;/td&gt;
&lt;td&gt;9770ms&lt;/td&gt;
&lt;td&gt;975ms&lt;/td&gt;
&lt;td&gt;198ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronized&lt;/td&gt;
&lt;td&gt;9768ms&lt;/td&gt;
&lt;td&gt;9762ms&lt;/td&gt;
&lt;td&gt;9766ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到，当线程数增多时，atom的运行时间大大减少，而synchronized没有变化。这是因为atom中多线程没有竞争，每个线程都会处于运行状态，减少了运行时间。而synchronized的，多个线程都要经过synchronized这条独木桥，实际上成了单线程。&lt;/p&gt;
&lt;p&gt;所以要注意，如非万分必要，一定不要在synchronized中进行耗时的操作（如IO操作，数据库等），否则会大大影响程序的性能。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>原子操作与synchronized在多线程环境下的性能差别</title>
                <link>http://freewind.in/posts/458-the-performance-diff-between-atomic-and-synchronized-in-multithread-env</link>
                <pubDate>Sat, 22 Oct 2011 22:05:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">458</guid>
                <description><![CDATA[&lt;p&gt;从另一篇两者在单线程环境下的测试可以看出，就算没有竞争，synchronized也比原子操作慢。地址如下：&lt;a href=&quot;http://freewind.me/blog/20111022/457.html&quot;&gt;http://freewind.me/blog/20111022/457.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里测试多线程环境下的影响。重构了代码，如下：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-458&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IncTestN {

    public static int MAX_COUNT = 50000000;
    public static int THREADS = 1;

    interface Incer {
        long inc();
    }

    static class AtomIncer implements Incer {
        private AtomicLong atom = new AtomicLong();

        @Override
        public long inc() {
            return atom.incrementAndGet();
        }
    }

    static class SynIncer implements Incer {
        private long syn = 0;

        @Override
        public synchronized long inc() {
            syn += 1;
            return syn;
        }
    }

    static class Tester {
        ExecutorService pool = Executors.newFixedThreadPool(THREADS);
        Incer incer;
        final AtomicLong start = new AtomicLong(0);
        final AtomicLong end = new AtomicLong(0);

        public Tester(Incer incer) {
            this.incer = incer;
        }

        public long test() throws InterruptedException {
            Callable&amp;lt;Void&amp;gt; task = new Callable&amp;lt;Void&amp;gt;() {
                @Override
                public Void call() throws Exception {
                    while (true) {
                        long v = incer.inc();
                        if (v == 1) {
                            start.set(System.nanoTime());
                        } else if (v == MAX_COUNT) {
                            end.set(System.nanoTime());
                            break;
                        } else if (v &amp;gt; MAX_COUNT) {
                            break;
                        }
                    }
                    return null;
                }
            };
            List&amp;lt;Callable&amp;lt;Void&amp;gt;&amp;gt; list = new ArrayList&amp;lt;Callable&amp;lt;Void&amp;gt;&amp;gt;();
            for (int i = 0; i &amp;lt; THREADS; i++) {
                list.add(task);
            }
            pool.invokeAll(list);
            long cost = (end.longValue() - start.longValue()) / 1000000;
            pool.shutdownNow();
            return cost;
        }
    }

    public static void main(String[] args) throws Exception {
        long atomCost = new Tester(new AtomIncer()).test();
        System.out.println(&quot;Atom cost: &quot; + atomCost + &quot;ms&quot;);

        long synCost = new Tester(new SynIncer()).test();
        System.out.println(&quot;Synchronized cost: &quot; + synCost + &quot;ms&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过修改THREADS的值，在我的电脑上可以得到以下数据：&lt;/p&gt;
&lt;table width=&quot;650&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;线程数&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;atom&lt;/td&gt;
&lt;td&gt;1413ms&lt;/td&gt;
&lt;td&gt;5066ms&lt;/td&gt;
&lt;td&gt;5226ms&lt;/td&gt;
&lt;td&gt;5283ms&lt;/td&gt;
&lt;td&gt;5328ms&lt;/td&gt;
&lt;td&gt;5248ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;synchronized&lt;/td&gt;
&lt;td&gt;1913ms&lt;/td&gt;
&lt;td&gt;24560ms&lt;/td&gt;
&lt;td&gt;25895ms&lt;/td&gt;
&lt;td&gt;25507ms&lt;/td&gt;
&lt;td&gt;25172ms&lt;/td&gt;
&lt;td&gt;25459ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可见，当变为多线程后，两者的用时都变多了，而synchronized受到的影响要大得多。&lt;/p&gt;
&lt;p&gt;但从表中发现，2个线程与50个线程用时差不多。这又应该如何解释呢？&lt;/p&gt;
&lt;p&gt;我想可能是因为我们的逻辑代码比较简单，在一个线程运行的时间内，就足以运行大量的循环，所以线程的切换与竞争，没并有想像中那么频繁。但这也已经让性能受到了很大的影响。&lt;/p&gt;
&lt;p&gt;所以在代码中，还是要尽量避免或减少synchronized的使用。这种性能问题很难测试出来。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>原子操作与synchronized在单线程环境下的性能差别</title>
                <link>http://freewind.in/posts/457-the-performance-diff-between-atomic-and-synchronized-in-singlethread-env</link>
                <pubDate>Sat, 22 Oct 2011 20:55:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">457</guid>
                <description><![CDATA[&lt;p&gt;synchronized因为多了一个&quot;加锁&quot;的过程，会占用额外的时间，导致性能较差。特别是在多线程环境中，如果存在竞争，性能会更差一些。但是到底有多差呢？&lt;/p&gt;
&lt;p&gt;我们先看看在单线程环境中，它的表现如何。这里使用了三种不同的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通变量加1&lt;/li&gt;
&lt;li&gt;原子变量加1&lt;/li&gt;
&lt;li&gt;先synchronized，再加1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-457&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IncTest1 {

    public static void main(String[] args) {
        // simple variable
        int simple = 0;
        long start = System.nanoTime();
        for (int i = 0; i &amp;lt; 100000000; i++) {
            simple = simple + 1;
        }
        long end = System.nanoTime();
        System.out.println(&quot;simple inc cost: &quot; + (end - start) / 1000000.0 + &quot;ms&quot;);

        // atom
        AtomicInteger atom = new AtomicInteger();
        start = System.nanoTime();
        for (int i = 0; i &amp;lt; 100000000; i++) {
            atom.incrementAndGet();
        }
        end = System.nanoTime();
        System.out.println(&quot;atom inc cost: &quot; + (end - start) / 1000000.0 + &quot;ms&quot;);

        // synchronized
        int syn = 0;
        start = System.nanoTime();
        for (int i = 0; i &amp;lt; 100000000; i++) {
            synchronized (IncTest1.class) {
                syn = syn + 1;
            }
        }
        end = System.nanoTime();
        System.out.println(&quot;snchronized inc cost: &quot; + (end - start) / 1000000.0 + &quot;ms&quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其运行结果如下：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;simple inc cost: 146.260704ms
&lt;br  /&gt;atom inc cost: 1473.678995ms
&lt;br  /&gt;synchronized inc cost: 2568.035ms&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从中可以看出，原子操作是普通变量的10倍，而synchronized是原子操作的近2倍。&lt;/p&gt;
&lt;p&gt;在单线程不存在竞争的情况下，synchronized的性能都是最差的，可见我们的确应尽量减少synchronized的使用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>windowsxp上的System.currentTimeMillis和System.nanoTime</title>
                <link>http://freewind.in/posts/455-system-currenttimemillis-nanotime-on-windows</link>
                <pubDate>Sat, 22 Oct 2011 20:00:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">455</guid>
                <description><![CDATA[&lt;p&gt;今天在看以前代码时，突然想起一个问题：在windows xp上，使用System.currentTimeMillis来得到当前时间毫秒值，但是它的精度只有15ms到16ms，而不是1ms。&lt;/p&gt;
&lt;p&gt;这个问题相当严重，因为我们平时经常会在代码中这样来计算代码的运行时间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long start = System.currentTimeMillis();
// ... some code
long end = System.currentTimeMillis();
System.out.println(&quot;Your code cost: &quot; + (end-start) + &quot;ms&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可惜的是，如果你要测量的代码运行得比较快的话，就会发现，其值要么是0ms，要么是15ms。没有0-15ms之间的值。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-455&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;我想到以前做过的一个项目，在日志中检查每一条信息接收时的毫秒值和发送时的毫秒值，以记录延时。但是统计时发现，要么就是0ms，要么就是15ms以上，中间这一块数据都去哪儿了？&lt;/p&gt;
&lt;p&gt;所以如果要求很精确的话，这种方式是不可靠的（在windows上）。&lt;/p&gt;
&lt;p&gt;在群友们的帮助下，在不同的操作系统中运行以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MillisTime {
    public static void main(String[] args) {
        long start = 0;
        long end = 0;
        while (true) {
            if (start == 0) {
                start = System.currentTimeMillis();
            } else {
                long current = System.currentTimeMillis();
                if (current != start) {
                    end = current;
                    break;
                }
            }
        }
        System.out.println(&quot;The time interval of your OS: &quot; + (end - start) + &quot;ms&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到的结果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;windows XP: 15ms&lt;/li&gt;
&lt;li&gt;windows 7: 1ms&lt;/li&gt;
&lt;li&gt;linux: 1ms&lt;/li&gt;
&lt;li&gt;mac: 1ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看来只有windows xp最菜。&lt;/p&gt;
&lt;p&gt;毫秒不行，那纳秒呢？我们知道还有一个System.nanoTime()方法呢。（注：1ms = 1,000,000ns )&lt;/p&gt;
&lt;p&gt;我猜想，在windows xp中，既然时间精度只有15ms，那么使用nanoTime应该也得到同样的值，即15000000ns。于是运行以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class NanoTime {
        public static void main(String[] args) {
                long start = 0;
                long end = 0;
                while (true) {
                        if (start == 0) {
                                start = System.nanoTime();
                        } else {
                                long current = System.nanoTime();
                                if (current != start) {
                                        end = current;
                                        break;
                                }
                        }
                }
                System.out.println(&quot;The time interval of your OS: &quot; + (end - start) + &quot;ns&quot;);
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果却是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The time interval of your OS: 763ns&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;奇怪，只有763ns，还不到0.0001ms呢，这是怎么回事？为什么1ms的间隔都得不到，却能得到0.0001ms的间隔？这个值不是瞎写的吧！&lt;/p&gt;
&lt;p&gt;于是我到万能的stackoverflow上问了几个问题，得到了几位大仙们的回答，终于明白了这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;System.currentTimeMillis得到的是一个绝对时间值，你可以从该值推算当前的时间，也可以从当前的时间推算出这个值。因为有这样的要求，所以它的精度不高，特别在windows xp上，只有15ms的精度。&lt;/li&gt;
&lt;li&gt;而System.nanoTime是专门用来算间隔的。它的值跟当前时间没有任何关系，它甚至可以是负值。也正因为没有这个限制，使用它反而可以得到精度很高的间隔值。比如在windows xp sp3上，这个时间是可信的。也就是说，例子中的&quot;763ns&quot;说明那段代码的确运行了大约700ns。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明白这一点之后，我得出了以下结论：&lt;/p&gt;
&lt;p&gt;如果我们要测量的代码运行时间很长，或者不是特别关心其准确度，可以使用System.currentTimeMillis图个方便。但如果要求很精确或者间隔很小，最好使用nanoTime。&lt;/p&gt;
&lt;p&gt;前面提到的几个问题地址如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7859019/system-currenttimemillis-is-not-accurate-on-windows-xp&quot;&gt;http://stackoverflow.com/questions/7859019/system-currenttimemillis-is-not-accurate-on-windows-xp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7859043/system-nanotime-on-windows-xp&quot;&gt;http://stackoverflow.com/questions/7859043/system-nanotime-on-windows-xp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/510462/is-system-nanotime-completely-useless&quot;&gt;http://stackoverflow.com/questions/510462/is-system-nanotime-completely-useless&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后再想一下，System.currentTimeMillis得到不准确值，是Java的问题还是windows xp的问题？在xp上使用其它的语言（如C等），会是什么情况？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7859417/how-accurate-of-system-currenttimemillis-on-winxp-with-other-language-than-java/7859457#7859457&quot;&gt;http://stackoverflow.com/questions/7859417/how-accurate-of-system-currenttimemillis-on-winxp-with-other-language-than-java/7859457#7859457&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;答案是，这是操作系统跟硬件的问题，与Java无关。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>股票实时数据转发方案的思考</title>
                <link>http://freewind.in/posts/454-solution-for-transfering-realtime-security-data</link>
                <pubDate>Fri, 21 Oct 2011 23:13:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">454</guid>
                <description><![CDATA[&lt;p&gt;我曾在一家香港公司做了三年，该公司是为香港的证券公司提供股票交易数据及后台软件。我在这三年时间，基本上都在做两个项目的开发与优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从香港联交所取得实时交易数据，转发到多台服务器，供更多的程序使用&lt;/li&gt;
&lt;li&gt;将实时数据解析，取得每个股票的数据，根据客户端请求的股票将不同的数据发过去&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后虽然因为某些原因从这家公司离职，但是这段项目经历非常宝贵，因为在别处是很难有这样的一个机会接触到完整的流程。感谢。&lt;/p&gt;
&lt;p&gt;证券公司对软件的要求有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定&lt;/li&gt;
&lt;li&gt;容错性强&lt;/li&gt;
&lt;li&gt;速度快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两点是必须的，大家都在拼第三点。大家都知道，股票市场里时间就是金钱，能比别人早一秒得到交易详情，就能早一点下单，有时候赚亏就在这一刹那。&lt;/p&gt;
&lt;p&gt;程序都是由Java开发的，为了能让程序运行得更快，数据延时更小，我花了近一年的时间对它们进行优化，尝试了所有我能想到的办法。最终数据延时在可接受范围内，但并未比其它公司的类似产品有优势。直到离职后，我还经常在想能用什么办法进一步提高其性能，但也没有什么好的办法。&lt;/p&gt;
&lt;p&gt;我的一个小弟接手维护我的程序。听说明年香港联交所的数据量会更大，担心现在的程序难以应付，所以与我交流后，我也想再好好想想有什么办法来提高其性能。&lt;/p&gt;
&lt;p&gt;前面提到的两个程序之间差异很大，所以这里只谈第一个项目：股票实时数据转发。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-454&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;简单介绍一下该项目的需求：&lt;/p&gt;
&lt;p&gt;从香港联交所拉一条专线到公司的机房，所有股票的实时交易数据，都将通过该专线发送过来，高峰期速度大约为200KB/s。我们有一台root服务器直接连到该专线，接收数据，并转发给多台children servers。其它所有的程序都将连到children server去取数据，这样就可以将压力分散到不同的服务器（但代价是多一次转发过程）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/454-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如上图，可以看到数据的流向。当其它程序取到数据时，这些数据已经经历了两次的转发：第一次是Root转发，第二次是Child转发。&lt;/p&gt;
&lt;p&gt;可以看到，如果数据在这两次转发中延时过多，其它程序拿到数据时，便已经晚了，输在了起跑线上。因此，如何减小转发延时是非常关键的。&lt;/p&gt;
&lt;p&gt;该项目有以下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;children servers数量较少，通常不多于10个&lt;/li&gt;
&lt;li&gt;child与root server之间通过socket连接&lt;/li&gt;
&lt;li&gt;root从HKEx收到数据后，马上push给所有child&lt;/li&gt;
&lt;li&gt;root将向child持续发送大量数据&lt;/li&gt;
&lt;li&gt;为了在程序崩溃后迅速恢复，每个server都有postgresql，异步将取得的数据保存起来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我使用了以下方式来提高性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用了基于nio的框架mina 2.x&lt;/li&gt;
&lt;li&gt;配置线程池，将收与发放入不同线程中，同时处理&lt;/li&gt;
&lt;li&gt;从HKEx取得的所有数据，都常驻内存，转发时直接从内存取&lt;/li&gt;
&lt;li&gt;精简日志，并使用了buffered方式写到文件中&lt;/li&gt;
&lt;li&gt;使用后台线程每隔一定时间将内存中的数据保存到数据库中，异步操作&lt;/li&gt;
&lt;li&gt;使用JProfile对程序进行监控，分析代码执行时间、gc、线程活动，寻找瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在的测试情况：当HKEx速度为550K/s、child数量为1时，root转发的信息有88%左右在0ms内完成。这个数据让我觉得还有再优化的空间。&lt;/p&gt;
&lt;p&gt;但这个程序，并不是单纯的接受与转发。比如，它需要将收到的二进制数据根据一定规则分为一个个不同长度的元素，还需要对每个元素进行简单的解析以提取其序号值和类型值进行某些特定的操作。为了能在重启后利用已经取得的数据，还需要把数据保存在数据库中。它还需要处理客户端的登录请求，发送客户端指定序号之后的数据。还需要处理断线等情况。还将记录日志以供后期分析程序运行情况及性能。&lt;/p&gt;
&lt;p&gt;所以如何提高性能，但不影响当前的功能，还是一件非常有挑战的工作。&lt;/p&gt;
&lt;p&gt;我曾经考虑过一些JMS工具，但试用一些之后，我发现一是难以掌控（对其内部运行原理不太明白），二是想不出自己的设计有什么不妥的地方，最终还是使用了自己的流程。&lt;/p&gt;
&lt;p&gt;这两年接触了不少新的信息，所以这两天还是专门花了不少时间来思考，如何能将其性能进一步提高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、用Java还是别的语言？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我曾经觉得原因是在Java语言本身，也许换一种语言比如c++或者scala，就能够将性能提高上去。但后来我想起自己以前曾经写过一个简单的socket程序，在两台服务器之间传送数据，可以轻易地达到10MB/s的速度，说明Java本身是有能力利用好带宽的。而这个程序内部逻辑并不复杂，JVM现在的性能也很好，所以原因很可能不在Java身上。如果换成C++或者Scala，很难在短短几个月时间内就掌握并写出一个同样的程序出来，很可能性能还不如现在的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、使用memcachedb代替程序的转发与同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个程序的主要作用，就是把从HKEx收到的数据，同步到多个服务器，减轻单台服务器的压力，让更多的程序使用。我使用的是mina手动收发数据来达到这一目的，能不能使用其它的产品来达到这一目的？&lt;/p&gt;
&lt;p&gt;比如memcachedb (&lt;a href=&quot;http://memcachedb.org/&quot;&gt;http://memcachedb.org/&lt;/a&gt;)，它是一个分布式的key-value存储系统，基于memcached和berkeleydb。既然它是分布式的，就意味着可以同时部署在多台服务器上，同时向外提供服务。各服务器之间的数据同步，由memcachedb自己负责，其性能会大大提高（它可能会在底层使用如ip multicast这样的技术，发送一次数据同时给多个服务器）。其它的好处是，可以大大简化程序结构，不需要以编程方式进行root与child间的数据同步，postgresql也可以省掉。&lt;/p&gt;
&lt;p&gt;memcachedb非常值得尝试，不过需要确定几下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;memcachedb各节点之间的同步速度非常快（可通过监测网卡上的数据发送速度）&lt;/li&gt;
&lt;li&gt;程序运行时，去掉某一节点，其它节点的程序依然正常运行&lt;/li&gt;
&lt;li&gt;增加一新节点，它可以快速得到完整数据，并向外提供服务&lt;/li&gt;
&lt;li&gt;当某节点的memcachedb得到新数据时，有办法向java程序发出通知，以调用某些操作（如果不行，测试轮询方案的性能）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果各要求都满足，可考虑改用memcachedb完成一个简单的程序，实际测试其性能是否比之前有所提高。&lt;/p&gt;
&lt;p&gt;因为该方法比较简单且可行性较大，所以应该优先考虑这一方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、使用Redis代替方案二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis是一个内存数据库，它也有主从复制的方案，所以可代替方案二中的memcachedb，看两者谁的性能更高一些。其它要求相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、zeromq&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;zeromq号称史上最快的消息系统。它有自己的数据传输协议，据说性能很高，远超RabbitMQ, ActiveMQ, MSMQ等，同时它提供了各种语言（包括c/c++/java等）绑定。我们可以使用Java来做，还可以用C进一步提高性能。它是LPGL协议的，意味着我们可以以链接库的形式免费使用。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www.zeromq.org/&quot;&gt;http://www.zeromq.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://blog.codingnow.com/2011/02/zeromq_message_patterns.html&quot;&gt;http://blog.codingnow.com/2011/02/zeromq_message_patterns.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、使用jgroups&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jgroups可以让我们在Java中进行ip multicast操作。现在的程序，是每个child都与root单独连接，有几个children，root就要发几遍数据。而使用ip mulitcast的话，root只需要发送一遍数据，所有children都能拿到，可以大大提高性能。&lt;/p&gt;
&lt;p&gt;不过考虑到某些child可能中途重启，则它需要的数据，就与root多播的数据不同了。如何处理这种情况，需要在程序中好好考虑。因为这种方案着眼于多客户端的传输，对于前面只有一个客户端的测试情况，并没有多大的帮助，所以让这一种方案放在第五位。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www.jgroups.org/&quot;&gt;http://www.jgroups.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、在solaris下改进现有程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;群里林晴鼓动我们安装使用solaris，说里面有一个dtrace的程序，非常厉害。Java源代码中就有很多dtrace的探针。通过它，我们可以方便且全面地了解程序的各种运行状况，可以轻易地找到程序的瓶颈。说得我很动心，但是考虑到这个比较大的学习成本，将这种方案放在靠后，但也值得一试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、使用real-time java&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在08年，sun曾提出了一个实时Java的方案，以满足Java在实时软件领域的需求。它有以下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一个任务都有一个deadline。如果在预定时间内没有完成，可以设置超时处理方案。&lt;/li&gt;
&lt;li&gt;线程分为22级，并且保证其优先级。对于实时程序来说这一点无比重要。因为windows等系统，并没有提供线程的优化级支持，所以real-time java只能运行在某些操作系统之上。&lt;/li&gt;
&lt;li&gt;低优先级的gc。Java中的gc是一旦运行，则&quot;stop the world&amp;rdquo;，其时间长短还不确定，这对于实时系统来说是难以接受的。而real-time中，gc的行为将被改变&lt;/li&gt;
&lt;li&gt;自管理的内存。对于这种内存，需要用户自己手动创建及销毁，gc不参与。这一点很像c/c++等自动管理内存的语言。对于某些常驻内存的数据，放在这种内存中可以提高性能&lt;/li&gt;
&lt;li&gt;其它&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以说这个实时Java中的很多地方都是与传统Java相反的，学习难度比较大，而且还是收费的（只能试用90天）。虽然有很多吸引人的地方，但使用它能否开发出一个超过现有性能的程序出来，我个人还是持怀疑态度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、操作系统、硬件等因素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当程序写到一定程度，影响性能的可能会是其它因素，比如操作系统、硬件配置、JVM参数设置等等，这就很难猜到，只能靠一一尝试。所以放在后面考虑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、使用其它语言的方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果以上所有的方法都不管用，则只能去尝试其它的高性能语言，比如c/c++。网络通常是这些语言的强项，肯定会有相应的解决方案。而且一旦使用这些语言，肯定会用到与操作系统相关的某些底层库，来进一步提高性能。如果走到这一步，那只有再好好研究相应的方法了。&lt;/p&gt;
&lt;p&gt;唐升华，加油啊!&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;htrmt&lt;/h3&gt;
&lt;p&gt;这件事，文中提到的方法都不是正解。使用任何一种通用工具的方法都不会比使用编译语言，甚至是原生编译型语言定制的程序来得高效。 曾做过一个与上面这个程序功能基本一致的应用，数据传输率达到理论速率的95%，性能瓶颈仅受限于硬件本身。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>windows上安装node+npm+coffeescript的悲催之路</title>
                <link>http://freewind.in/posts/452-install-node-npm-coffeescript-on-windows</link>
                <pubDate>Fri, 21 Oct 2011 21:06:31 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">452</guid>
                <description><![CDATA[&lt;p&gt;在linux上，安装它们都相当容易，步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载node(v0.4.12)的源代码，以标准方式安装(./configure &amp;amp; make &amp;amp; make install)&lt;/li&gt;
&lt;li&gt;npm更简单：curl &lt;a href=&quot;http://npmjs.org/install.sh&quot;&gt;http://npmjs.org/install.sh&lt;/a&gt; | sh&lt;/li&gt;
&lt;li&gt;coffeescript：npm install -g coffee-script&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一切搞定，运行coffee就可以看到它的提示符，可以输入一些coffee代码试验。&lt;/p&gt;
&lt;p&gt;但是在windows上，相当麻烦。首先，你不能使用cygwin来安装npm，见&lt;a href=&quot;http://npmjs.org/doc/README.html&quot;&gt;http://npmjs.org/doc/README.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Installing on Cygwin
&lt;br  /&gt;Don&apos;t.&lt;/p&gt;
&lt;p&gt;It&apos;s not supported, and terrible. Use the windows native approach, or use a Linux or Solaris virtual machine in VMWare or VirtualBox.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们也不能使用cygwin来安装node了。（我是在花了一下午的时间在cygwin下安装好node后，才发现这一点的）&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-452&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;按&quot;Installing on Windows&quot;所写的方式，直接下载node.exe(v0.5.8)，再设置一堆属性，再安装npm，成功。&lt;/p&gt;
&lt;p&gt;再安装coffeescript，使用&lt;code&gt;npm install -g coffee-script&lt;/code&gt;安装成功，但是！&lt;/p&gt;
&lt;p&gt;输入coffee后，进行coffee的提示符后，随便输入点什么，比如&lt;code&gt;a=2&lt;/code&gt;，出错：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;coffee&gt; a=2
&lt;br  /&gt;Error: require.paths is removed. Use node_modules folders, or the NODE_PATH environment variable instead.
&lt;br  /&gt;at Function.&lt;anonymous&gt; (module.js:360:11)
&lt;br  /&gt;at Object.eval (D:\home\lib\node_modules\coffee-script\lib\coffee-script.js:97:32)
&lt;br  /&gt;at Interface.&lt;anonymous&gt; (D:\home\lib\node_modules\coffee-script\lib\repl.js:44:34)
&lt;br  /&gt;at Interface.emit (events.js:67:17)
&lt;br  /&gt;at Interface.&lt;em&gt;onLine (readline.js:153:10)
&lt;br  /&gt;at Interface.&lt;/em&gt;line (readline.js:408:8)
&lt;br  /&gt;at Interface._ttyWrite (readline.js:585:14)
&lt;br  /&gt;at ReadStream.&lt;anonymous&gt; (readline.js:73:12)
&lt;br  /&gt;at ReadStream.emit (events.js:70:17)
&lt;br  /&gt;at onKeypress (tty_win32.js:46:10)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过一番排查，发现原因是nodejs在0.5.x中改变了一些内部实现，导致coffeescript的代码无法正常工作。可是想安装nodejs 0.4.x的话，又没法安装npm。这可真让人纠结啊。&lt;/p&gt;
&lt;p&gt;最终，还是按照&lt;a href=&quot;https://github.com/alisey/CoffeeScript-Compiler-for-Windows&quot;&gt;https://github.com/alisey/CoffeeScript-Compiler-for-Windows&lt;/a&gt;所讲的&quot;Better solution&amp;rdquo;，直接使用node.exe与coffee结合在一起，去掉npm。再次进入coffee环境，输入代码，一切正常。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sudo的path问题</title>
                <link>http://freewind.in/posts/451-sudo-path-problem</link>
                <pubDate>Fri, 21 Oct 2011 20:36:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">451</guid>
                <description><![CDATA[&lt;p&gt;我在fedora上安装完node后，接着安装npm，使用了以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl [http://npmjs.org/install.sh](http://npmjs.org/install.sh) | sudo sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;却出现以下错误：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;npm cannot be installed without nodejs.
&lt;br  /&gt;Install node first, and then try again.&lt;/p&gt;
&lt;p&gt;Maybe node is installed, but not in the PATH?
&lt;br  /&gt;Note that running as sudo can change envs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我当前正运行于一个普通用户下，输入node，正常运行。又用su -切换成root，运行node，也正常运行。但在普通用户下执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;却提示：sudo: node: command not found&lt;/p&gt;
&lt;p&gt;这可是非常奇怪！&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-451&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;在群里提出这个问题后，有前辈提示说，让我把PATH打印出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/freewind/bin
$ sudo echo $PATH
/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/freewind/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个看起来是一样的，应该不会出问题的啊&lt;/p&gt;
&lt;p&gt;再试试which&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ which node
/usr/local/bin/node
$ sudo which node
which :  no node in (/sbin:/bin:/usr/sbin:/usr/bin)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，此时搜索的PATH变少了，找不到node了。怎么回事？&lt;/p&gt;
&lt;p&gt;在万能的stackoverflow上，搜索到了一个同样的问题：&lt;a href=&quot;http://stackoverflow.com/questions/257616/sudo-changes-path-why&quot;&gt;http://stackoverflow.com/questions/257616/sudo-changes-path-why&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面说sudo可能因为安全上的原因，不会使用修改过的PATH。好在下面的回答中，给出了一个可行的方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias sudo=&apos;sudo env PATH=$PATH&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按这种方式，我把命令改为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://npmjs.org/install.sh | sudo env PATH=$PATH sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就完全没问题了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>windows下安装使用coffeescript</title>
                <link>http://freewind.in/posts/450-coffeescript-on-windows</link>
                <pubDate>Thu, 20 Oct 2011 23:58:44 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">450</guid>
                <description><![CDATA[&lt;p&gt;coffeescript是javascript的一种变种语言，它设计了各种好用的语法糖，让我们在写javascript代码时，会更加清晰简洁，带函数式语言的体验。&lt;/p&gt;
&lt;p&gt;coffeescript有一个黄金定律：它就是Javascript&lt;/p&gt;
&lt;p&gt;因为coffeescript提供了转换器，可以把写出来的coffee代码转换为等价的javascript代码。这样我们就可以在开发时写coffeescript，而在发布时把它转换为javascript。&lt;/p&gt;
&lt;p&gt;例子可参看coffee的主页：&lt;a href=&quot;http://jashkenas.github.com/coffee-script/&quot;&gt;http://jashkenas.github.com/coffee-script/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有很多精彩的例子，看完后就会让人爱上写coffeescript。&lt;/p&gt;
&lt;p&gt;这里讲的是如果在windows下安装coffeescript。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-450&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;coffeescript依赖于node.js，它们这一套&quot;运行于服务器端的js&quot;通常在linux下会用的比较爽，因为node有一个叫npm(Node Package Manager)的工具，可以让我们方便地安装各种js库。比如在linux下安装coffee，只需要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g coffee-script
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可惜的是，这个npm工具不支持windows，如果想在windows下使用，还得安装一些如cygwin这样的linux模拟环境。如果我们仅仅想使用coffee的话，安装这个就太麻烦了。&lt;/p&gt;
&lt;p&gt;在这个网页上，介绍了一种简单的方法：&lt;a href=&quot;https://github.com/alisey/CoffeeScript-Compiler-for-Windows&quot;&gt;https://github.com/alisey/CoffeeScript-Compiler-for-Windows&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在node.js网站上下载node.exe: &lt;a href=&quot;http://nodejs.org/#download&quot;&gt;http://nodejs.org/#download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载coffeescript: &lt;a href=&quot;http://github.com/jashkenas/coffee-script/tarball/master&quot;&gt;http://github.com/jashkenas/coffee-script/tarball/master&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;然后创建一个coffee.cmd文件，内容如下：&lt;pre&gt;&lt;code&gt;@echo off
&quot;C:/Node/node.exe&quot; &quot;C:/CoffeeScript/bin/coffee&quot; %*
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意你需要把里面的路径写对，并把它加入到path中，以方便调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个文件，如test.coffee，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;square = (x) -&amp;gt; x * x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用coffee.cmd将它编译为js文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;coffee -c test.coffee
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行后，如果一切正常的话，你会发现test.coffee同级目录下，将会多出一个test.js文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(function() {
  var square;

  square = function(x) {
    return x * x;
  };

}).call(this);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就说明我们的coffee安装成功了！&lt;/p&gt;
&lt;p&gt;此命令行有以下参数可供使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c, --compile       compile to JavaScript and save as .js files
-o, --output [DIR]  set the directory for compiled JavaScript
-j, --join [FILE]   concatenate the scripts before compiling
-b, --bare          compile without the top-level function wrapper
-v, --version       display CoffeeScript version
-h, --help          display a list of available options
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>backbone.js</title>
                <link>http://freewind.in/posts/446-backbonejs</link>
                <pubDate>Thu, 20 Oct 2011 18:17:17 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">446</guid>
                <description><![CDATA[&lt;p&gt;&lt;img src=&quot;/user_images/446-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;backbone.js是一个javascript库。当我们需要在页面中写大量的javascript代码来处理页面逻辑时，backbone非常有用，因为它的设计目的就是把javascript代码分解为不同的层来让代码更加清晰。&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;http://documentcloud.github.com/backbone/&quot;&gt;http://documentcloud.github.com/backbone/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名字backbone中文是&quot;脊椎&amp;rdquo;，可以想到它的定位：就像脊椎骨一样撑起整个程序的结构，其它的javascript代码，都是附着在它上面的血肉。&lt;/p&gt;
&lt;p&gt;在backbone里，有这样几个概念：Model, View, Router, Collection, Events。没错，它有MVC结构。&lt;/p&gt;
&lt;p&gt;Model就像是javabean，它对应的是数据。View对应的是页面上的某一个组件，可以增加各种改变页面效果的方法。Router可用来将页面上的链接（准确的说，是用不同的锚点来代替可跳转的链接）与某些方法联系起来。Collection是一些Model的集全，它比Model多一些事件。Event用来表明发生了什么操作。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-446&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;刘松利用backbone.js和coffeescript写了一个简单的程序，是一个简单的聊天室程序的页面。我先把它们的代码贴在这里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main.html&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;!DOCTYPE html&gt;
&lt;br  /&gt;&lt;html&gt;
&lt;br  /&gt;&lt;head&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;      
&amp;lt;style&amp;gt;      
        /** reset **/      
    body {      
        font-size: 14px;      
    } 

    body, ul, li, div, h3 {     
        padding: 0;      
        margin: 0;      
    } 

    ul {     
        list-style: none;      
    } 

        /** layout **/     
    .main {      
        display: box;      
        box-orient: horizonal; 

        display: -moz-box;     
        -moz-box-orient: horizonal;      
        display: -webkit-box;      
        -webkit-box-orient: horizonal; 

        width: 100%;     
    } 

    .content {     
        box-flex: 1; 

        -moz-box-flex: 1;     
        -webkit-box-flex: 1;      
    } 

        /** header **/     
    .header {      
        background-image: linear-gradient(top, #6381B8, #264175);      
        background-image: -moz-linear-gradient(top, #6381B8, #264175);      
        background-image: -webkit-linear-gradient(top, #6381B8, #264175); 

        box-shadow: 0 1px 0 #809DD4 inset, 0 -1px 0 #000000 inset;     
        height: 40px;      
    } 

        /** sidebar **/     
    .sidebar {      
        height: 600px;      
        width: 200px;      
        background-color: #DFE6EE;      
        border-right: 1px solid #B4BBC4;      
    } 

    .sidebar h3 {     
        background-image: linear-gradient(top, #EDF3FA, #D0D9E4);      
        background-image: -moz-linear-gradient(center top, #EDF3FA, #D0D9E4);      
        background-image: -webkit-linear-gradient(top, #EDF3FA, #D0D9E4); 

        border-top: 1px solid #FFFFFF;     
        border-bottom: 1px solid #B4BBC4;      
        color: #747D84;      
        text-shadow: 0 1px 0 #FFFFFF;      
        font-size: 14px;      
        line-height: 20px;      
        font-weight: bold;      
        text-indent: 10px;      
    } 

    .sidebar ul li a {     
        box-shadow: 0 1px 0 #EEF6FF inset, 0 -1px 0 #D3D9E1 inset;      
        display: block;      
        line-height: 26px;      
        padding-left: 6px;      
        text-decoration: none;      
        color: #000;      
        cursor: pointer;      
        font-size: 12px;      
        /*-webkit-transition:All 0.1s ease;*/      
        /*-moz-transition:All 0.1s ease;*/      
        border-left: 3px solid transparent;;      
    } 

    .sidebar ul li a:hover {     
        border-left: 3px solid #748DBB;      
    } 

    .sidebar ul li.active a {     
        background-color: #748DBB;      
        background-image: linear-gradient(center top, #ADBDD7 0pt, #748DBB 100%);      
        background-image: -moz-linear-gradient(center top, #ADBDD7 0pt, #748DBB 100%);      
        background-image: -webkit-linear-gradient(top, #ADBDD7 0pt, #748DBB 100%);      
        box-shadow: 0 1px 0 #899CC0 inset, 0 2px 0 #B4C6E4 inset, 0 -1px 0 #6C7B98 inset;      
        margin: -1px 0 0;      
        text-shadow: 0 1px 1px #474E59;      
        font-weight: bold;      
        display: block;      
        line-height: 30px;      
        color: #FFFFFF;      
    } 

        /** content **/     
    .content {      
        color: #444444;      
    } 

    .content &amp;gt; h3 {     
        background: linear-gradient(center top, #F3F3F3, #D7D7D7) repeat scroll 0 0 #E7E7E7;      
        background: -moz-linear-gradient(center top, #F3F3F3, #D7D7D7) repeat scroll 0 0 #E7E7E7;      
        background: -webkit-linear-gradient(top, #F3F3F3, #D7D7D7) repeat scroll 0 0 #E7E7E7;      
        border-bottom: 1px solid #B7B7B7;      
        border-top: 1px solid #FFFFFF;      
        color: #777777;      
        font-size: 14px;      
        font-weight: bold;      
        line-height: 20px;      
        text-shadow: 0 1px 0 #FFFFFF;      
        padding-left: 10px;      
    } 

    .chats li.chat {     
        border-top: 1px solid #ECECEC;      
        line-height: 26px;      
        text-indent: 10px;      
    } 

        /** activeChatView **/     
    .chats li.chat.active {      
        background-image: linear-gradient(center top, #ADBDD7 0pt, #748DBB 100%);      
        background-image: -moz-linear-gradient(center top, #ADBDD7 0pt, #748DBB 100%);      
        background-image: -webkit-linear-gradient(top, #ADBDD7 0pt, #748DBB 100%);      
        box-shadow: 0 1px 0 #899CC0 inset, 0 2px 0 #B4C6E4 inset, 0 -1px 0 #6C7B98 inset;      
        margin: -1px 0 0;      
        text-shadow: 0 1px 1px #474E59;      
        color: #FFF;      
    } 

        /** writer **/     
    .writer {      
        position: fixed;      
        bottom: 0;      
        height: 100px;      
    } 

&amp;lt;/style&amp;gt;     
&amp;lt;script src=&quot;jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;      
&amp;lt;script src=&quot;socket.io.js&quot;&amp;gt;&amp;lt;/script&amp;gt;      
&amp;lt;script src=&quot;underscore.js&quot;&amp;gt;&amp;lt;/script&amp;gt;      
&amp;lt;script src=&quot;backbone.js&quot;&amp;gt;&amp;lt;/script&amp;gt;      
&amp;lt;script src=&quot;app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/head&gt;
&lt;br  /&gt;&lt;body&gt;&lt;/p&gt;
&lt;div class=&quot;header&quot;&gt; 

&lt;/div&gt;     
&lt;div class=&quot;main&quot;&gt; 

    &lt;div class=&quot;sidebar&quot;&gt;     
        &lt;h3&gt;标题&lt;/h3&gt;      
        &lt;ul&gt;      
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;好啊&lt;/a&gt;&lt;/li&gt;      
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;好啊&lt;/a&gt;&lt;/li&gt;      
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;好啊&lt;/a&gt;&lt;/li&gt;      
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;好啊&lt;/a&gt;&lt;/li&gt;      
            &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;好啊&lt;/a&gt;&lt;/li&gt;      
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;好啊&lt;/a&gt;&lt;/li&gt;      
        &lt;/ul&gt;      
    &lt;/div&gt;      
    &lt;div class=&quot;content&quot;&gt;      
        &lt;h3&gt;这是标题 &amp;gt; 好啊&lt;/h3&gt;      
        &lt;ul class=&quot;chats&quot;&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
            &lt;li class=&quot;chat&quot;&gt;这是一条&lt;/li&gt;      
        &lt;/ul&gt;      
        &lt;div class=&quot;writer&quot;&gt;      
            &lt;textarea class=&quot;writerInput&quot;&gt;&lt;/textarea&gt;      
            &lt;button class=&quot;sendBtn&quot;&gt;发送&lt;/button&gt;      
        &lt;/div&gt;      
    &lt;/div&gt;      
&lt;/div&gt;      
&lt;p&gt;&lt;/body&gt;
&lt;br  /&gt;&lt;/html&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从中可以看到，html页面中的代码十分干净，只有html和css定义，没有复杂的js。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;app.coffee&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;root = this
&lt;br  /&gt;root.App = App =&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Models: {}      
Views: {}      
Collections: {}      
chatsView: null      
topicView: null      
writerView: null      
io: null      
initialize: -&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class App.Models.Chat extends Backbone.Model&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defaults:      
    id: null      
    content: &quot;&quot;      
    author: null      
    timestamp: null 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class App.Models.Topic extends Backbone.Model&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defaults:      
    id: null      
    title: &quot;&quot;      
    description: &quot;&quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class App.Collections.Chats extends Backbone.Collection&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;initialize: -&amp;gt;      
    super      
    @io = App.io      
    @io.on(&quot;message.send&quot;, @on_message_send)      
on_message_send: (msg) =&amp;gt;      
    chat = new App.Models.Chat(msg)      
    @add(chat) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class App.Collections.Topics extends Backbone.Collection&lt;/p&gt;
&lt;p&gt;class App.Views.ChatsView extends Backbone.View&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    initialize: -&amp;gt;      
        @collection.bind &quot;add&quot;, @addChat      
        @activeChatView = null      
    render: -&amp;gt;      
        @collection.each @addChat      
        @      
    addChat: (model) =&amp;gt;      
        chatView = new App.Views.ChatView(model)      
        $(@el).append(chatView.el)      
    markActive: (chatView) -&amp;gt;      
        $(@activeChatView.el).removeClass(&quot;active&quot;) if @activeChatView?      
        @activeChatView = chatView      
        $(@activeChatView.el).addClass &quot;active&quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class App.Views.ChatView extends Backbone.View&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATE : &quot;&quot;&quot; &amp;lt;span class=&quot;content&quot;&amp;gt;&amp;lt;%= content%&amp;gt;&amp;lt;/span&amp;gt;      
       &amp;lt;span class=&quot;timestamp&quot;&amp;gt;&amp;lt;%= timestamp%&amp;gt;&amp;lt;/span&amp;gt;      
       &amp;lt;span class=&quot;author&quot;&amp;gt;&amp;lt;%= author%&amp;gt;&amp;lt;/span&amp;gt; 

       &quot;&quot;&quot;     
tagName: &quot;li&quot;      
className: &quot;chat&quot;      
initialize: (@model) -&amp;gt;      
    model.bind(&quot;change&quot;, @render)      
    @render()      
render: -&amp;gt;      
    $(@el).html @model.get(&quot;content&quot;)      
    this      
events:      
    click : &quot;markActive&quot;      
markActive: -&amp;gt;      
    App.chatsView.markActive(@) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;class App.Views.WriterView extends Backbone.View&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;events:      
    &quot;click .sendBtn&quot; : &quot;send_message&quot;      
    &quot;keyup .writerInput&quot; : &quot;send_message_on_enter&quot;      
send_message: -&amp;gt;      
    input = @$(&quot;.writerInput&quot;)      
    return unless (value = input.val())?      
    App.io.emit(&quot;message.send&quot;, content: value)      
    input.val(&quot;&quot;)      
send_message_on_enter: (event)-&amp;gt;      
    @send_message() if event.keyCode == 13 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;App.initialize = -&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;App.io = root.io.connect(&quot;[http://localhost:8081&quot;)](http://localhost:8081&quot;))      
chat = new App.Models.Chat(content: &quot;这是个试验1&quot;)      
chats = new App.Collections.Chats([chat])      
App.chatsView = new App.Views.ChatsView(collection: chats, el: $(&quot;.chats&quot;)).render()      
App.writerView = new App.Views.WriterView(el: $(&quot;.writer&quot;)).render() 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$ -&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;App.initialize()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些coffee代码，与js代码比起来可读性更好一些。当然，它们最终将被转换为js链到页面中。&lt;/p&gt;
&lt;p&gt;下面的这些对话，就是我向刘松请教backbone的过程，仔细看一下，基本上就能明白backbone.js是怎么回事了。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;我(23246779) 11:49:03
&lt;br  /&gt;我有backbone方面的问题想问你&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:12:11
&lt;br  /&gt;我到了。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:12:59
&lt;br  /&gt;backbone到底是用来做什么的
&lt;br  /&gt;我虽然有个大概的感觉，但还是不太清楚&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:14:08
&lt;br  /&gt;参考这里的代码：
&lt;br  /&gt;&lt;a href=&quot;https://github.com/scalaeye/scalaeye/blob/sliu/html/app.coffee&quot;&gt;https://github.com/scalaeye/scalaeye/blob/sliu/html/app.coffee&lt;/a&gt;
&lt;br  /&gt;在js端也使用mvc框架，分离数据、UI的职责&lt;/p&gt;
&lt;p&gt;我(23246779) 12:14:45
&lt;br  /&gt;我看到你的main.html，里面很干净
&lt;br  /&gt;只有html和css&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/446-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:14:37
&lt;br  /&gt;它也提供了事件抽象。
&lt;br  /&gt;比方咱们的页面，应该有TopicView(主题界面）、ChatsView(含多个ChatView)和WriterView(输入界面）&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:15:42
&lt;br  /&gt;这是ui层。
&lt;br  /&gt;对应backbone就是views&lt;/p&gt;
&lt;p&gt;我(23246779) 12:16:16
&lt;br  /&gt;这几个view在html代码中，有没有表现出来？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:16:53
&lt;br  /&gt;对.&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:17:13
&lt;br  /&gt;&lt;ul class=&quot;chats&quot; 对应的ChatsView
&lt;br  /&gt;writer对应WriterView
&lt;br  /&gt;TopicView我还没来得及玩，应该对应sidebar里的某个区&lt;/p&gt;
&lt;p&gt;我(23246779) 12:19:10
&lt;br  /&gt;哦，需要事先在html中定义好块
&lt;br  /&gt;每个&quot;块&quot;可看作一个view的占位符&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:19:28
&lt;br  /&gt;对。
&lt;br  /&gt;其实这些东西 backbone没有强制要求&lt;/p&gt;
&lt;p&gt;我(23246779) 12:20:19
&lt;br  /&gt;在app.coffee中，定义好几个view
&lt;br  /&gt;每个view都是继承于Backbone.View&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:20:29
&lt;br  /&gt;你可以在backbone的render方法里定义它的内容，或者在自己的js里全部生成所有html。或者全部使用html,只用backbone绑定，都行。
&lt;br  /&gt;一个View对应一个html区块，具体这个区块是用js生成还是原来html写好的，还是一部分生成，backbone都支持。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:21:17
&lt;br  /&gt;这些view，感觉就像是一个个组件？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:21:35
&lt;br  /&gt;是的，一个个组件&lt;/p&gt;
&lt;p&gt;我(23246779) 12:21:17
&lt;br  /&gt;里面还定义了一些方法，比如render, addChat, markActive&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:21:51
&lt;br  /&gt;addChat、markActive是我自定义方法&lt;/p&gt;
&lt;p&gt;我(23246779) 12:22:18
&lt;br  /&gt;view中定义的这些方法，是不是都是对页面的修改？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:22:30
&lt;br  /&gt;render在它里面有特殊含义，当这个view绑定的model对象发生改变时，render会被自动调用，相应于重绘
&lt;br  /&gt;定义这些方法主要是看怎么给这个组件定义行为，可以是读取ui信息，修改ui，修改model，或其它的，没有限制。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:22:57
&lt;br  /&gt;这个方便&lt;/p&gt;
&lt;p&gt;我(23246779) 12:23:26
&lt;br  /&gt;还定义了一些Model，它们可看作是javabean?
&lt;br  /&gt;model中并没有定义额外的方法&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:24:03
&lt;br  /&gt;对，model相当于javabean&lt;/p&gt;
&lt;p&gt;我(23246779) 12:24:45
&lt;br  /&gt;model与view之间的定义关系，是任意的吗？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:25:17
&lt;br  /&gt;常规的一个view会对应一个model对象，或一个collection对象。
&lt;br  /&gt;从实现上也不是强制的。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:25:53
&lt;br  /&gt;view怎么跟model绑定？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:25:59
&lt;br  /&gt;new XXView(model: xxx)&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:26:10
&lt;br  /&gt;看app.coffee的最后几行。
&lt;br  /&gt;91行。
&lt;br  /&gt;我传给它一个collection
&lt;br  /&gt;一个collection就是一个数组，它比数组多了：
&lt;br  /&gt;当往这个数组里增加、删除元素时，会trigger &amp;ldquo;add&amp;rdquo; &amp;ldquo;remove&quot;事件&lt;/p&gt;
&lt;p&gt;我(23246779) 12:27:31
&lt;br  /&gt;Chat这个model有没有跟哪个view绑定？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:30:32
&lt;br  /&gt;哦，看89行，我new 出一个Chat对象，放到 collection里，再由collection创建了ChatsView。在ChatsViews的initialize里（41行）循环collection构建的各个ChatView
&lt;br  /&gt;相当于ChatsView是ChatView的manager，所有ChatView（ui)的构建、删除，都在ChatsView里。
&lt;br  /&gt;恶，说错了，我是在ChatsView的render里画的。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:31:43
&lt;br  /&gt;原来如此，圈还转得挺大的&lt;/p&gt;
&lt;p&gt;我(23246779) 12:32:02
&lt;br  /&gt;为什么有model，还有collection？
&lt;br  /&gt;它们两个是什么关系？
&lt;br  /&gt;用法应该是一样的吧？只是collection多了一些不同的event&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:32:32
&lt;br  /&gt;是的。
&lt;br  /&gt;我理解collection是一种特殊的model: 代表数组，有不同的event&lt;/p&gt;
&lt;p&gt;我(23246779) 12:33:11
&lt;br  /&gt;root = this
&lt;br  /&gt;这个是什么意思？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:33:30
&lt;br  /&gt;你看它编译完的js文件：
&lt;br  /&gt;&lt;a href=&quot;https://github.com/scalaeye/scalaeye/blob/sliu/html/app.js&quot;&gt;https://github.com/scalaeye/scalaeye/blob/sliu/html/app.js&lt;/a&gt;
&lt;br  /&gt;前后用function(){}包起来了，把this当参数传了进去。
&lt;br  /&gt;在网页上this是window对象。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:34:51
&lt;br  /&gt;哦，这样的话，js中调用this时，都会指向这个window对象&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:34:49
&lt;br  /&gt;是的。
&lt;br  /&gt;它这样做是为了避免向命名空间引入过多的垃圾
&lt;br  /&gt;如果要引入全局变量，必须显式的用root.xx = xx定义。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:36:00
&lt;br  /&gt;coffee中以@开头的，表示什么？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:35:54
&lt;br  /&gt;this
&lt;br  /&gt;@a 等价于 this.a&lt;/p&gt;
&lt;p&gt;我(23246779) 12:36:24
&lt;br  /&gt;哦，好&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:36:37
&lt;br  /&gt;看78行。
&lt;br  /&gt;猜猜干什么的&lt;/p&gt;
&lt;p&gt;我(23246779) 12:37:48
&lt;br  /&gt;得到html上&lt;div class=&quot;writerInput&quot;  /&gt;这个块？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:37:42
&lt;br  /&gt;是的。
&lt;br  /&gt;@$(&amp;ldquo;&amp;hellip;&amp;ldquo;)
&lt;br  /&gt;等价于this.$(&amp;ldquo;&amp;hellip;&amp;ldquo;)&lt;/p&gt;
&lt;p&gt;我(23246779) 12:38:10
&lt;br  /&gt;这里的$，等价于jquery中的$?
&lt;br  /&gt;能否直接用$(&amp;ldquo;.writerInput&amp;rdquo;)，前面不加@?&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:38:15
&lt;br  /&gt;不完全等于&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:38:35
&lt;br  /&gt;Backbone.View提供了一个$方法。
&lt;br  /&gt;跟jquery的全局$方法用法完全一样。
&lt;br  /&gt;区别是
&lt;br  /&gt;view.$(&amp;ldquo;.a&amp;rdquo;) 相当于
&lt;br  /&gt;$(&amp;ldquo;.a&amp;rdquo;, view.el)&lt;/p&gt;
&lt;p&gt;我(23246779) 12:39:55
&lt;br  /&gt;.el是什么意思？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:39:54
&lt;br  /&gt;在view对应的区块的根元素（el）范围内查&amp;rdquo;.a&amp;rdquo;
&lt;br  /&gt;这个功能我很喜欢。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:40:43
&lt;br  /&gt;能否同时使用jquery的$?&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:40:36
&lt;br  /&gt;可以。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:41:06
&lt;br  /&gt;通常用backbone的就够了？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:41:00
&lt;br  /&gt;实际上，backbone的view.$的实现，就是调了全局的$方法
&lt;br  /&gt;所以需要依赖jquery或zepto&lt;/p&gt;
&lt;p&gt;我(23246779) 12:41:26
&lt;br  /&gt;哦，所以还是得加上jquery才行？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:41:18
&lt;br  /&gt;似乎是。
&lt;br  /&gt;如果不用这个this.$，就不需要引入。
&lt;br  /&gt;我没查证哈
&lt;br  /&gt;原理是这样的。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:42:21
&lt;br  /&gt;好&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:42:17
&lt;br  /&gt;这个很实用。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:42:32
&lt;br  /&gt;还有两个问题
&lt;br  /&gt;在backbone中，看到有一些save这样的方法
&lt;br  /&gt;是把model保存在服务器上的，这怎么实现的
&lt;br  /&gt;怎么用？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:43:51
&lt;br  /&gt;它有个叫Backbone.sync的方法，当调用model.save, model.destroy, collection.fetch等方法时，会根据一定规则拼一个url出来，通过jquery或zepto的ajax支持发请求。
&lt;br  /&gt;如果用websocket做backend的话，需要改写Backbone.sync，这样才能支持当model.save时，向websocket发数据。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:44:40
&lt;br  /&gt;在服务器端收到请求后，解析url，再生成一个对应的model，保存之&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:44:37
&lt;br  /&gt;对。
&lt;br  /&gt;如果不使用它的save, fetch方法，就不会调Backbone.sync。
&lt;br  /&gt;也没关系。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:45:20
&lt;br  /&gt;有没有哪个库，在服务器端与backbone是对应的？
&lt;br  /&gt;不需要手动解析
&lt;br  /&gt;如同socket.io的服务器端与客户端的关系&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:45:29
&lt;br  /&gt;backbone似乎有服务器端版本。&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:45:38
&lt;br  /&gt;我不明白你说的手工解析。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:46:16
&lt;br  /&gt;我的意思是，假如我用play，还需要先查它拼url的规则
&lt;br  /&gt;再按这个规则来取对应的数据&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:46:08
&lt;br  /&gt;rails的Restful支持不错，backbone跟rails结合比较好。
&lt;br  /&gt;play也是完整的Restful支持，你只需要按它的规则去配routes&lt;/p&gt;
&lt;p&gt;我(23246779) 12:46:54
&lt;br  /&gt;backbone还有一个地方
&lt;br  /&gt;Router
&lt;br  /&gt;var Workspace = Backbone.Router.extend({&lt;/p&gt;
&lt;p&gt;routes: {
&lt;br  /&gt;&amp;ldquo;help&amp;rdquo;: &amp;ldquo;help&amp;rdquo;, // #help
&lt;br  /&gt;&amp;ldquo;search/:query&amp;rdquo;: &amp;ldquo;search&amp;rdquo;, // #search/kiwis
&lt;br  /&gt;&amp;ldquo;search/:query/p:page&amp;rdquo;: &amp;ldquo;search&amp;rdquo; // #search/kiwis/p7
&lt;br  /&gt;},&lt;/p&gt;
&lt;p&gt;help: function() {
&lt;br  /&gt;&amp;hellip;
&lt;br  /&gt;},&lt;/p&gt;
&lt;p&gt;search: function(query, page) {
&lt;br  /&gt;&amp;hellip;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;});
&lt;br  /&gt;看这个例子，routes里，key是一个个url?&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:47:34
&lt;br  /&gt;我们这个应用里，没必要用Router，至少目前没发现这个必要。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:47:59
&lt;br  /&gt;嗯。我是看文档时，这一点不太明白&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:49:30
&lt;br  /&gt;我理解，就是对于单个页面，一直不刷新的应用，页面上有好多链接、按钮，点击都会执行不同的操作，比如与服务器端交互、更新本地ui片段，就是不刷新。
&lt;br  /&gt;这样，将这些链接的地址用router的方式声明起来，就有了规划。
&lt;br  /&gt;它还支持一个pushState的选项，我没研究，似乎是可以支持 浏览器历史的前进、后退。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:50:24
&lt;br  /&gt;有没有实际使用过该功能？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:50:18
&lt;br  /&gt;没有。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:50:38
&lt;br  /&gt;我就是有点奇怪，点了一个链接后，页面都跳转了
&lt;br  /&gt;岂不是白定义了&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:50:31
&lt;br  /&gt;没有。
&lt;br  /&gt;它是用anchor
&lt;br  /&gt;链接后是 &amp;ldquo;#xxx&amp;rdquo;
&lt;br  /&gt;锚点
&lt;br  /&gt;不刷新。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:51:26
&lt;br  /&gt;哦，你的意思是，页面中不出现可跳转的url?
&lt;br  /&gt;而是定义一些锚点，把它们看作是url?&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:51:20
&lt;br  /&gt;嗯。
&lt;br  /&gt;对。
&lt;br  /&gt;锚点里也可以携带一些有意义的信息，如业务类型、id，把它个形式设计的跟RESTful api的url规则很象。
&lt;br  /&gt;但锚点不会引发页面跳转。
&lt;br  /&gt;就象github里看代码时，点左侧的页号一样。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:53:38
&lt;br  /&gt;这一点很有趣，也很精彩&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:54:06
&lt;br  /&gt;是啊，这样既起到规划作用，又能保存历史记录，当点击浏览器的前进、后退也好使（跟gmail那样）&lt;/p&gt;
&lt;p&gt;我(23246779) 12:54:50
&lt;br  /&gt;通过锚点，还能让浏览器的前进后退也能用？
&lt;br  /&gt;那太好了，我一直没想明白，怎么跨浏览器做到这一点呢&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:56:23
&lt;br  /&gt;点击锚点不会页面刷新，浏览器却能存到history列表里，当切换锚点时，js能收到location change的event，所以能做这件事。
&lt;br  /&gt;但history的保存、恢复也需要js做很多事，不知道backbone能不能达到这个效果，不过我觉得这不重要，整体感觉router在我们这个案例里没有用处。
&lt;br  /&gt;我甚至觉得model.save等也没必要用，也就不用改写它的sync方法了。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:53:38
&lt;br  /&gt;还有一点
&lt;br  /&gt;每个model都定义了一些默认的event的
&lt;br  /&gt;是不是所有的event，都会触发对应的view的render方法？&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:54:58
&lt;br  /&gt;我原先以为是，后来试验着发现不是。
&lt;br  /&gt;所以我在view的initialize方法（构造方法）里显式的绑定了。
&lt;br  /&gt;象63行。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:55:45
&lt;br  /&gt;嗯，看到了
&lt;br  /&gt;这样子代码之间隔离得很清楚
&lt;br  /&gt;只要明白了backbone的规则，就能理解它的运转方式&lt;/p&gt;
&lt;p&gt;我(23246779) 12:57:15
&lt;br  /&gt;也不像之前用jquery那样，给某个div绑函数时，写得乱七八糟
&lt;br  /&gt;backbone+coffeescript，太好了
&lt;br  /&gt;让人对javascript编程完全有了新的感觉&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:58:38
&lt;br  /&gt;哈哈，是啊。&lt;/p&gt;
&lt;p&gt;我(23246779) 12:59:12
&lt;br  /&gt;这个功能：写上内容，点发送，提交给服务器，怎么实现&lt;/p&gt;
&lt;p&gt;刘松(42279444) 12:58:58
&lt;br  /&gt;看74行。&lt;/p&gt;
&lt;p&gt;我(23246779) 13:00:05
&lt;br  /&gt;这个把button的click事件，绑定到一个方法上了&lt;/p&gt;
&lt;p&gt;刘松(42279444) 13:00:30
&lt;br  /&gt;对。
&lt;br  /&gt;一个组件上的所有事件在一个地方声明，把对应的行为（方法）也对应起来了。
&lt;br  /&gt;而且
&lt;br  /&gt;声明方式是：
&lt;br  /&gt;&amp;ldquo;event selector&amp;rdquo; : &amp;ldquo;方法名&amp;rdquo;
&lt;br  /&gt;这个selector，不是在body下去找，而是在当前view的根结点上去找，效率好，不易出错。&lt;/p&gt;
&lt;p&gt;我(23246779) 13:02:25
&lt;br  /&gt;嗯，这样好&lt;/p&gt;
&lt;p&gt;刘松(42279444) 13:02:25
&lt;br  /&gt;我没看backbone的代码，还有可能是用jquery的live，使用event delegation做 的。&lt;/p&gt;
&lt;p&gt;我(23246779) 13:01:07
&lt;br  /&gt;我明白那个Router的作用了，它就是在backbone中用来代替以前的超链接
&lt;br  /&gt;我们平时开发网站，会用到大量的超链接（会跳转）
&lt;br  /&gt;改用backbone后，我们可以利用锚点沿用这个习惯&lt;/p&gt;
&lt;p&gt;刘松(42279444) 13:01:16
&lt;br  /&gt;嗯&lt;/p&gt;
&lt;p&gt;我(23246779) 13:02:46
&lt;br  /&gt;还有一个小问题&lt;/p&gt;
&lt;p&gt;我(23246779) 13:02:53
&lt;br  /&gt;你的代码里有这样的：aaa if bbb?
&lt;br  /&gt;最后一个问号是什么意思？
&lt;br  /&gt;为什么不写成aaa if bbb&lt;/p&gt;
&lt;p&gt;刘松(42279444) 13:03:09
&lt;br  /&gt;哦。
&lt;br  /&gt;if bbb.isDefined()
&lt;br  /&gt;我追时髦了。&lt;/p&gt;
&lt;p&gt;我(23246779) 13:03:38
&lt;br  /&gt;哦，表示&quot;存在&amp;rdquo;
&lt;br  /&gt;没什么其它的问题了
&lt;br  /&gt;呵呵，明白了
&lt;br  /&gt;真多谢你了，一席话让我基本上明白backbone是怎么回事了&lt;/p&gt;
&lt;/blockquote&gt;
]]></description>
            </item>
        
            <item>
                <title>java中的Continuation实现：commons-javaflow</title>
                <link>http://freewind.in/posts/442-java-continuation-commons-javaflow</link>
                <pubDate>Wed, 19 Oct 2011 16:21:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">442</guid>
                <description><![CDATA[&lt;p&gt;在看play的libs.F时，发现它使用了一个叫commons-javaflow的库，来实现continuation，即将某一个程序的运行暂停，将现场保护起来，等晚点再读回来接着运行。&lt;/p&gt;
&lt;p&gt;其网址为：&lt;a href=&quot;http://commons.apache.org/sandbox/javaflow/index.html&quot;&gt;http://commons.apache.org/sandbox/javaflow/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后更新日期为2008年，最新版本为1.0-snapshot，看来又是一个夭折的项目。&lt;/p&gt;
&lt;p&gt;这里是一个简单的说明页面，讲解了其工作过程：&lt;a href=&quot;http://commons.apache.org/sandbox/javaflow/tutorial.html&quot;&gt;http://commons.apache.org/sandbox/javaflow/tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从这里我们可以看出，它还是很神奇的。当我们在代码中运行了Continuation.suspend()时，它就会把所有的局部变量和stack保存在一个Continuation对象里，马上跳出整个run方法。我们只要有了这个continuation对象，就可以在以后的任意时刻，运行Continuation.continueWith(c)继续执行刚才的代码，就好像中间没有断开过一样。&lt;/p&gt;
&lt;p&gt;正是因为它能做到如此神奇的功能，play才会使用它来做到Promise：当需要的数据还没有准备好的时候，就把它暂停并保存好，腾出线程做别的事情。等数据准备好之后，再把那个对象取回来恢复，继续执行。&lt;/p&gt;
&lt;p&gt;因为这样的功能肯定不是java自己可以提供的，所以javaflow也使用了一些修改字节码的库，必须先对字节码进行增强，才能正常运行。它提供了两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用一个ant任务预增强&lt;/li&gt;
&lt;li&gt;使用它提供的一个ContinuationClassLoader类，指定需要增强的jar，在运行期增强&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我尝试了第二种方法，可惜的是，不论我怎么调试，都会报ClassNotFoundException，无奈放弃。&lt;/p&gt;
&lt;p&gt;Play对其代码进行了裁减，没有使用ant和ContinuationClassLoader，可能用到了其它的方法实现。&lt;/p&gt;
&lt;p&gt;到处都是魔法代码啊。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>play之libs.F</title>
                <link>http://freewind.in/posts/438-play-libs-f</link>
                <pubDate>Wed, 19 Oct 2011 13:18:39 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">438</guid>
                <description><![CDATA[&lt;p&gt;我是在看play自带的聊天室程序&lt;code&gt;samples-and-tests/chat&lt;/code&gt;时，发现了这个类&lt;code&gt;libs.F&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Play的文档，在基本使用方面写得很详细，但对于较高级的功能，如这个&lt;code&gt;libs.F&lt;/code&gt;类，则非常简略。没有注释，没有文档，只有源代码，以及网上一篇辛苦找到的很简单的介绍性文章：&lt;a href=&quot;https://github.com/playframework/play/blob/master/documentation/manual/libs.textile&quot;&gt;https://github.com/playframework/play/blob/master/documentation/manual/libs.textile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里做一下简单介绍（边学边写）：&lt;/p&gt;
&lt;p&gt;libs.F中的F，指的是&quot;Functional programming&amp;rdquo;，即函数式编程。Java本身不支持函数式编程，所以play试图将一些函数式编程中的概念移植到java中，所以有了这个libs.F。&lt;/p&gt;
&lt;p&gt;libs.F虽然是一个类，但play其实是把它当成&quot;包&quot;在用。因为里面定义了很多public类和方法，放在一起显得更加方便。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-438&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;基本结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/438-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;虽然定义了不少类，但是如果你对scala有所了解的话，可以看出它实际上模拟了scala中的一些概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Option&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Option&lt;T&gt;, None&lt;T&gt;, Some&lt;T&gt;三个类，与scala中的Option一一对应，其作用也是一样的：避免null的使用和NullPointerException的产生。更详细的讲解可参看scala中的相关文章。&lt;/p&gt;
&lt;p&gt;Some和None都继承于Option类，提供了&lt;code&gt;isDefined&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;等方法。所以以前这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (obj==null) {
    // do something
} else {
    // do something else
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在则写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (opt.isDefined()) {
    // do something
} else {
    // do something else
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;错！！如果仅仅是这样，那么没有任何意义。使用Option就是为了让我们省掉这个判断，直接使用其值（如果有的话）。&lt;/p&gt;
&lt;p&gt;在Scala中，我们可以这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opt map { v =&amp;gt; dosomething(v) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在java中怎么模拟呢？使用&lt;code&gt;for&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;None和Some类都实现了Iterable接口，这意味着我们可以使用这种用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for ( T v : opt ) {
    dosomething(v);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果对象opt为None，则循环中的内容不执行；否则执行一次。Play通过这种巧妙的方式，避免了判断，模拟出了scala中的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Tuple&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同样模仿了Scala，表示同时提供多个不同类型的值。不过这里只提供了最多5个元素（Scala中是22个），对应的类分别是Tuple, T2, T3, T4, T5。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Either&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模仿了Scala，表示只提供了多种可能值中的一个。只提供了最多5种可能，对应的类是：Either, E2, E3, E4, E5。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Pattern match&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式匹配是Scala中的一个强大的特性，play在这里通过Matcher等类进行模仿。先看Scala中的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj match {
    case s:String if s.startsWith(&quot;command:&quot;) =&amp;gt; println(s.toUpperCase())
    case _ =&amp;gt; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在Java中，应该写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(obj instanceof String &amp;amp;&amp;amp; ((String)obj).startsWith(&quot;command:&quot;)) {
    String s = (String)obj;
    System.out.println(&quot;s.toUpperCase());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而使用libs.F，可写成这样（注意其中中String是F.Matcher中定义的一个字段）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static import libs.F.Matcher.*;
for (String s : String.and(StartsWith(&quot;command:&quot;)).match(obj)) {
    System.out.println(s.otUpperCase());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5. 并发及异步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的这些，在代码中使用的并不多。它们的存在，实际上是为了这里的&quot;并发及异步&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;这里涉及到的类（和接口）有：Action, Action0, Promise, Timeout, EventStream, IndexedEvent, ArchivedEventStream&lt;/p&gt;
&lt;p&gt;这一块的代码写得极其复杂且完全没有注释，看起来让人头大无比。这也能代表play整体的代码风格：代码写得比较玄，有些地方逻辑复杂，很难理解。&lt;/p&gt;
&lt;p&gt;在play的google group中有一段描述，也许可以帮助理解：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;pre&gt;
&lt;br  /&gt;&amp;ndash; Promises:
&lt;br  /&gt;In Play 1.2 we introduce Promise that is the Play&apos;s custom Future type
&lt;br  /&gt;(Promise was named Task in previous commits on master) . In fact a
&lt;br  /&gt;Promise&lt;T&gt; is also a Future&lt;T&gt; so you can use it as a standard Future.
&lt;br  /&gt;But it has also a very interesting property: the ability to register
&lt;br  /&gt;callback using onRedeem(…) that will be called as soon as the promised
&lt;br  /&gt;value is available. It allows the framework to register itself on them
&lt;br  /&gt;and to reschedule the request invocation as soon as possible.
&lt;br  /&gt;Promises are used everywhere in Play in place of Future (for Jobs,
&lt;br  /&gt;WS.async, etc…)
&lt;br  /&gt;Promises can be combined in several way. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise p = Promise.waitAll(p1, p2, p3)&lt;/li&gt;
&lt;li&gt;Promise p = Promise.waitAny(p1, p2, p3)&lt;/li&gt;
&lt;li&gt;Promise p = Promise.waitEither(p1, p2, p3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ndash; play.libs.F:
&lt;br  /&gt;The Promise type is part of new library (play.libs.F) that introduces
&lt;br  /&gt;several useful constructs coming from functional programming. These
&lt;br  /&gt;constructs are used to handle complex cases that I will expose just
&lt;br  /&gt;later. For those that are accustomed to functional programming we
&lt;br  /&gt;provide:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Option&lt;T&gt; (a T value that can be or not set)&lt;/li&gt;
&lt;li&gt;Either&lt;A,B&gt; (contains either a A value or a B value)&lt;/li&gt;
&lt;li&gt;Tuple&lt;A,B&gt; (contains both A and B values)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ndash; await(…):
&lt;br  /&gt;So, now when your application code returns values that are not yet
&lt;br  /&gt;available using a Promise&lt;T&gt;, you want to be able to ask Play to wait
&lt;br  /&gt;for this promised result to be available before resuming your request.
&lt;br  /&gt;It allows your code to say explicitly: &amp;ldquo;I&apos;m waiting for a result that
&lt;br  /&gt;will be available later&amp;rdquo;, and so the framework to handle it as &amp;ldquo;Ok I
&lt;br  /&gt;will stop your code, reuse the thread to serve other requests, and
&lt;br  /&gt;resume your code as soon as the promised value you wait for is
&lt;br  /&gt;available&amp;rdquo;.
&lt;br  /&gt;It is the point of the await(…) controller methods:
&lt;br  /&gt;Promise&lt;String&gt; delayedResult = veryLongComputation(…);
&lt;br  /&gt;await(delayedResult);&lt;/p&gt;
&lt;p&gt;&amp;ndash; Continuations:
&lt;br  /&gt;Because the framework needs to recover the thread you were using in
&lt;br  /&gt;order to use it to serve other requests, it has to suspend your code.
&lt;br  /&gt;In the previous Play version the await(…) equivalent was waitFor(…).
&lt;br  /&gt;And waitFor was suspending your action, and then recalling it later
&lt;br  /&gt;from the beginning.
&lt;br  /&gt;To make it easier to deal with asynchronous code in Play 1.2 we have
&lt;br  /&gt;introduced continuations. Continuations allow your code to be
&lt;br  /&gt;suspended and resumed transparently. So you write your code in a very
&lt;br  /&gt;imperative way, as:
&lt;br  /&gt;public static void computeSomething() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; Promise&amp;lt;String&amp;gt; delayedResult = veryLongComputation(…); 
 String result = await(delayedResult); 
 render(result); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;In fact here, your code will be executed in 2 steps, in 2 different
&lt;br  /&gt;threads. But as you see it, it&apos;s very transparent for your application
&lt;br  /&gt;code.
&lt;br  /&gt;Using await(…) and continuations, you could write a loop:
&lt;br  /&gt;public static void loopWithoutBlocking() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; for(int i=0; i&amp;lt;10; i++) { 
      System.out.println(i); 
      await(&quot;1s&quot;); 
 } 
 renderText(&quot;Loop finished&quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;And using only 1 thread (which is the default in development mode) to
&lt;br  /&gt;process requests, Play 1.2 will be able to run concurrently these
&lt;br  /&gt;loops for several requests at the same time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以将Promise看作是jdk中提供的Future，可用于将某些任务异步执行。实际上Promise实现了Future，并且提供了一些增强的功能。作者在论坛的一个帖子里说，jdk提供的Future没什么用，所以才弄了一个Promise出来。&lt;/p&gt;
&lt;p&gt;我们在代码中，使用的时候，通常是在controller中通过&lt;code&gt;await()&lt;/code&gt;方法，将某一个耗时的操作暂停，将线程让出执行别的操作。等到耗时操作完成的时候，再回来继续刚才的操作。这样可以节省线程资源。&lt;/p&gt;
&lt;p&gt;这里涉及的代码有点复杂，而且我也没有实际用过，所以先略过不提。等在使用中有了新的发现，再补充在这里。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>系统时间错误，导致连不上github.com</title>
                <link>http://freewind.in/posts/430-cannot-connect-to-github-due-to-incorrect-system-time</link>
                <pubDate>Wed, 28 Sep 2011 07:59:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">430</guid>
                <description><![CDATA[&lt;p&gt;今天发现自己怎么都打不开&lt;a href=&quot;https://github.com&quot;&gt;https://github.com&lt;/a&gt;，翻墙也不行，错误信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/user_images/430-0.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;怎么弄都没弄好，最后仔细地看错误提示：ERR_CERT_DATE_INVALID，再看系统时间是2007年。&lt;/p&gt;
&lt;p&gt;原来上午为了测试新的显卡，把主板拆了，导致系统时间变成了2007年。&lt;/p&gt;
&lt;p&gt;难道是这个原因？马上把它改成正确的时间，再访问一切正常。没想到时间不对也有可能访问不了网站。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>脑图软件</title>
                <link>http://freewind.in/posts/381-brain-graph-software</link>
                <pubDate>Tue, 27 Sep 2011 20:00:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">381</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;一、我一直用的是Freemind&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网站：&lt;a href=&quot;http://freemind.sourceforge.net/&quot;&gt;http://freemind.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/381-1.png&quot;&gt;&lt;img src=&quot;/user_images/381-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于swing，界面简洁，操作比较方便（好像各脑图软件快捷键都差不多），中文字体清晰，对于单机用户来说足够好用。不支持上传及多人合作。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-381&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Xmind&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网站：&lt;a href=&quot;http://xmind.net&quot;&gt;http://xmind.net&lt;/a&gt;，据说是国人开发的（网站却没有中文版）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/381-3.png&quot;&gt;&lt;img src=&quot;/user_images/381-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于swt，功能比较强大，可以在官网上注册后，将设计的脑图上传。它有一个特色的“自由主题”功能，不像freemind只能有一个root。有一点不方便的是，移动画布时，只能通过移动两边的滚动条。另外，我注册帐号始终不成功，一点&quot;Sign up&amp;rdquo;，它就自动刷新了。&lt;/p&gt;
&lt;p&gt;中文字体有点虚虚的，看起来不舒服。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、PersonalBrain&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网站：&lt;a href=&quot;http://www.thebrain.com/products/personalbrain&quot;&gt;http://www.thebrain.com/products/personalbrain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/381-5.png&quot;&gt;&lt;img src=&quot;/user_images/381-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也是基于swt，界面初看起来觉得很酷，里面那些小圈还是动画的，不停转动。但是用起来的时候觉得很不舒服，跳来跳去，闪来闪去，一点也不好操作。本来是因为集中思想去相问题的，老是被它的动画打断思路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、mind42&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网站：&lt;a href=&quot;http://mind42.com&quot;&gt;http://mind42.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这实际上是一个免费的在线服务，直接在浏览器中画图。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/381-7.png&quot;&gt;&lt;img src=&quot;/user_images/381-7.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作时主要用鼠标来选择动作，不像前面那些软件用键盘那么顺手。可以方便地把脑图发布出来，得到一个url，供其它人查看。还支持多人协作，点击顶部中间的“invite and manage collaborators&amp;rdquo; 即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人比较喜欢freemind和mind42。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>设置linux的”最大打开文件数量</title>
                <link>http://freewind.in/posts/351-setup-max-open-files-of-linux</link>
                <pubDate>Thu, 22 Sep 2011 12:34:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">351</guid>
                <description><![CDATA[&lt;p&gt;通过&lt;code&gt;ulimit -n&lt;/code&gt;可以看到linux&quot;最大打开文件数量&quot;的默认值是&lt;code&gt;1024&lt;/code&gt;。对于一些程序，如web服务，太小不够用。由于建立SOCKET会占用一个系统句柄，效果类似于打开了一个文件。LINUX默认的最大文件打开个数是1024（可能不同内核版本不一样），所以如果并发太多连接时就会报错。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-351&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;可通过下面几个步骤修改：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;vi /etc/pam.d/login&lt;/p&gt;
&lt;p&gt;添加:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session required /lib/security/pam_limits.so
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意看这个文件的注释&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vi /etc/security/limits.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在最后添加：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;nofile 819200&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;nproc 819200&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;表示所有用户，如果想仅设置某一个用户，则换成其登录名，如&lt;code&gt;www&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;设置的数值与硬件配置有关，别设置太大了。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vi /etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在最后添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fs.file-max = 819200
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后启用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sysctl -p&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;4.  查看 `ulimit -a`，注意其中的`-n`那一行

    设置：

    ```
ulimit -n 819200
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;echo 819200 &amp;gt; /proc/sys/fs/file-max&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /proc/sys/fs/file-max 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Java中如何把两个数组合并为一个</title>
                <link>http://freewind.in/posts/350-how-to-combine-two-arrays-into-one-in-java</link>
                <pubDate>Thu, 22 Sep 2011 12:32:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">350</guid>
                <description><![CDATA[&lt;p&gt;在Java中，如何把两个&lt;code&gt;String[]&lt;/code&gt;合并为一个？&lt;/p&gt;
&lt;p&gt;看起来是一个很简单的问题。但是如何才能把代码写得高效简洁，却还是值得思考的。这里介绍四种方法，请参考选用。&lt;/p&gt;
&lt;h2&gt;一、apache-commons&lt;/h2&gt;
&lt;p&gt;这是最简单的办法。在apache-commons中，有一个&lt;code&gt;ArrayUtils.addAll(Object[], Object[])&lt;/code&gt;方法，可以让我们一行搞定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String[] both = (String[]) ArrayUtils.addAll(first, second);

其它的都需要自己调用jdk中提供的方法，包装一下。

为了方便，我将定义一个工具方法`concat`，可以把两个数组合并在一起：

static String[] concat(String[] first, String[] second) {}

为了通用，在可能的情况下，我将使用泛型来定义，这样不仅`String[]`可以使用，其它类型的数组也可以使用：

static &amp;lt;T&amp;gt; T[] concat(T[] first, T[] second) {}

当然如果你的jdk不支持泛型，或者用不上，你可以手动把T换成`String`。

## 二、System.arraycopy()

````static String[] concat(String[] a, String[] b) {
   String[] c= new String[a.length+b.length];
   System.arraycopy(a, 0, c, 0, a.length);
   System.arraycopy(b, 0, c, a.length, b.length);
   return c;
}

使用如下：

String[] both = concat(first, second);

## 三、Arrays.copyOf()

在java6中，有一个方法`Arrays.copyOf()`，是一个泛型函数。我们可以利用它，写出更通用的合并方法：

````public static &amp;lt;T&amp;gt; T[] concat(T[] first, T[] second) {
  T[] result = Arrays.copyOf(first, first.length + second.length);
  System.arraycopy(second, 0, result, first.length, second.length);
  return result;
}         

如果要合并多个，可以这样写：

````public static &amp;lt;T&amp;gt; T[] concatAll(T[] first, T[]... rest) {
  int totalLength = first.length;
  for (T[] array : rest) {
    totalLength += array.length;
  }
  T[] result = Arrays.copyOf(first, totalLength);
  int offset = first.length;
  for (T[] array : rest) {
    System.arraycopy(array, 0, result, offset, array.length);
    offset += array.length;
  }
  return result;
}

使用如下：

String[] both = concat(first, second);
String[] more = concat(first, second, third, fourth);

## 四、Array.newInstance

还可以使用`Array.newInstance`来生成数组：

````private static &amp;lt;T&amp;gt; T[] concat(T[] a, T[] b) {
    final int alen = a.length;
    final int blen = b.length;
    if (alen == 0) {
        return b;
    }
    if (blen == 0) {
        return a;
    }
    final T[] result = (T[]) java.lang.reflect.Array.
            newInstance(a.getClass().getComponentType(), alen + blen);
    System.arraycopy(a, 0, result, 0, alen);
    System.arraycopy(b, 0, result, alen, blen);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>1927年12月31日午夜一秒谜案</title>
                <link>http://freewind.in/posts/349-a-secret-case-about-one-second-of-1927-12-31</link>
                <pubDate>Thu, 22 Sep 2011 12:03:51 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">349</guid>
                <description><![CDATA[&lt;p&gt;我在stackoverflow上问了一个关于Java中时间的问题，居然火了那么一下下。其实那个问题也不是我自己发现的，而是在一个Java群中有人提了，但没人知道怎么回事，所以我便到stackoverflow上问了一下而已。&lt;/p&gt;
&lt;p&gt;后来发现网上有人写了一个段子，报道了这件事，大意是程序员伤不起，不但要会写程序，还得上知天文下知地理。同一件事情，别人的语言写得非常生动幽默，值得好好学习。&lt;/p&gt;
&lt;p&gt;文章见：&lt;a href=&quot;http://jandan.net/2011/07/30/1927-java-time.html&quot;&gt;http://jandan.net/2011/07/30/1927-java-time.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-349&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽说是程序员向，不过内容和编程本身其实并没什么太大关系，请各位听我细细道来。
&lt;br  /&gt;&lt;p&gt;StackOverflow是一个程序员向的问答网站，广大程序员们在上面交流经验、提问答疑，三天前，一位名叫Freewind的用户发布了&lt;a href=&quot;http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result&quot;&gt;下面这个问题&lt;/a&gt;：
&lt;br  /&gt;&lt;p&gt;If I run the following program, which parses two date strings referencing times one second apart and compares them:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws ParseException {
    SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  
    String str3 = &quot;1927-12-31 23:54:07&quot;;  
    String str4 = &quot;1927-12-31 23:54:08&quot;;  
    Date sDt3 = sf.parse(str3);  
    Date sDt4 = sf.parse(str4);  
    long ld3 = sDt3.getTime() /1000;
    long ld4 = sDt4.getTime() /1000;
    System.out.println(ld3);  
    System.out.println(ld4);  
    System.out.println(ld4-ld3);
} 


The output is:
````
-1325491905
-1325491552
353

&amp;lt;p&amp;gt;Why is `ld4-ld3` not `1` (as I would expect from the one-second difference in the times), but `353`? 

If I change the dates to times a second later:
````String str3 = &quot;1927-12-31 23:54:08&quot;;&amp;amp;nbsp; 
String str4 = &quot;1927-12-31 23:54:09&quot;;&amp;amp;nbsp; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;p&gt;Then &lt;code&gt;ld4-ld3&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;p&gt;翻译过来即是：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;我在用Java编写一段比较两个字符串时间间隔的程序，然而当我比较“1927-12-31 23:54:07”和“1927-12-31 23:54:08”这两个时间时，输出结果却不是1……而是353。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;当我把两个时间分别往后调整1秒，变成“1927-12-31 23:54:08”和“1927-12-31 23:54:09”，结果就又是1了！——可为什么那两个时间的结果，却是353呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（……没错，Freewind君，似乎是一位魔都死程。不知道这里有没有人认识这位老兄？）&lt;/p&gt;
&lt;p&gt;在这份追加信息出现仅仅两分钟之后，StackOverflow站上的问答狂人Jon Skeet&lt;a href=&quot;http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result/6841479#6841479&quot;&gt;给出了如下答复&lt;/a&gt;——&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;这是因为上海的时区在12月31日发生了变化。&lt;/p&gt;
&lt;p&gt;请看&lt;a href=&quot;http://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;这里&lt;/a&gt;。（网页截图如下）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/349-1.png&quot;&gt;&lt;img src=&quot;/user_images/349-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（1928年1月1日0点0分，当地时间由&lt;a href=&quot;http://baike.baidu.com/view/2553310.htm&quot;&gt;地方平时（Local Mean Time）&lt;/a&gt;改为北京时间/中国标准时间）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;简单地说，在1927年末的最后那一个午夜，时钟被往回拨了5分52秒。所以“1927-12-31 23:54:08”这一秒，事实上，发生了两次，而看起来在计算当地时间时，Java将其视为了后面那一个时间点，于是就产生了这一差别。&lt;/p&gt;
&lt;p&gt;这正是时区世界的奇妙与不可思议啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在StackFlow网民们纷纷膜拜Jon Skeet的神速之时，其他程序员也以测试的方式验证了这一结果的正确——美国时间木有这个问题。看来，当一枚程序员，有时真的需要上通天文、下知地理啊……&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在java中调用系统的命令行工具</title>
                <link>http://freewind.in/posts/348-invoke-system-commands-in-java</link>
                <pubDate>Thu, 22 Sep 2011 11:53:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">348</guid>
                <description><![CDATA[&lt;p&gt;我们经常需要在java程序中，调用某些系统命令，来完成一些工作。原理简单，但是要注意处理好程序的输出，否则可能会卡住。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Process process = null;
try {
     String cmd = &quot;c:\\dbbackup.bat&quot;;
     process = Runtime.getRuntime().exec(cmd);
     StreamReader err = new StreamReader(process.getErrorStream());
     StreamReader out = new StreamReader(process.getInputStream());
     err.start();
     out.start();
     int exitCode = process.waitFor();
     String errMessage = err.getMessage();
     String outMessage = out.getMessage();
     if(exitCode==0) {
         System.out.println(&quot;操作成功!&quot;);
     } else {
         System.out.println(&quot;操作失败!返回代码为&quot; + exitCode);
     }

} finally {
     if (process != null) {
         process.destroy();
     }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span id=&quot;more-348&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;注意，代码中的&lt;code&gt;err&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;用于读取程序的输出。就算是我们不需要管程序的输出，也要把它们读取出来丢掉，否则程序有可能会卡住。它们分别在后台各启动一个线程，同时读取。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;StreamReader&lt;/code&gt;的代码如下：　&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;

public class StreamReader extends Thread {
     private InputStream input;
     private List&amp;lt;String&amp;gt; lines = new ArrayList&amp;lt;String&amp;gt;();
     public StreamReader(InputStream input) {
         this.input = input;
         setDaemon(true);
         setName(&quot;process stream reader&quot;);
     }

     @Override
     public void run() {
         BufferedReader reader = new BufferedReader(new InputStreamReader(input));
         try {
             do {
                 String line = reader.readLine();
                 if (line != null) {
                     this.lines.add(line);
                 } else {
                     return;
                 }
             } while (true);
         } catch (IOException e) {
             return;
         }
     }

     public String getMessage() {
         return StringUtils.join(this.lines, &quot;\r\n&quot;);
     }
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在Java中得到程序使用的内存，以及JVM的总内存</title>
                <link>http://freewind.in/posts/347-how-to-get-java-memory-used-and-jvm-total-mem</link>
                <pubDate>Thu, 22 Sep 2011 11:48:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">347</guid>
                <description><![CDATA[&lt;p&gt;&lt;p&gt;参见&lt;code&gt;java.lang.Runtime&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.out.println(&quot;Max:&quot; + Runtime.getRuntime().maxMemory());
System.out.println(&quot;Total:&quot; + Runtime.getRuntime().totalMemory());
System.out.println(&quot;Free:&quot; + Runtime.getRuntime().freeMemory());
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>参数curry化</title>
                <link>http://freewind.in/posts/346-scala-function-curry</link>
                <pubDate>Thu, 22 Sep 2011 11:46:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">346</guid>
                <description><![CDATA[&lt;p&gt;在scala中看到一个的函数定义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; def execute(sql: String) (f: PreparedStatement =&amp;gt; Unit)

这种语法叫作**参数curry化**，即把函数的参数分开写。它等价于：

````def execute(sql: String, f: PreparedStatement =&amp;gt; Unit)

即第一个参数是一个String，第二个是一个函数定义：输入PreparedStatement，得到Unit

&amp;lt;span id=&quot;more-346&quot;&amp;gt;&amp;lt;/span&amp;gt;

之所有要把它分开写，是因为在scala中，`()`可以写作`{}`，我们在调用时，可以写得好看一些：

````execute(&quot;select* from users&quot;) { ps: PreparedStatement =&amp;gt; // do something with the ps }

再来一个例子，对于这个函数：

````def exec(s1:String)(s2:String)(s3:String)

可以这样调用：

````exec(&quot;s1&quot;)(&quot;s2&quot;)(&quot;s3&quot;) exec(&quot;s1&quot;)(&quot;s2&quot;){&quot;s3&quot;} exec(&quot;s1&quot;){&quot;s2&quot;}{&quot;s3&quot;} exec{&quot;s1&quot;}{&quot;s2&quot;}{&quot;s3&quot;} exec{&quot;s1&quot;}(&quot;s2&quot;){&quot;s3&quot;}

注意里面的()和{}，任意一个都可以互换的。

当然，我们通常在参数内容比较长的时候，才用`{}`，并且分行写:

````exec(&quot;s1&quot;)(&quot;s2&quot;){ val s3 = &quot;sdfdsfdsfdsfsdfsdfsdfdsf&quot; s3 + &quot;rrrrrrrr&quot; }
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>基于jvm的语言，有哪些？</title>
                <link>http://freewind.in/posts/345-languages-on-jvm</link>
                <pubDate>Thu, 22 Sep 2011 11:40:39 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">345</guid>
                <description><![CDATA[&lt;p&gt;现在各种新语言不断推出，可谓百花奇放。每种语言都有各自的特色，那么，在JVM上，现在有哪些语言呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Groovy: &lt;/strong&gt;&lt;a href=&quot;http://groovy.codehaus.org/&quot; title=&quot;http://groovy.codehaus.org/&quot;&gt;&lt;strong&gt;http://groovy.codehaus.org/&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于jvm的一种动态语言，在java的基础上增加了很多特性，用起来很方便。但因为其动态语言的原因，性能较java弱。&lt;/p&gt;
&lt;p&gt;好消息是，现在有一个&lt;a href=&quot;http://code.google.com/p/groovypptest/&quot;&gt;groovy++&lt;/a&gt;的项目，可以把groovy代码以静态语言方式编译，基本上不需要修改原有代码，就可以达到和java几乎相同的性能。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&quot;Rod&quot;, &quot;Carlos&quot;, &quot;Chris&quot;].findAll{it.size() &amp;lt;= 4}.each{println it}

它对应的java代码为：

````for (String it : new String[] {&quot;Rod&quot;, &quot;Carlos&quot;, &quot;Chris&quot;}) if (it.length() &amp;lt;= 4) System.out.println(it);
````&amp;lt;span id=&quot;more-345&quot;&amp;gt;&amp;lt;/span&amp;gt;


**jython: **[**http://www.jython.org/**](http://www.jython.org/)

[Python](http://python.org/)语言在jvm上的实现，对于喜欢python的javaer是很有用的。

**jruby: **[**http://jruby.org/**](http://jruby.org/)

[Ruby](http://ruby-lang.org/)在jvm上的实现，sun公司其开发者招到了自己公司全职开发，只是不知道被oracle收购后，现在的情况如何。

**Clojure: **[**http://clojure.org/**](http://clojure.org/)

Lisp语言在jvm上的实现

**AspectJ: **[**http://www.eclipse.org/aspectj/**](http://www.eclipse.org/aspectj/)

一种面向切面的语言，可以对java类进行增强。功能很强大，可惜在国内应用不多。其eclipse插件功能强大，与java插件配合得很好。

**JavaFx: **[**http://javafx.com/**](http://javafx.com/)

是由sun公司推出的一种脚本语言，用于创建基于Rich Internet Application，与Adobe的[Flex](http://www.adobe.com/products/flex/)和微软的[Silverlight](http://www.silverlight.net/)属于同类产品。

代码示例：

````import javafx.stage.Stage; import javafx.scene.Scene; import javafx.scene.text.Text; import javafx.scene.text.Font; Stage { title: &quot;Hello World&quot; width: 250 height: 80 scene: Scene { content: Text { font : Font { size : 24 } x: 10, y: 30 content: &quot;Hello World&quot; } } } 

它将创建一个窗口，内容为&quot;Hello World&quot;

**现在风头正胜的scala: **[**http://scala-lang.org**](http://scala-lang.org/)

它是一种结合了面向对象及函数式的静态类型语言，提供了很多强大而灵活的特性，对于并发支持很好。

代码示例：

````object HelloWorld extends App { println(&quot;Hello, world!&quot;) }

复杂一些的，排序：

````def qsort: List[Int] =&amp;gt; List[Int] = { case Nil =&amp;gt; Nil case pivot :: tail =&amp;gt; val (smaller, rest) = tail.partition(_ &amp;lt; pivot) qsort(smaller) ::: pivot :: qsort(rest) }

**Rhino: **[**http://www.mozilla.org/rhino/**](http://www.mozilla.org/rhino/)

Javascript在jvm上的实现。

代码示例：

````import javax.script.ScriptEngine; import javax.script.ScriptEngineManager; import javax.script.ScriptException; public class RhinoEngine { public static void main(String[] args) { ScriptEngineManager mgr = new ScriptEngineManager(); ScriptEngine engine = mgr.getEngineByName(&quot;JavaScript&quot;); // Now we have a script engine instance that // can execute some JavaScript try { engine.put(&quot;name&quot;, args[0]); engine.eval(&quot;print(&apos;Hello &apos; + name + &apos;!&apos;)&quot;); } catch (ScriptException ex) { ex.printStackTrace(); } } }

**Kotlin: **[**http://confluence.jetbrains.net/display/Kotlin/Kotlin**](http://confluence.jetbrains.net/display/Kotlin/Kotlin)

一个正在开发中的新语言，由JetBrains公司（即开发Intellij-idea的公司）推出。据说开发它的原因是，觉得scala太复杂（以至于连开发出一个好用的ide插件都很困难），而groovy又是动态语言，所以结合它们的一些优点，创造一种不像scala那样复杂的静态语言（只支持面向对象风格，不支持函数式，这是与scala最大的区别）。

另外由于JetBrains公司本来就是一个开发IDE的公司，所以Kotlin的IDE插件将同语言一起开发，这一点非常重要，也非常有吸引力。

我觉得如果它顺利并且尽快推出，同时编辑器的支持很好的话，会吸引很多的Javaer.

**Mirah: **[**http://www.mirah.org/**](http://www.mirah.org/)

严重借鉴了ruby的语法，但是是一种静态语言，可以看作是“静态的ruby”。它的性能不错，生成的代码不需要额外的库（其它的语言，基本上都需要另外带一个jar）。

代码示例：

````def fib(a:fixnum):fixnum if a &amp;lt; 2 a else fib(a - 1) + fib(a - 2) end end

**Fantom: **[**http://fantom.org/**](http://fantom.org/)

Fantom名字译成中文有点杯具。它的主要特点是，同一个程序可同行运行于java/.net/javascript平台。它在java的基础上，增加了一些高级特性，如函数式、动静态类型、Mixins等。

代码示例：

````// Hello from Fantom! class HelloWorld { static Void main() { echo(&quot;Hello, World!&quot;) } }
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>配置nginx，让主域名访问网页，而某个子域名只能访问静态文件</title>
                <link>http://freewind.in/posts/344-setup-nginx-to-let-primary-domain-visit-pages-sub-domain-vists-static-files</link>
                <pubDate>Thu, 22 Sep 2011 11:21:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">344</guid>
                <description><![CDATA[&lt;p&gt;我的网站中（以zhidao.it）为例，有两种形式的域名：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;zhidao.it 主域名，可访问所有内容&lt;/li&gt;
&lt;li&gt;static_$version.zhidao.it 子域名，可访问/public下的静态文件，如js/css/image等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以会在2中使用单独的子域名来引用静态文件，主要是为了使客户端打开文件更快；而其中的$version是可变的，当我修改了css/js/image后，在配置文件中修改一下version，客户端便可以使用新的文件。&lt;/p&gt;
&lt;p&gt;我在前端使用了nginx，通过反向代理连接到真正的服务器。在配置文件中，我只做了最基本的设置，本来一切正常，但是突然发现百度索引网站时，没有使用zhidao.it的主域名，而是通过static_xxx.zhidao.it&lt;/p&gt;
&lt;p&gt;所以我得将nginx重新配置一下，让static_$version.zhidao.it只能访问/public下的静态文件，要访问其它内容，只能使用主域名zhidao.it。&lt;/p&gt;
&lt;p&gt;nginx的配置中的核心内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; # 设置后台服务地址
upstream zhidao.it {
     server 127.0.0.1:8080;
}

# 将www.zhidao.it转到zhidao.it
server {
    listen   80;
    server_name www.zhidao.it;
    rewrite ^/(.*) http://zhidao.it permanent;
}

# 处理static_$version.zhidao.it
server {
    listen 80;
    server_name ~^static_(.*)\.zhidao\.it$;
    root /webs/zhidao.it;

    # 检查请求的地址，是不是以/public开头，&quot;~*&quot;表示&quot;不分大小写的正则&quot;
    if ( $request_uri ~* ^/public/.* ) {
        set $ok &apos;1&apos;;
    }

    # 如果不是，永久重定向到zhidao.it
    if ($ok !~ &apos;1&apos;) {
        rewrite ^ http://zhidao.it$request_uri permanent;
    }

    # 否则自动去root下找对应的文件
}

# zhidao.it的处理
server {
    listen   80;
    server_name zhidao.it;

    access_log /webs/zhidao.it.logs/access.log;
    error_log /webs/zhidao.it.logs/error.log;
    root   /webs/zhidao.it/;

    location / {
          proxy_pass http://zhidao.it;
    }

}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在linux上安装nginx</title>
                <link>http://freewind.in/posts/336-install-nginx-on-linux</link>
                <pubDate>Thu, 22 Sep 2011 00:13:11 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">336</guid>
                <description><![CDATA[&lt;p&gt;nginx是一个高性能的web server，它还有一个非常好用的功能叫反向代理。考虑到这种情况：我在一台服务器上，要用tomcat跑java程序，还要运行php程序，80端口只有一个，怎么办给谁好呢？使用nginx就可以方便地解决这个问题：让nginx监听80，其它程序各自监听自己的端口，然后在nginx内部配置反向代理，指向它们即可。对于用户的访问，我们可以在nginx通过判断域名或者请求的内容，进行不同的转发，让各请求达到正确的目的地。&lt;/p&gt;
&lt;p&gt;下面是在linux安装nginx的步骤：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-336&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;下载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从官网上下载新版本，这里以0.8.45为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget [http://www.nginx.org/download/nginx-0.8.45.tar.gz](http://www.nginx.org/download/nginx-0.8.45.tar.gz)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nginx将安装到/usr/local/nginx下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立管理脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了方便管理nginx，我们将建立/etc/init.d/nginx，定义一些如start/stop/status/restart等任务，方便管理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/init.d/nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;#!/bin/sh 
# 
# nginx - &amp;lt;span class=&quot;kwrd&quot;&amp;gt;this&amp;lt;/span&amp;gt; script starts and stops the nginx daemin 
# 
# chkconfig:   - 85 15 
# description:  Nginx &amp;lt;span class=&quot;kwrd&quot;&amp;gt;is&amp;lt;/span&amp;gt; an HTTP(S) server, HTTP(S) reverse \ 
#               proxy and IMAP/POP3 proxy server 
# processname: nginx 
# config:      /usr/local/nginx/conf/nginx.conf 
# pidfile:     /usr/local/nginx/logs/nginx.pid 

# Source function library. 
. /etc/rc.d/init.d/functions 

# Source networking configuration. 
. /etc/sysconfig/network 

# Check that networking &amp;lt;span class=&quot;kwrd&quot;&amp;gt;is&amp;lt;/span&amp;gt; up. 
[ &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;$NETWORKING&quot;&amp;lt;/span&amp;gt; = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;no&quot;&amp;lt;/span&amp;gt; ] &amp;amp;&amp;amp; exit 0 

nginx=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;/usr/local/sbin/nginx&quot;&amp;lt;/span&amp;gt; 
prog=$(basename $nginx) 

NGINX_CONF_FILE=&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;/usr/local/nginx/conf/nginx.conf&quot;&amp;lt;/span&amp;gt; 

lockfile=/var/&amp;lt;span class=&quot;kwrd&quot;&amp;gt;lock&amp;lt;/span&amp;gt;/subsys/nginx 

start() { 
    [ -x $nginx ] || exit 5 
    [ -f $NGINX_CONF_FILE ] || exit 6 
    echo -n $&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Starting $prog: &quot;&amp;lt;/span&amp;gt; 
    daemon $nginx -c $NGINX_CONF_FILE 
    retval=$? 
    echo 
    [ $retval -eq 0 ] &amp;amp;&amp;amp; touch $lockfile 
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; $retval 
} 

stop() { 
    echo -n $&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Stopping $prog: &quot;&amp;lt;/span&amp;gt; 
    killproc $prog -QUIT 
    retval=$? 
    echo 
    [ $retval -eq 0 ] &amp;amp;&amp;amp; rm -f $lockfile 
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; $retval 
} 

restart() { 
    configtest || &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; $? 
    stop 
    start 
} 

reload() { 
    configtest || &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; $? 
    echo -n $&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Reloading $prog: &quot;&amp;lt;/span&amp;gt; 
    killproc $nginx -HUP 
    RETVAL=$? 
    echo 
} 

force_reload() { 
    restart 
} 

configtest() { 
  $nginx -t -c $NGINX_CONF_FILE 
} 

rh_status() { 
    status $prog 
} 

rh_status_q() { 
    rh_status &amp;gt;/dev/&amp;lt;span class=&quot;kwrd&quot;&amp;gt;null&amp;lt;/span&amp;gt; 2&amp;gt;&amp;amp;1 
} 

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;case&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;$1&quot;&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;in&amp;lt;/span&amp;gt; 
    start) 
        rh_status_q &amp;amp;&amp;amp; exit 0 
        $1 
        ;; 
    stop) 
        rh_status_q || exit 0 
        $1 
        ;; 
    restart|configtest) 
        $1 
        ;; 
    reload) 
        rh_status_q || exit 7 
        $1 
        ;; 
    force-reload) 
        force_reload 
        ;; 
    status) 
        rh_status 
        ;; 
    condrestart|&amp;lt;span class=&quot;kwrd&quot;&amp;gt;try&amp;lt;/span&amp;gt;-restart) 
        rh_status_q || exit 0 
            ;; 
    *) 
        echo $&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot;&amp;lt;/span&amp;gt; 
        exit 2
esac
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中这一句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nginx=&quot;/usr/local/sbin/nginx&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要根据你的安装的情况来选择nginx执行文件的路径。&lt;/p&gt;
&lt;p&gt;然后给它加上运行权限:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chmod +x /etc/init.d/nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这个脚本，我们可以方便的管理nginx，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/nginx start|stop|status|restart|reload|force_reload|configtest|rh_status|rh_status_q
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时我们先检查一下这个脚本和nginx的配置文件有没有问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/nginx configtest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果输出全部为successful，说明没有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设为开机启动&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/sbin/chkconfig nginx on
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/sbin/chkconfig --list nginx 
nginx   0:off   1:off   2:on    3:on    4:on    5:on    6:off
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下次重启时，nginx将自动运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改配置，每个配置文件定义一个虚拟主机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，nginx提供了一个/usr/local/nginx/conf/nginx.conf这个配置文件。如果我们把所有的配置都写在这个文件中，不易管理，所以打算为每一个虚拟主机弄一个单独的配置文件，然后在nginx.conf把它们包含进去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /usr/local/nginx/conf 
mkdir conf.d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个conf.d用来放置单独的虚拟主机配置。&lt;/p&gt;
&lt;p&gt;修改nginx.conf，在http节点中增加下面这行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include /usr/local/nginx/conf/conf.d/*.conf;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意最后的分号。&lt;/p&gt;
&lt;p&gt;同时把里面的server节点内容全部注释掉。&lt;/p&gt;
&lt;p&gt;在/conf.d/下新建default_server.conf，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server { 
    listen       80 default_server; 
    server_name  localhost; 

    location / { 
        root   html; 
        index  index.html index.htm; 
    } 

    error_page   500 502 503 504  /50x.html; 
    location = /50x.html { 
        root   html; 
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个配置用于当找不到与请求的url相对应的信息时。&lt;/p&gt;
&lt;p&gt;为abc.com建立/conf.d/abc.dom.conf，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream abc.com { 
    server 127.0.0.1:3000; 
    server 127.0.0.1:3001; 
    server 127.0.0.1:3002; 
    } 

server { 
    listen   80; 
    server_name www.abc.com; 
    rewrite ^/(.*) http:&amp;lt;span class=&quot;rem&quot;&amp;gt;//abc.com permanent; &amp;lt;/span&amp;gt;
       } 

server { 
    listen   80; 
    server_name abc.com; 

    access_log /home/www/abc.com/log/access.log; 
    error_log /home/www/abc.com/log/error.log; 

    root   /home/www/abc.com/site/; 
    index  index.html; 

    location / { 
          proxy_set_header  X-Real-IP  $remote_addr; 
          proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for; 
          proxy_set_header Host $http_host; 
          proxy_redirect off; 

          &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (-f $request_filename/index.html) { 
               rewrite (.*) $1/index.html &amp;lt;span class=&quot;kwrd&quot;&amp;gt;break&amp;lt;/span&amp;gt;; 
          } 

          &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (-f $request_filename.html) { 
               rewrite (.*) $1.html &amp;lt;span class=&quot;kwrd&quot;&amp;gt;break&amp;lt;/span&amp;gt;; 
          } 

          &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (!-f $request_filename) { 
               proxy_pass http:&amp;lt;span class=&quot;rem&quot;&amp;gt;//abc.com; &amp;lt;/span&amp;gt;
               &amp;lt;span class=&quot;kwrd&quot;&amp;gt;break&amp;lt;/span&amp;gt;; 
          } 
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置内容还是比较容易看懂的。从中可以看出，首先通过upstream定义了thin的几个服务端口（转发目标），下面是把对于abc.com和&lt;a href=&quot;http://www.abc.com&quot;&gt;www.abc.com&lt;/a&gt;的请求，转发给那几个端口。&lt;/p&gt;
&lt;p&gt;对于def.com，可以生成一个conf.d/def.com.conf，把上面的内容复制进去，修改目标端口和相关的域名及路径。&lt;/p&gt;
&lt;p&gt;然后使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/nginx configtest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看有没有错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;启动nginx&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/nginx start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后打开浏览器，访问http://www.abc.com和&lt;a href=&quot;http://www.def.com&quot;&gt;http://www.def.com&lt;/a&gt;，正常情况下应该能成功打开对应的网站。如果不行，请检查：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;域名是否指向了正确的ip
&lt;br  /&gt;&lt;li&gt;&lt;a href=&quot;http://ip:80&quot;&gt;http://ip:80&lt;/a&gt;能不能访问。如果打不开，说明nginx没有启动成功
&lt;br  /&gt;&lt;li&gt;&lt;a href=&quot;http://ip:3000&quot;&gt;http://ip:3000&lt;/a&gt;能不能访问。如果不能，说明thin没有启动成功
&lt;br  /&gt;&lt;li&gt;如果都能访问，说明nginx关于虚拟主机的配置有问题，仔细检查路径和名字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>关于mongodb的使用</title>
                <link>http://freewind.in/posts/332-guide-mongodb</link>
                <pubDate>Tue, 20 Sep 2011 15:06:34 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">332</guid>
                <description><![CDATA[&lt;p&gt;mongodb是NOSQL数据库中的一种，它是一种文档数据库，其特点是：每一个文档（相当于关系数据库中的一条记录）就像一个json，它的结构是可以完全自定义的；同一个集合（相当于关系数据库中的表）中的所有文档都可以互相不同。这一特点给了mongodb极大的自由，完全不像在关系数据库中那样，必须先规定好每一个表的所有字段。&lt;/p&gt;
&lt;p&gt;自由不一定就是力量，要看用在哪里。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-332&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;我在一个问答网中使用了mongodb，设计了如users, questions, answers, comments等表，在使用中并没有感觉到什么方便之处。相反，因为管理程序的不成熟，在后台维护数据时非常不方便，比如根据条件搜索一些数据，都很难做到。因为mongodb使用的json结构的查询语句，与SQL相比实在太难用了。另外，因为mongodb不要求每个文档的结构相同，也不进行检查，我有时候重构了代码后，发现mongodb的表中居然保存了几种不同结构的数据，还得一个个去检查，改成一样的。&lt;/p&gt;
&lt;p&gt;用过一段时间之后很后悔，如果不是暂停开发，我一定会把它换回postgres。&lt;/p&gt;
&lt;p&gt;后来看到不少朋友都想在项目中尝试使用mongodb。大家都是在尝鲜，并不清楚会带来什么好处。我劝他们不要用，因为得不偿失。&lt;/p&gt;
&lt;p&gt;那么，应该在什么时候使用mongodb呢？我一直在思考，却没有答案。&lt;/p&gt;
&lt;p&gt;直到前两天，跟群里一个朋友聊天，看了他写的一个OA系统，才恍然大悟：原来mongodb应该用于数据结构非常灵活多变的程序中。比如设计表单，每一个表单的结构都是不同的，还可能比较复杂（大表套小表）。如果使用关系数据库，非常麻烦，因为一个表单就需要设计好几个表，表与表之间还可能有复杂的关系。之后的增删改查和统计，都会是非常麻烦的事情。&lt;/p&gt;
&lt;p&gt;然而使用mongodb，一切都变得非常轻松自然。我们需要做的，仅仅是使用json定义一个表单结构，不管多复杂，一个json就搞定了。增删改查也非常简单。所以朋友的系统功能强大，但是代码量很少，表也很少。在实际开发中，效率比同类型的软件高出一个数量级。非常感谢朋友的无私分享，让我学到了。&lt;/p&gt;
&lt;p&gt;再引申出来一个问题：我们可以在关系数据库中的字段里存储json字符串，载入时再把它转换为对象，这样不是也能达到mongodb的效果。我们是不是可以在关系数据库中这样做？&lt;/p&gt;
&lt;p&gt;我的看法是，如果有这种需求，还是直接使用mongodb比较好。因为它不仅仅可以存储类似json的数据，还可以对其中的每一个节点进行查询、排序等，这一点是无法模拟出来的。另外，它在性能上也占有绝对优势。&lt;/p&gt;
&lt;p&gt;最终结论就是：如果你的程序要求数据表结构固定，不会轻易变动，请继续使用传统的关系数据库，不用考虑mongodb；如果相反，则考虑mongodb，会让开发更容易一些。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>整合playframework与activejdbc</title>
                <link>http://freewind.in/posts/243-integrate-playframework1-and-activejdbc</link>
                <pubDate>Thu, 15 Sep 2011 23:03:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">243</guid>
                <description><![CDATA[&lt;p&gt;Play是一个高效的java web开发框架，而activejdbc是一个看起来很不错的activerecord模式的持久层，但是它们两个不能放在一起用。因为Play启动后，直接读取java源代码，然后编译、增强，都是由Play自己的classloader载入的。而activejdbc要求先用maven或ant手动增加.class文件，然后再部署。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，需要写一个插件，接管activejdbc的增强工作。其原理是，在play将java源代码编译为字节码之后，我们可以在plugin中的enhance方法中，拿到这些字节码，并手动调用activejdbc中的相关函数，直接对其进行增强，然后再交还给play。这样就完美解决了两者各自为政的问题，原理还是非常简单的。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-243&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; ActiveJdbcPlugin extends PlayPlugin {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; ActiveJdbcEnhancer enhancer = &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; ActiveJdbcEnhancer();
@Override
&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; enhance(ApplicationClass applicationClass) throws Exception {
    enhancer.enhanceThisClass(applicationClass);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;p&gt;以上代码中的enhance方法是重点。ActiveJdbcEnhancer是专门进行增强的类，它的代码是从play-ebean插件和activejdbc本身提供的一个叫activejdbc-instrument的项目中抄来的，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; ActiveJdbcEnhancer extends Enhancer {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; enhanceThisClass(ApplicationClass applicationClass) throws Exception {
    CtClass ctClass = makeClass(applicationClass);

    CtClass modelClass = classPool.get(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;org.javalite.activejdbc.Model&quot;&amp;lt;/span&amp;gt;);

    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (!ctClass.subtypeOf(modelClass)) {
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt;;
    }

    addDelegates(modelClass, modelClass);
    CtMethod m = CtNewMethod.make(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;public static String getClassName() { return \&quot;&quot;&amp;lt;/span&amp;gt; + modelClass.getName()
            + &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;\&quot;; }&quot;&amp;lt;/span&amp;gt;, modelClass);
    CtMethod getClassNameMethod = modelClass.getDeclaredMethod(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;getClassName&quot;&amp;lt;/span&amp;gt;);
    modelClass.removeMethod(getClassNameMethod);
    modelClass.addMethod(m);

    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;new&amp;lt;/span&amp;gt; ModelInstrumentation().instrument(ctClass);
    applicationClass.enhancedByteCode = ctClass.toBytecode();
    ctClass.defrost();
    Logger.debug(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;ActiveJdbc: Class &apos;%s&apos; has been instrumented&quot;&amp;lt;/span&amp;gt;, ctClass.getName());
}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; addDelegates(CtClass modelClass, CtClass target) throws NotFoundException, CannotCompileException {
    CtMethod[] modelMethods = modelClass.getDeclaredMethods();
    CtMethod[] targetMethods = target.getDeclaredMethods();
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;for&amp;lt;/span&amp;gt; (CtMethod method : modelMethods) {

        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (Modifier.PRIVATE == method.getModifiers()) {
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;continue&amp;lt;/span&amp;gt;;
        }

        CtMethod newMethod = CtNewMethod.delegator(method, target);

        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (!targetHasMethod(targetMethods, newMethod)) {
            target.addMethod(newMethod);
        } &amp;lt;span class=&quot;kwrd&quot;&amp;gt;else&amp;lt;/span&amp;gt; {
            System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;Detected method: &quot;&amp;lt;/span&amp;gt; + newMethod.getName() + &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;, skipping delegate.&quot;&amp;lt;/span&amp;gt;);
        }
    }

}

&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; boolean targetHasMethod(CtMethod[] targetMethods, CtMethod &amp;lt;span class=&quot;kwrd&quot;&amp;gt;delegate&amp;lt;/span&amp;gt;) {
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;for&amp;lt;/span&amp;gt; (CtMethod targetMethod : targetMethods) {
        &amp;lt;span class=&quot;kwrd&quot;&amp;gt;if&amp;lt;/span&amp;gt; (targetMethod.equals(&amp;lt;span class=&quot;kwrd&quot;&amp;gt;delegate&amp;lt;/span&amp;gt;)) {
            &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;true&amp;lt;/span&amp;gt;;
        }
    }
    &amp;lt;span class=&quot;kwrd&quot;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;false&amp;lt;/span&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;有这两个，再加其它一些读取play配置文件建立连接、关闭连接的方法，这个插件就算基本完成了。

但是这样还是不行，程序运行起来后，activejdbc会报错，说找不到model类。原来我们需要在classpath里，加上一个activejdbc_models.properties的文件，里面写上所有model类的全名（每行一个），如下：

&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;models.User
models.Article```

这一点在activejdbc的官方网站上没有提到，其原因是按照标准方式，使用maven或ant进行增强时，会自动生成该文件。但我们就必须手动加上。

再启动，还是报错，activejdbc还是找不到model类。经常检查，发现activejdbc的源代码中，有多处代码如下：

&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;Class cls = Class.forName(modelCls);```

这样的话，activejdbc会使用载入自己的classloader（即AppClassLoader）来读取model类，而此时只有playClassLoader才知道从哪儿读，所以读不到。为了解决这个问题，我把多处类似代码改为：

&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;Class cls = Thread.currentThread().getContextClassLoader().loadClass(modelCls);```

因为Play在启动后，会把contextClassLoader设为自己的classloader，所以activejdbc可以正确地读取到。

再次启动，运行正常，可以成功地使用activejdbc从数据库中读取数据，写入也没有问题。但很快又发现了一个问题：当我们修改了一个model类的代码，刷新页面后，play重新编译增强，然后报错：

&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;Can&apos;t cast models.User to models.User```

这说明activejdbc与play使用了不同的classloader（可能是一个新的一个旧的），载入了同一个类。因为Play在重新编译时，会生成新的classloader，所以猜测activejdbc可能缓存了旧的class。

检查代码，发现果然在Registry中，有一个initedDbs的set，读取一次model classes后，就缓存起来。所以我又修改了代码，增加了一个清空函数，在plugin的onApplicationStart里（该函数将在play重新编译后调用）对它清空。

目前已经基本可以运行，但还是会报一些异常。等我用这个插件做个项目，把相关的问题都解决之后，将会把相关代码发布在github上。
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>复习ClassLoader</title>
                <link>http://freewind.in/posts/238-go-over-classloader</link>
                <pubDate>Thu, 15 Sep 2011 15:38:53 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">238</guid>
                <description><![CDATA[&lt;p&gt;这两天在尝试把activejdbc集成到play中。因为两者都需要对类进行增强，有冲突，所以不能直接使用。经过一晚上的反复尝试，终于能让activejdbc在play上跑起来了。但是，很快发现，一旦model类被修改，play重新载入后会报错。&lt;/p&gt;
&lt;p&gt;源代码为：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;font color=&quot;#ff0000&quot;&gt;&lt;strong&gt;&lt;span class=&quot;kwrd&quot;&gt;for&lt;/span&gt; (User user : users) {
&lt;br  /&gt;&lt;/strong&gt;&lt;/font&gt;     System.err.println(&lt;span class=&quot;str&quot;&gt;&amp;ldquo;&amp;raquo;&gt; &amp;ldquo;&lt;/span&gt; + user);
&lt;br  /&gt;}```&lt;/p&gt;
&lt;p&gt;红色那行报错为：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;ClassCastException&lt;/strong&gt; occured : models.User cannot be cast to models.User&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个&quot;models.User&quot;不能转换为另一个&quot;models.User&amp;rdquo;，只能说明一种情况：这个类被两个不同classloader导入了。&lt;/p&gt;
&lt;p&gt;为了完全解决这个问题，我需要好好复习一下Java的classloader机制以及play的classloader运作原理。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-238&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;几篇不错的资料&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/turkeyzhou/article/details/2776752&quot;&gt;http://blog.csdn.net/turkeyzhou/article/details/2776752&lt;/a&gt;
&lt;br  /&gt;&lt;li&gt;&lt;a href=&quot;http://wolfware.bokee.com/3412061.html&quot;&gt;http://wolfware.bokee.com/3412061.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看完这两个，再随便找点别的看看，差不多就能明白个大概了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Jvm已经提供了三个级别的ClassLoader，分别是boot -&gt; ext -&gt; app
&lt;br  /&gt;&lt;li&gt;双亲委托：即在找一个类之前，先交给上级，上级搞不定，再自己动手
&lt;br  /&gt;&lt;li&gt;全盘负责：如果自己动手，导入一个类时，它所引用的其它类也由自己导入（导入过程中，遵守双亲委托规则）
&lt;br  /&gt;&lt;li&gt;共享ClassLoader：通过Thread.currentThread().set/getContextClassLoader()
&lt;br  /&gt;&lt;li&gt;两个classloader导入同一个类，不能互相转换。JVM把它们当作不同的类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;JVM默认提供的ClassLoader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Test {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;public&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;kwrd&quot;&amp;gt;void&amp;lt;/span&amp;gt; main(String[] args) {
    &amp;lt;span class=&quot;rem&quot;&amp;gt;// AppClassLoader&amp;lt;/span&amp;gt;
    ClassLoader app = Test.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;class&amp;lt;/span&amp;gt;.getClassLoader();
    System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(app);

    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(systemClassLoader);

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Ext&amp;lt;/span&amp;gt;
    ClassLoader ext = systemClassLoader.getParent();
    System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(ext);

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Boot&amp;lt;/span&amp;gt;
    ClassLoader boot = ext.getParent();
    System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(boot);

    &amp;lt;span class=&quot;rem&quot;&amp;gt;// Context&amp;lt;/span&amp;gt;
    ClassLoader context = Thread.currentThread().getContextClassLoader();
    System.&amp;lt;span class=&quot;kwrd&quot;&amp;gt;out&amp;lt;/span&amp;gt;.println(context);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```&lt;/p&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;a href=&quot;mailto:sun.misc.Launcher$AppClassLoader@addbf1sun.misc.Launcher$AppClassLoader@addbf1sun.misc.Launcher$ExtClassLoader@42e816nullsun.misc.Launcher$AppClassLoader@addbf1&quot;&gt;sun.misc.Launcher$AppClassLoader@addbf1 &lt;br  /&gt;sun.misc.Launcher$AppClassLoader@addbf1 &lt;br  /&gt;sun.misc.Launcher$ExtClassLoader@42e816 &lt;br  /&gt;&lt;span class=&quot;kwrd&quot;&gt;null&lt;/span&gt; &lt;br  /&gt;sun.misc.Launcher$AppClassLoader@addbf1&lt;/a&gt;```&lt;/p&gt;
&lt;p&gt;从中可以看到，我们通常都是在跟AppClassLoader打交道。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>github基本使用教程</title>
                <link>http://freewind.in/posts/236-guide-to-github</link>
                <pubDate>Wed, 14 Sep 2011 19:23:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">236</guid>
                <description><![CDATA[&lt;p&gt;play中文化项目确定后，文档都放在github上（地址：&lt;a href=&quot;https://github.com/hotplay/playframework-document-cn&quot;&gt;https://github.com/hotplay/playframework-document-cn&lt;/a&gt;），参与者可通过git进行合作。&lt;/p&gt;
&lt;p&gt;但很快有群友问怎么用。考虑到git与github在国内使用得还不够广泛，我打算写个博客，讲解一下基本用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先需要下载git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方主页：&lt;a href=&quot;http://www.git-scm.com/&quot;&gt;http://www.git-scm.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当前最新版本v1.7.6.1下载地址：&lt;a href=&quot;http://code.google.com/p/msysgit/downloads/detail?name=Git-1.7.6-preview20110708.exe&amp;amp;can=3&amp;amp;q=&quot;&gt;http://code.google.com/p/msysgit/downloads/detail?name=Git-1.7.6-preview20110708.exe&amp;amp;can=3&amp;amp;q=&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-236&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;**安装git**

安装比较简单，一路next即可，其中有两个地方需要注意一下。

[![image](/user_images/236-1.png &quot;image&quot;)](/user_images/236-1.png) 

Git Bash是指git安装好之后，有一个专用的命令行工具（开始-&gt;Git-&gt;Git Bash），像cmd一样，截图如下：

[![image](/user_images/236-3.png &quot;image&quot;)](/user_images/236-3.png) 

它可以执行一些linux上的命令，方便操作。但在windows上，不能复制粘贴，不太好用。所以我们一般会选择第2项或第3项，在windows的cmd上直接运行git命令。

另一个窗口是：

[![image](/user_images/236-5.png &quot;image&quot;)](/user_images/236-5.png) 

让我们选择如何处理文本文件中的选行符。git考虑到合作者可能在不同的操作系统下，如windows下使用\r\n，linux下使用\n，mac下使用\r。为了既能保证服务器上的代码使用相同的换行符，在各自的电脑上又能使用各自的换行符，所以有三种处理方式：

1.  下载时把换行符变成\r\n，提交时变成\n
2.  下载时不转换，提交时变成\n
3.  下载和提交时都不处理

作为windows用户，我们应该选择第一项。

**关于git gui**

安装好git后，还有一个git gui，如下图：

[![image](/user_images/236-7.png &quot;image&quot;)](/user_images/236-7.png) 

个人觉得这个东西实在太难用，不如不用。我们可以使用命令行，也可以在eclipse下使用egit。其它如idea下也有对应的工具。

&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时我们已经可以下载github上的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于我们只想下载不打算提交的项目，现在已经可以下载了。以&lt;a href=&quot;https://github.com/hotplay/playframework-document-cn&quot;&gt;playframework-document-cn&lt;/a&gt;为例：&lt;/p&gt;
&lt;p&gt;打开&lt;a href=&quot;https://github.com/hotplay/playframework-document-cn&quot;&gt;https://github.com/hotplay/playframework-document-cn&lt;/a&gt;，点击下图中的Git Readonly按钮：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-9.png&quot;&gt;&lt;img src=&quot;/user_images/236-9.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;把右边显示的git://github.com/xxx这一串地址拷贝下来，然后打开命令行，输入命令：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;git clone git://github.com/hotplay/playframework-document-cn.git```&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-11.png&quot;&gt;&lt;img src=&quot;/user_images/236-11.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;git会自动把代码下载下来，放在当前目录下的playframework-document-cn目录下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-13.png&quot;&gt;&lt;img src=&quot;/user_images/236-13.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意这是readonly的，只能看，不能提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尝试以SSH方式下载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们想提交，除了我们的帐号已经加入到该项目的提交者白名单中，最最基本的条件是，我们要生成公私钥，并把公钥填到github上。现在尝试SSH方式，会提示错误：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-15.png&quot;&gt;&lt;img src=&quot;/user_images/236-15.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提示说我们没有权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成公私钥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公私钥的认证方式在很多地方都可以使用，具有较好的安全性。我们可以使用一些工具生成，小心保管好生成的公钥和私钥，它可以重复使用。公钥的信息可以公开（它实际上就是一段字符串），而私钥一定不可以让其它人知道。&lt;/p&gt;
&lt;p&gt;关于生成方式，在github上有专门的帮助内容，请参看：&lt;a href=&quot;http://help.github.com/ssh-issues/&quot;&gt;http://help.github.com/ssh-issues/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为此处比较难讲，所以省略，请自行google或baidu&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把生成的公私钥放在用户目录下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-17.png&quot;&gt;&lt;img src=&quot;/user_images/236-17.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的用户目录是C:\Documents and Settings\nowind，放在.ssh目录下（如果没有，新建）。其中前两个文件是我们生成的，known_hosts是后来自己生成的，不需管。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将公钥上传到github上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-19.png&quot;&gt;&lt;img src=&quot;/user_images/236-19.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次下载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;git clone git@github.com:hotplay/playframework-document-cn.git```&lt;/p&gt;
&lt;/p&gt;
&lt;/p&gt;
&lt;/p&gt;
&lt;/p&gt;
&lt;p&gt;期间会提示你输入你生成密钥时的密码，如果正确，将如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/236-21.png&quot;&gt;&lt;img src=&quot;/user_images/236-21.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载egit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用eclipse，可下载egit插件。地址：&lt;a href=&quot;http://eclipse.org/egit/download/&quot;&gt;http://eclipse.org/egit/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于egit的使用太琐碎，请自行研究。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>读“悟透JavaScript”</title>
                <link>http://freewind.in/posts/210-notes-of-book-understand-javascript-completely</link>
                <pubDate>Wed, 14 Sep 2011 01:34:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">210</guid>
                <description><![CDATA[&lt;p&gt;学习JavaScript已经成为我无法逃避的问题。我发现，一个网站的开发时间，前端比后端用的还多，主要是因为组件不易复用、跨浏览器问题。解决这一问题的方法是，可以采用一些JavaScript UI库，如Jquery-UI, YUI, Ext-js, Qooxdoo, SmartClient, Ukijs等等。其中Ukijs我尤其推荐。&lt;/p&gt;
&lt;p&gt;我以前看过国人李战写的一些文章，叫“悟透JavaScript”，不长，但是写得非常好，后来出版了。当时觉得不错，现在有些地方模糊了，又把它找出来重读。这本书是我最为推荐的一本JavaScript书籍，任何一个想学JavaScript的人，都应该先认真地把这本书看一遍，然后再看别的。&lt;/p&gt;
&lt;p&gt;现在记得的几个要点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;放下“类型”。JavaScript是动态语言，所以变量没有类型。这可以做出很多静态语言难以做到的事情，比如动态改变类，增删属性或方法，把数据当作代码执行等。&lt;/li&gt;
&lt;li&gt;放下“自我”。function中的this，跟Java中的this不一样，并不总是指向自己。我们可以通过fun.call(other)，将other传进去，变成fun中的this。这样看来，javascript中的函数与groovy中的闭包相当相似。&lt;/li&gt;
&lt;li&gt;prototype继承。与面向对象语言中的继承不同，JavaScript用的是prototype。每一个类都有一个特殊的属性叫prototype，该类所有的对象共用它。当调用一个方法而本身没有时，则去prototype去找。利用它，我们可以设计出父类和子类的继承关系，即让子类的prototype属性指向父类。&lt;/li&gt;
&lt;li&gt;甘露模型。以实例说明，如何利用一个公用函数，优雅的模拟出面向对象语言中的继承语法，需要好好体会。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看完这本书，我有种“听君一席话，胜读十年书”的感觉。只花短短几个小时，便学到了自学数月也难以理解到的JavaScript原理，真不愧“悟透”两字。像李战这样的作者，才算得上是深入浅出的高手。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala中==是比较内容，但为什么Array(1,2)==Array(1,2)为false</title>
                <link>http://freewind.in/posts/201-why-array-1-2-array-1-2-is-false</link>
                <pubDate>Tue, 13 Sep 2011 22:41:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">201</guid>
                <description><![CDATA[&lt;p&gt;在scala中，==就相当于java中的equals，基于内容比较。
&lt;br  /&gt;&lt;p&gt;比如:
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;List(1,2,3) == List(1,2,3) // true&lt;code&gt;`
&amp;lt;br /&amp;gt;&amp;lt;p&amp;gt;但是有一个例外：
&amp;lt;br /&amp;gt;&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;Array(1,2,3) == Array(1,2,3) // false&lt;/code&gt;`
&lt;br  /&gt;&lt;p&gt;为什么Array与众不同？是因为java语言的限制，性能上的担心，还是故意设计的呢？&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-201&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;在scala官网上有这个讨论：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.scala-lang.org/node/3487&quot;&gt;http://www.scala-lang.org/node/3487&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是对于英文不怎么样，同时对scala不怎么了解我们，还是看不太懂。（其中odersky是scala作者）&lt;/p&gt;
&lt;p&gt;大概意思是担心性能被拖后腿，ordersky的这段回话是重点：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Even Java seems to admit they got equals/hashCode wrong for Arrays. Would it be possible to use java.util.Arrays.equals and ju.Arrays.hashCode (note plural Arrays) instead of the inherited equals/hashCode from Object?&lt;/p&gt;
&lt;p&gt;No, unfortunately, because arrays might masquerade as objects. So we could only do it with a run-time check, which would slow down all calls to equals and hashCode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可惜的是，还是不太明白&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>怎样实现 ‘aaa := &quot;AAA&quot;，即为符号增加函数并隐式转换</title>
                <link>http://freewind.in/posts/200-how-to-implement-aaa-AAA-to-add-implicit-conversions-for-symbols</link>
                <pubDate>Tue, 13 Sep 2011 22:40:03 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">200</guid>
                <description><![CDATA[&lt;p&gt;我们在写web应用时，经常会在controller中写如此的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;context(&quot;aaa&quot;)=&quot;AAA&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;p&gt;这个aaa就是将传给view层的变量。&lt;/p&gt;
&lt;p&gt;能否用一种更简化的写法达到同样的效率？可以利用scala中的符号（Symbol），写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&apos;aaa := &amp;amp;#8220;AAA&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隐式转换&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 创建一个symbol的wrapper类，将对符号的操作，转换到它身上。&lt;/p&gt;
&lt;p&gt;2.在wrapper类中，定义:=方法&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;implicit def symbolWrapper(s: Symbol) = new SymbolHelper(s)

var map = Map()

class SymbolHelper(s: Symbol) {
    def :=(value:String) {
        map += (s.name -&amp;gt; value)
    }
}

object testSymbol {
    def main(args : Array[String]) : Unit = {
        &apos;a := &quot;AAA&quot;
        &apos;b := &quot;BBB&quot;
        println(map)
    }
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>actor的个数限制</title>
                <link>http://freewind.in/posts/199-limit-of-actor-count</link>
                <pubDate>Tue, 13 Sep 2011 22:39:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">199</guid>
                <description><![CDATA[&lt;p&gt;axgle给了一段代码，发现一个奇怪的问题：
&lt;br  /&gt;&lt;p&gt;1. 首先准备了一个本地的web程序，提供了一个url，返回简单的自增数字。该url在处理期间需要等待10秒，也就是说，每次读取该url，需要花10秒
&lt;br  /&gt;&lt;p&gt;2. scala中，使用1000个actor去读取它。因为actor是在新线程中运行，所以在理想情况下，总共花的时间大约是10多一点点才对。
&lt;br  /&gt;&lt;p&gt;3.但是在实际过程中，发现时间远大于10秒。这是怎么回事。
&lt;br  /&gt;&lt;p&gt;经过讨论与排查，发现scala中，并不是actor有多少个，就新开多少个线程。而是把actor只代理给有限的线程，剩下的就等待，直到有了新的可用线程。而这个有限，根据测试，发现是250多个（非确定）。
&lt;br  /&gt;&lt;p&gt;所以我们在使用actor中要注意，不要有太耗时或会阻塞的代码，比如IO,sleep等。要记住线程有限，不要空占着。
&lt;br  /&gt;&lt;p&gt;这一个文档中，有比较详细的提到：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://wenku.baidu.com/view/845626fc700abb68a982fb50.html&quot;&gt;http://wenku.baidu.com/view/845626fc700abb68a982fb50.html&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>&quot;val s:BigInt = 3333333333333333 为什么编译出错&quot;</title>
                <link>http://freewind.in/posts/198-why-s-bigint-3333333333333333-cannot-be-compiled</link>
                <pubDate>Tue, 13 Sep 2011 22:37:48 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">198</guid>
                <description><![CDATA[&lt;p&gt;&lt;p&gt;val s:BigInt = 3333333333333333 为什么编译出错，不是说scala中，会自动把超长的整数变为BigInt吗？
&lt;br  /&gt;&lt;p&gt;在stackoverflow上有人提了这个问题，也有回答：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1689414/java-scala-biginteger-pasting&quot;&gt;http://stackoverflow.com/questions/1689414/java-scala-biginteger-pasting&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;简单点说，就是如果在编码中手动写一个超长的int，还是要用java中的方式：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;val s:BigInt = BigInt(&lt;span class=&quot;str&quot;&gt;&amp;ldquo;3333333333333333333333333&amp;rdquo;&lt;/span&gt;)```&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>形如abc_=的函数，有什么用？</title>
                <link>http://freewind.in/posts/197-scala-abc_-functions</link>
                <pubDate>Tue, 13 Sep 2011 22:37:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">197</guid>
                <description><![CDATA[&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; A {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;private&amp;lt;/span&amp;gt; var _a = &amp;lt;span class=&quot;str&quot;&amp;gt;&quot;&quot;&amp;lt;/span&amp;gt;
def a = _a
def a_=(newValue:String) { _a = newValue }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;p&gt;其中的a&lt;em&gt;=函数，是方便我们赋值，见下例：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;val a = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; A
&lt;br  /&gt;a.a &lt;span class=&quot;rem&quot;&gt;// -&gt; &amp;ldquo;&amp;ldquo;&lt;/span&gt;
&lt;br  /&gt;a.a = &lt;span class=&quot;str&quot;&gt;&amp;ldquo;x&amp;rdquo;&lt;/span&gt; &lt;span class=&quot;rem&quot;&gt;// invoke a&lt;/em&gt;=&lt;/span&gt;
&lt;br  /&gt;a.a &lt;span class=&quot;rem&quot;&gt;// -&gt; &amp;ldquo;x&amp;rdquo;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;如果不是需要在赋值或取值的时候需要做一些转换的操作，一般没有必要这样做。事实上，scala已经把所有的属性隐藏起来了。

例如：
&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;class&amp;lt;/span&amp;gt; A{
    var id: Int = _
}```
&amp;lt;p&amp;gt;看上去我们定义了一个公开的属性id,实际上属性id是被隐藏起来的（private可见），这里只是定义了两个方法
&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;def id : Int
def id_=(v: Int)```
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>class中定义的apply有什么用？</title>
                <link>http://freewind.in/posts/196-scala-apply-in-classes</link>
                <pubDate>Tue, 13 Sep 2011 22:35:30 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">196</guid>
                <description><![CDATA[&lt;p&gt;我们知道，在object中定义apply方法后，我们可以把()操作，转化为apply函数，如：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&lt;span class=&quot;kwrd&quot;&gt;object&lt;/span&gt; test {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def apply(s:String) = s*2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;则test(&amp;amp;#8220;a&quot;)实际上是test.apply(&amp;amp;#8220;a&quot;)

那么，下面这段代码呢？
&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;&amp;lt;span class=&quot;kwrd&quot;&amp;gt;class&amp;lt;/span&amp;gt; A {
    def apply(s:String) = s*2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;p&gt;虽然我们不能直接A(&amp;#8220;a&amp;rdquo;)，但是我们可以：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;val a = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; A
&lt;br  /&gt;a(&lt;span class=&quot;str&quot;&gt;&amp;ldquo;a&amp;rdquo;&lt;/span&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;.csharpcode, .csharpcode pre
{
    font-size: small;
    color: black;
    font-family: consolas, &quot;Courier New&quot;, courier, monospace;
    background-color: #ffffff;
    /*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
    background-color: #f4f4f4;
    width: 100%;
    margin: 0em;
}
.csharpcode .lnum { color: #606060; }
&amp;lt;/style&amp;gt;
&amp;lt;p&amp;gt;即，将实例的()操作，转化为apply。
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>关于flatMap的用法</title>
                <link>http://freewind.in/posts/195-scala-flatmap</link>
                <pubDate>Tue, 13 Sep 2011 22:34:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">195</guid>
                <description><![CDATA[&lt;p&gt;我将从下面这段简单的代码，引申出不少问题：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;val list = List(1,2,3)
&lt;br  /&gt;val result = list map ( _+1 )
&lt;br  /&gt;println(result)
&lt;br  /&gt;// -&gt; List(2,3,4)&lt;code&gt;`
&amp;lt;br /&amp;gt;&amp;lt;p&amp;gt;1. 如果把map改为flatMap，则：
&amp;lt;br /&amp;gt;&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;list flatMap ( _+1 )&lt;/code&gt;`
&lt;br  /&gt;&lt;p&gt;编译出错，为什么？&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-195&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;原因是flatMap的定义如下：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;flatMap [B](f : (A) =&gt; Iterable[B]) : List[B]```
&lt;br  /&gt;&lt;p&gt;可见，flatMap的参数必须是一个返回Iterable的函数。&lt;/p&gt;
&lt;p&gt;所以，如果把代码改成 list flatMap ( List(_) )，即可得到正确答案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么list flatMap ( List(_+1) ) 编译出错呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;出错信息为：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;console&gt;:7: error: missing parameter type for expanded function ((x$1) =&gt; x$1.$plus(1))&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; list flatMap ( List(_+1) )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说是不知道参数类型。&lt;/p&gt;
&lt;p&gt;为什么List(&lt;em&gt;)可以而List(&lt;/em&gt;+1)不可以，是因为List(&lt;em&gt;)不需要知道参数类型，而List(&lt;/em&gt;+1)，调用了+函数，所以需要知道类型，而我们没有提供。所以应该改成：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;list flatMap ( it =&gt; List(it + 1) )```
&lt;br  /&gt;&lt;p&gt;这样，scala就能推断出it的类型了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;既然在2中，scala无法推荐_的类型，那我们手动设定类型，如下：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;list flatMap ( List( (&lt;em&gt;:Int) + 1 ))&lt;code&gt;`
&amp;lt;br /&amp;gt;&amp;lt;p&amp;gt;应该可以了吧。可惜编译还是出错：
&amp;lt;br /&amp;gt;&amp;lt;pre class=&quot;csharpcode&quot;&amp;gt;scala&amp;gt; list flatMap ( List( (_:Int) +1 ))
&amp;lt;br /&amp;gt;&amp;lt;console&amp;gt;:7: error: type mismatch;
&amp;lt;br /&amp;gt;found   : List[(Int) =&amp;gt; Int]
&amp;lt;br /&amp;gt;required: (Int) =&amp;gt; Traversable[?]
&amp;lt;br /&amp;gt;list flatMap ( List( (_:Int) +1 ))&lt;/code&gt;`
&lt;br  /&gt;&lt;p&gt;难道 List( (&lt;/em&gt;:Int) + 1 ) 不是一个返回List[Int]的函数吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;scala&gt; def g = List ( (_:Int) + 1)
&lt;br  /&gt;g: List[(Int) =&gt; Int]```
&lt;br  /&gt;&lt;p&gt;原来它是List[(Int)=&gt;Int]，为什么不是(Int)=&gt;List[Int]呢？&lt;/p&gt;
&lt;p&gt;对最后一个问题，还是想得不太明白。比如说以下这几个例子：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;def f = 1 + (&lt;em&gt;:Int)
&lt;br  /&gt;def f = (&lt;/em&gt;:Int) + 1
&lt;br  /&gt;def f = 1 to (&lt;em&gt;:Int) +1
&lt;br  /&gt;def f = 1 to 1 + (&lt;/em&gt;:Int) + 2```
&lt;br  /&gt;&lt;p&gt;下面这个就不行：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;def f = 1 to ( 1 + (_:Int) )```&lt;/p&gt;
&lt;p&gt;而def f = List((_:Int)+1)实际上得到的是一个List，里面有一个函数元素。&lt;/p&gt;
&lt;p&gt;总之我最后的感觉就是，只在很简单的情况下，使用_，否则还是乖乖的写全，比如:&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;def f = { x:Int =&gt; List(x+1)}```&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>关键字type</title>
                <link>http://freewind.in/posts/193-scala-keyword-type</link>
                <pubDate>Tue, 13 Sep 2011 22:30:56 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">193</guid>
                <description><![CDATA[&lt;p&gt;在看scalatra源代码时，看到它在一段代码中，使用了type关键字，如下：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;type Attributes = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def getAttribute(name: String): AnyRef
def getAttributeNames(): java.util.Enumeration[_]
def setAttribute(name: String, &amp;lt;span class=&quot;kwrd&quot;&amp;gt;value&amp;lt;/span&amp;gt;: AnyRef): Unit
def removeAttribute(name: String): Unit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}```
&lt;br  /&gt;&lt;p&gt;这个type是干什么用的呢？&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-193&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;@爱国者给了一段代码，解答了这个问题，如下：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;type A = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func : Int
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;val a: A = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt;{
&lt;br  /&gt;def func = 2;
&lt;br  /&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; B{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def func = 20
def print = println(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;hello world&quot;&amp;lt;/span&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;val b = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; B
&lt;br  /&gt;var bb: A = b&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;看起来，type定义的，就像是一个接口。然后神奇的地方在于，class B，与type A看起来并没有任何关系，但是它却能赋给A！仅仅是因为A定义的函数，B也有

这和动态语言中的duck type非常相似，即只要你的函数签名与我期望的一样，我就可以把你当作另一个类型来使用。不同的是，scala还让它拥有了静态编译的优点。

真没想到，原以为动态语言中才能有的特性，在scala中也可以实现。
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>一个函数的优化（从命令式到函数式）</title>
                <link>http://freewind.in/posts/192-rewrite-a-function-from-imperative-to-functional</link>
                <pubDate>Tue, 13 Sep 2011 22:30:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">192</guid>
                <description><![CDATA[&lt;p&gt;我想写一个函数，功能很简单，如下：把一个字符串里的b改为*，把结尾的c改为#。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;object Main {
    def fix(text: String) = {
        val s = text.replace(&quot;b&quot;, &quot;*&quot;)
        if (s.endsWith(&quot;c&quot;)) {
            s.stripSuffix(&quot;c&quot;) + (&quot;#&quot;)
        } else s
    }
    def main(args: Array[String]) {
        println(fix(&quot;abbbbccc&quot;)) // -&amp;gt; a***cc#
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，还是在用java的方式来写，总觉得不够scala。应该怎么优化呢？&lt;/p&gt;
&lt;p&gt;首先，要转变思想，多使用正则表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;def fix(s: String) = s.replace(&apos;b&apos;, &apos;*&apos;).replaceAll(&quot;c$&quot;, &quot;#&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一行就搞定。&lt;/p&gt;
&lt;p&gt;如果我们不想定义那个变量&lt;code&gt;s&lt;/code&gt;，希望使用链式风格，可以使用Some，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;def fix(s: String) = Some(s.replace(&apos;b&apos;, &apos;*&apos;)).map(s =&amp;gt; if(s.endsWith(&quot;c&quot;)) s.init + &quot;#&quot; else s).get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是一行。&lt;/p&gt;
&lt;p&gt;最后，我们还有一个match可用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;text.replace(&quot;b&quot;, &quot;*&quot;) match {
   case t if t.endsWith(&quot;c&quot;) =&amp;gt; t.stripSuffix(&quot;c&quot;) + &quot;#&quot;
   case t =&amp;gt; t
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数式的风格写起来就是很爽，如行云流水一般。从java到scala，不仅仅是语法变了，更重要的是编程的风格，这个转变可不容易。&lt;/p&gt;
&lt;p&gt;我在stackoverflow上问了这个问题，请参见完整版：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5140465/how-to-optimize-this-simple-function-in-scala&quot;&gt;http://stackoverflow.com/questions/5140465/how-to-optimize-this-simple-function-in-scala&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;htrmt&lt;/h3&gt;
&lt;p&gt;这个功能用C写很简单，而且近乎是最优化的代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;char *Fun(char *str)
{
  for(;*str;++str)
    if(‘b’ == *str)
      *str = ‘*’;
  if(‘c’ == *(str-1))
    *(str-1) = ‘#’;
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>系统重装后，连不上github了，怎么办？</title>
                <link>http://freewind.in/posts/191-cannot-connect-to-github-after-reinstalling-windows</link>
                <pubDate>Tue, 13 Sep 2011 22:29:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">191</guid>
                <description><![CDATA[&lt;p&gt;昨天重装了windows，今天连接github.com时，提示连接不上。我记得已经备份过了密钥，怎么用不了了呢？&lt;/p&gt;
&lt;p&gt;后来发现，原来我把文件拷错了地方，应该拷到&lt;code&gt;C:\Documents and Settings\current_user\.ssh&lt;/code&gt;下，有三个文件，分别是&quot;id_rsa&amp;rdquo;，&amp;ldquo;id_rsa.pub&amp;rdquo;，&amp;ldquo;known_hosts&amp;rdquo;&lt;/p&gt;
&lt;p&gt;重新拷完，再试，一切正常。&lt;/p&gt;
&lt;p&gt;如果以后出现这样的问题，可以在git bash下，使用命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh -v git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可打印出详细信息，比如在哪个位置去寻找那些密钥，有利于找出问题原因&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在scala中，如何创建annotation</title>
                <link>http://freewind.in/posts/189-how-to-create-annotation-in-scala</link>
                <pubDate>Tue, 13 Sep 2011 22:27:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">189</guid>
                <description><![CDATA[&lt;p&gt;在开发scalaeye的过程中，我想定义一些annotation，让用户以注解方式自定义route。所以，要先创建annotation。&lt;/p&gt;
&lt;p&gt;发现scala.annotation包下，有一些已经定义好的annotation，看源代码，形如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class MyAnno extends StaticAnnotation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是我也这样定义了一些annotation，并且加到代码中，编译也能通过。&lt;/p&gt;
&lt;p&gt;但是，通过class.getAnnotations或method.getAnnotations时，发现找不到这些annotation的信息。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-189&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;@唐说，在scala中定义的annotation，仅仅用于scala的编译。如果我们想在程序中使用，只能先在java下定义annotation，然后在scala中调用。&lt;/p&gt;
&lt;p&gt;经过测试，发现只有这种方式可行，所以又定义了一些java下的annotation，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
public @interface any {
    public String value() default &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在scala中调用，即可用，也可得到，完成了预期的功能。可惜纯scala框架的愿望没了，还是得有java代码才行。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>如何使用match来检查一个对象的类</title>
                <link>http://freewind.in/posts/187-scala-how-to-use-match-to-check-the-type-of-an-instance</link>
                <pubDate>Tue, 13 Sep 2011 22:24:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">187</guid>
                <description><![CDATA[&lt;pre&gt;&lt;code&gt;class checkType(cls: AnyRef) {
   cls match {
        case _:String =&amp;gt; println(&quot;is a string&quot;)
        case _:Date =&amp;gt; println(&quot;is a date&quot;)
        case _ =&amp;gt; println(&quot;others&quot;)
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span id=&quot;more-187&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;但对于泛型集合，无法断定其具体类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj : List[Int] = List(1)
val obj2 = List(1.2)
def typeCheck(obj: AnyRef) = obj match{
    case _:Array[Int] =&amp;gt;　println(&quot;Array[int]&quot;);
    case _ : List[Int] =&amp;gt; println(&quot;List[Int]&quot;)
    case _ =&amp;gt; println(&quot;println other type&quot;);
}
typeCheck(obj) // 输出List[Int]
typeCheck(obj2) // 输出List[Int]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为scala和java一样，在运行时把泛型的类型去掉了。
&lt;br  /&gt;但数组例外&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typeCheck(obj.toArray) // 输出Array[Int]
typeCheck(obj2.toArray) // 输出 println other type
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>为什么通不过编译 class X extends Map[String,String]</title>
                <link>http://freewind.in/posts/185-why-class-x-extends-map-string-string-cannot-be-compiled</link>
                <pubDate>Tue, 13 Sep 2011 22:21:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">185</guid>
                <description><![CDATA[&lt;p&gt;我想定义一个类，继承自HashMap，并增加一些额外方法，用于保存一些配置数据。我开始写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class X extends Map[String, String] {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码不能通过编译，提示说：X应该是abstract的。&lt;/p&gt;
&lt;p&gt;scala中两个叫Map的，一个是trait，一个是object。我们平时使用&lt;code&gt;Map()&lt;/code&gt;来生成一个新的空Map，实际上调用的是object Map的apply()函数。而这里想要继承，extends Map[String,String]，继承的是trait Map。&lt;/p&gt;
&lt;p&gt;并且，这个trait Map还是abstract的，里面有几个方法没有实现。所以提示X应该是abstract的才行。&lt;/p&gt;
&lt;p&gt;明白之后，改成:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.collection.immutable.HashMap

class X extends HashMap[String, String] {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;没有问题了。&lt;/p&gt;
&lt;p&gt;然后，我想给它增加一个方法，比如叫createEmpty()，返回一个新的空X。写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class X extends HashMap[String,String] {
    def createEmpty():X {
         X() // 这里有误
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我还想着&lt;code&gt;Map()&lt;/code&gt;呢，所以这里写成了X()，显示不能能过。HashMap可没有定义&lt;code&gt;apply()&lt;/code&gt;函数，正确的写法应该是&lt;code&gt;new X()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，发现这个createEmpty()，应该放在object中，它应该是一个(java中的)static方法，不能放在class里，所以呢，应该这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.collection.immutable.HashMap
class X extends HashMap[String, String]
object X { def createEmpty() = new X }
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>type A=B不等于import {A=&gt;B}</title>
                <link>http://freewind.in/posts/183-why-type-a-b-is-not-the-same-to-import-a-b</link>
                <pubDate>Tue, 13 Sep 2011 22:18:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">183</guid>
                <description><![CDATA[&lt;p&gt;今天被一个问题折磨了很久，最后才想明白。&lt;/p&gt;
&lt;p&gt;在检查代码的时候，发现不少类为了使用mutable的map，都进行了这样的导入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.collection.mutable.{ Map =&amp;gt; MMap }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后这样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;val map = MMap[String,String]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;于是想，何不把它放到一个package object中，这样就不需要到处导入了。于是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org
package object scalaeye {
    type MMap[K,V] = scala.collection.mutable.Map[K,V]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后去掉了其它类中的import {Map=&gt;MMap}的导入声明。结果发现编译时，所有使用了MMap的类，都报错：找不到type MMap。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-183&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;MMap明明已经定义了，为什么找不到呢？简化问题为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Test {
    type MMap[K,V] = scala.collection.mutable.{Map=&amp;gt;MMap}
    val data = MMap[String,String]()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是报找不到MMap，可是明明就在前面定义了！&lt;/p&gt;
&lt;p&gt;调试了好久，突然想起之前问过这个问题，答案也差不多想起来了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type MMap[K,V] = scala.collection.mutable.Map[K,V]

import scala.collection.mutable.{ Map =&amp;gt; MMap }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两者右边的Map是不一样的。第一个是trait Map，第二个是object Map。第一个像是一个接口，并没有apply()函数可让我们调用，所以MMap()出错。而第二个，实际上还是object Map，我们可以调用它的()函数&lt;/p&gt;
&lt;p&gt;下面是唐古拉山的回贴：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.collection.mutable.{ Map =&amp;gt; MMap }
-&amp;gt; Map trait及其伴生对象都可见了
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;classOf[MMap[_,_]]
MMap()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;scala 知道什么时候是trait，什么时候object
&lt;br  /&gt;看看Predef里对immuable.Map的导入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
type Map[A, +B] = collection.immutable.Map[A, B] //类型别名
val Map = collection.immutable.Map //引用对象
...
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>基于scala的web框架搜集</title>
                <link>http://freewind.in/posts/182-web-frameworks-in-scala</link>
                <pubDate>Tue, 13 Sep 2011 22:13:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">182</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;一、liftweb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;http://www.liftweb.net/&quot;&gt;http://www.liftweb.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是scala官方推荐的web框架，不仅包含mvc，也包含orm。在基于scala的各框架中，应该算是比较成熟的一个。不过据说不容易入门，因为它有自己的一套处理方式，叫view-first。我大略看了一下它的demo，感觉的确有点不太好看明白。但有些人特别喜欢这种模式，说代码编写很简洁。习惯了mvc的通常难以适应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、circumflex&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;http://www.circumflex.ru/&quot;&gt;http://www.circumflex.ru&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是我现在正在研究的一个东西，包含了mvc、orm及其它的一些工具，支持freemarker和scalate。其orm的api设计得很好，用起来就像是在写sql，却可以让编译器对其进行验证，减少出错。mvc很简洁明了，看一遍就差不多明白怎么回事了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、scalatra&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://github.com/scalatra/scalatra&quot;&gt;https://github.com/scalatra/scalatra&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个只是mvc层，也是很简单明了的风格，跟circumflex-mvc很像，支持scalate。没有提供orm，但可以和circumflex-orm或者squeryl结合使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、playframework&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;http://www.playframework.org/&quot;&gt;http://www.playframework.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;playframework是一个java的web框架，但现在的play2则完全基于scala。使用sbt代替了原来的python来执行命令，修改代码后，不需要重启（与以前一样），在中档电脑上需要大约3到4秒的时间。开发了新的基于scala的view层，大大提高了性能。还有新的orm层，叫anorm，有点类似于mybatis，但利用了scala的特性，让结果集与model类之间的匹配更加容易。我非常看好它的发展，欢迎加入play热情交流群：168013302&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、xitrum&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://github.com/ngocdaothanh/xitrum&quot;&gt;https://github.com/ngocdaothanh/xitrum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;xitrum内部使用netty作为服务器，可与jrebel结合，实现大多数修改无须重启。其view层直接使用scala的xml特性，可及时发现代码错误，但也限制了我们使用html编辑器对代码进行着色及提示。使用中感觉不太好的地方是，当代码出现错误时，只会在sbt控制台中显示，刷新页面时不会有提示（还显示之前的页面）。我们必须每次修改代码后，盯着sbt，才知道有没有出问题，很不方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、arden推荐：brzy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://github.com/m410/brzy-webapp&quot;&gt;https://github.com/m410/brzy-webapp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;未使用过，不评论。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>circumflex入门感受</title>
                <link>http://freewind.in/posts/181-try-circumflex</link>
                <pubDate>Tue, 13 Sep 2011 22:03:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">181</guid>
                <description><![CDATA[&lt;p&gt;使用circumflex大约一周，通过边写代码边写测试的方式，到今天终于把它的orm,mvc等基本功能跑通。感觉如下：
&lt;br  /&gt;&lt;p&gt;1. orm模块：api设计巧妙，用起来很顺手。提供了类似于SQL的DSL来写查询，在编译器的实时查错的帮助下，不易出错。源代码中注释和文档写得很好，连我这刚学scala半个月的新手，读起来都不觉得费力。在测试时，可以方便地根据定义的model，去生成表，还可以在xml中定义测试数据，导进去。有一点需要注意，官方现在仅支持postgresql数据库，其它数据库的支持需自己扩展或搜索。
&lt;br  /&gt;&lt;p&gt;2. mvc模块：结构很简单，controller+action，再render view层，就搞定了。其中router那一块，可以很灵活地支持各种结构的url。view层支持freemarker及scalate。这一块很简单，基本上看两眼就知道大概了。
&lt;br  /&gt;&lt;p&gt;3. view层：我使用的是scalate，jade语法。因为我比较喜欢这种类haml的风格，比较顺手。需要先看scalate定义的那些简化符号。
&lt;br  /&gt;&lt;p&gt;其它的，就是用sbt来控制库依赖、编译、测试及启动jetty，使用scalatest来写测试代码。每写一个类，就马上写它的对应代码，对于学习新框架很有帮助。另外，使用eclipse加scala插件来编码，有点卡，差不多每次保存都需要卡3到5秒，勉强接受。只使用了它的代码着色、格式化及实时查询功能，函数提示基本无视。
&lt;br  /&gt;&lt;p&gt;期间遇到了一些问题，主要是因为对scala不熟悉，没细看circumflex的文档和api，在google group中问了不少问题，好在开发组很热心，基本上都解决了。
&lt;br  /&gt;&lt;p&gt;目前感觉还不错。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala中尽量避免使用null</title>
                <link>http://freewind.in/posts/180-avoid-null-in-scala</link>
                <pubDate>Tue, 13 Sep 2011 22:01:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">180</guid>
                <description><![CDATA[&lt;p&gt;刚才在google群中与人交流时，有朋友说在scala中，应该尽量避免使用null，不能像java那样。发了一个博客中的文章，感觉不错，贴在这里。
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://jim-mcbeath.blogspot.com/2008/10/avoiding-nulls.html&quot;&gt;http://jim-mcbeath.blogspot.com/2008/10/avoiding-nulls.html&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用sbt时遇到的一些问题</title>
                <link>http://freewind.in/posts/179-sbt-problems</link>
                <pubDate>Tue, 13 Sep 2011 22:00:34 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">179</guid>
                <description><![CDATA[&lt;p&gt;一、使用sbt时，经常出现PermSize不够用的错误，怎么办？&lt;strong&gt;
&lt;br  /&gt;&lt;p&gt;修改sbt的启动文件sbt.bat，增加启动参数：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;-XX:MaxPermSize=256M```
&lt;br  /&gt;&lt;p&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二、scala文件中含有中文，编译正常；而java文件中有中文，编译提示错误（注：java文件为utf8，而系统字符集为gbk）**&lt;/p&gt;
&lt;p&gt;在sbt下，输入debug命令，打开debug级的log，再次运行compile，发现它使用的scalac有utf8的选项，而javac没有，说明javac使用的是系统默认字符集。需要更改项目配置文件project/build/config.scala，在里面添加一行：&lt;/p&gt;
&lt;p&gt;override def javaCompileOptions = super.javaCompileOptions ++ javaCompileOptions(&amp;ldquo;-encoding&amp;rdquo;, &amp;ldquo;utf8&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、 一个web项目，代码中引用了servlet的一些类，并且还要运行sbt的jetty-run，则需要要匹配文件中增加：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;org.mortbay.jetty&amp;rdquo; % &amp;ldquo;jetty&amp;rdquo; % &amp;ldquo;6.1.25&amp;rdquo; % &amp;ldquo;compile-&gt;default&amp;rdquo;, // 用于编译&lt;/p&gt;
&lt;p&gt;&amp;ldquo;org.mortbay.jetty&amp;rdquo; % &amp;ldquo;jetty&amp;rdquo; % &amp;ldquo;6.1.25&amp;rdquo; % &amp;ldquo;test-&gt;default&amp;rdquo;, // 用于sbt的jetty-run&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、 lib_managed目录下的jar，有时候并不是最新的，即使使用了clean-lib和update。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最好的办法就是手动删除lib_managed下的所有文件，再重新update一下。然后再编译，运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 本地的jar放在lib目录下，可嵌套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 如果在一个项目中，定义多个子项目&lt;/strong&gt;，简单的做法可在匹配文件中：&lt;/p&gt;
&lt;p&gt;lazy val demo = project(&amp;ldquo;demo&amp;rdquo;, &amp;ldquo;Demo of ScalaEye&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;前面是目录名，后面是项目全名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 如果使用了jrebel插件，希望修改后热生效，不用重启jetty&lt;/strong&gt;，可在config.scala中增加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;override def scanDirectories = Nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但我在使用中，发现了一些问题（如css文件没有及时生效等问题)，觉得还不如不用，直接让jetty重新载入吧。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>sbt+jrebel成功，jetty不用再重启</title>
                <link>http://freewind.in/posts/178-succesfully-applied-sbt-jrebel-and-jetty-is-needed-restart</link>
                <pubDate>Tue, 13 Sep 2011 21:59:54 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">178</guid>
                <description><![CDATA[&lt;p&gt;首先打消各位scala开发者的疑虑：jrebel对scala是免费的！大家只需要去申请一个licence即可（注意，如果gmail收不到，可试其它邮箱）：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://sales.zeroturnaround.com/&quot;&gt;http://sales.zeroturnaround.com/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;下载并安装之后，修改sbt的启动文件(在windows下，通常是sbt.bat)，增加以下参数:
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;-noverify -javaagent:E:/java/jrebel/jrebel.jar```
&lt;br  /&gt;&lt;p&gt;如果启动sbt时，看到jrebel的提示信息，就说明jrebel已经启用了。还差一步：修改项目的配置文件，让jetty不再自动重启（否则jrebel就白忙活了）。&lt;/p&gt;
&lt;p&gt;修改/project/build/config.scala，增加：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;override def scanDirectories = Nil```
&lt;br  /&gt;&lt;style type=&quot;text /css&quot;&gt;.csharpcode, .csharpcode pre
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;font-size: small;
color: black;
font-family: consolas, &quot;Courier New&quot;, courier, monospace;
background-color: #ffffff;
/*white-space: pre;*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode pre { margin: 0em; }
&lt;br  /&gt;.csharpcode .rem { color: #008000; }
&lt;br  /&gt;.csharpcode .kwrd { color: #0000ff; }
&lt;br  /&gt;.csharpcode .str { color: #006080; }
&lt;br  /&gt;.csharpcode .op { color: #0000c0; }
&lt;br  /&gt;.csharpcode .preproc { color: #cc6633; }
&lt;br  /&gt;.csharpcode .asp { background-color: #ffff00; }
&lt;br  /&gt;.csharpcode .html { color: #800000; }
&lt;br  /&gt;.csharpcode .attr { color: #ff0000; }
&lt;br  /&gt;.csharpcode .alt
&lt;br  /&gt;{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;background-color: #f4f4f4;
width: 100%;
margin: 0em;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
&lt;br  /&gt;.csharpcode .lnum { color: #606060; }
&lt;br  /&gt;&lt;/style&gt;
&lt;br  /&gt;&lt;p&gt;禁止jetty检查文件改变。&lt;/p&gt;
&lt;p&gt;再使用sbt时，输入的命令变为：
&lt;br  /&gt;&lt;pre class=&quot;csharpcode&quot;&gt;&gt; sbt&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;jetty-run
&lt;br  /&gt;~compile```
&lt;br  /&gt;&lt;p&gt;当我们修改了任一scala文件后，马上就能看到它被编译的信息，而jetty却没有重新载入。刷新页面看，就能看到改动过的效果了，每次修改都可以节省几秒钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该方法在sbt 0.7.x上测试通过&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>解析一句信息量很大的代码</title>
                <link>http://freewind.in/posts/174-scala-some-code-with-much-information</link>
                <pubDate>Tue, 13 Sep 2011 21:50:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">174</guid>
                <description><![CDATA[&lt;p&gt;在scalatra的RichRequest类中，发现了一句信息量很大的代码，值得分析。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scala.collection.{Map =&amp;gt; CMap}

case class RichRequest(r: HttpServletRequest) extends AttributesMap {

  def multiCookies: CMap[String, Seq[String]] =
    Option(r.getCookies).getOrElse(Array()).toSeq.
      groupBy { _.getName }.
      transform { case(k, v) =&amp;gt; v map { _.getValue }}.
      withDefaultValue(Seq.empty)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中r.getCookies()将返回一个Cookie[].&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-174&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;multiCookies的作用，是把request的cookies转换成一个Map[String,Seq[String]]，其中key为cookie的name，值为cookie的value的序列。因为可能有多个同名的cookie，所以是个序列。另外，如果请求的cookie不存在，返回一个空序列。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Option(r.getCookies) // -&amp;gt; 把cookies变成一个Option，方便后面的操作
  .getOrElse(Array()) // -&amp;gt; 得到cokkies，如果为空，得到一个空数组
  .toSeq // -&amp;gt; 把数组变成序列，方便后面操作
  .groupBy { _.getName } // 按name，将序列中的元素分组，得到一个Map[String, Seq[Cookie]]
  .transform { case(k,v) =&amp;gt; v map { _.getValue } // -&amp;gt; 得到一个新Map，key为原key，值变成原值的value
  .withDefaultValue(Seq.empty) // -&amp;gt; 设定对于不存在的key，返回一个Seq.empty
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>在scala中实现using自动关闭资源</title>
                <link>http://freewind.in/posts/173-how-to-close-resource-with-using-in-scala</link>
                <pubDate>Tue, 13 Sep 2011 21:48:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">173</guid>
                <description><![CDATA[&lt;p&gt;这是在scalatra中看到的一段代码，觉得非常好。它定义了一个using方法，可以这样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using(resouse) { resourse =&amp;gt;
    // do something with the resourse
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当块结束后，resourse的close函数将自动被调用。能够当resourse的对象，必须拥有一个close()函数。使用这种方式，可以使资源在用完后自动关闭，减少我们出错的机会。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-173&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package org.scalatra

package object util {
  /**
   * Executes a block with a closeable resource, and closes it after the block runs
   *
   * @tparam A the return type of the block
   * @tparam B the closeable resource type
   * @param closeable the closeable resource
   * @param f the block
   */
  def using[A, B &amp;lt;: { def close(): Unit }](closeable: B)(f: B =&amp;gt; A) {
    try {
      f(closeable)
    }
    finally {
      if (closeable != null)
        closeable.close()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从中可以看到这一句运用了duck type，定义了一个拥有close()函数的type&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;B &amp;lt;: { def close(): Unit } 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，不管是什么对象，只要它拥有一个close():Unit的函数，都可以在这里使用，并且这个close最后将被自动调用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在scala中，如何取得一个函数的参数名</title>
                <link>http://freewind.in/posts/172-how-to-get-the-parameter-name-of-a-scala-method</link>
                <pubDate>Tue, 13 Sep 2011 21:45:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">172</guid>
                <description><![CDATA[&lt;p&gt;问题很简单，定义了一个函数，怎样才能取得参数名？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User {
    def insert(name:String, age: Int) {}
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在scala中，有没有办法得到这个函数的参数名name和age呢？&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-172&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;因为scala在很多地方受制于java，先让我们看看在java中怎么解决。java的反射，可以得到类名，函数名，参数类型，就是得不到参数的名。曾经在jdk6.0时打算加入，后来因为时间不足放弃，而现在java7.0也没打算加入，可能是考虑到代码的兼容。在java中，不外乎是两种做法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在编译时，使用一些(ant或mvn的）插件，扫描源代码，将这些信息加入到生成的字节码中，然后再用一些库读取。&lt;/li&gt;
&lt;li&gt;在编译时，打开编译器的-g开关，让生成的字节码中包含有参数名等信息，再用库读取。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Paranamer这个库就是按第2种方式做的，见：&lt;a href=&quot;http://paranamer.codehaus.org/&quot;&gt;http://paranamer.codehaus.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在scala中，按说也可以这么做。但是我尝试了几次，却都没有成功。scalac的-g参数，后面还有5个可选值，分别是none,source,vars,line,notailcall，我都试了，可是使用paranamer，都什么也没得到，看来scala的编译器跟java的做法还不一样。是不是就没有办法做到了？&lt;/p&gt;
&lt;p&gt;最后，在stackoverflow上，有一个高手给我介绍了他写的一个工具，叫scalaj-reflect，可以做到。见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5191726/is-it-possible-to-get-the-parameter-names-of-a-method-in-scala&quot;&gt;http://stackoverflow.com/questions/5191726/is-it-possible-to-get-the-parameter-names-of-a-method-in-scala&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过这一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import scalaj.reflect._
for {
  clazz &amp;lt;- Mirror.ofClass[UsersController].toSeq
  method &amp;lt;- clazz.allDefs.find(_.name == &quot;insert&quot;).toSeq
  params &amp;lt;- method.flatParams
} yield params
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就可以成功得到insert函数的参数值了。&lt;/p&gt;
&lt;p&gt;其项目位于：&lt;a href=&quot;https://github.com/scalaj/scalaj-reflect&quot;&gt;https://github.com/scalaj/scalaj-reflect&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要手动编译，得到jar。&lt;/p&gt;
&lt;p&gt;这么高难的，scala都能解决。&lt;/p&gt;
&lt;p&gt;经过后来在实际项目中使用，发现如果一个类的结构比较复杂，比如函数中有内部类或者闭包，可能读取错误。所以如果要使用这个功能，一定要注意测试。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>一个有趣的类scala.util.DynamicVariable</title>
                <link>http://freewind.in/posts/170-an-interesting-class-scala-util-dynamicvariable</link>
                <pubDate>Tue, 13 Sep 2011 21:41:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">170</guid>
                <description><![CDATA[&lt;p&gt;该文章以前发表在scala群（132569382）的论坛里，现在拿出来放在博客里。&lt;/p&gt;
&lt;p&gt;刚在看scalatra源代码时，发现这么一段：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;protected val _response = new DynamicVariable[HttpServletResponse](null)
protected val _request = new DynamicVariable[HttpServletRequest](null)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;里面用到了一个叫DynamicVariable的类，为什么要用它呢？经过一翻研究，发现这个类比较重要，很适合用于做context.&lt;/p&gt;
&lt;p&gt;首先看一下这个类的api文档，发现它类似于一个栈，不过已经处理好了多线程的调用问题。它有一个方法叫withValue()，很常用，我们一般都这么用它：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;someDynamicVar.withValue(newValue) {
    someDynamicVar.value // -&amp;gt; 得到的就是newValue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先看一个简单的例子，熟悉一下用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;val context = new scala.util.DynamicVariable[String](&quot;000&quot;)
println(context) // -&amp;gt; DynamicVariable(000)
context.withValue(&quot;111&quot;) {
    println(context) // -&amp;gt; DynamicVariable(111)
}
println(context) // -&amp;gt; DynamicVariable(000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从中可以看到，在withValue后面块中，访问context时，它的值是新值。而过了块以后，值又变成了原来的值。&lt;/p&gt;
&lt;p&gt;那么，这对我们有什么用呢？&lt;/p&gt;
&lt;p&gt;我在stackoverflow上看到一个问题，解答了我的疑惑，原帖可见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2629367/scala-closure-context&quot;&gt;http://stackoverflow.com/questions/2629367/scala-closure-context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看完这个问题，以及它的回答，就差不多明白了。&lt;/p&gt;
&lt;p&gt;还是把例子抄过来吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在groovy中，闭包中的代码，似乎可以知道它正在被谁调用。所以，我们才可以写出下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;groovy&quot;&gt;swing = new SwingBuilder()
frame = swing.frame(title:&apos;Demo&apos;) {
  menuBar {
    menu(&apos;File&apos;) {
      menuItem &apos;New&apos;
      menuItem &apos;Open&apos;
    }
  }
  panel {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;menuBar知道自己在哪个frame中，menu知道自己在哪个menuBar中，menuItem知道自己在哪个menu中，这样才不会乱套。在scala中，能不能做到同样的效果呢？&lt;/p&gt;
&lt;p&gt;答案当然是可以，关键就是这个DynamicVariable，看以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;scala&quot;&gt;import scala.util.DynamicVariable
import javax.swing._

object SwingBuilder {
  case class Context(frame: Option[JFrame], parent: Option[JComponent])
}

class SwingBuilder {
  import SwingBuilder._
  val context = new DynamicVariable[Context](Context(None,None))

  def frame(title: String)(f: =&amp;gt;Unit) = {
    val res = new JFrame(title)
    res.add(new JPanel())
    context.withValue(Context(Some(res),context.value.parent)){f;res}
  }

  def menuBar(f: =&amp;gt;Unit) = {
    val mb = new JMenuBar()
    context.value.frame.foreach(_.setJMenuBar(mb))
    context.withValue(Context(context.value.frame,Some(mb))){f;mb}
  }

  def menu(title: String)(f: =&amp;gt;Unit) = {
    val m = new JMenu(title)
    context.value.parent.foreach(_.asInstanceOf[JMenuBar].add(m))
    context.withValue(Context(context.value.frame,Some(m))){f;m}
  }

  def menuItem(title: String) = {
    val mi = new JMenuItem(title)
    context.value.parent.foreach(_.asInstanceOf[JMenu].add(mi))
  }
}

object Test {
  def main(args: Array[String]) {
    val builder = new SwingBuilder()
    import builder._

    val f = frame(&quot;Demo&quot;) {
      val mb = menuBar {
        menu(&quot;File&quot;) {
          menuItem(&quot;New&quot;)
          menuItem(&quot;Open&quot;)
        }
      }
    }
    f.setVisible(true)
  }
}
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>Ecere 首页设计及思考</title>
                <link>http://freewind.in/posts/154-ecere-front-page-design-and-thinking</link>
                <pubDate>Tue, 13 Sep 2011 14:15:20 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">154</guid>
                <description><![CDATA[&lt;p&gt;Ecere的首页(&lt;a href=&quot;http://www.ecere.com&quot;&gt;http://www.ecere.com&lt;/a&gt;)设计比较粗糙，布局有些乱，重点没有突出，让人很难快速找到需要的信息。如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/154-1.png&quot;&gt;&lt;img src=&quot;/user_images/154-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-154&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;我打开网页的第一感觉，以为自己用的是IE6，出现了布局混乱。确认一下，是chrome，看来网站的确是这么设计的。&lt;/p&gt;
&lt;p&gt;我认为这个网页存在以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;布局乱。最上面居中，中间占满整屏，下面又居左。除了技术高超的设计师，一般人真没能力掌握这种布局
&lt;br  /&gt;&lt;li&gt;图片太过显眼。比如左边的那个大标志，右边的Download按钮，占据了浏览者的全部目光，但又很难从中了解到什么有用信息
&lt;br  /&gt;&lt;li&gt;下方的链接太多，让人不知道点哪个好。一般这样的链接，人们会选择性忽视。
&lt;br  /&gt;&lt;li&gt;浏览者最关心的：如“这是做什么用的”（功能、特色、卖点），“做得怎么样”（效果截图，示例程序），“难不难学”（示例代码、入门指南），“是否开源免费”（授权协议）等，在页面上没有清楚的体现出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我曾经在它的论坛里提过一些问题，作者很热心，让我对他感觉不错，所以，我打算自告奋勇地帮助它改善一下首页。虽然我的美工设计也不好，但希望能把它变得清晰一些，这点应该没问题。做了一个简单的原型图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/154-3.png&quot;&gt;&lt;img src=&quot;/user_images/154-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个页面，应该足够简单清楚，至少能让浏览者能从上到下看一遍后，就知道Ecere是做什么的，有什么特点。对于此类项目的网站，我的观点就是“简洁、清晰、入手快”。然后我在论坛里发了一个帖，把这个图附上，并说明了我的意见。如果作者认可的话，我就开始着手来设计。&lt;/p&gt;
&lt;p&gt;可惜，作者委婉地告诉我说，他很喜欢目前的主页，不打算对它进行修改。虽然我设计的页面简洁明了，但不适合当首页。有可能的话，可以把它用到“Learn more”文档页里。&lt;/p&gt;
&lt;p&gt;对于这个回应，我挺失望的，因为作者跟我的看法相反。其实除了首页，我还有很多想跟他谈的，但感觉一下子都说不出来了。作者的热心让我想在力所能及的范围为他做点什么，但可以预料我的看法他不会接受。而他现在的做法，我又觉得有很多问题。&lt;/p&gt;
&lt;p&gt;是我错了吗？自负于自己的观点？毕竟对方是有着十几年开发经验的资深开发人员，这个Ecere从技术上来说，的确让人觉得很厉害。&lt;/p&gt;
&lt;p&gt;我这段时间对Ecere感兴趣，除了因为之前觉得可能会用到它以外，更多是在思考：“为什么Ecere没有发展起来”，面对现在的这种情况，应该怎么做？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我所了解的Ecere&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里先说一下我所了解到的Ecere的情况。在08年的时候，有人在网上介绍了Ecere，引起了不少人的兴趣。Ecere是一个跨平台的GUI库，并且有着自己的开发语言叫eC。与QT/WxWidgets等相比，它的license很好（BSD），并且开发语言难度较小，给出来的示例也很漂亮。比如一个3D的国际象棋的例子，一共才不到4M，但是实现的效果真不错。截个图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/154-5.png&quot;&gt;&lt;img src=&quot;/user_images/154-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时因为作者是一个略懂中文的加拿大程序员，所以很多中国人尝试了该项目。短时间内，那个QQ群就有100多个人，还有人把它的教程翻译成中文。当时我也试用了一下，感觉有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仿windows 2000的界面，在windows xp上显得不协调。如果用它做成通用性程序，会让人觉得这是几年以前的产物。
&lt;br  /&gt;&lt;li&gt;提供的控件只有十来个，实在太少&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为没有能力参与进去，所以采取了观望态度。然而一年之后，发现没有任何新版本发布，所有存在的问题依然存在。大家慢慢退出，我只是偶尔回来看看有没有什么新版本。直到前几天，我以前在里面发一个帖子作者回复了，告诉我Ecere现在有了windows XP的风格，去看了一下。另外发现近期代码提交比较勤，我在想，Ecere是不是在沉寂这么久之后，打算大干一场了？正好我现在打算什么也不折腾了，不如参与进去。&lt;/p&gt;
&lt;p&gt;从网站上看，情况如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网站主页是：&lt;a href=&quot;http://www.ecere.com&quot;&gt;http://www.ecere.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;讨论场所是自建的论坛：&lt;a href=&quot;http://ecere.com/forums/&quot;&gt;http://ecere.com/forums/&lt;/a&gt;，需注册&lt;/li&gt;
&lt;li&gt;效果展示页面（叫Action Gallery）：&lt;a href=&quot;http://ecere.com/action.html&quot;&gt;http://ecere.com/action.html&lt;/a&gt;，有很多很酷的截图，但我今天才发现这页&lt;/li&gt;
&lt;li&gt;文档页是wiki: &lt;a href=&quot;http://ecere.com/wiki/index.php?title=Main_Page&quot; title=&quot;Main_Page&quot;&gt;http://ecere.com/wiki/index.php?title=Main_Page&lt;/a&gt;，需注册&lt;/li&gt;
&lt;li&gt;PDF文档：&lt;a href=&quot;http://ecere.com/tao.pdf&quot; title=&quot;http://ecere.com/tao.pdf&quot;&gt;http://ecere.com/tao.pdf&lt;/a&gt;，比较详细，像半本书&lt;/li&gt;
&lt;li&gt;Bug跟踪是mantis: &lt;a href=&quot;http://ecere.com/mantis/my_view_page.php&quot;&gt;http://ecere.com/mantis/my_view_page.php&lt;/a&gt;，近期相当活跃。需注册&lt;/li&gt;
&lt;li&gt;博客是：&lt;a href=&quot;http://www.ecere.com/blog/&quot;&gt;http://www.ecere.com/blog/&lt;/a&gt;，最新一篇是去年3月&lt;/li&gt;
&lt;li&gt;API是wiki页面：&lt;a href=&quot;http://ecere.com/wiki/index.php?title=Topical_Reference&quot; title=&quot;Topical_Reference&quot;&gt;http://ecere.com/wiki/index.php?title=Topical_Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Roadmap是很长的一篇文章：&lt;a href=&quot;http://ecere.com/roadmap.html&quot;&gt;http://ecere.com/roadmap.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;邮件列表有google group：&lt;a href=&quot;http://groups.google.com/group/ec-programming-language&quot;&gt;http://groups.google.com/group/ec-programming-language&lt;/a&gt;，最后一帖是去年2月&lt;/li&gt;
&lt;li&gt;源代码：&lt;a href=&quot;https://github.com/ecere/sdk&quot;&gt;https://github.com/ecere/sdk&lt;/a&gt;，仅用到版本控制的功能，缺README&lt;/li&gt;
&lt;li&gt;项目开发人员：未找到列表，从论坛交流情况来看，只有作者jerome一人&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从程序方面来看，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载包有30多M，其中包含所有需要的：编译器，IDE，教程，示例代码，可视化设计。这点很不错。&lt;/li&gt;
&lt;li&gt;跨平台GUI目前依然不理想：QT license，Air性能，WxWidgets难度，而Ecere在这几方面有优势&lt;/li&gt;
&lt;li&gt;弱点：如前面所说，界面、控件、开发进度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我个人非常希望Ecere能够成功，至少在技术上来说，它还有很有需求的。对于很多非c/c++开发者来说，一个配置简单、快速入门、可视化设计、性能优良的GUI框架还是有相当吸引力的。毕竟有很多人对于GUI的功能要求不高，只是想做出一些比较简单的程序，或者与网站结合。但是该项目的现状让我担忧。&lt;/p&gt;
&lt;p&gt;我的意见有以下几点：&lt;/p&gt;
&lt;p&gt;一是要展示开放的姿态。论坛、wiki、bug跟踪，每个都需要别人单独注册，这能算是开放姿态吗？为什么不用google group完全代替论坛，github的wiki和bug跟踪，代替现有的系统？仅仅只是因为自己已经用习惯了？&lt;/p&gt;
&lt;p&gt;二是要积极往人堆里扎。现在的Ecere像是互联网上的一个孤岛，所有的东西都是在自己的封闭系统中，与外界没有交集。为什么不多利用github，而它为核心来开发项目？github上的项目首页连README都没有，谁都不知道它是做什么的。&lt;/p&gt;
&lt;p&gt;三是要分解项目，让更多人参与进来。现在看起来好像是作者全包，编译器、语言、IDE、网站、文档，全是一个人在干。在论坛里我发现有些人想参与进来，但不知道自己能干什么。像网站这样技术含量比较低的，为什么不放手让别人来做呢？&lt;/p&gt;
&lt;p&gt;四是要简化网站结构。在github上，很多有名的项目，其网站都是非常简单而清晰，没有多余的东西。而Ecere首上，连某某网站发了一篇Ecere的报道，也加了一个与主要链接同等地位的友情链接。&lt;/p&gt;
&lt;p&gt;最后是要建立起社区。作者给我的感觉是很热心，有什么问题很快就会回复。但是通过首页这件事情，我看到了作者的固执。也许因为作者是一个资深的底层开发人员，能力很强，所以在网站方面也同样相信坚持自己的观点。这样的话，很难吸引到其他人参与进来，毕竟说服一个资深开发者同意自己的观点，是一件很有压力的事情。但如果违心地按照作者的想法去做，那就不是贡献，而且雇佣了。&lt;/p&gt;
&lt;p&gt;以上是我的粗浅想法，哪些对，哪些错，哪些无关痛痒？欢迎提意见&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>WordPress 设置301转向</title>
                <link>http://freewind.in/posts/149-how-to-set-301-redirection-in-wordpress</link>
                <pubDate>Tue, 13 Sep 2011 14:10:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">149</guid>
                <description><![CDATA[&lt;p&gt;按照以往惯例，网站以www开头，比如&lt;a href=&quot;http://www.freewind.me&quot;&gt;www.freewind.me&lt;/a&gt;。但是现在的流行又是，不要二级域名，直接freewind.me。问题来了：搜索引擎可能会把&lt;a href=&quot;http://www.freewind.me&quot;&gt;www.freewind.me&lt;/a&gt;和freewind.me当作两个不同的网站，分别计算权重。&lt;/p&gt;
&lt;p&gt;最好的作法就是选定其中的一个作为主域名，另一个设成301转向过来。&lt;/p&gt;
&lt;p&gt;在Wordpress中，怎么设？&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-149&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;首先要在域名管理面板中，将freewind.me与&lt;a href=&quot;http://www.freewind.me&quot;&gt;www.freewind.me&lt;/a&gt;都指向网站所在的ip，如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/149-1.png&quot;&gt;&lt;img src=&quot;/user_images/149-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你新设了域名A记录，需要等一段时间才能生效。&lt;/p&gt;
&lt;p&gt;然后找到虚拟主机上的.htaccess文件，其位置如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/149-3.png&quot;&gt;&lt;img src=&quot;/user_images/149-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果没有自行创建。在文件中增加以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Options +FollowSymLinks
RewriteEngine on
RewriteCond %{HTTP_HOST} ^www\.freewind\.me
RewriteRule ^(.*)$ http://freewind.me/$1 [R=permanent,L]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后测试：curl &lt;a href=&quot;http://www.freewind.me&quot;&gt;http://www.freewind.me&lt;/a&gt; -I，得到：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;HTTP/1.1 301 Moved Permanently
&lt;br  /&gt;Date: Tue, 13 Sep 2011 05:59:51 GMT
&lt;br  /&gt;Server: Apache/2
&lt;br  /&gt;X-Powered-By: PHP/5.2.17
&lt;br  /&gt;X-Pingback: &lt;a href=&quot;http://freewind.me/xmlrpc.php&quot;&gt;http://freewind.me/xmlrpc.php&lt;/a&gt;
&lt;br  /&gt;Location: &lt;a href=&quot;http://freewind.me/&quot;&gt;http://freewind.me/&lt;/a&gt;
&lt;br  /&gt;Vary: Accept-Encoding,User-Agent
&lt;br  /&gt;Content-Type: text/html; charset=UTF-8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;果然已经成了301，完工。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Ecere 跨平台的2D/3D GUI语言</title>
                <link>http://freewind.in/posts/143-ecere-cross-platform-2d-3d-gui-language</link>
                <pubDate>Tue, 13 Sep 2011 13:32:31 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">143</guid>
                <description><![CDATA[&lt;p&gt;Ecere在两三年前火过一阵，当时我还加入了一个Ecere的QQ群，里面也有100多人。作者是加拿大人，略懂中文，对中国开发者很热情。Ecere的开发文档也有中文版本。后来因为长期不出新版本，一些Bug也一直没有修复，所以慢慢变得冷清了，直到被我遗忘了。&lt;/p&gt;
&lt;p&gt;前两天突然收到了一封邮件，是我很久以前在论坛里发的一个帖子被人回复了，于是过去看看，原来我当时的一个需求，现在终于解决了。看了下，ecere从0.4.3变成了0.4.4，再看看github上的提交记录，这个项目并没有死，所以我的兴趣又回来了。&lt;/p&gt;
&lt;p&gt;网站是：&lt;a href=&quot;http://www.ecere.com&quot;&gt;http://www.ecere.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-143&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;Ecere是一个跨平台的2D/3D GUI语言，它有自己的开发语言叫eC（这名字怪怪的），以及自己的IDE，及大量的示例。它与C/C++在链接库层面是兼容的，可以互相调用。它的GUI是自己绘制的，没有使用本地界面。&lt;/p&gt;
&lt;p&gt;我觉得它最大的优点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跨平台：可以windows/Linux/Unix等平台上运行
&lt;br  /&gt;&lt;li&gt;小巧：只需要一个2M多的ecere.dll。它的示例程序只有2M多，即可在windows上运行出一个GUI界面
&lt;br  /&gt;&lt;li&gt;对于3D程序支持强劲：示例中有一个3D版的国际象棋，很漂亮。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里先截图一张，是ecere自带的IDE：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/143-1.png&quot;&gt;&lt;img src=&quot;/user_images/143-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到整个开发环境还是相当完备的，代码高亮、GUI designer、调试器等，都已经提供。不过看起来提供的可用控件还比较少。&lt;/p&gt;
&lt;p&gt;截几个比较有效果的示例图，下面这个是一个2D程序：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/143-3.png&quot;&gt;&lt;img src=&quot;/user_images/143-3.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/143-5.png&quot;&gt;&lt;img src=&quot;/user_images/143-5.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：[&lt;a href=&quot;http://www.ecere.com/downloads/fractals-0.3.zip&quot;&gt;windows&lt;/a&gt;][&lt;a href=&quot;http://www.ecere.com/downloads/fractals-0.3.tar.gz&quot;&gt;linux&lt;/a&gt;][&lt;a href=&quot;http://www.ecere.com/downloads/fractals.zip&quot;&gt;source&lt;/a&gt;]。下载包仅仅1M多，仅有一个ecere.dll链接库！可以说是小巧玲珑，不能不试。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.ecere.com/blog/category/user-applications/&quot;&gt;http://www.ecere.com/blog/category/user-applications/&lt;/a&gt;中还有一些其它的例子，比如mp3 player和一个3D版的国际象棋，不过不知道怎么回事，在我的系统(windows xp)上会报错。以前试的时候是没有问题的。&lt;/p&gt;
&lt;p&gt;Ecere从技术层面上，我觉得是很有前途的。但是现在发展不是很顺利，我觉得其原因主要在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序界面不够美观。可能作者是典型的程序员，精于代码但美工不行，所以设计出来的程序界面只能算是中等偏下水平
&lt;br  /&gt;&lt;li&gt;网站页面不美观。网站打开后，感觉很奇怪，像是一个年久失修的网站
&lt;br  /&gt;&lt;li&gt;与用户的交互方式不够开放。比如仅仅把代码放在了github上，没有充分利用github的功能。使用自己的bbs程序来与用户交流，不如放在google groups中。&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>连WordPress都不支持IE6了</title>
                <link>http://freewind.in/posts/130-wordpress-not-support-ie6-any-more</link>
                <pubDate>Tue, 13 Sep 2011 02:29:26 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">130</guid>
                <description><![CDATA[&lt;p&gt;今天开了独立博客，下载了最新的wordpress3.2.1，安装后，发现在IE6下面目全非！进入后台，也看到了一个红底的提示，说我使用的浏览器太旧了，不安全，建议我更换到最新的浏览器。&lt;/p&gt;
&lt;p&gt;上网一查，果然看到人们说，wordpress已经公开表示不支持IE6了。&lt;/p&gt;
&lt;h2&gt;问：中国还有多少人在用IE6?美国还有多少人？&lt;/h2&gt;
&lt;p&gt;答：打开&lt;a href=&quot;http://ie6countdown.com&quot;&gt;http://ie6countdown.com&lt;/a&gt;，可以看到世界地图上，“红色”的中国&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/130-1.png&quot;&gt;!image&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中国以30.5%的最高比例，压倒性的优势，稳居世界第一！中国的程序员苦啊，特别是前端工程师。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>继续用play，等待Kotlin</title>
                <link>http://freewind.in/posts/116-use-play-and-wait-for-kotlin</link>
                <pubDate>Tue, 13 Sep 2011 02:03:22 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">116</guid>
                <description><![CDATA[&lt;p&gt;作为一个一心想做个什么网站的屡败屡战屡战屡败游走于各语言框架之间脚踏N只船反复尝试但一直没找到满意的web框架和orm方案的杯具的我来说，继续用Java版的Play+Ebean，再考虑Japid当View，也许是目前最好的选择了。虽然还有着各种不满意，但放低标准端正心态，生活才可以更美的。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-116&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;Scala在开发后台并发程序方面，可以说已相当成熟，有越来越多的公司招聘Scala程序员开发此类程序。相比Java，这的确是Scala的一个强项。Scala的一些弱点如编辑器支持不够好、编译时间过长等，对这类程序影响不大，绝对可以忽略。而语言层面的改进和对并发的优良支持，可以大幅提高其开发效率。
&lt;br  /&gt;&lt;p&gt;然而说到Web，Scala处境尴尬。持久层、View层、编译时间、热修改、编辑器支持，这些对于Web开发比较重要的因素，Scala反而不如Java。Scala界有一个官方推荐的Lift框架，得到很多资深人士的支持，个人以为这只是因为没有太多选择。Play现在押宝Scala，其2.0版本推出在即，拥有众多让人激动的特性，如热修改、新View层、新持久层等，如果这个持久层经受住了用户的检验，那么Play的前景将会相当光明。只有它可以担当起拯救Scala web的重任，当然还需要时间检验。所以目前还不是使用Scala开发网站的好时候。
&lt;br  /&gt;&lt;p&gt;Groovy是一个动态语言，强项在于脚本程序和Web。在Groovy界，只有一个web框架，即grails。Grails越来越小众，因为它过于模仿rails，扬短避长。会学groovy和grails的大多是Java程序员，其特点是喜欢静态类型、依赖编辑器，但groovy/grails在这两方面仿佛故意与人作对。groovy语言明明可以设计得稍静态一些，以提高性能和讨好编辑器；grails也明明可以设计得不那么像Rails，而突出其JVM平台的优势，这样才能利用JVM和Java的优势，做出更符合Java平台的框架。可惜，现在已经晚了。
&lt;br  /&gt;&lt;p&gt;Groovy++是对groovy的改良，提供了动态与静态类型相结合的方式，大幅提高性能，并带来一些不错的新特性。我认为这才是正确的道路。毕竟在写程序时，有时适合静态有时适合动态。如果Groovy从一开始就这么设计，现在肯定会发展得相当不错。然而让人遗憾的是，groovy的开发人员对此毫不支持，认为其多此一举，并表示不会将其并入Groovy。所以Groovy++的发展前景并不理想，毕竟人单力弱，还不被支持。
&lt;br  /&gt;&lt;p&gt;最后，我把希望寄托于至今还未发布的Kotlin身上。Kotlin和Groovy++比较相似，只是它完全不支持动态类型。它比Scala简单，与Java更亲近，也不像Groovy那样动态。它其实很像是几个版本之后的Java。之所以看好这个语言，是因为它将会有与Java同水平的编辑器支持，还有商业公司在后面推动，不像Groovy++那样只有几个人在努力。我觉得Jetbrains应该把Groovy++的开发人员招过来，一起开发Kotlin.
&lt;br  /&gt;&lt;p&gt;Java已经有太多的历史包袱，如同一只大象，再也无法轻盈。期待Kotlin不会让我失望。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Play的最大缺点</title>
                <link>http://freewind.in/posts/115-biggest-weakness-of-playframework1</link>
                <pubDate>Tue, 13 Sep 2011 02:02:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">115</guid>
                <description><![CDATA[&lt;p&gt;Play的优点无数，缺点只有一个，但也是最大的一个：
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;　　很多第三方的Java库在Play中无法直接使用！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-115&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;这就是所谓的有得即有失。Play通过实现自己的ClassLoader，做到了修改源代码不用重启，大大提高了开发效率，让Play脱颖而出。但同时也导致与其它Java类库（涉及到ClassLoader的），与Play一起使用时，有可能因为ClassLoader的问题，无法正常运行。
&lt;br  /&gt;&lt;p&gt;比如我现在正打算使用guice，发现得去找一个play-guice的plugin。之前用Ebean，得写一个play-ebean的plugin。不知道Mybatis，是不是也需要一个plugin。
&lt;br  /&gt;&lt;p&gt;明明大家都是Java，却不能一块工作。现在我用play写网站时，一看到第三方的Java库，首先想到的就是“不知道是不是又得写个插件”，太麻烦了。&lt;/p&gt;
&lt;h2&gt;一些评论&lt;/h2&gt;
&lt;h3&gt;green&lt;/h3&gt;
&lt;p&gt;总的来说我不赞同这个观点。&lt;/p&gt;
&lt;p&gt;拿guice来说吧，给guice写plugin不是因为guice和play的class loader冲突，而是通常来讲guice并不是作为一个app的library来使用，而是有容器来初始化并调用。你可以直接在应用里面用guice，只是比较麻烦而已。另外guice模块也增强了一些特性，以更方便地在play app里面使用，比如允许注入到static member，这个原有的guice库是不能做到的。这也是仰仗play class loader的威力。&lt;/p&gt;
&lt;p&gt;同样的道理也适用于morphia模块，你可以直接用原生的morphia库，但是morphia模块提供了好些特性让你在play里面可以讲模版本身的功能发挥得淋漓尽致，甚至衍生出更好用的特性。&lt;/p&gt;
&lt;p&gt;要点在于play和Java传统的servlet是不同的系列，而很多在servlet容器里能直接使用的库，play需要用插件的形式来使用。另外因为有了app classloader，play往往能让库的使用更加方便，所以才会有插件加入，将本来的特性发挥更多。如果只是单纯的库，不需要容器来注入或者初始化，比方说commons-xxx之类的，应用大可放心地用，没有什么非得插件不可的说法。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Mybatis体验</title>
                <link>http://freewind.in/posts/114-try-mybatis</link>
                <pubDate>Tue, 13 Sep 2011 02:02:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">114</guid>
                <description><![CDATA[&lt;p&gt;话说上次用Hibernate，发觉性能问题处理起来很麻烦之后，我又拾起了Mybatis。Mybatis曾经叫作ibatis，它与Hibernate同时代，但以Hibernate相反的方式来实现orm（准确的说，叫mapper）。即仍然以SQL为重心，但自动将结果集装配成pojo（当然配置是少不了的）。&lt;/p&gt;
&lt;p&gt;　　Mybatis的特色是：1。手写所有的SQL　2。SQL写在XML文件里　3。pojo与数据表的映射关系，以及与结果集的映射关系，也写在XML中。4。当我们需要操作数据库时，在java代码中，调用XML文件中定义的某SQL的ID，同时传参数进去。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-114&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;　　与Hibernate相比，使用mybatis的人少得多，但也有不少死忠。它的显著优点是：你可以完全自由的写SQL，可以使用某些数据库特定的写法，甚至存储过程，来实现高性能的数据库操作。比如N+1问题，在mybatis中也存在，但是我们完全可以手写复杂的join语句来避免。因为mybatis中的所有SQL都是手写的，你在写的时候会自然而然地使用掌握的技巧，写出高性能的SQL，哪怕复杂一些，都不会让你觉得别扭。而这在Hibernate中，复杂的hql就会让人感觉有点别扭。&lt;/p&gt;
&lt;p&gt;　　缺点也很显著：你需要手写SQL，以及定义结果集如何映射到java对象中。手写SQL有时候比较复杂，而定义映射有时候更加复杂，所以怕麻烦的人都倾向于hibernate进行快速开发，至于性能问题，等遇到时再说吧。&lt;/p&gt;
&lt;p&gt;　　Mybatis提供了一个generator，让我们设计好数据库之后，直接生成对应的java类和配置文件。这个generator是个败笔，因为它生成的代码太复杂了，一个几个字段的数据表，生成了近千行的代码，谁敢用？曾经也是这些代码把我吓退了－－难道Mybatis这么复杂？&lt;/p&gt;
&lt;p&gt;　　好在仔细看过Mybatis的文档和相关的demo，发现其实很简单，关键就在于XML中的SQL和ResultMap的配置。在IDE的帮助下，使用XML并不是一件复杂的事情，但是用XML来描述映射关系，却非常啰嗦，因为XML的表达力比较弱。但是放在java中也不行，因为Java的表达力同样弱，所以最终还是放在XML中。好在现在支持annotation了，可以把一些东西放在java代码里，方便清晰很多。&lt;/p&gt;
&lt;p&gt;　　我觉得mybatis与play中提供的那个anorm，在原理上非常相似，只是因为anorm使用了scala，利用其强大的表达力，简化了SQL定义以及映射。开发效率提高了很多，代码量少很多，而且还有了编译器的检查。我感觉mybatis的思想，只有在表达力丰富的语言上（如scala），才能得到发扬光大。&lt;/p&gt;
&lt;p&gt;　　现在遇到的问题是事务。我看的一些例子，都是以编码的方式实现事务，插入数据后，马上要调用session.commit，最后还要session.close。对于测试来说，这有些麻烦。因为这样做，每一个测试运行后，数据库的内容就会变化，对后面的测试产生影响。如果在每个测试运行前，都删除所有数据再插入初始数据，又太费时了。以前在使用hibernate的时候，人们通常使用spring，利用spring的声明性事务，避免在代码中硬编码commit/close，然后，在单元测试中，使用spring提供的一个测试基类，就可以做到在测试完成后，rollback事务，即不会修改数据库内容，又成功的测试了代码。(Spring在易用性方面，的确做得非常好）&lt;/p&gt;
&lt;p&gt;　　我本想只使用mybatis，不想引入spring，但是mybatis似乎没有考虑到测试的问题。经常多次尝试，发现要想rollback，唯一的方式就是声明性事务，要达到这一点，只能使用一些提供了aop功能的ioc容器，比如spring，guice等。我打算先尝试一下guice，不行的话再使用spring。（为什么先试guice？因为我感觉它比较轻量，spring很庞大）&lt;/p&gt;
&lt;p&gt;　　原理如下：&lt;/p&gt;
&lt;p&gt;　　１。声明一个datasource。可采用一些数据库连接池提供的datasource，如今天发现的一个叫bonecp的连接池（当然，dbcp,c3p0,proxool等也可以），生成一个datasource对象。&lt;/p&gt;
&lt;p&gt;　　２。datasource似乎通常都是以jndi方式提供的，但是实现起来有些麻烦，不知道可否以非jndi的方式实现&lt;/p&gt;
&lt;p&gt;　　３。在代码中，使用该datasource取connection，进行数据库操作。同时，使用声明性事务，commit/rollback/close都不要出现在代码中。&lt;/p&gt;
&lt;p&gt;　　４。不论使用guice还是spring，都将以代码方式实现mybatis的配置，而不是用XML。&lt;/p&gt;
&lt;p&gt;　　５。可能需要实现一个junit的基类（如果是guice的话），实现事务不提交，在测完后自动回滚。&lt;/p&gt;
&lt;p&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-　接上　&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-&lt;/p&gt;
&lt;p&gt;出门回来后，继续使用mybatis。&lt;/p&gt;
&lt;p&gt;对于之前想将mybatis与guice结合起来，做成声明性事务，以便在测试时回滚，经研究后，发现在play的环境下难以实现，并且不太有必要。我之所以希望这样，是因为在测试数据库时，每个测试前都需要手动删除数据，再添加预定义的数据，非常麻烦；如果回滚事务不提交，则可省了这步，因为数据库内容不会变化。但是后来发现，使用dbunit这个东西，可以方便地解决这个问题，而且适用性更广泛，那么就没有必要把事情弄那么复杂。&lt;/p&gt;
&lt;p&gt;然后继续写dao。mybatis没有提供让我们自定义pojo字段名与表中列名的对应关系的方法，所以只能在xml中手写映射。我起的名字都是有规则的，比如在pojo中叫createdAt，在数据库中就是created_at，即java中是驼峰式，而数据库中是下划线式，这符合两者的命名习惯。但是mybatis就是不认，也没有提供一个简单的方法让我们配置一下，要写很多繁琐的废话，真麻烦。&lt;/p&gt;
&lt;p&gt;体力活干完了，简单的SQL没有问题了，但是很快发现了一个大问题：&lt;strong&gt;重复列名如何区分？！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这在hibernate中根本无须考虑的事情，在mybatis中却成了一个麻烦的事情，而且是我完全没有预料到的。假设我有两个表questions和answers，它们都有一些通用的字段，比如id, content, created_at, user_id等等。如果我要写一个SQL，来读取questions以及它的answers，会写成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select q.*, a.* from questions as q left join answers as a on q.id=a.question_id order by q.created_at desc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;映射成pojo之后，发现answers中的很多字段都有问题，比如id, content, created_at，都是question的数据。原因是questions和answers中的相同字段名，只有第一个被多次使用，其它的被忽略。&lt;/p&gt;
&lt;p&gt;要解决这个问题，我想到两种办法，都不太好。&lt;/p&gt;
&lt;p&gt;一是手动将数据库中的字段名改成完全不重复的，所以questions中的id会变为question_id，content会变为question_content，created_at会变为question_created_at，answers和其它表中也这么改。&lt;/p&gt;
&lt;p&gt;二是不改数据库，而改sql语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select q.id as q_id, q.content as q_content, q.created_at as q_created_at, ..., a.id as a_id, a.content as a_content, a.created_at as
   a_created_at from questions as q left join answers as a on q.id=a.question_id order by q.created_at desc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样每个类似的SQL都要改，更是麻烦无比。&lt;/p&gt;
&lt;p&gt;我想这就是风格问题。从数据库管理员出身的程序员，因为数据库方面的限制，早已养成了自己的习惯：比如使用业务主键（所以各个表的主键名是基本上不同的），每个字段名都是不同的（比如加前缀），避开了字段名重复的问题，且不以此为苦。mybatis延续了这种风格，强调严谨、繁琐，正合他们的口味。而hibernate就会让他们觉得难以理解和使用。&lt;/p&gt;
&lt;p&gt;而普通程序员则追求的是代码的简洁、不重复、设计优良，所以倾向于使用非业务主键（基本上都叫id），简洁名称（所以会重复）。Hibernate就是为他们准备的，而mybatis会让他们觉得繁琐、啰嗦。&lt;/p&gt;
&lt;p&gt;正是这个问题，直接导致我不想再使用mybatis。为什么hibernate没有这个问题呢？因为hibernate的sql是自动生成的，它可以在生成的字段名前面加一些前缀之类，让每个字段都不重复。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Hibernate，谈性能</title>
                <link>http://freewind.in/posts/113-the-performance-of-hibernate</link>
                <pubDate>Tue, 13 Sep 2011 02:01:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">113</guid>
                <description><![CDATA[&lt;p&gt;我对Hibernate一直是相当抵触的，主要原因有三：设计复杂，调试困难，性能优化麻烦。前两点之前已经说过多次，这次再谈谈第三点。&lt;/p&gt;
&lt;p&gt;之所以突然想到写这个，是因为这几天使用hibernate写了一个小网站。数据表就几个，功能也相当的简单，但是刚刚做完后，我使用ab对首页进行了一下简单的性能测试，结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   E:\&amp;gt;ab -c 30 -n 1000 [http://localhost:9000/](http://localhost:9000/)
   Percentage of the requests served within a certain time (ms)
   50% 2219
   66% 2281
   75% 2328
   80% 2375
   90% 2453
   95% 2547
   98% 2672
   99% 2734
   100% 3016 (longest request)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，在30个并发请求下，差不多每个页面都需要2到3秒才能处理完，这个速度相当不理想。我第一时间想到了hibernate的N+1问题，因为我的代码中，没有对这方面进行过专门的处理，直接使用了最简单的方式来实现功能。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-113&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;于是我将play的application.conf中的debugSql设为true，以便在控制台上看到运行的sql。再次刷新首页，控制台上刷的流下一大堆SQL日志，数了一下，102条SQL。没错，102条。简单分析了一下，原来是在首页需要统计某些分类下的问题数量，我直接用了一个count方法去数据库取的，所以有多少分类，就至少有多少条count语句。现在数据库中的分类还比较少，可以想像再多一些以后，一个首页调用上千条SQL都是可能的。所以首页如此之慢，是必须的。&lt;/p&gt;
&lt;p&gt;当然，这可以说是我的设计问题。比如对于这种需要统计数量的，通常的做法，应该是在每个分类中增加一个count字段，当其下的问题增删之后，对它进行更新。查询时，直接使用它的值即可。另外，关于N+1问题，我们也可以通过预先fetch来避免。&lt;/p&gt;
&lt;p&gt;我想这些都是可行的，只要你对hibernate掌握得够熟练，你不光可以使用这些优化手段，还可以再利用上它的缓存系统，再次优化性能。另外，对于不经常变动的页面，还可以使用页面缓存，那样的话，就更快了。但是我觉得麻烦之处，不是在这里。而是在于思考重心的矛盾。&lt;/p&gt;
&lt;p&gt;Hibernate的目标，本来是为了简化持久层的操作，让我们面对pojo，不需要再关心它下面的数据库（卖点之一是可以随意更换数据库，只需要修改一下配置文件及少数使用了与特定数据库的SQL语句即可）。所以我们在使用Hibernate时，会把思考的重心放在pojo上，以面向对象的方式来设计结构良好的pojo们，而数据库在hibernate的刻意掩饰下，似乎变得无足轻重（比如你甚至可以不关心到底生成了哪些字段）。的确，Hibernate初用起来，感觉很好。对于简单的增删改查，非常方便，基本上调用几个方法即可。对于复杂一些的查询，使用它提供的HQL查询语句，也可以写出来。在不关心性能的情况下，一切都很美好。&lt;/p&gt;
&lt;p&gt;但是现实是残酷的，除非这网站只给自己用。一旦数据量多一些，访问人数多一些，性能瓶颈马上就可能出现。对于性能问题，通常我们都会去分析使用的SQL，比如是否有N+1，是否可以把几个SQL取得的数据一次取出，数据库的结构是否需要调整等等。此时才发现，TMD，之前hibernate口口声声对我说：&amp;ldquo;有我在，你不用考虑数据库了&amp;rdquo;，到最后，还是得去分析数据库，然后再根据问题，去调整pojo的结构、查询语句等。之前的&quot;以pojo为重心&amp;rdquo;，到最后还是要回到&quot;以数据库为重心&amp;rdquo;，甚至双重心。于是，最开始简单优雅的代码，被改得复杂；某些地方，需要使用SQL代替之前写的HQL；最要命的是，hibernate的SQL是动态生成的，必须在日志中才能看到最终的真实SQL，调试起来简直头大无比。&lt;/p&gt;
&lt;p&gt;这个时候会觉得，之前看起来那么优雅的代码，现在成了累赘，一方面想保持它，一方面又难免要破坏它。矛盾吧，是不是有种被欺骗的感觉？原以为可以从数据库中解脱出来，最后发现仅仅是为了少写几句代码，得多学习一整个框架，代码还弄得不沦不类。优化性能的时候，不但要考虑数据库，还要去考虑hibernate，更累了。&lt;/p&gt;
&lt;p&gt;如果在一开始，我们就以数据库为重心，则写每一条SQL时，都会自然而然地想到性能问题，这样就可以避免大部分的性能问题。而且，因为每一条SQL是都固定的，都是自己手写的，比较放心，还可以利用数据库的工具，去分析它是否存在性能上的问题。不像hibernate，一个大圈回到了原点，问题还更加复杂了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>关于页面布局，用div还是table</title>
                <link>http://freewind.in/posts/112-page-layout-use-div-or-table</link>
                <pubDate>Tue, 13 Sep 2011 02:00:45 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">112</guid>
                <description><![CDATA[&lt;p&gt;有时候追求技术的纯粹性，是一件费时费力的事情，特别是某些技术在某些方面设计得不够好的时候。比如说，页面布局，是用div+css，还是用table?&lt;/p&gt;
&lt;p&gt;记得上大学刚学做网页时，好像css用得很少，那时候布局基本上就一个选择：table。利用table的单元格td，将页面分成几块，里面再套table。&lt;/p&gt;
&lt;p&gt;这种方式挺古老，但是很好用：比如，你把table的宽设为100%，再将其中某些列的宽度设个固定值，则其它没有设值的，就会自动占满剩余空间。每一行的各单元格，总是拥有相同的高度。在一个单元格内，可以方便的设置其align，即里面的内容是靠左靠右，还是靠上靠下。我们可以很轻松地利用它做出一些复杂的页面布局，虽然用的标签稍有点多。&lt;code&gt;(table &amp;gt; tr &amp;gt; td )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大约是毕业那会儿，突然css流行起来了。人们仿佛一夜之间，发现了css的强大，于是那种复杂的效果都出来了，网页也越来越漂亮。&lt;/p&gt;
&lt;p&gt;有人说，我们做网页时，html是用来放数据的，而css是用来放样式的，不能混在一起。html中的标签是有语义的，比如table，它表示的是一个数据表格，是用来放数据的，而不是布局的。要布局，一定要用div+css这种方式，这才是纯粹的css用法。而且，div+css还有其它的好处，比如你要更改页面，把这一块放在那一块的前面，只需要改改css即可，而不用动html，这多好。&lt;/p&gt;
&lt;p&gt;好吧，我承认这的确很有吸引力，于是开始学着用div+css来布局。然而，很快发现，这东西怎么这么难以理解？要理解div的定位方式&lt;code&gt;absolute&lt;/code&gt;, &lt;code&gt;relative&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;，要理解它的流布局，以及方向&lt;code&gt;floa&lt;/code&gt;t，还有换行&lt;code&gt;clear&lt;/code&gt;，还有&lt;code&gt;margin&lt;/code&gt;的设置，还要解决IE6的某些bug，以前不同浏览器上的显示差异。我只想做一个简单的左右两列布局，左列固定右列自动占满剩余空间，并且两列等高。这用table一分钟完成的任务，用div搞了一天都没搞定。&lt;/p&gt;
&lt;p&gt;上网搜索一下，发现这的确是个大问题，无数的人在问怎么写。当然也发现了一些解决方案：比如一些网站，列出了一些常见布局，直接下载它写好的css。还有就是960.gs/blueprint等，居然是专门的布局框架，只需要用它定义好的一些css类，就可以方便地做出布局。（这在table时代是没有的，可以说是制造问题再解决它）&lt;/p&gt;
&lt;p&gt;我很认真地学习了它们，并且在自己的项目中使用了960.gs，效果还不错。但是，总是感觉手脚被绑着。比如，它推荐的布局方式是宽960px，分成12列（可调整），这表明我无法弄一个占满页面100%宽度的布局出来。而且，把页面分成12列，大多数时候够用，但是一旦需要一些不规则的宽度，那就相当的头疼。但是我一直认同那种观点：布局应该是css的事情，这样比较纯粹。&lt;/p&gt;
&lt;p&gt;直到前某几天，突然想做一个很简单的网站，不想再拷960gs过来，就偷个懒用table吧。当我花了几分钟把布局做好之后，我愣住了－－竟然这么轻松！之前用div+css费老劲做出来的布局，用table两下子搞定了！&lt;/p&gt;
&lt;p&gt;仔细想想，之前用960gs那么麻烦的布局，最终也只能得到一个近似table的效果。而且难度、复杂度远高于用table，可维护性反而更差（因为太复杂）。以前期望的优点没有得到，反而更麻烦了。这样做，唯一达到的效果就是：看，我的布局全是div+css搞定的，没有用table！牛B吧！&lt;/p&gt;
&lt;p&gt;之所以会产生这样的情况，是因为css关于布局这一块，没有设计好。使用div进行定位、大小控制、缩放方面，比较麻烦，而且各浏览器的实现情况不一样，容易产生不同的布局效果。如果它设计得更好一些的话，我想我们是可以抛开table，大胆使用div+css布局。&lt;/p&gt;
&lt;p&gt;在当前的现实情况下，某些时候使用table方便，某些时候使用div+css方便。对于同一个网页，有多种显示效果的（比如博客），应该尽量使用div+css，因为虽然麻烦一些，但可以通过css定义出产生非常自由的效果。而对于普通网站，不妨直接使用table，因为简单方便，容易控制。&lt;/p&gt;
&lt;p&gt;写了这么多，只是想强调：大多数的技术都不够完美，都有自己擅长和不擅长的地方。如果你不去思考，只是为了用而用，会很辛苦。更不能因为想用某一种技术，就盲目地认为它是最好的，其它的看都没看就否认了。我们的选择标准，应该是：简单、方便、快捷，稳定。至于到底用了什么技术，一点也不重要。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>一个艰难的决定：终止zhidao.it的开发</title>
                <link>http://freewind.in/posts/111-a-hard-decision-stop-zhidao-it</link>
                <pubDate>Tue, 13 Sep 2011 02:00:07 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">111</guid>
                <description><![CDATA[&lt;p&gt;本来打算今晚早睡，结果又没睡成，因为我终于做出了一个艰难的决定：&lt;strong&gt;终止zhidao.it的开发&lt;/strong&gt;。作为我努力了近一年的事情的终结，我必须回忆一下，以表达我的深切哀悼。&lt;/p&gt;
&lt;p&gt;在一年另两个月前，我偶然知道了Stackoverflow.com这个网站，当我用蹩脚的英语花了半个小时，在上面发出了我的第一个问题之后，我震惊了。因为困扰了我几个小时、在国内网站上很难找到答案的问题，在不到十分钟的时间里，就有人给出了详细而专业的答案，解决了我的问题。&lt;/p&gt;
&lt;p&gt;在那一刻，我激动地跳了起来。因为我觉得自己压抑多年的想法，终于有了实现的可能性。&lt;/p&gt;
&lt;p&gt;我在大学时，编程方面的知识差不多都是自学的。每次遇到问题，除了看书、网上查资料，就是在各论坛里求人。可惜的是，要么一天过去都没人理，要么就是几句简单模糊的回答，我还得小心翼翼的追问，生怕别人不耐烦。到后来，基本上放弃了提问，因为知道那是白费时间。所以我基本上都是自学的，走了很多弯路，而且还学得没深度。&lt;/p&gt;
&lt;p&gt;那个时候，我就想做一个网站，专门为像自己一样的程序员提供一个问答与交流的场所，让我们可以“在最短的时间内得到最满意的答案”。但是我想了很久，也没有想到一个可行的方案。所有的想法，都无法解决“有人问，还得有人答”的问题。一直到毕业四年后，看到了Stackoverflow.com的那一刻，我终于看到了希望。&lt;/p&gt;
&lt;p&gt;Stackoverflow的方式很好，它的确达到了我期望的效果，而且，它是英文的。对于国内大多数英文不怎么样的程序员来说，Stackoverflow太难了，如果有一个中文版，大家都用中文来交流，岂不是一件很幸福的事情？而且当时国内知道这个网站的人还不多，所以做一个中文版出来，还是很可行的。&lt;/p&gt;
&lt;p&gt;所以我马上开始开发，打算两到三个月完成，然后慢慢推广，不断完善。同时跟我爸说了这个想法，我爸非常支持，并且决定给我一年的时间折腾，甚至资金上的支持。&lt;/p&gt;
&lt;p&gt;可是计划是美好的，现实是残酷的：&lt;/p&gt;
&lt;p&gt;1。校友录项目、回家、买房、装修等等，耽误了我太多的时间。有时候一个月能坐下来写代码的时间只有几天。直到这几个月，才有了全天的时间来做。&lt;/p&gt;
&lt;p&gt;2。把网站的功能做出来不难，但是要让它快速、稳定、安全，才是真正的难点。从最开始访问服务器上的网页，需要7秒，到现在的不到1秒，我对网站不知道进行了多少次的优化。&lt;/p&gt;
&lt;p&gt;3。年初花了5000多买了一台电信的服务器，想着应该够用了。结果网站放上去才发现中国的网络环境如此之差，电信与网通的网络距离甚至超过了中国到美国。网通用户访问网站时，经常半分钟打不开网页，害得我天天想办法解决这个问题，最终的结论是，这5000块白瞎了，我得重买个双线的、至少7000以上的，才能用得放心。&lt;/p&gt;
&lt;p&gt;这些问题让我非常郁闷，原打算两个月左右完成的功能，花了9个月。而且现在还不敢推广（因为还没有换服务器）。&lt;/p&gt;
&lt;p&gt;在做这个网站期间，尝试着做一些小范围内的推广。比如经常向常去的几个群里，报告一下开发进展。或者主动去一些技术交流群，回答别人的问题，然后记录在zhidao.it上，引导他们去看。还有各搜索引擎等，也都做了sitemap。但是效果非常不好，发现人们来一两次之后，就不来了，基本上都是我在自问自答。&lt;/p&gt;
&lt;p&gt;我开始一直把问题归结于网速太慢、没有做宣传，以及功能不够贴心，但是后来慢慢发现，这些的确是问题，不过还有更重要的问题：我没有让Stackoverflow在国内成功的影响力、能力以及资金。就算是现在把Stackoverflow的代码给我，硬件配好，交给我运营，我也没有办法让它成功。因为我还是没有办法解决那个“有人问，还得有人答”的问题。&lt;/p&gt;
&lt;p&gt;看一下Stackoverflow的发展过程，为自己的失败找点原因（或者借口）。Stackoverflow的两位创始人，可以说是技术上的牛人，即有影响力，又有能力，而且对开发人员的需求理解很得透彻。他们为Stackoverflow设计的功能、规则，达到了提问者与回答者的双赢，其中的几个关键特性，是环环相扣的。所以，当网站做好以后，以他们的影响力，可以吸引不少有同样影响力的人参与进来。而他们的技术，以及与用户之间的交流，又可让各功能做得十分好用且贴心。如果有兴趣，可以搜索一下“Stackoverflow为什么成功”，看看详细情况，以及它的那九大特点。 同时还需要特别注意的是，在那个专门用于Stackoverflow与开发人员交流的meta栏目里，竟然有25000多个问题，这也是它的功能为什么做得如此贴心的原因。&lt;/p&gt;
&lt;p&gt;但是我现在只能做到简单的模仿，甚至某些我觉得很重要的功能，我都做不出来（比如“精确”的“相关问题”，如何用算法判定一个问题的热门程度，等等）。我更没有影响力号召人们参与进来，更没有能力改变国内的程序员的交流习惯。不仅我做不到，我想国内应该没有人能够通过直接模仿Stackoverflow而成功，虽然现在类似的网站已经有十来个。因为如果想成功，必须对Stackoverflow的规则进行一些适合国内现状的更改，而这种更改的难度，恐怕没人能做到。有些必须的条件，在国内不知道还需要多少年，才能在程序员中培养起来。&lt;/p&gt;
&lt;p&gt;我常常觉得csdn里的问答，实在太没有效率，而iteye里的管理，又太专制，还有不少人讨论时的语气很装B。可是不能不承认它们在国内程序员界的地位。也许他们现在的状态，才最符合中国国情。可能他们也想改变，但同样拿不出更好的方案。&lt;/p&gt;
&lt;p&gt;所以我终于做出了这个决定，虽然很艰难，但总算看清楚了，失败得很踏实。&lt;/p&gt;
&lt;p&gt;我还是非常希望能有一个这样的或者类似的网站，能让国内的程序员们能够交流得更有效率一些。在国内，英语不好的程序员们，实在是太辛苦了。我这段时间加了十来个Java群，力所能及的回答别人的问题。看到有些人问了问题之后，很久都没有一个人回答，就让我想起了以前的我，所以会尽量帮他们。但是我很快发现，在QQ群里的回答，没法积累。一个问题，第一次回答，帮助了一个人。不久又有人问类似的问题，后来实在没有心情去回答了。这就是为什么技术群里到后来，都成了聊天群，或者无声群。&lt;/p&gt;
&lt;p&gt;我无力改变这种情况，至少目前没有办法。那就不要多想了，以后不会再为了那些技术问题或者zhidao.it的发展吃不好饭睡不好觉了。好好过一过规律且放松的日子，不会像现在这么熬夜了。&lt;/p&gt;
&lt;p&gt;现在觉得，做网站，或者别的其它什么东西，技术只是工具，到最后反映的都是对社会、对人心、对文化、对需求的把握。这些东西是需要交流、生活、体验、思考、积累，也许还有天赋，才能得到的。我要做的，是改变现在的唯技术论的心态，改变生活状态，同时不放弃理想，也许会在未来的某一天，以另一种方式，实现我的想法。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>使用linux下的命令简化工作</title>
                <link>http://freewind.in/posts/110-use-linux-commands-to-simply-work</link>
                <pubDate>Tue, 13 Sep 2011 01:59:16 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">110</guid>
                <description><![CDATA[&lt;p&gt;linux下有很多神奇的命令行小工具，功能强大，使用灵活方便，学会使用它们可以让我们的工作简单而高效。&lt;/p&gt;
&lt;p&gt;比如今天，我需要把一个csv格式的文件，从第二行开始，把每行的第一列取出来，保存在一个单独的文件中。之前遇到这样的任务，我会写一个java程序，读取文件的每一行，分解为数组，取出每一个元素，保存在一个list中，再写到另一个文件。虽说代码也比较简单，但是每次遇到这样的任务都要写一次，也相当不便。我发现linux下有两个小工具：&lt;code&gt;sed&lt;/code&gt;和&lt;code&gt;awk&lt;/code&gt;，处理这种操作非常方便。&lt;/p&gt;
&lt;p&gt;但我现在是在windows下，怎么使用呢？好在这些小工具基本上都有windows的版本，很快就找到了。&lt;/p&gt;
&lt;p&gt;下面编写命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat c:\data\1.csv | sed &quot;2,$p&quot; -n | awk &quot;BEGIN {FS=\&quot;,\&quot;} print $1&quot; &amp;gt; ids.txt 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搞定。&lt;/p&gt;
&lt;p&gt;简单说明一下，这一句其实是由三个命令组成，它们之间用&amp;rdquo;|&amp;ldquo;分隔开，&amp;ldquo;|&amp;ldquo;的作用是把前一个命令的输出转为下一个命令的输入。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cat c:\data\1.csv&lt;/code&gt; 读取1.csv文件的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &quot;2,$p&quot; -n&lt;/code&gt; 输出第2行到最后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;awk &quot;BEGIN {FS=\&quot;,\&quot;} print $1&quot;&lt;/code&gt; 设置逗号为分隔符，只打印每一行的第一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt; ids.txt&lt;/code&gt; 把结果保存到1.txt文件中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个过程还是相当清晰明了的。特别是，sed和awk还有很多灵活的参数，可以组合在一起，实现更复杂一些的功能。相比使用java来写程序，不需要开编辑器，不需要配置，不需要编译，仅仅写一行命令即可，实在是太方便了。&lt;/p&gt;
&lt;p&gt;注意看第3行，如果是在linux中，可以写成：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;awk &apos;BEGIN {FS=&quot;,&quot;} print $1&apos;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;的，而不像windows下，只能使用双引号，中间的双引号还需要用&lt;code&gt;\&quot;&lt;/code&gt;来转义一下，不太方便。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>postgres的客户端</title>
                <link>http://freewind.in/posts/109-the-admin-tool-of-postgres</link>
                <pubDate>Tue, 13 Sep 2011 01:58:36 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">109</guid>
                <description><![CDATA[&lt;p&gt;Postgresql自带了一个pgAdmin的管理程序，提供了一些基本且常用的功能，我一直用它，而且以为只有它。可惜它提供的功能，有时候有点太简单了，稍复杂一点的，操作起来异常麻烦。比如，我以前建立的外键都是on delete on action的，现在想把它改为on delete set null，需要先删除原有的，再新建一个。其实仅仅是想更改一个属性而已，但是我要做一大堆的操作才能完成。我改了两三个以后，看着还有三十来个，决定找找看，有没有别的工具。&lt;/p&gt;
&lt;p&gt;首先想到的是phppgadmin这个东西。既然phpmyadmin这个程序人人皆知，想必phppgadmin也不会差到哪儿去。下载后，解压到web目录，再配置APMServ，却总是提示“你的php不能完全支持postgresql”。经过好一番搜索，也没找到解决方法。最后发现，还不能使用postgres8.4自带的那个168K的libpq.dll，而是从别处找到一个96K的，放过去，才正常。进去之后，看到功能也挺全的，可惜对于外键，也只有删除新增，而没有修改。&lt;/p&gt;
&lt;p&gt;最后在万能的stackoverflow上，找到了一个问题：
&lt;br  /&gt;http://stackoverflow.com/questions/105788/good-postgresql-client-for-windows&lt;/p&gt;
&lt;p&gt;里面提到了一个Postgresql Maestro，它是一个收费的，但好评不好。下载后，发现它有30天的试用。安装后试用，果然不错，对得起收费两字。使用它可以很方便地更改外键，很满意，三两天就改完了。还有很多其它的功能，暂时用不到。&lt;/p&gt;
&lt;p&gt;网址是：http://www.sqlmaestro.com/products/postgresql/maestro/&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>spring mvc，吐个槽</title>
                <link>http://freewind.in/posts/108-spring-mvc-is-not-so-good</link>
                <pubDate>Tue, 13 Sep 2011 01:57:59 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">108</guid>
                <description><![CDATA[&lt;p&gt;昨天做的这个项目是一个spring mvc下的controller的实现。代码写好后，该写demo了，是一个简单的spring mvc的web程序。因为mvc的结构都差不多，而且我几年前也用过一段时间的spring，所以想想这应该不难，到网上找个例子，把配置文件配好就差不多了。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-108&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;结果却花了我两个小时，几乎所有的时间都花在了spring的配置上。spring使用xml作为它的配置文件，而且还在xml中玩出了花。虽然其语法还不是怎么麻烦，但是，在定义各个bean的时候，它里面有很多约定的东西，比如哪个类的bean是一定要配置的，就算没有被人引用；哪个bean要赋给另一个bean的；对于流程中的每一步，都给出了一个堆的可选项，让我不知道选哪个好。
&lt;br  /&gt;&lt;p&gt;我要做的很简单：定义了一个MultiActionController的controller，它可以处理多个url的请求。我想让spring根据url的不同，自动寻找该controller对应的方法名去处理，这是最常见的一种处理方式了。然而我在网上搜了不少教程，一个个试下去，却总是提示找不到url的映射。
&lt;br  /&gt;&lt;p&gt;spring的提示也真够简洁，就算我已经把log设置为trace了，它还是只会提示：找不到，找不到，找不到。
&lt;br  /&gt;&lt;p&gt;好在最后找到了一个例子，作者的需求跟我一样，并且都讲在重点上，我按着他的做法，终于成功。两个小时啊，都花在这里去了。&lt;a href=&quot;http://www.blogjava.net/wangqi/archive/2007/12/24/66845.html&quot;&gt;http://www.blogjava.net/wangqi/archive/2007/12/24/66845.html&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;难怪人们都说spring的配置文件是“xml地狱”，这些xml，既有各种各样的语法，定义bean时还有一些特别的约定，还不能使用编辑器的提示功能（比如设置某个bean的属性），让人一看，心里就产生一种畏惧感。这些xml，写错一个地方，程序就跑不起来，而且提示信息可能还没什么用，只能靠长期犯错积累的经验来解决。
&lt;br  /&gt;&lt;p&gt;另外，把做这个项目的感觉与用playframework做网站的感觉相比，playframework的开发效率真是高了三五倍不止啊。
&lt;br  /&gt;&lt;p&gt;再另外，spring大力提倡的IoC思想，对于测试来说，真的是非常方便。配合上mockito这个好用的mock库，写起单元测试，基本上没有遇到什么困难。看来我以后得好好研究一下另一个IoC框架，guice，它可不需要像spring这样，满天的xml配置。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala啊scala</title>
                <link>http://freewind.in/posts/107-scala-scala-scala</link>
                <pubDate>Tue, 13 Sep 2011 01:57:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">107</guid>
                <description><![CDATA[&lt;p&gt;我的scala群里越来越冷清了，这两天没有一个人说话。另一个scala群里，也是偶尔一两人。想到三个月前的时候，那时还是相当的热闹。群里的爱国者天天搞scala，唐古拉山也在研究，我也兴致勃勃地想写一个scala的mvc框架出来。然而现在，爱国者搞nodejs去了，唐在观望，我也因为受不了修改重启的折磨，又转到java下了。还有闪电侠，曾经也打算看看scala，现在则彻底转向python了。现在应该就只有一个Nil还在坚持热爱着scala吧。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-107&quot;&gt;&lt;/span&gt;
&lt;br  /&gt;&lt;p&gt;至于群里其它的朋友，大多出于好奇试试，几天就放弃了。我曾经相当看好scala，还鼓动唐升华一起来学习，现在看来，还是太武断了。scala看起来很好，但是有很多地方难以让人满意：编译时间奇慢无比，没有一个成熟又好用的web框架，编辑器支持还不够理想，与java交互时麻烦很多，对电脑配置要求很高（eclipse的scala插件，要想流畅运行，需要给它分配1.5G内存）。还有，它的文档，写得如天书一般（有点像学术论文），很难看完一个函数的注释，就知道怎么去用。我一般都是先查文档，再到网上搜示例，才知道怎么用。
&lt;br  /&gt;&lt;p&gt;还有官方推荐的web框架liftweb，我只能说，太高端了。用一位网友的话来说：“你很少能遇到一个像它这样，框架比语言本身还复杂的框架”。那些能把liftweb玩熟练的人，绝对个个都是大师级。
&lt;br  /&gt;&lt;p&gt;现在play正在大力向scala挺进，模板、orm都搞出来了，马上要发布play-scala1.0，不知道是否能做到像它的java一样热修改。希望play能够成功。我很佩服play的作者，因为他很有创造力，很善于扬长避短，将各个工具的优势发挥出来，提高开发效率。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala，离天堂只差一步</title>
                <link>http://freewind.in/posts/106-scala-the-last-weakness</link>
                <pubDate>Tue, 13 Sep 2011 01:56:38 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">106</guid>
                <description><![CDATA[&lt;p&gt;　学用scala两个月了，遇到很多问题，也有很多惊喜。scala功能强大，语法灵活简洁，让我深受震撼。现在再让我去写java代码，心理特别抵触，觉得java代码太繁琐了。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　如果不需要考虑与java的交互，使用scala是一件美妙的事情。写代码时，感觉如行云流水，特别顺畅。一些在java中做起来很复杂的功能，这里很轻松就做到了，这种感觉特别好。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　然而，离天堂只差一步。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　scala中的第三方库还是太少了，很多时候，都必须使用java的库。比如数据库orm，mongodb的orm，还有其它一些。scala虽然号称与java无缝集成（因为scala的代码将被编译为java字节码），但是在使用过程中，常常会出现各种稀奇古怪的问题。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　比如我在java中常用的Ebean，在java下一切正常，在scala里，简单地用起来也正常，突然有一天发现有一个重要的功能，在scala里就是得不到正确结果（可能跟Ebean在后面对java字节码进行了增强有关）。
&lt;br  /&gt;&lt;p&gt;　　郁闷之下，不用关系数据库了，换mongodb。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　java里有一个mongodb的orm，叫morphia，在java里用起来很爽，在scala下，开始也正常。但是有一天，我想把本来定义在class中的字段放到trait中以重用，可惜morphia报错，找不到trait中的那些字段的类型。如果不能用trait，我干脆直接用java算了。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　折腾了几天，还是没有好的解决方法，正郁闷着，突然今天群里有人介绍了一个orientdb。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　一看它的演示文件，这可是个好东西，专为web设计的高性能数据库，直接保存pojo，不需要转来转去。非常激动，如果能用的话，那我可以省很多事了。赶快用scala写了一个简单的例子。可惜竟然编译不过！
&lt;br  /&gt;&lt;p&gt;　　经过检查，这是一个诡异的错误。因为从java的角度看，那些代码没有任何问题。如果在scala中实现类似的功能，也不会有问题。可是从scala中调用java中的那个方法，就会出问题。像这样的问题，真是让人想解决都无从下手。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　这就是scala的现状。无异，scala本身是优秀的，它的很多设计都是纠正了java中的一些不好的做法。但是它还是太年轻了，使用纯scala写的库太少，有时候必须使用java的库。这时候，两者之间的不匹配会给我们带来很多麻烦：&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;1. 两者的集合类不同，必须经常转来转去，这是一个异常繁琐的过程
&lt;br  /&gt;&lt;p&gt;2. java中使用null，而scala推荐使用Option。这两者处理起来方式不同，两种风格不断冲突
&lt;br  /&gt;&lt;p&gt;3. java代码中如果某一个函数有重名函数，并且使用了可变参数，在scala中，很可能不能直接调用，而得用一种丑陋的方式去转换
&lt;br  /&gt;&lt;p&gt;4. 如果java中的代码，使用了一些偏门的语法或技巧（比如大量使用反射，cglib后台增强之类），这些代码很可能在scala中无法正常运行。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;这种感觉，就好像我们正看着喜欢的电视剧，突然蹦出一段广告。如果一两次还能忍了，可惜像我这样做网站的，使用的是java的orm，那就意味着三分钟一段广告。&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;　　想到之前scala火了一阵，之后使用者又减少了，我想原因就是我现在遇到的情况：使用scala的确很爽，但是我们的工作，必须用到很多java库。这种情况，使用scala带来的麻烦实在太多，还不如用java吧。
&lt;br  /&gt;&lt;p&gt;　　真可惜，scala离天堂只有一步。这一步，不知道需要多久的时间，才能跨过去&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>scala一周研究成果</title>
                <link>http://freewind.in/posts/105-scala-after-a-week</link>
                <pubDate>Tue, 13 Sep 2011 01:56:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">105</guid>
                <description><![CDATA[&lt;p&gt;其实有十五天了，但这些天过年比较忙，实际能看书编码的时间不多，算一周吧。回家后没网可上，便专门从卓越上买了本书，叫“scala编程”，花了60多。前面翻译的还行，后面就有点拗口，看着郁闷了。&lt;/p&gt;
&lt;p&gt;对于scala，我的感觉真是非常之好。在结合了函数式编程风格之后，与java相比，scala在代码的简洁性方面，有了质的提高。从前在与java代码时，经常会有一些代码写了千百遍，但是每次都不得不写，而现在，通过新的语法，一下子就简化了，再没有什么废话。在scala中新增加的那些特性，比如伴生类伴生对象，trait，case class，函数值的传递，闭包，以及DSL，都让人爱不释手。记得看到有人说：用了一段时间的scala之后，java代码都不会写了。我也觉得使用了scala之后，不想再去写java了。&lt;span id=&quot;more-105&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之前使用的play因为魔术代码太多而不再使用，这段时间又去寻找新的东西。scala下的新东西很多，但是成熟的不多，毕竟真正流行起来的时间还不长，不过还是发现了很多让人振奋的东西。现在在寻找一套基于scala的web开发框架，正在尝试以下各库及框架：&lt;/p&gt;
&lt;p&gt;一、sbt&lt;/p&gt;
&lt;p&gt;这是一个基于scala的项目生成、管理工具，有点像scala版的ant，但是远比ant好用且智能。进入其控制台后，可以自动去下载依赖文件、编译、运行、测试、发布等。还可以设置“当源代码发生变化时，立刻执行某操作（如编译、测试）”等。通过它，大大简化了编译、运行及测试scala代码的难度，相当好用，有前途。&lt;/p&gt;
&lt;p&gt;二、circumflex-orm&lt;/p&gt;
&lt;p&gt;这是一个由俄罗斯人写在的一站式的web开发框架，里面有mvc模块、orm模块等，网址是&lt;a href=&quot;http://circumflex.ru/&quot;&gt;http://circumflex.ru&lt;/a&gt;。当前基于scala的orm有两个，一个circumflex-orm，一个是squeryl，两者相比，我觉得circumflex的代码风格更好一些，看过它们两个的使用示例即可感觉到。我下载了circumflex的源代码，大略看了一下，感觉它的文档和注释写得很不错，代码的构造也相当的巧妙。这段时间便开始使用它，写一些简单的类，以及相关的单元测试，通过单元测试来学习它的使用。其中遇到了不少问题，好在通过在google group中的交流，基本上都得到了解决，也学到了不少。感觉作者对于scala的研究很深，所以才能写出这么好用的api。&lt;/p&gt;
&lt;p&gt;有一点需要注意，circumflex只提供了对postgresql的直接支持，如果使用别的数据库，还需要提供额外的dialet（可到网上搜搜看有没有别人已经写好了）。好在我一直用的是postgresql，所以这不是问题。&lt;/p&gt;
&lt;p&gt;三、circumflex-web&lt;/p&gt;
&lt;p&gt;基于scala的web框架，目前有4个比较好。一是官方推荐的liftweb，二是playframework，三是scalatra，四是circumflex-web。经过我的研究与比较，我觉得liftweb太笨重难用，其代码看起来很费力，pass；playframework虽然支持scala，但是底层还是java，还是有大量的魔术代码，pass；scalatra和circumflex-web差不多，都是很简洁明了的风格，功能也都差不多，所以就选择了circumflex-web。这样有问题了在一处问即可，还是很看好circumflex的（除了这个名字，没起好，不好读不好记）&lt;/p&gt;
&lt;p&gt;四、view层&lt;/p&gt;
&lt;p&gt;scalate比较火热，提供了多种风格的语法供使用，其中的jade风格我比较喜欢，所以到时候就尝试使用它吧。如果不行，再试试freemarker，毕竟它的“宏”功能我比较喜欢，eclipse有编辑器插件支持，circumflex也提供了直接的支持。&lt;/p&gt;
&lt;p&gt;五、单元测试&lt;/p&gt;
&lt;p&gt;scalatest这个东西不错，我很喜欢，提供了多种DSL，供喜欢不同风格的人使用。稍加练习之后，即可上手。现在还是通过sbt来运行测试代码的，改天有空研究一下，如何让它在eclipse中直接运行。&lt;/p&gt;
&lt;p&gt;六、编辑器&lt;/p&gt;
&lt;p&gt;又简单尝试了一下各编辑器的表现，eclipse，idea，netbeans，vim，notepad++等等，都简单用了一下。发现相对于eclipse，idea和netbeans的支持也都差不多，好不到哪儿去，而vim,notepad++又没法利用编辑器的实时查错功能，所以到最后还是使用eclipse来吧。&lt;/p&gt;
&lt;p&gt;七、版本控制&lt;/p&gt;
&lt;p&gt;回家时，把代码都拷到了移动硬盘上，这段时间在笔记本上，不同的网吧的电脑上编码，真是多亏了git。分布式提交版本控制，的确是使用方便啊。同时又经常使用github.com，那就继续使用git吧，不用再看到那一大堆讨厌的.svn目录了。&lt;/p&gt;
&lt;p&gt;上面七个差不多把web开发需要的东西都包含了，剩下的时间就是继续学习、继续研究，继续搞我的网站。&lt;/p&gt;
&lt;p&gt;说到scala的不方便之处，有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编辑器支持不佳，除了实时查错外，其它的功能基本无用，并且编辑器会经常卡一下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译速度慢。相比java，要慢不少，感觉明显。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数式风格，与面向对象的风格，相差巨大，需要一段时间的学习和适应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>haml – rails的新view层模板</title>
                <link>http://freewind.in/posts/104-haml-rails-new-view-template-engine</link>
                <pubDate>Tue, 13 Sep 2011 01:54:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">104</guid>
                <description><![CDATA[&lt;p&gt;http://haml-lang.com&lt;/p&gt;
&lt;p&gt;表现层是一个web框架中最重要，却又最被忽视的一层。人们把精力都放在了MC，后台部分已经很完善了，但是前台V，即表现层，却一直没有太多改进。对于表现层，人们总希望&quot;页面中不要嵌入逻辑代码，内容要与样式分离&amp;rdquo;，但是由于难度大，或者后台语言的限制，这个目标很难达到。可以说，我之前见过用过的大多数表面层，做的都不太好，如jsp, asp, php, velocity, freemarker, rails erb等等。&lt;/p&gt;
&lt;p&gt;而haml的出现，则让我有了一点惊喜：内容跟样式分离得如此彻底，代码却又如此清晰。虽然对于纯美工MM来说，不是个好消息（完全无法使用dreamweaver等工具），但对于程序员来说，却是非常的贴心。&lt;/p&gt;
&lt;p&gt;初看下，这种模板语言有点怪异，没有出现一个html tag，写起来好像在写配置文件。但是很快就会发现，没有了众多html tag的打扰，可以如此专注的把精力放在内容上，完全不用考虑样式，的确可以让开发效率大大提高。内容全部交给haml，样式全部交给css，各司其职。这种大胆前卫的设计，真的是非常具有想像力。&lt;/p&gt;
&lt;p&gt;贴段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#profile
  .left.column
  #date= print_date
  #address= current_user.address
.right.column
  #email= current_user.email
  #bio= current_user.bio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它将被解析为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;profile&quot;&amp;gt;
  &amp;lt;div class=&quot;left column&quot;&amp;gt;
  &amp;lt;div id=&quot;date&quot;&amp;gt;${print_date}&amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;address&quot;&amp;gt;${current_user.address}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;right column&quot;&amp;gt;
  &amp;lt;div id=&quot;email&quot;&amp;gt;${current_user.emil}&amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;bio&quot;&amp;gt;${current_user.bio}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对比上下两段，是否觉得前面的代码更让人把注意力集中在内容上？&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>mongodb</title>
                <link>http://freewind.in/posts/103-about-mongodb</link>
                <pubDate>Tue, 13 Sep 2011 01:53:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">103</guid>
                <description><![CDATA[&lt;h2&gt;mongodb是什么&lt;/h2&gt;
&lt;p&gt;http://baike.baidu.com/view/3385614.htm&lt;/p&gt;
&lt;h2&gt;主页&lt;/h2&gt;
&lt;p&gt;http://www.mongodb.org/&lt;/p&gt;
&lt;p&gt;由介绍可知，这是一种与传统的关系数据库不同的数据库，跟google、amason等提供的数据存储方式很像，不用建表，而是根据&lt;strong&gt;key-value&lt;/strong&gt;的方式存储。key是一个个字符串，而value可以是复杂的数据类型。感觉跟哈希表有点像。另外，它是分布式的。&lt;/p&gt;
&lt;p&gt;为什么用它，而不用传统的数据库呢？好像是从这几年开始，这种&lt;strong&gt;NoSQL&lt;/strong&gt;类型的数据库流行起来，原因应该是它速度快，性能好，能比关系型数据库支持更大的负载，使用简单（不需要sql），对于网站这样的应用也比较适合（没有复杂的报表）。跟它类似的还有一个叫couchdb的数据库。&lt;/p&gt;
&lt;p&gt;mongodb&lt;strong&gt;授权基于AGPL&lt;/strong&gt;，详情请看&lt;a href=&quot;http://www.mongodb.org/display/DOCS/Licensing&quot;&gt;http://www.mongodb.org/display/DOCS/Licensing&lt;/a&gt;. 我的英语不太好，没看太懂它的意思。感觉好像是比较宽松，只要不改它的源代码，就不需要自己开源，也不需要付费。但是为了保险，还是问了一下：&lt;/p&gt;
&lt;p&gt;http://stackoverflow.com/questions/2984634/i-wanna-build-a-website-use-mongodb-is-it-free-do-i-need-to-open-my-source-of&lt;/p&gt;
&lt;p&gt;回答者果然也这么说，这下我就放心了。&lt;/p&gt;
&lt;h2&gt;在线体验&lt;/h2&gt;
&lt;p&gt;打开主页，点&quot;try it out&quot;按钮，会出现一个由javascript做出来的交互式教程，简洁明了，更有趣的是可以直接输入各种mongodb的命令，在线体验一把mongodb的增删改查是怎么做的，有一个基本的印象。做的真贴心。注意：要用&lt;strong&gt;非IE6&lt;/strong&gt;的浏览器，才能正常使用。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;http://www.mongodb.org/display/DOCS/Building+for+Linux#BuildingforLinux-Fedora8or10&lt;/p&gt;
&lt;p&gt;按照教程，大约花了一个小时才安装完。注意要先安装下面的dependencies，然后再用git下载源代码，编译并安装。这种安装方式与windows上的傻瓜安装完全不同，这可是拿到了原原本本的代码(这里是c代码)，从头做起。进行到scons all那一步时，将编译所有的代码，看着满屏幕飞滚的字母，有点像电影里演黑客时的感觉。漫长的编译过程（半个多小时），真让人担心，万一哪一行有问题，失败了怎么办，满屏幕的日志真会把人看死。好在一切顺利，终于安装好了。&lt;/p&gt;
&lt;p&gt;看看这几篇入门教程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;http://database.51cto.com/art/201003/187379.htm&lt;/li&gt;
&lt;li&gt;http://www.mongodb.org/display/DOCS/Developer+FAQ&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>vim快速定位文件，花了一天才搞定</title>
                <link>http://freewind.in/posts/102-vim-locate-file-quickly</link>
                <pubDate>Tue, 13 Sep 2011 01:51:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">102</guid>
                <description><![CDATA[&lt;p&gt;eclipse里有一个很好用的功能：按Ctrl+Shift+R后，会出来一个“文件查询框”，可以非常方便的找到当前所有项目中的某一个文件，快速定位。&lt;/p&gt;
&lt;p&gt;vim中有没有呢？找到这样几个插件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;FuzzyFinder : buffer/file/command/tag/etc explorer with fuzzy matching&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=1984&quot;&gt;http://www.vim.org/scripts/script.php?script_id=1984&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Command-T : Fast file navigation for VIM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=3025&quot;&gt;http://www.vim.org/scripts/script.php?script_id=3025&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lookupfile : Lookup files using Vim7 ins-completion&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=1581&quot;&gt;http://www.vim.org/scripts/script.php?script_id=1581&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;FuzzyFinder_textmate&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://github.com/jamis/fuzzyfinder_textmate&quot;&gt;http://github.com/jamis/fuzzyfinder_textmate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然而，坏消息是，这四个都有这样那样的问题：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-102&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FuzzyFinder找深层的文件不方便，Command-T在我这里（windowsxp+ruby1.8.7+gvim7.2)怎么也装不上，好像是ruby的问题，弄了一天也没解决。lookupfile需要用linux下的一个程序生成特定格式的索引，而FuzzyFinder_textmate由于它所依赖的FuzzyFinder不断变化，作者已经停止维护。&lt;/p&gt;
&lt;p&gt;郁闷得吐血，但是这个功能由于太常用，所以还是不能放弃。最后找到了这样一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://intraspirit.net/scratchpad/a-simple-fuzzyfinder-improvement/&quot;&gt;http://intraspirit.net/scratchpad/a-simple-fuzzyfinder-improvement/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者给FuzzyFinder里增加了一小段代码，让它也可以查找深层的文件了。虽然只改动了一点点，但是的确方便了很多。（不过实话说，跟eclipse的相比，还是差一点）&lt;/p&gt;
&lt;p&gt;在没有找到更好的插件之前，先用这个方法了。&lt;/p&gt;
&lt;p&gt;打开vim/vim72/autoload/fuf/file.vim，找到function fuf#file#onInit()，增加一行：&lt;/p&gt;
&lt;p&gt;call fuf#defineLaunchCommand(&apos;FufFileRecursive&apos;, s:MODE_NAME, &apos;&amp;ldquo;**/&amp;ldquo;&apos;)&lt;/p&gt;
&lt;p&gt;然后定义快捷键，在_vimrc中增加：&lt;/p&gt;
&lt;p&gt;&quot; FuzzyFinder - Ctrl + Shift + R&lt;/p&gt;
&lt;p&gt;map &lt;C-S-R&gt; :FufFileRecursive&lt;CR&gt;&lt;/p&gt;
&lt;p&gt;这样，在vim中，按下Ctrl+Shift+R，就可以快速查找文件了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>VIM插件收集</title>
                <link>http://freewind.in/posts/101-vim-plugins</link>
                <pubDate>Tue, 13 Sep 2011 01:51:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">101</guid>
                <description><![CDATA[&lt;p&gt;前段时间经过尝试，发现使用vim来开发java（或者在eclipse中使用类似vim的插件），并不会提高多少效率。毕竟eclipse和vim是两个不同的生态圈，单靠一点是无法带来巨大的改变的。&lt;/p&gt;
&lt;p&gt;又现在又开始学ruby，用vim就很适合了。因为ruby不像java，它是在语言层面减化操作，对编辑器的要求并不高。使用那些笨重的IDE，反而会降低操作效率。于是，又搬出来了vim这个神器。&lt;/p&gt;
&lt;p&gt;又发现了一些人们推荐的vim插件，有的已经用上了，有的还待尝试。先记在这里：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-101&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rails.vim 这个是rails的插件,必不可少的.&lt;/p&gt;
&lt;p&gt;snipMate 这个就是号称让VIM跟MAC下的神器TextMate有同样表现的插件,也是必装的.&lt;/p&gt;
&lt;p&gt;NERD_tree 显示目录树,我觉得比那个Project.vim要好用多了,所以我没有装Project.vim&lt;/p&gt;
&lt;p&gt;supertab.vim&lt;/p&gt;
&lt;p&gt;NERD_commenter.vim 快捷来加删comment的,不过我好像还没用过.&lt;/p&gt;
&lt;p&gt;lookupfile.vim 找文件,如果你只是用来开发rails的话,可以不用.&lt;/p&gt;
&lt;p&gt;bufexplorer.vim buffer切换&lt;/p&gt;
&lt;p&gt;genutils.vim&lt;/p&gt;
&lt;p&gt;javascript.vim&lt;/p&gt;
&lt;p&gt;blackboard.vim 这个就是模仿TextMate的配色,很重要.&lt;/p&gt;
&lt;p&gt;Monaco字体 这个不是插件,不过这个字体很漂亮 下载地址: &lt;a href=&quot;http://www.webdevkungfu.com/textmate-envy-aka-monaco-font-for-windows/&quot;&gt;http://www.webdevkungfu.com/textmate-envy-aka-monaco-font-for-windows/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AlignPlugin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=294&quot;&gt;http://www.vim.org/scripts/script.php?script_id=294&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CommandT&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=3025&quot;&gt;http://www.vim.org/scripts/script.php?script_id=3025&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Grep&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=311&quot;&gt;http://www.vim.org/scripts/script.php?script_id=311&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NERD_commenter&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/scrooloose/nerdcommenter&quot;&gt;http://github.com/scrooloose/nerdcommenter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NERD_tree&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/scrooloose/nerdtree&quot;&gt;http://github.com/scrooloose/nerdtree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rails&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/tpope/vim-rails&quot;&gt;http://github.com/tpope/vim-rails&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SnipMate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://github.com/msanders/snipmate.vim&quot;&gt;http://github.com/msanders/snipmate.vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
]]></description>
            </item>
        
            <item>
                <title>Rails的ORM</title>
                <link>http://freewind.in/posts/100-railes-orm</link>
                <pubDate>Tue, 13 Sep 2011 01:50:05 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">100</guid>
                <description><![CDATA[&lt;p&gt;这几天一直在看ruby和rails的书，感触颇多。特别是今天看到了rails的ActiveRecord，即rails提供的ORM，感觉非常欣慰－－看来这次转ruby是转对了。&lt;/p&gt;
&lt;p&gt;为什么？因为我从Java转到Ruby，就是因为Java的ORM。也许是跟语言本身的限制有关，也许跟Javaer的文化有关，Java的ORM就是找不到好用的。Hibernate，这个东西把我折腾坏了。它认为SQL是罪恶、难以理解和学习的，而且不够OO，所以在SQL的基础上，自己搞了一套叫HQL的查询语言。可惜，这个HQL复杂度跟SQL差不多，但是功能却不够强大（在不少地方有限制），为了增强其功能，又弄了一些其它的东西加进去。所以最终的结果，就是把问题弄得更复杂了：你不光要学习HQL，最终还是得学习SQL。&lt;/p&gt;
&lt;p&gt;说到这里，我感觉java中有一种文化，就是死板僵硬，思路全被设计模式固定死了，写代码一定要按套路来。把实现功能、处理异常做为主要目的，而易用性却无所谓。Java的开源库有很多，但是顺手好用的，却没有多少。（好在这两年有不少人意识到了这一点，设计出来的库很好用，比如Mockito，相比之前的EasyMock，好用多了）&lt;/p&gt;
&lt;p&gt;我认为，从根源上来说，这是由于Java语言本身的限制和JDK本身的代码风格所决定的。比如，java的String类，内置的方法只有那么多，很多常用的功能都得靠第三方的库来完成（比如commons-lang）。虽然借助第三方库可以做到，但是用起来就是没那么顺手。再看看那些集合类，如ArrayList，要想新建一个有三个元素的ArrayList，必须得先建生成一个List，再调用三次add，四行代码，明明可以简化的，可惜当时写这些代码的大牛们却没多做一点点。同时由于Java本身的限制，太静态了，以至于有时候想设计一些易用的函数都困难。形象一点的比喻，用Java写代码就像是穿着紧身的西装在球场上踢球，除了跑步传球，是没办法做出复杂精彩的动作的。&lt;/p&gt;
&lt;p&gt;然而ActiveRecord不一样。它认为SQL是很好的，所以直接利用SQL本身，再结合自己动态语言的优势，弄出了一个ORM。在看书的过程中，我开始还担心这样做会不会有问题，但是发现不但没问题，反而很优雅的解决了一些在Hibernate很难处理的问题。现在觉得，Hibernate真是把简单的弄复杂，然后再用更复杂的方法来解决复杂。而ruby，则是想方设法让事情更简单，让程序更容易使用。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>op4j</title>
                <link>http://freewind.in/posts/99-op4j</link>
                <pubDate>Tue, 13 Sep 2011 01:48:42 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">99</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://www.op4j.org/&quot;&gt;http://www.op4j.org/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;这是一个在Java中模似出函数式风格的库，示例代码如下：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;csharpcode&quot;&gt;Calendar now = Calendar.getInstance();
&lt;br  /&gt;Set&lt;Calendar&gt; set =&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Op.on(list).toSet().map(FnString.toCalendar(&amp;lt;span class=&quot;str&quot;&amp;gt;&quot;dd/MM/yyyy&quot;&amp;lt;/span&amp;gt;)).removeAllNullOrTrue(FnCalendar.after(now)).get();```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一行代码，做了很多事情：&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-99&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将list变为set，可去掉重复&lt;/li&gt;
&lt;li&gt;对每个元素进行转换为Date的操作&lt;/li&gt;
&lt;li&gt;去掉所有null&lt;/li&gt;
&lt;li&gt;如果某个某个元素的值在当前时间之后，选用&lt;/li&gt;
&lt;li&gt;取出符合条件的Date，得到一个Set
&lt;br  /&gt;&lt;p&gt;看起来挺酷的，但其实我不太推荐在Java中使用这种伪函数式风格。毕竟是模拟出来的，用起来总觉得手脚僵硬。有时候一些很自然的需求，却无法用这种方式实现，比如：取成一个Person列表中每个人的名字，组成一个新list，不知道怎么用这个实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到这些，又不自然地去想到如scala, groovy这样的语言了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Siena</title>
                <link>http://freewind.in/posts/98-try-siena</link>
                <pubDate>Tue, 13 Sep 2011 01:47:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">98</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://www.sienaproject.com/index.html&quot;&gt;http://www.sienaproject.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个需要翻墙才能看到，一个技术网站也被我们伟大的长城防火墙给和谐了，真让人郁闷。&lt;/p&gt;
&lt;p&gt;Siena也是一个设计非常简单的ORM，而且很有自己的特色。可以说，它是目前我看到的里面最好的那个（如果ActiveObjects不用接口和getter/setter的话，两个就并列第一了）。&lt;/p&gt;
&lt;p&gt;它的灵感来源于Google App Engine Python Datastore API，看一个查询的例子：&lt;/p&gt;
&lt;p&gt;List&lt;Employee&gt; someEmployees = Employee.all()&lt;/p&gt;
&lt;p&gt;.filter(&amp;#8220;firstName&amp;rdquo;, &amp;#8220;Mark&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;.order(&amp;#8220;-lastName&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;.fetch(10);&lt;span id=&quot;more-98&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相当的简洁明快。再和它的实体类的定义：&lt;/p&gt;
&lt;p&gt;@Table(&amp;#8220;employees&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;public class Employee extends Model {&lt;/p&gt;
&lt;p&gt;@Id(Generator.AUTO_INCREMENT)&lt;/p&gt;
&lt;p&gt;public Long id;&lt;/p&gt;
&lt;p&gt;@Column(&amp;#8220;first_name&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;@Max(200) @NotNull&lt;/p&gt;
&lt;p&gt;public String firstName;&lt;/p&gt;
&lt;p&gt;@Column(&amp;#8220;last_name&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;@Max(200) @NotNull&lt;/p&gt;
&lt;p&gt;public String lastName;&lt;/p&gt;
&lt;p&gt;@Column(&amp;#8220;contact_info&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;public Json contactInfo;&lt;/p&gt;
&lt;p&gt;@Column(&amp;#8220;boss&amp;rdquo;) @Index(&amp;#8220;boss_index&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;public Employee boss;&lt;/p&gt;
&lt;p&gt;@Filter(&amp;#8220;boss&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;public Query&lt;Employee&gt; employees;&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;
&lt;p&gt;Employee e = new Employee();&lt;/p&gt;
&lt;p&gt;e.firstName = &amp;#8220;John&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;e.lastName = &amp;#8220;Smith&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;e.contactInfo = map()&lt;/p&gt;
&lt;p&gt;.put(&amp;#8220;email&amp;rdquo;, &amp;#8220;&lt;a href=&quot;mailto:john.smith@example.com&quot;&gt;john.smith@example.com&lt;/a&gt;&amp;#8220;)&lt;/p&gt;
&lt;p&gt;.put(&amp;#8220;telephone&amp;rdquo;, list(&amp;#8220;xxx&amp;rdquo;, &amp;#8220;yyy&amp;rdquo;));&lt;/p&gt;
&lt;p&gt;e.insert();&lt;/p&gt;
&lt;p&gt;System.out.println(e.contactInfo);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public static Query&lt;Employee&gt; all() {&lt;/p&gt;
&lt;p&gt;return Model.all(Employee.class);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;类似于play中的JPA，也是很好理解和接受的。&lt;/p&gt;
&lt;p&gt;它有这么几个优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计简单，好学好用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不光支持常见的数据库，还支持Google App Engine datastore和Amazon&apos;s SimpleDB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你某些字段的结构比较复杂，可以把它变成json保存在一个字段里，非常方便&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;准备好好研究一下这个项目。它当前的版本才0.7.x，看起来还不太成熟&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>EBean</title>
                <link>http://freewind.in/posts/97-try-ebean</link>
                <pubDate>Tue, 13 Sep 2011 01:46:46 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">97</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://www.avaje.com/ebean&quot;&gt;http://www.avaje.com/ebean&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个playframework邮件组里的一个热心朋友介绍给我的，因为我发了一个&quot;I hate Hibernate&quot;的信，他便把他使用的这个ORM介绍给了我，还把他们做的play插件源代码也发给了我，让我参考。在此表示感谢。&lt;/p&gt;
&lt;p&gt;我大约得看了一下这个EBean，它和JPA很像，但是对其进行了简化：&lt;/p&gt;
&lt;p&gt;– No Session Object (or UnitOfWork or EntityManager)&lt;/p&gt;
&lt;p&gt;– No Attached or Detached Beans&lt;/p&gt;
&lt;p&gt;– No merge(), persist(),  flush(), or clear().  Instead Ebean has save() and delete()&lt;/p&gt;
&lt;p&gt;的确，这些设计是罪恶的根源，我每次用JPA/Hibernate出问题，都是用了它们或者没用它们。理解起来虽然不是非常难，但是它们规则太多了，一点误用就会产生错误或者性能问题。看来EBean果然有眼光。&lt;span id=&quot;more-97&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;增改：&lt;/p&gt;
&lt;p&gt;ESimple e = new ESimple();&lt;/p&gt;
&lt;p&gt;e.setName(&amp;#8220;test&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;e.setDescription(&amp;#8220;something&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;// will insert&lt;/p&gt;
&lt;p&gt;Ebean.save(e);&lt;/p&gt;
&lt;p&gt;e.setDescription(&amp;#8220;changed&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;// this will update&lt;/p&gt;
&lt;p&gt;Ebean.save(e);&lt;/p&gt;
&lt;p&gt;查询：&lt;/p&gt;
&lt;p&gt;// find a customer by their id&lt;/p&gt;
&lt;p&gt;Customer customer = Ebean.find(Customer.class, 4);&lt;/p&gt;
&lt;p&gt;// find a list&amp;hellip;&lt;/p&gt;
&lt;p&gt;List&lt;Customer&gt; customers = Ebean.find(Customer.class)&lt;/p&gt;
&lt;p&gt;.where().like(&amp;#8220;name&amp;rdquo;, &amp;#8220;Rob%&amp;ldquo;)&lt;/p&gt;
&lt;p&gt;.orderBy(&amp;#8220;name desc&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;.findList();&lt;/p&gt;
&lt;p&gt;这种语法跟ActiveObjects挺像的。&lt;/p&gt;
&lt;p&gt;文档有点长，有机会再研究一下。不过我还是稍稍觉得它有点麻烦，可能ActiveObjects更爽一些。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>BeanKeeper – 简单到了诡异的Orm</title>
                <link>http://freewind.in/posts/96-beankeeper-simple-orm</link>
                <pubDate>Tue, 13 Sep 2011 01:46:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">96</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://beankeeper.netmind.hu/&quot;&gt;http://beankeeper.netmind.hu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是另一个ORM，文章写得不太好看，但是内容还是挺让人震惊的。代码太简单了，简单到了诡异的地步。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Book { private String id; private String author; private String title; // getters and setters } 

要把它的一个实例保存到数据库，只需要:

````store.save(new Book());

删除：

````store.delete(book);

什么映射之类的都不用写，就直接搞定了，连一对多关系的都可以处理。

&amp;lt;span id=&quot;more-96&quot;&amp;gt;&amp;lt;/span&amp;gt;

真是如其名：Bean Keeper，只需要写一个Bean，其它全部搞定。

再看看查询：

````List books = store.find(&quot;find book&quot;);
````List books = store.find(&quot;find book where title=&apos;Java for dummies&apos;&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里返回的这个List是一个自定义的实现，实现了lasy loading。它里面最初只包含了30个左右的对象，如果你用到更多的，它会在需要的时候再查询数据库。所以你可以尽情的查询，不必担心内存不够－－你以为你拿到了全部，实际上只有几十个，但是对于你来说，没什么区别。就像我们的邮箱，看着几G，挺爽，实际上你用到的只有那么一点。&lt;/p&gt;
&lt;p&gt;简单的看完了它的介绍，觉得它虽然有创意，我却不是很推荐它。因为它看起来太简单了，简单到了诡异的地步。看着它的代码，我都想不出来它是怎么实现的。在这种简单的表面之下，应该对应着复杂的封装。其结果就是，简单的应用，用起来很爽，但是一旦出问题，只能干瞪眼，想调试都无处下手。因为你不知道它内部是如何实现的，如果简单好理解还好，否则的话，那就祈祷吧。&lt;/p&gt;
&lt;p&gt;与它相比，前面那个ActiveObjects还是要清晰得多。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>ActiveObjects – 值得一看的orm</title>
                <link>http://freewind.in/posts/95-activeobjects-an-orm-worth-noting</link>
                <pubDate>Tue, 13 Sep 2011 01:45:23 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">95</guid>
                <description><![CDATA[&lt;p&gt;&lt;a href=&quot;http://www.javalobby.org/articles/activeobjects&quot;&gt;http://www.javalobby.org/articles/activeobjects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章，讲述了一个故事，悬念重重，引人入胜，看得非常过瘾。技术文章写成这样，作者可真是厉害。&lt;/p&gt;
&lt;p&gt;他一步步的讲述了现在的ORM有哪些问题，RoR的ActiveRecord有哪些优点可以借鉴。同时因为java语言本身的限制，无法做到和ActionRecord一模一样，但是可以根据java中的一些语言特点，采用迂回战术，做到八分满意。于是，ActiveObjects诞生了。&lt;/p&gt;
&lt;p&gt;可以说这篇文章看完后，基本上就知道ActiveObjects怎么用了。与Hibernate等相比，真的是相当的简单，半小时内应该就可以掌握。我下载了它的包看了一下，里面的包和类都比较少，很简洁。有空的时候，一定要好好研究一下。&lt;span id=&quot;more-95&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/95-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/95-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://activeobjects.dev.java.net/&quot;&gt;https://activeobjects.dev.java.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天又仔细地想了想，觉得ActiveObjects中有一个地方，还是让人用起来不太舒服。看这里：&lt;/p&gt;
&lt;p&gt;// Person.java&lt;/p&gt;
&lt;p&gt;public interface Person extends Entity {&lt;/p&gt;
&lt;p&gt;public String getName();&lt;/p&gt;
&lt;p&gt;public void setName(String name);&lt;/p&gt;
&lt;p&gt;public int getAge();&lt;/p&gt;
&lt;p&gt;public void setAge(int age);&lt;/p&gt;
&lt;p&gt;@SQLType(Types.CLOB)&lt;/p&gt;
&lt;p&gt;public String getComment();&lt;/p&gt;
&lt;p&gt;@SQLType(Types.CLOB)&lt;/p&gt;
&lt;p&gt;public void setComment(String comment);&lt;/p&gt;
&lt;p&gt;public Family getFamily();&lt;/p&gt;
&lt;p&gt;public void setFamily();&lt;/p&gt;
&lt;p&gt;@ManyToMany(PersonToPerson.class)&lt;/p&gt;
&lt;p&gt;public Person[] getPeople();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;定义一个实体的时候，用的是interface，这里倒好理解和接受，关键是，它用的是getter/setter来对应数据库中的字段。这个写起来会比较麻烦，因为通常我们都是利用编辑器来自动生成的，快速且不易出错。而现在全得手动去写，错一个字母到时候查错就很麻烦。同时因为它是在一个接口里，就算我们先利用编辑器生成getter/setter，还是得把每个方法体的括号什么的都删掉，这也挺麻烦的。&lt;/p&gt;
&lt;p&gt;我想ActiveObjects为什么不在接口里定义一些常量，比如：&lt;/p&gt;
&lt;p&gt;public interface Person extends Entity {&lt;/p&gt;
&lt;p&gt;public String name;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;调用者直接使用Person.name = &amp;#8220;sss&quot;这样的方式来赋值，ActiveObjects在后台把它变为getter/setter呢？结果一尝试，发现这样是行不通的，因为接口中的常量都是final，无法再赋值，所以ActiveObjects只好使用getter/setter来做。&lt;/p&gt;
&lt;p&gt;我觉得如果不用接口而用类来做，就可以实现只使用字段不用getter/setter，可以简化很多，像play中就是这么做的。可是这样需要使用cglib的库去动态改变字节码，而ActiveObjects强调它们不想使用这样的方式，所以只好用接口。&lt;/p&gt;
&lt;p&gt;如果你能接受这样稍稍的麻烦，ActiveObjects还是一个很不错的ORM框架，值得尝试。如果不喜欢这样的方式，可以再看看这个叫Siena的东西。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>java的持久层们</title>
                <link>http://freewind.in/posts/92-the-orms-in-java</link>
                <pubDate>Tue, 13 Sep 2011 01:43:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">92</guid>
                <description><![CDATA[&lt;p&gt;从前，写sql是一件痛苦的事情，不论是写还是调试，都很痛苦，痛苦是因为太麻烦，体力活。&lt;/p&gt;
&lt;p&gt;有一天，出现了一个叫Hibernate的东西，你只要写一下配置文件，增删改查全都帮你搞定，好简单~ 于是，一下子就火了，火遍大江南北，成为著名“SSH”组合的尾巴。&lt;/p&gt;
&lt;p&gt;好日子没多久，人们发现，只用hibernate的简单功能还好，很顺手，一旦功能复杂，性能问题就出来了。而且它自己也挺矛盾的，一方面想让人们用面向对象的方式来操纵数据，一方面又得向下面的关系数据库妥协，所以写起代码来，一方面要装作很面向对象，一方面又得经常担心这样做那样做生成的sql是什么样的，会不会性能很差。还有，为了提高性能，它又提供了一些缓存机制，这个缓存机制，对于不深入了解hibernate的人来说，还有点难以理解。&lt;/p&gt;
&lt;p&gt;所以最终造成的结果是：对于一个新手来说，hibernate在节约了你的小部分开发时间的同时，增加了你大量的调试、找错的时间，让你感受到在遇到问题时只能干瞪眼的感觉。只有当你花了大量的时间，深入理解了hibernate之后，你才可能用起来顺手一些。只是这样的学习成本，对于大多数人来说，都还是太高了一些。&lt;span id=&quot;more-92&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;iBatis这个东西，看起几次，始终没有什么兴趣。因为比起来，spring jdbc template这个东西，不仅简单，而且用起来很舒服，一些数据表不多的地方，直接用它，还是很不错的。&lt;/p&gt;
&lt;p&gt;后来又出了一个JPA，跟hibernate差不多。只是它是一个标准，而hibernate是一个具体的实现。所以用起来觉得麻烦更多，因为你既要理解JPA是怎么规定的，使用时又可能会因为某些特别的功能，需要使用具体实现（如hibernate）中的特定代码，结果是，你两个都得学。&lt;/p&gt;
&lt;p&gt;我这段时间使用play做一些简单的小工具，它使用的是JPA及Hibernate。在使用过程中，出现大量的问题，全是因为这该死的hibernate。出现的异常莫名诡异，让我想调试都没法下手。后来在高人指导下不明不白的解决了。后来又遇到性能问题，到现在还没解决，非常郁闷。郁闷就是因为，问题出现了，你只能干着急，没处下手调试，因为这涉及到别人的设计思路，不理解的话没法调。所以，估计我得先买本厚厚的hibernate书看一遍，才能下手解决这个问题，花儿都谢了。现在，不写sql了，可是更痛苦了。&lt;/p&gt;
&lt;p&gt;一怒之下，真想大骂hibernate。你为了解决一个问题，引来了更多的问题，还你欺骗了大家的感情。现在铺天盖地，到处都是hibernate，不学点还不行，学好又很难。以前你还只是一个项目衷谝丫涑闪艘桓黾易辶耍略鼐偷眉甘甅，看得人怕怕。&lt;/p&gt;
&lt;p&gt;难道这个世界，真的已经被hibernate一统天下了吗？我不相信。经过我的搜索，还真找到一些项目，在夹缝中生存着。看着他们创建的介绍上，也都非常不满hibernate的复杂，我不是一个人~~&lt;/p&gt;
&lt;p&gt;先把网址贴在这里，改天好好研究一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.javalobby.org/articles/activeobjects/&quot;&gt;http://www.javalobby.org/articles/activeobjects/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;a href=&quot;http://www.sienaproject.com/index.html&quot;&gt;http://www.sienaproject.com/index.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;a href=&quot;http://beankeeper.netmind.hu/index.php&quot;&gt;http://beankeeper.netmind.hu/index.php&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.avaje.com/ebean&quot;&gt;http://www.avaje.com/ebean&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>JEasyTest</title>
                <link>http://freewind.in/posts/91-try-jeasytest</link>
                <pubDate>Tue, 13 Sep 2011 01:41:19 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">91</guid>
                <description><![CDATA[&lt;p&gt;曾经，所有的mock库都有这样的缺陷：不能mock静态方法，不能mock final方法，不能mock new出来的对象。所以，你的代码中，总是有一些地方是无法测试的，测试覆盖率总是无法达到100%。
&lt;br  /&gt;&lt;p&gt;但是，JEasyTest出现了。这个家伙，可以在你的测试代码运行前，通过AOP的方式，改变那些依赖的类的字节码。哪怕是静态函数，final函数，以及new方式创建对象时所调用的函数，都可以被改变，返回你所希望返回的内容。这样，以前无法测试的内容，都可以被测试了，太厉害了。
&lt;br  /&gt;&lt;p&gt;JEasyTest提供了一个eclipse的插件，安装后，可以调用它来运行测试代码。不足之处是不能与junit进行良好的集成，所以对于我做topcoder帮助不大。
&lt;br  /&gt;&lt;p&gt;但是，这毕竟是一个激动人心的工具，以后mock库的发展趋势，将会是这个方向。
&lt;br  /&gt;&lt;p&gt;主页：&lt;a href=&quot;https://jeasytest.dev.java.net/&quot;&gt;https://jeasytest.dev.java.net/&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>mockito</title>
                <link>http://freewind.in/posts/90-try-mockito</link>
                <pubDate>Tue, 13 Sep 2011 01:40:44 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">90</guid>
                <description><![CDATA[&lt;p&gt;写单元测试，早晚会需要mock，不然有的东西没法测。曾经在一年前，我试用过EasyMock，这个目前使用人数最多、好评也很多的mock库，可以让我们方便的mock一个接口或者一个类。
&lt;br  /&gt;&lt;p&gt;但是，还不够方便，虽然比我们自己写一个mock类方便很多，但是，总觉得还不够方便。
&lt;br  /&gt;&lt;p&gt;直到有一天，我看到了mockito，原来，mock还可以更简单。如果自己写mock的复杂度是10的话，使用easymock大约是4，而mockito应该是3。不要小看这一点点，这就是创造力，这就是方便。
&lt;br  /&gt;&lt;p&gt;主页：&lt;a href=&quot;http://www.mockito.org/&quot;&gt;http://www.mockito.org/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;两个缺点：
&lt;br  /&gt;&lt;p&gt;1. 只能使用jdk1.5以上，因为它的方便是用jdk1.5的泛型换来的
&lt;br  /&gt;&lt;p&gt;2. 不能mock &amp;#8220;static method&amp;rdquo;,&amp;ldquo;final method&amp;rdquo;,&amp;ldquo;new&amp;rdquo;，这没办法，简单易用的mock库基本上都有这缺陷。
&lt;br  /&gt;&lt;p&gt;另一个专讲mock的有名网站：&lt;a href=&quot;http://www.mockobjects.com/&quot;&gt;http://www.mockobjects.com&lt;/a&gt;，上面有各个语言的常用的mock库的链接&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>关于规则，转截自《亵渎》</title>
                <link>http://freewind.in/posts/89-about-the-rules-from-xiedu</link>
                <pubDate>Tue, 13 Sep 2011 01:38:15 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">89</guid>
                <description><![CDATA[&lt;p&gt;“这世上成为强者之路，无外乎魔武两途。魔法分成八大体系，而武技更是流派繁多，职业复杂。我来问你，一个大魔导师与一个剑圣生死相斗，最后会是谁胜谁负？”&lt;/p&gt;
&lt;p&gt;罗格沉思良久，才道：“若是两人单打独斗，剑圣可能会胜出；若是各带一军，则无疑是魔导会胜。这胜负关键，其实还在时间。”&lt;/p&gt;
&lt;p&gt;罗德里格斯点了点头，法杖一挥，一个小小的象棋棋盘出现在二人中间，微笑道：“来，先陪我下一盘棋再说。”&lt;/p&gt;
&lt;p&gt;罗格虽然有些不解，但仍依言开局。老少两个死灵法师很快就下了十几手棋。&lt;/p&gt;
&lt;p&gt;罗德里格斯边下棋边说：“单以威力而言，魔导师的魔法要远远强于剑圣的武技。然而一对一的战斗中，魔导几乎必定要落败，原因就是多了一个因素，时间。这时间根源于对力量的控制，剑圣的力量虽然较小，但是却对这力量有着绝对的控制力。魔导师引动天地间的魔法能量伤敌，威力可以震天动地，但聚集魔法能量却需要时间。所以，任何一个魔法师在作战之前，所有的准备都是为发动强力魔法争取时间！”&lt;/p&gt;
&lt;p&gt;二人象棋造诣天差地别，老法师口里解说，手下不闲，片刻之间，就连吃了罗格两个小兵，破了他的兵阵。&lt;span id=&quot;more-89&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“这世间之人，往往以为拥有力量就是强大。就象认为五级魔法师一定要强于四级魔法师一样。比如我这只后，在这棋盘之上，就要远远强过你的相。”说着，骷髅手一抬，后自阵中飞出，吃掉了罗格的白格相，并稳居盘中，一时之间，死死的压住了罗格整个棋阵。&lt;/p&gt;
&lt;p&gt;罗格苦思冥想起来，老死灵法师悠然的声音却没有停下来。&lt;/p&gt;
&lt;p&gt;“有些聪明的人，在力量达到了一定程度之时，发现强大的力量并不是一切，对力量的了解、控制和运用也非常重要。于是他们便开始向这方面钻研，比如大卫.罗歇里奥的剑技，并不在于力量强大，而是控制精妙，所以能以巧破力，以弱胜强。再看那个雾幻，没有几斤力气，却能轻易破开堪比石块的硬木，靠得就是对物质本身的透彻了解，以及力量运用的至高技巧。”&lt;/p&gt;
&lt;p&gt;“啊，原来是这样！”罗格灵光一闪，冲起一个小兵，重整兵阵，逼得罗德里格斯不得不收回了后。&lt;/p&gt;
&lt;p&gt;“呵呵，领悟的很快嘛。其实魔法的道理也是一样，致胜的魔法不见得是最强的魔法，而是最正确的魔法。这方面嘛，你天生就有这种本能的。”&lt;/p&gt;
&lt;p&gt;聊着聊着，罗格的棋已经被吃得七零八落的，只余三兵一后一马对老死灵法师的五兵一后相马车全。而且棋阵破烂，眼见过不了几步，王就无路可逃了。&lt;/p&gt;
&lt;p&gt;老死灵法师法杖一挥，棋盘转了个圈，“来，我们现在换棋来下下！”&lt;/p&gt;
&lt;p&gt;两人接过对方的棋，又开始下了起来。罗格虽然棋力远远不如老死灵法师，但棋上优势实在过于巨大，且整个棋盘要冲都控制在手里，老死灵法师棋力再高，也没有回天之力，勉强挣扎了七八步，终于山穷水尽，再过两步，就要被罗格将死。&lt;/p&gt;
&lt;p&gt;“孩子，我的棋力比你高得多，为什么现在会下不过你呢？”&lt;/p&gt;
&lt;p&gt;罗格思索片刻，道：“我明白了，绝对的力量是一切的基础。这力量上的差距大到了一定程度，单凭技巧就再也不可能以弱胜强了。大卫的剑技漂亮是漂亮了，可惜中看不中用，根本称不上是力量。有起这剑影的功夫，还不如一剑直刺，来得简单直接。”&lt;/p&gt;
&lt;p&gt;“嗯，你能了解这一点，非常好。其实以你对力量的了解和掌握，要远远超过了大卫，大卫这种层次也敢宣称掌握了力量的本质，呵呵，真是可笑！不过这世界所谓的大陆强者们，绝大多数也只能停留在他那个层次罢了。单以对力量的掌控来说，现在就算是奥菲罗克也不见得比更加深入。假如把你们的力量限制在同样程度上，他们是斗不过你的。可是你们之间力量的绝对差距太过巨大，已经不是技巧可以弥补的了。这就好比一只全副武装的老鼠，在老鼠的世界里是所向无敌的，甚至连猫都可以斗上一斗，但是面对猛虎，装备再精良，技艺再高超的老鼠都是无能为力的。”&lt;/p&gt;
&lt;p&gt;老死灵法师停了一会，给了罗格一点思索的时间，续道：“在对付魔界探子这类小卒的时候，就算是那个什么剑圣普罗西斯亲至，也不见得比你更历害；但如果对手是奥菲罗克，你们的下场就会完全不同。所以你想要成为一个真正的强者，首要就是增加自己魔力！”&lt;/p&gt;
&lt;p&gt;长叹一口气，罗格有点垂头丧气的，本来他还以为可以不用象以前一样努力了呢。现在看来，还是得天天冥想增长魔力啊，不过，有没有速成的办法呢？&lt;/p&gt;
&lt;p&gt;当，胖子头上挨了死灵法师重重一击，虽然是幻影，可是打人倒是一样的痛。“哪有这等好事？魔力的增加只有靠你自己努力，用功一分，就强得一分！”&lt;/p&gt;
&lt;p&gt;罗格嘿嘿一笑，不敢再胡思乱想了。&lt;/p&gt;
&lt;p&gt;“我们再来看看，这技巧的本质是什么？”罗德里格斯重新摆了一盘棋。&lt;/p&gt;
&lt;p&gt;二人又对弈起来，这次不同的是，罗德里格斯一边下，一边指点罗格棋艺。罗格人也聪明，一点就透，十几步过后，虽然仍是被打得落花流水，但和上一盘全无还手之力比起来，局面已经好得多了。&lt;/p&gt;
&lt;p&gt;“这技巧的本质，就是规则！”死灵法师的声音突然有如千均之重，每一个字都似有排山倒海之威，轰轰隆隆的在罗格脑海中炸响。&lt;/p&gt;
&lt;p&gt;一盘棋有游戏规则。&lt;/p&gt;
&lt;p&gt;一个家族有家法。&lt;/p&gt;
&lt;p&gt;一个国家有法律。&lt;/p&gt;
&lt;p&gt;水往低流，树向阳光，鹿马逐水草而居，候鸟依天时而徙。&lt;/p&gt;
&lt;p&gt;就是这天，也有雨露风霜，也有四季分明。这地，也有山川湖泊，也有地脉龙气。&lt;/p&gt;
&lt;p&gt;世界万物，日月星辰，莫不依规则而行。&lt;/p&gt;
&lt;p&gt;罗格脑中如雷轰电闪，但觉妙悟明思不绝而来，手下妙着频发，顷刻间已经扳回了局势。&lt;/p&gt;
&lt;p&gt;“世人诸多强者，无非是由力量而技艺，再由技艺而力量。正有观树是树，观花是花；观树不是树，观花不是花；以及观花还是花，观树还是树三重境界。其实返朴归真，万流归宗，依然是徘徊门外罢了。我既然曾为十大魔导师之首，而你是我选之人，（当然了，当时也别无其它选择），怎么也不能给我丢脸！增长魔力之道，天长日久，急也急不得。可是如果眼光见识，还停留在观花还是花，观树还是树这一层上，未免太说不过去了。”&lt;/p&gt;
&lt;p&gt;两人棋局胶着。&lt;/p&gt;
&lt;p&gt;“孩子，你那日所见的，是在所有规则之上的，这世界运行的最基本规律。只是你现在力量不够，还不能全部领悟罢了。现在你看了，但没有看到；终有一日，你会看了万物为空，但你还是看到了。”&lt;/p&gt;
&lt;p&gt;转眼之间，棋局急转直下，罗德里格斯已是岌岌可危了。&lt;/p&gt;
&lt;p&gt;“我的孩子，有朝一日，当你面对着理解了所有规则，掌握了至高无上的技巧和力量之人的时候，你要如何取胜呢？”&lt;/p&gt;
&lt;p&gt;罗格这一次愣住了，那只将要绝杀罗德里格斯的手始终放不下去。&lt;/p&gt;
&lt;p&gt;他苦思片刻，终于落下棋子，将死了罗德里格斯，且要看他如何破解这局面。&lt;/p&gt;
&lt;p&gt;罗德里格斯诡秘一笑，棋局骤生变化，那王飞了个大斜线，躲入角落自己的阵营中去了。同时，所有小兵都在原地升后，反而将罗格将死了。&lt;/p&gt;
&lt;p&gt;“这！……你……你居然耍无赖？！”罗格气得话都有些说不出来了。&lt;/p&gt;
&lt;p&gt;“孩子，你再仔细看看，我是不是在无赖？”&lt;/p&gt;
&lt;p&gt;罗格运起精神力仔细的探索起整个棋盘来，突然惊叫一声，：“啊！？这规则怎么变了？”&lt;/p&gt;
&lt;p&gt;“哈哈哈哈！我订的规则，我当然可以改变它。就算你规则掌握的再好，只要威胁到了我的存在，我就会设置一套新的规则来限制你，束缚你，直至绞杀你。”&lt;/p&gt;
&lt;p&gt;这真正的力量，就是制订规则。&lt;/p&gt;
&lt;p&gt;罗格再次苦思起来。&lt;/p&gt;
&lt;p&gt;突然，他站了起来，手一挥，所有的棋局都烟消云散。&lt;/p&gt;
&lt;p&gt;“我不玩了！”胖子笑眯眯的说。&lt;/p&gt;
&lt;p&gt;“哈哈哈哈”，老死灵法师仰天长笑，道：“好，好，好！我虽然没能躲过审判之光，但有了你和风月，这世间完美无缺的轶序，已经算是破了一角，不枉我一生心血了。”&lt;/p&gt;
&lt;p&gt;狂笑中的死灵法师自下而上，突然亮了起来，躯体迅速化作无数光点，飞散在空中，随后消失无迹。&lt;/p&gt;
&lt;p&gt;“其实，还可以下我这一局啊。”罗格喃喃的说道，面前又现出一个棋盘。&lt;/p&gt;
&lt;p&gt;罗格这里一王十后，老死灵法师那边只有孤零零的一个王，且动弹不得。&lt;/p&gt;
&lt;p&gt;罗德里格斯临去前终于看到了这一局，眼眶中闪过一丝欣慰。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>python三周感言</title>
                <link>http://freewind.in/posts/88-python-after-3-weeks</link>
                <pubDate>Tue, 13 Sep 2011 01:30:50 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">88</guid>
                <description><![CDATA[&lt;p&gt;使用python已经三周了。随着使用的深入，对于它的了解比以前要多，优缺点也有更切身的体会了。现在回头看两周前写的“python一周感言”，总体感觉还是差不多的，看来python真是一个学习曲线很平滑的语言（不像ruby）。&lt;/p&gt;
&lt;p&gt;现在就讲一下python与web开发相关的一些问题。这些问题对于web开发来说，是通用的，不论使用哪种语言，都是需要面对与解决的。从另一方面来说，哪种语言解决得更好，哪种语言就更有优势。&lt;/p&gt;
&lt;h2&gt;一、字符集&lt;/h2&gt;
&lt;p&gt;python有这个问题上还不错，通常只需要在文件最前面写一句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个文件就会以utf-8的方式编码，通常不会遇到中文乱码的问题。不过如果你调用了第三方的库，要是那边没有使用utf8，或者没有处理好编码，还是有可能出现问题。那时就需要手动进行转码，会麻烦一些。&lt;/p&gt;
&lt;p&gt;python3会使用与java类似的方式来处理，但是目前人们广泛使用的还是python2.7。&lt;/p&gt;
&lt;p&gt;Java在这个方面做得真是太好了，从Java转到ruby和python的人，都会怀念吧。&lt;/p&gt;
&lt;p&gt;评价：四星&lt;/p&gt;
&lt;h2&gt;二、web框架&lt;/h2&gt;
&lt;p&gt;使用人数最多、支持最多的还是django。从google的关键字趋势图上可以看到，django的指数比其它（如pylons, turbogears）大20倍，这跟django历史悠久很有关系。另外，现在很多编辑器都对django提供了直接的支持，其它的框架都没这个福气。&lt;/p&gt;
&lt;p&gt;python中现在流行的框架有django, pylons, turbogears, cherrypy, 2py, web.py等。但是，python的web开发，真的是远远不如ruby，甚至相对java来说，也不够优秀。这一块不太想详细说，因为自己都觉得没多少意思，感觉挺灰暗的。简单来说，社区薄弱，文档落后，插件少，兼容性差，感觉各个框架的前途都挺灰暗的，说不定什么时候就没人维护了。&lt;/p&gt;
&lt;p&gt;如果说原因的话，我觉得应该是“接口”的问题。因为python不像java那样注重接口与兼容性，大家的代码都是互相直接调用。所以经常出现这样的情况：你使用的某一个组件的版本号更新了0.1，都导致整个程序运行不起来了。这比ruby要严重一些，因为ruby对于模块和类结构的规定要完善一些。&lt;/p&gt;
&lt;p&gt;评价：二星&lt;/p&gt;
&lt;h2&gt;三、ORM&lt;/h2&gt;
&lt;p&gt;Python中目前最有名的orm当属alchemy。其它一些要么没它出名，要么没它好用。alchemy的设计不错，即可以方便地处理遗留数据表结构，又可以很好地使用orm方式来设计，而且这两种方式使用起来，风格的差异并不大。&lt;/p&gt;
&lt;p&gt;alchemy有个特点对于提高性能很有帮耗阈戳艘淮蠖汛邮菘舛寥∈莼蛘吒率莸牟僮鳎撬鞘导噬喜⒚挥兄葱校挥械钡饔昧薙ession.flush()或Session.commit()时，才会一次性批量提交，这样可以提高数据读写的性能。比hibernate之类的lazy load要厉害得多。&lt;/p&gt;
&lt;p&gt;另外，alchemy使用起来非常灵活，基本上直接写sql能做的，它都能做。虽然灵活，且用法很多，但一旦熟悉之后，并不觉得很难记，这与它的api设计得好有关系。&lt;/p&gt;
&lt;p&gt;不过有得也有失，alchemy对于回调支持很差。比如说你有一个对象，希望它在保存的时候，修改与它关联另一个对象的内容，就很麻烦。自己写了一些简单的代码来扩展它，虽然能做到，但是用起来很别扭。&lt;/p&gt;
&lt;p&gt;评价：四星&lt;/p&gt;
&lt;h2&gt;四、模板&lt;/h2&gt;
&lt;p&gt;python中的模板有四五种，如mako, genshi, jinja等，设计理念相差不大。感觉python中的模板层都做得挺不错的，不论是功能、灵活性和易用性，都很好。我最终使用的是mako，它也是由sqlahchemy的作者创建。&lt;/p&gt;
&lt;p&gt;功能上没什么问题，但是我已经习惯了&quot;haml+sass&quot;那样的方式（没办法，这种方式对于布局实在太方便了）。我原以为，同为动态语言，python应该像ruby那样，很容易地就实现了haml语法，结果大失所望，找了几天只找到了几个不太成熟的类haml的库，而且用起来都不顺手。&lt;/p&gt;
&lt;p&gt;好在最后发现了一个叫shpaml的，用起来还不错。&lt;/p&gt;
&lt;p&gt;评价：四星&lt;/p&gt;
&lt;h2&gt;五、文档生成&lt;/h2&gt;
&lt;p&gt;不得不说，python程序的文档网站都很漂亮专业，如：&lt;a href=&quot;http://pylonsbook.com/en/1.1/&quot;&gt;http://pylonsbook.com/en/1.1/&lt;/a&gt;。这得益于它们使用的一个叫&quot;sphinx&quot;的一个文档工具，可以直接读取写在源代码中的文档，生成一个漂亮的文档网站。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://sphinx.pocoo.org/&quot;&gt;http://sphinx.pocoo.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;评价：五星&lt;/p&gt;
&lt;h2&gt;六、分页&lt;/h2&gt;
&lt;p&gt;pylons中的分页很简单，可以把一个sqlalchemy的query对象传过去，就直接能分页，再配合一个生成链接的函数，很方便且完美。跟ruby中差不多。&lt;/p&gt;
&lt;p&gt;评价：五星&lt;/p&gt;
&lt;h2&gt;七、循环导入&lt;/h2&gt;
&lt;p&gt;不能不说，python的这个限制非常不方便：当你使用一个类之前，必须先定义它或者导入它。&lt;/p&gt;
&lt;p&gt;当我们使用orm时，通常都会在不同的文件中，定义互相调用的类。&lt;/p&gt;
&lt;p&gt;比如，定义了一个User和一个Question，它们都在自己的文件里，且会互相引用，就会很麻烦，而且很难解决。sqlalchemy的做法是，在引用时使用字符串代替，比如User.id要写出&quot;User.id&amp;rdquo;，虽然可行，但是实在太丑了。其它语言中，基本上都不会出现这样的问题。&lt;/p&gt;
&lt;p&gt;转换语言，最大的郁闷就是：之前那个语言的不爽的地方被解决了，但是爽的地方变不爽了。而有时候，不是技术上的问题，而是风格和文化的问题。比如对haml的使用，在ruby世界已经风形，用过的人都说好，但是在python中，唉。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>python一周感言</title>
                <link>http://freewind.in/posts/87-python-after-one-week</link>
                <pubDate>Tue, 13 Sep 2011 01:30:18 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">87</guid>
                <description><![CDATA[&lt;p&gt;从开始学python到现在正好一周，终于可以开始动手再重做网站了。在这几天里，看了以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python的语法，一天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个web开发框架: pylons，两天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个orm框架: sqlalchemy，两天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个view层模板语言: mako，两天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;学习使用IntelliJ idea作为开发工具，一天&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;做网站就是mvc,orm这些套路，各个语言都差不多，只要了解了其原理和常用写法，就可以动手了。至于细节部分，用到的时候再去查资料研究。&lt;span id=&quot;more-87&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;python的语法相当简单，简单到你只需要用一天的时间，就能基本上看懂别人的代码。可以说，这是我学过的各种编程语言中，上手最快的一种了。然而简单并不代表功能弱，python提供的很多语言特性，可以实现很强大的功能。&lt;/p&gt;
&lt;p&gt;学Python，只需要记住两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;python的哲学：简单优于复杂，显式优于隐式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果解决问题的方式有多种，python只用其中最好的那一种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一切都是&quot;namespace&amp;rdquo;：包括package, module, class, object&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python的面向对象，更像javascript，而不像java, c++或者ruby&lt;/p&gt;
&lt;p&gt;下面从做网站的角度谈谈python。&lt;/p&gt;
&lt;p&gt;python中目前有这几个比较有名的web框架：django, turbogears, pylons, web.py等。首先可以肯定的是，它们没有一个能赶上ruby on rails，并且有着数量级的差距（这让我感觉有点意外，我高估了python）。其中django历史悠久，使用人数众多，但它的所有东西基本上都是自己开发的。turbogears和pylons则是选用了各个开源的部件，按自己的规则拼在一起。web.py的特点是小巧而简洁。&lt;/p&gt;
&lt;p&gt;我最终选择了pylons，主要是因为它的网站做的好，介绍也很好，给了我们很大的选择。我喜欢自由。如果有一天我觉得turbogears不错，想要转过去，应该也不需要重写太多的东西。&lt;/p&gt;
&lt;p&gt;python中的orm好像并不多，看了一下就两三个，SQLObject和Sqlchemy，还有django自己的orm。我选用了python界目前最流行功能最强大文档写得最好的sqlchemy。这个东西其实还是有点复杂的，特别是刚入门时，因为它跟java里的orm声明方式差别太大了，很难下手。不过可以看出，它的功能真是非常强大，远超java中的各orm，并且入门之后，其复杂性就比hibernate之流要小很多。&lt;/p&gt;
&lt;p&gt;python中模板层倒挺多的。有django自己的模板，还有mako, genshi，还有一些我忘了。可惜的是，我最爱的haml，在python中实现得并不好，用起来很别扭，完全没有在ror下的那种畅快。最终无奈放弃了它，使用了mako。选用mako，是因为它也是出自sqlchemy的作者之手，功能强大而方便，文档详细而丰富，还算是八分满意。&lt;/p&gt;
&lt;p&gt;编辑器，选择了intellij idea。开始时使用的是eclipse+pydev，不知怎么回事，经常发生启动后就卡住，折腾半个小时也没弄好的情况，实在受不了了。idea其实很受好评，它的界面没有eclipse好看，但是在细节上做得很用心，用起来很顺手。我重新调整了它的字体等，快捷键还用的是eclipse那一套，感觉也还不错。据说在很多方面，idea都已经超过了eclipse，这些只有用过的人才知道。目前我使用到的python及html的编辑，都是idea要做得好一些。如果eclipse将要推出的E4没有太大的进步的话，我要考虑一直使用idea了。&lt;/p&gt;
&lt;p&gt;最后一点是关于修改文件后重启服务器的问题。我还以为python在这一块会做得很好（像ror那样），结果有点失望。虽然修改后不需要重启服务器，但是它会有3到5秒的restarting时间，还是很不方便。不知道是不是我的方式不对（我用的是paster serve -reload），如果有更好的方式，请告诉我。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Try python</title>
                <link>http://freewind.in/posts/86-try-python</link>
                <pubDate>Tue, 13 Sep 2011 01:29:37 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">86</guid>
                <description><![CDATA[&lt;p&gt;当我写下这个标题时，只有一个感觉：真杯具。&lt;/p&gt;
&lt;p&gt;这半年来，真是把各种流行的语言都翻了个遍（除了.net和php），而当初的伟大理想“网站计划”还在家门口徘徊，转了几圈就是走不出院子。&lt;/p&gt;
&lt;p&gt;java开发的的低效与变态的繁琐，ruby的太过于灵活而难以掌握，scala的年轻导致相关资源太少，让我郁闷至极。特别是近期重回java，为了找到一个顺手的orm，又把能找到的各种orm都试了个遍，还是没找到一个合适的。&lt;/p&gt;
&lt;p&gt;我为什么不能深入学习一种（比如最熟悉的java），而要反复折腾？之前我也不明白，直到刚才在某博客上看到一段话，恍然大悟。&lt;span id=&quot;more-86&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/mozilla/archive/2007/07/22/1702365.aspx&quot;&gt;http://blog.csdn.net/mozilla/archive/2007/07/22/1702365.aspx&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;“一年多以前我对Java还抱有一些幻想，认为Java社区如果有更好的框架，开发效率一定会追上Rails。今年5月我读了 Bruce A. Tate的《超越Java》这本书，希望从专家那里了解一下Java语言和Java社区到底出了什么问题。这本书打消了我的幻想，让我理解了Java最大的问题在于静态类型对开发效率造成的严重影响。联想到我去年下半年做的那个广告发布平台，我对此深有感触。我当时所采用的框架是Spring MVC+Spring IoC+Hibernate+FreeMarker+SiteMesh，按理说在Java开发领域，这套组合的开发效率应该算是比较高的了。然而实际的开发进度远远低于我的预期，我作出第一个版本的时间差不多是预计时间的两倍。当然因为资金的缺乏，大部分时间都只有我一个人在做开发，什么都要亲自动手，困难确实很多。不过我认为主要的问题还是在于Java语言做Web开发的笨拙。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为资金的缺乏，我今后要做一些自己感兴趣的东西，注定仍然只会有很少的人参与（2、3个人），Java这样笨拙的语言可能会使我付出双倍的代价。”&lt;/p&gt;
&lt;p&gt;没错，就是这个原因。我没有资金，找不到人帮我做。我的朋友们，因为各种原因不能与我合作。我只能一个人去做我想做的事情。那么，找到一种能最大程序发挥个人开发效率的语言，就是非常重要的事情了。我反复折腾，是因为我找不到一件顺手的兵器，这是我迟迟没有上战场的原因。&lt;/p&gt;
&lt;p&gt;可惜的是，那个博主2007年时就明白了这一点，而我，则在现在才明白。之前一直在用java做后台，觉得还好。而现在用它做网站之后，这种难以忍受的感觉才如此强烈。&lt;/p&gt;
&lt;p&gt;再捡回python，准备花一个星期的时间好好学一下，看能不能成为我锋利的剑。要是不能，我也不知道还能做什么了。。。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>HTML5 – web的未来</title>
                <link>http://freewind.in/posts/85-html5-future-of-web</link>
                <pubDate>Tue, 13 Sep 2011 01:28:12 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">85</guid>
                <description><![CDATA[&lt;p&gt;刚刚在这篇文章中看到，rails3的主力开发者Yehuda Katz从Engine Yard公司辞职，进入一家新的创业公司，从事html5的纯js框架SproutCore框架的开发工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.javaeye.com/news/17731-yehuda-kats-leave-engine-yard&quot;&gt;http://www.javaeye.com/news/17731-yehuda-kats-leave-engine-yard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;于是我找到了SproutCore的主页，看到了它的示例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://demo.sproutcore.com/sample_controls/&quot;&gt;http://demo.sproutcore.com/sample_controls/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意上面这个例子只能在支持html5的浏览器上，如firefox,chrome上正常显示。如果是低版本的ie，则什么也看不到。&lt;span id=&quot;more-85&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看完它的示例，我心里突然觉得：html5终于来了，网站的格局将发生翻天覆地的变化。感觉有一点无奈：自己好不容易把各种做网站后台的技术弄熟悉，马上网站开发又要转到前台了，到时候html5,javascript将会是开发的主力语言，又要学新东西了。程序员真惨。然而又一想，这又是一个新的机会，一个酝酿了多年的难得的机会，就看你能不能抓住。之前这些年所谓各种技术上的创新，不过是下下小雨，而这次可是台风过境。&lt;/p&gt;
&lt;p&gt;其实html5的基本内容我前两天也看过，很简单，主要是多了一个画布、视频和音频的直接支持，和一些其它的小变化。看完之后，我觉得好像也没什么新鲜的东西，值得各大公司力推吗？&lt;/p&gt;
&lt;p&gt;然而今天才知道，是自己的眼界太低了。这些东西，在牛人的眼里，就是能颠覆现在网站技术、改变人们生活习惯的宝物。如果把现在已经广泛使用十来年的html4比做固定电话，则html5就是手机。互联网正在从固定转向移动，而html5就是点燃导线的那把火。html5一旦成熟起来，在各种移动终端上就可以很容易的做出跨终端的应用程序，它的低技术门槛将会让移动互联网火爆起来。&lt;/p&gt;
&lt;p&gt;一个新的移动互联网的时代将到来，现在正是开始学习的机会。两三年后，将会有大量基于html5的网站和程序出现，出现在你的电脑上、手机上、平板电脑上。那个时候再开始介入，可能就已经晚了。&lt;/p&gt;
&lt;p&gt;最后，让我膜拜一下这位Yehuda Katz，这位神级别的人，看看他的作品：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;jquery 占据第一位的javascript库，简洁的api与无与伦比的表达力，解救了无数的web页面开发者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;merb及rails3 曾经rails以绝对优势将其它所有语言的web开发框架远远抛在后面，而现在rails3是以merb为蓝本开发的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两项只要做成一个，都足以名垂千古，而他居然两个都拿下了。能让如此神人辞职加入的SproutCore，你认为其前景如何呢？&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>纪念逝去的colinux</title>
                <link>http://freewind.in/posts/84-the-dead-colinux</link>
                <pubDate>Tue, 13 Sep 2011 01:26:40 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">84</guid>
                <description><![CDATA[&lt;p&gt;想在本机上搭建一个linux，以便学习linux及测试我的那些程序，翻出了两年前使用过的colinux。这个东西，比虚拟机什么的方便多了，下载一个几M的程序和一个几十M的linux映像文件，配置一下，就直接在windows上把linux跑起来了。再开个putty连过去，用起来和真的linux一样一样的。更好的是，占用的资源极小，比虚拟机节省多了。
&lt;br  /&gt;&lt;p&gt;然而这么好的东西，却落没了。虽然程序半年前还更新过，但是提供的各版本的linux映像都已经太老了。ubuntu, fedora, 都是老早的版本，已经无法在线更新了。想找新版本的映像文件，官方没有提供，只有一个热心网友制做了fedora 11, centos 5.x （这也都是很早的，好在还可以更新）的映像，下载下来，却要么启动不了，要么连不上网。把我折腾了整整一天，最后只能无奈的放弃。
&lt;br  /&gt;&lt;p&gt;真是想不明白，这么好的东西，为什么就没有发展起来呢。最后无奈，还是下载了virtual box和centos的dvd，终于把centos装起来了。期间发现了一个好网址：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://mirrors.163.com/&quot;&gt;http://mirrors.163.com&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;这是网易提供的各linux镜像，东西很全，速度很快，居家必备。
&lt;br  /&gt;&lt;p&gt;仅以此文纪念colinux。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>idea安装后需要做的几个设置</title>
                <link>http://freewind.in/posts/83-some-settings-after-idea-installation</link>
                <pubDate>Tue, 13 Sep 2011 01:26:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">83</guid>
                <description><![CDATA[&lt;p&gt;从eclipse转到idea后，有一些操作习惯发生变化，不太适应，所以需要先对idea进行一下设置。记录下来，以备后用。&lt;/p&gt;
&lt;p&gt;1。使用eclipse的快捷键&lt;/p&gt;
&lt;p&gt;File -&gt; Settings -&gt; Keymap -&gt;　右边选&quot;Eclipse&amp;rdquo;&lt;/p&gt;
&lt;p&gt;2。调整字体&lt;/p&gt;
&lt;p&gt;File -&gt; Settings -&gt; Editor -&gt; Colors &amp;amp; Fonts -&gt; Font -&gt; 字体名调整为Courier New，大小为12，行距为1.3&lt;/p&gt;
&lt;p&gt;注意调整前需要先另存为一个新的Scheme name，不然无法修改。&lt;span id=&quot;more-83&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3。点击时超过行尾字符，则定位在最后一个字符，而不是点击的位置&lt;/p&gt;
&lt;p&gt;File -&gt; Settings -&gt; Editor -&gt; 右边 &amp;#8220;Allow placement of caret after end of line&amp;rdquo;，去掉勾&lt;/p&gt;
&lt;p&gt;4。按Ctrl+方向键移动鼠标时，不是按整词，而是按词中词来跳动&lt;/p&gt;
&lt;p&gt;File -&gt; Settings -&gt; Editor -&gt; Smart Keys -&gt; 右边选中&quot;user CamelHumps words&amp;rdquo;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;鼠标双击一个单词时，则选中全部，而不是词中词&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;File -&gt; Settings -&gt; Editor -&gt; 右边去掉“Honor CamelHups words settings when selecting on double click”&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>一个问题7个小时内浏览数过千，引发的思考</title>
                <link>http://freewind.in/posts/81-thinking-about-the-question-which-has-more-than-1000-visits-in-one-hour</link>
                <pubDate>Tue, 13 Sep 2011 01:24:25 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">81</guid>
                <description><![CDATA[&lt;p&gt;今天某群里有人发了一个问题：1927年12月31日晚的某两个时刻，明明看起来只相差1秒，但是Java在对它们解析之后一相减，结果却是353秒。但是把时间稍稍改动一下，比如都增加1秒，再算，结果又变为1秒了。&lt;/p&gt;
&lt;p&gt;我对这个问题很感兴趣，感觉像是Java里的bug。但想不到答案，于是把它发在了stackoverflow上：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/6841333/a-very-strange-date-before-1970&quot;&gt;http://stackoverflow.com/questions/6841333/a-very-strange-date-before-1970&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有它的中文版本：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zhidao.it/questions/241&quot;&gt;http://zhidao.it/questions/241&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;果然，在伟大的stackoverflow上，十分钟左右，就有牛人给出了非常准确的答案，并且有十多人参与进来，回答、评论、投票。仅十分钟，就得到了非常满意的答案。我原以为事情就过去了，但是刚刚打开stackoverflow时，系统提示我得到了几个奖章，包括“流行问题”，“好问题”等。我一看，不得了，&lt;strong&gt;这个问题已经得到了35个好评，8个收藏以及超过1000的访问量。而其中最佳答案，竟然得到了82个好评。&lt;span id=&quot;more-81&quot;&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是什么概念？这一个问题得到的好评，几乎&lt;strong&gt;超过了我之前一年时间提出的近百个问题的好评总和&lt;/strong&gt;！而这发生在短短的7个小时内。&lt;/p&gt;
&lt;p&gt;事情差不多就这样，而我在想的是：&lt;strong&gt;stackoverflow通过什么方法，能让这么多人看到这个问题？为什么我的其它问题，在第一天，访问量基本上只有几十？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Stackoverflow没并有管理员来手动将某个问题置顶，人们通常看到一个问题，是通过这样几种途径：&lt;/p&gt;
&lt;p&gt;1。打开首页时，会显示“有趣问题的列表”。这些问题会获得最多的关注，但是使用什么算法来判断一个问题是“有趣”呢？旁边的tab页，可以在点击后显示“悬赏的问题”，“当前最热门问题”，“本周热门问题”，“本月热门问题”&lt;/p&gt;
&lt;p&gt;2。打开问题栏目时，会默认显示最新的问题，旁边还有tab页，点击后会显示“悬赏的问题”，“最常被引用的问题”，“评分最高的问题”，“最近活跃问题”，“无人回答的问题”&lt;/p&gt;
&lt;p&gt;3。每一个问题旁边，都有会“引用了该问题的问题”，和“类似的问题”&lt;/p&gt;
&lt;p&gt;4。通过站内搜索引擎，找到该问题。&lt;/p&gt;
&lt;p&gt;5。通过外部搜索引擎，如google。stackoverflow上发布的问题，通常在3分钟之后，就会显示在google的搜索列表中。&lt;/p&gt;
&lt;p&gt;我能想到的所有有可能看到该问题的方式都在上面了，但却没有找到一个很好的解释：&lt;strong&gt;为什么就这个问题会被这么多人看到？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照正常情况来说，一个问题提出之后，在几分钟之内就会跑到第二页之后了，一个小时之后就会在十几页之后了，这时基本上等于淹没于问题的海洋中了。日后想再被人看到，只能靠被人搜索到。而这个问题，在短时间内被大量人看到，应该与搜索引擎无关（不会这么巧就今天有无数人想起来搜索这个问题，而且问题的标题和内容看着不都热门）。那么就只有一种情况了，它被系统定义为“热门问题”、“有趣问题”，并且在相关问题中，排名靠前。这样才会有这么多的人看到。&lt;/p&gt;
&lt;p&gt;那么我去验证一下，我按照一个普通浏览者的身份来浏览Stackoverflow，看能不能轻易地找到这个问题。果然，在首页的“周热门问题栏”，这个问题排在第4名。并且，显示的最后回答者的&quot;86.4K&quot;的贡献值（这绝对是超级大牛级的人物）给这个问题增加了莫大的吸引力，见下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/81-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/81-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;马上又在“月热门问题”中找到了这个问题，排名18。只在这两个地方发现了这个问题，但是已经非常足够了，按照Stackoverflow的访问量，每小时100多人的访问是非常轻松的。而且这个问题又的确很有意思，回答者给出来的回答又非常好，所以很容易引得人们的参与欲望。&lt;/p&gt;
&lt;p&gt;刚刚搜了一下那个86.4K牛人的信息，八卦一下，他的网站上，直接把Stackoverflow上的贡献值列出来了，这是一个非常有说服力的证明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/81-3.jpg&quot;&gt;&lt;img src=&quot;/user_images/81-3.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他在Stackoverflow旗下的五个网站中，总的贡献值达到了&quot;90K&amp;rdquo;，我才1800多。&lt;/p&gt;
&lt;p&gt;回到主题，看来的确是因为这个问题被评为了“热门问题”，它才得到了这么多的浏览量和参与；但是反过来，正是人们的参与，又让Stackoverflow判定它是一个好问题，所以放在首页。通过这件事，我觉得Stackoverflow不仅仅是一个简单的问答网站，它不仅仅是提供了“可编辑”“贡献多者拥有更多管理权限”“奖章”来保证问题的质量和人们的参与性，它还通过一些算法，&lt;strong&gt;让好问题得到更多的展示机会&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只有在网站上看到更多的好问题，人们才愿意去看，去看，去投票，提问者也会受到肯定和鼓励，下次再有问题时，会第一时间想到这个网站。可以说，这个网站是活的，因为它可以找出最热门的问题并展示出来，并且它展示出来的问题，都是被人认可的好问题。&lt;/p&gt;
&lt;p&gt;这和google对网站的判定一样：什么样的网站是好网站，它应该排在前面。想判定一个网站是好还是不好，为什么比另一个好，这不是一件容易的事情。而Stackoverflow所做的很类似，这也不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;再看看国内的类似网站（包括我的zhidao.it），都可以说是死的。排在前面的，要么是最新发表的，最新回复的，要么就是悬赏分高的，或者是管理员手动加个精华、置顶等。在这样的网站里，所有的问题都是流水，你问的再好再有趣，也有可能很快就淹没于题海，再无出头之日。而作为浏览者，看到的要么是最新发表的但不一定有趣的问题，要么是管理员人工置顶几天不变的问题。这样的网站，只有靠人数堆积出来的量，又没有质。&lt;/p&gt;
&lt;p&gt;我想这应该就是Stackoverflow远超同类网站，难以模仿的原因：它是有技术含量的，不是谁都可以复制的。比如这个“热门问题”的评定，肯定要首先记录下来每个人的访问时间，回答、评价、收藏、评论等所有信息，然后再给每一种信息一个权重，最后算出一个评分。而机器算出来的热门问题，能不能得到人脑的认可，则要经常多次改良。这个过程，想想都挺难的。&lt;/p&gt;
&lt;p&gt;看来zhidao.it要想改变现在这种死气沉沉的感觉，得要在这方面多花精力。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Xtext：自定义DSL语言（同时拥有完善的编辑器支持）</title>
                <link>http://freewind.in/posts/76-xtext-to-define-dsl-with-good-ide-support</link>
                <pubDate>Tue, 13 Sep 2011 01:22:55 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">76</guid>
                <description><![CDATA[&lt;p&gt;今天看到了一个很惊艳的东西：&lt;a href=&quot;http://www.eclipse.org/Xtext/&quot;&gt;http://www.eclipse.org/Xtext/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;这是eclipse的一个项目，可以运行在eclipse3.7上。它是一个让我们可以“自己建立一个编程语言或者DSL的框架”。需要做的只是定义一些语法规则，然后，你的新语言或者DSL就出来了。
&lt;br  /&gt;&lt;p&gt;仅仅这样，还不足以让人觉得惊艳，而是因为它天生具有了eclipse中那些代码高亮、语法检查、实时查错、代码提示等高级功能。看一下主页上提供的那些flash演示，那些自定义的语言在编辑时就好像是在eclipse中写java似的，只是语法、关键字和结构等不一样。
&lt;br  /&gt;&lt;p&gt;以我不深入的了解来看，可以使用它简化我们在开发中经常做的事情。比如定义JPA或hibernate的实体bean时，我们以前是通过xml或者注解来给一个javabean增加上各种描述关系。不能不说的是，这样的做法很繁琐、很别扭，但是如果设计出一个专门的DSL呢？其实已经有了，在演示文件中，已经可以看到这种DSL的用法，相当的方便。
&lt;br  /&gt;&lt;p&gt;我现在在想，不知道能不能使用它，来造出一个自己的Java出来。比如我们可以不用等到java8出来，也不需要转向别的语言，自己使用Xtext给java增加上闭包之类的功能。如果再强撼一些，弄出个scala。估计是不可能做到的，但是应该可以实现出一些简单的东西。
&lt;br  /&gt;&lt;p&gt;比如我现在就希望，可以用它定义出一个单元测试生成器DSL。只需要定义一些规则出来，就能智能生成一大堆的单元测试，这样我做topcoder就可以省下很多时间了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>CoffeeScript</title>
                <link>http://freewind.in/posts/75-try-coffeescript</link>
                <pubDate>Tue, 13 Sep 2011 01:21:59 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">75</guid>
                <description><![CDATA[&lt;p&gt;CoffeeScript is a little language that compiles into JavaScript.
&lt;br  /&gt;&lt;p&gt;Javascript的语法，不得不说，实在太多的function定义以及花括号了，常常让人看得眼花缭乱。所以有了CoffeeScript。
&lt;br  /&gt;&lt;p&gt;它的语法相比javascript，实在是简洁太多了，有点像python，甚至更简洁一些。它将会编译成Javascript代码，所以写的还是javascript，只是有了很多的语法糖而已。它与Javascript的关系，就如同scala与java之间的关系。
&lt;br  /&gt;&lt;p&gt;截个图，看一眼就明白了：&amp;nbsp;
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;/user_images/75-1.png&quot;&gt;&lt;img src=&quot;/user_images/75-1.png&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;看了CoffeeScript，让我又有了学习javascript的欲望了：）&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>魔幻的grails</title>
                <link>http://freewind.in/posts/72-magic-grails</link>
                <pubDate>Tue, 13 Sep 2011 01:20:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">72</guid>
                <description><![CDATA[&lt;p&gt;今天尝试着使用grails来做一个小网站，感觉grails有点魔幻。虽然比rails好很多，但对于不熟悉它的人来说，还是经常让人摸不着头脑。&lt;/p&gt;
&lt;p&gt;grails是基于groovy的一个web框架，它在相当大的程度上模仿了rails，同一种思想，同一种风格。要想快速入门，建议搜索一个叫“grails入门指南.pdf”的中文文档，短短70页，可以让人很快了解如何用grails开发。然后，新建自己的项目，开始。&lt;/p&gt;
&lt;p&gt;在开发之前，准备好这几样：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载STS：&lt;a href=&quot;http://www.springsource.com/developer/sts&quot;&gt;http://www.springsource.com/developer/sts&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;STS全称SpringSource Tool Suite，是由spring提供的一个基于eclipse的开发工具。其特色是集成了很多spring项目的插件，比如spring roo, groovy, grails等等。由于groovy被spring收购了，所以它提供的插件功能是最强大的（远比idea的要强）。要注意的是，grails插件并没有包含在里面，下载之后，点击其“extendsions”按钮，手动选中grails等插件，下载安装。&lt;span id=&quot;more-72&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Grails文档：&lt;a href=&quot;http://grails.org/Documentation&quot;&gt;http://grails.org/Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找到其中的User Guide Pdf，这是一个官方提供的pdf文档，非常全面详细。因为grails大量使用了groovy的动态语言特征，导致IDE的提示功能有限，所以经常需要查手册。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Groovy文档 &lt;a href=&quot;http://groovy.codehaus.org/Documentation&quot;&gt;http://groovy.codehaus.org/Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;里面有一些教程，以及Reference处有一些可供下载的资料。不知道为什么，我下载下来的chm打开后，内容全是“无法显示”&lt;/p&gt;
&lt;p&gt;groovy的语法很灵活，开始的学习成本很低。因为它的语法风格与java非常相似，很多java代码直接拷到groovy中就可以运行。groovy提供的一些语法糖很不错，可以让代码写得很简洁。&lt;/p&gt;
&lt;p&gt;groovy与java相比，语言特性可以分为这几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;语法糖，简化代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大量使用闭包，需要专门理解闭包的delegate机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态部分，这是groovy的特色以及难点&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以用groovy写出很静态的代码，看起来就像是简化了的java。比如，每个变量和方法，都标明类型，这种情况下，IDE的提示会比较准确。有一个groovy++的项目，就是将groovy代码编译为静态类型代码，以提高性能，它要求的写法，就是这样。我很喜欢这样，有安全感。&lt;/p&gt;
&lt;p&gt;但是grails，作为ruby on rails的模仿者，当然是全力发挥其动态特性。这样，grails可以用很简洁方便的代码，快速实现功能。但也同样因为这个原因，如果你对grails不熟悉，特别是它约定的惯用法，就会觉得无所适从，无从下手。&lt;/p&gt;
&lt;p&gt;举几个例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义domain&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;class User {&lt;/p&gt;
&lt;p&gt;String email&lt;/p&gt;
&lt;p&gt;String name&lt;/p&gt;
&lt;p&gt;String password&lt;/p&gt;
&lt;p&gt;static hasMany = [ questions: Question]&lt;/p&gt;
&lt;p&gt;static contraints = {&lt;/p&gt;
&lt;p&gt;email nullable:false, blank:false, email:true, unique:true&lt;/p&gt;
&lt;p&gt;name nullable:false, blank:false&lt;/p&gt;
&lt;p&gt;password nullable:false, blank:false&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这是一个简单的Domain，它做了很多事情：定义了一个User类，声明了各属性，它与Question之间的一对多关系，它的每个字段在保存（或验证）时必须满足的条件。&lt;/p&gt;
&lt;p&gt;短短几行代码就做了这么多事情，开发效率果然高。但是，如果你不熟悉grails的话，就会觉得hasMany和constraints来得很突然。User类没有继承或实现任何接口，我们没法从代码中找到hasMany和constraints的来源（除非看文档），这是一种按名称事先约定好的惯例。只有靠看文档来熟悉这些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;controller&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;class Users {&lt;/p&gt;
&lt;p&gt;def create = {&lt;/p&gt;
&lt;p&gt;def user = new User(params)&lt;/p&gt;
&lt;p&gt;if(user.save()) {&lt;/p&gt;
&lt;p&gt;[user: user]&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;render view: &amp;#8220;register&amp;rdquo;, model: [user: user]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这是一个controller和action。注意，该controller同样没有继承或实现任何类，但是在create对应的闭包中，可以直接使用params这个参数（它表示得到的http参数）。为什么？我怎么知道这个params从哪儿来？除了它，我还能用什么？&lt;/p&gt;
&lt;p&gt;答案在文档中。打开grails.pdf，搜索controllers，写得清清楚楚，我们在controller中，可以使用request, response, params, flash, servletContext, pageScope等等变量。但是如果没有文档写着，谁知道会有这些东西？&lt;/p&gt;
&lt;p&gt;诸如此类，还有很多很多。要想熟练掌握这些，就必须先把文档看透，里面的知识点一个都不能漏，因为这些东西，你只能从文档中看到。还有多写程序，写多了就习惯了。同时多准备几个chm格式的api文档，groovy的，java的，grails的，放在手边经常查。因为很多时候，IDE都不能给你正确的提示，编译器也不会告诉你方法写错了，所以靠多查多背。&lt;/p&gt;
&lt;p&gt;这里有必要讲讲，那些在controller中可用的，如params,request这些变量，到底从哪儿来。在groovy中，闭包被大量使用，比如上面的create就是一个闭包。闭包中有一个特殊的变量叫delegate，它默认指向声明该闭包的外部结构（如类或者闭包），但是它是可变的。当我们在闭包中写“params”的时候，它其实是指“delegate.params”。这一点，与javascript中的函数function中的this，非常相似。当我们写好一个闭包后，可以将任意一个对象赋给它的delegate变量，闭包在执行时，就会从这个新的delegate对象上去调用方法或拿数据。我们可以把闭包看作一个司机，而delegate是他要开的车，虽然他默认有自己的车，但你随时可以把别的车换给他开，甚至飞机，当然很可能机毁人亡（程序出错）。&lt;/p&gt;
&lt;p&gt;这样我们就好理解了，肯定是在运行的时候，会将一个拥有着request, params, session等属性的对象，传给了这些action的delegate中，所以它才可以直接调用。但是我们是很难从代码中看到这些，除非你把grails的源代码下载下来，一点点地看。&lt;/p&gt;
&lt;p&gt;对于像我这样长期习惯了静态类型以及IDE提示的人来说，grails还是相当地魔幻。当然不可否认的是，一旦熟悉之后，你将拥有非常高的开发效率（如同ruby on rails一样），但是在那之前，你需要花很长时间去猜测、理解它的惯用约定，以前多看文档和代码，并记熟常用的api。我还是非常想念静态语言开发的感觉（比如play），那种安心感，是让人非常舒适的。&lt;/p&gt;
&lt;p&gt;我个人觉得，我们使用groovy不一定要全面使用它的动态类型。除去动态特性，groovy已经提供了比java丰富得多的表达能力。利用好这一点，应该也可以做出一个远比java中的那些web框架好用的groovy框架出来。在这种以静态类型为主的写法下，IDE的提示能力会比较好用，使用者也可以不必记那么多的东西，这已经是相当大的优势了。可惜的是，不知道为什么，在groovy世界中，好像除了grails，基本上找不到别的web框架了。&lt;/p&gt;
&lt;p&gt;groovy++现在正在蓬勃发展之中，它写出来的代码，主要以静态为主。使用它，我们可以写出容易理解的代码来。不过似乎它现在还不够成熟，离正式使用还有一段距离。我想它发展起来以后，使用它开发的web框架，应该易学很多。最后还要提一下还未发布的Kotlin，我感觉它与groovy++很像，但是它将拥有很好的IDE支持，所以我非常期待它早日发布。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>深入Java虚拟机之字节码文件格式</title>
                <link>http://freewind.in/posts/70-dive-into-jvm-the-format-of-byte-code</link>
                <pubDate>Tue, 13 Sep 2011 01:18:02 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">70</guid>
                <description><![CDATA[&lt;p&gt;这两天在研究JavaAgent，动力是想弄明白playframework到底是做到热修改的。从目前的少许了解，推测出它利用javaagent在类导入到JVM之前，对字节码进行了修改。然后再配合classloader，实现热修改。&lt;/p&gt;
&lt;p&gt;从网上找到的相关资料上来看，如果想理解清楚其原理，必须要了解字节码文件的格式和指令，也就是我们的.java文件编译后生成的.class二进制文件。听起来挺难的，毕竟我们在编程时，只需要面对java文件，从不需要考虑.class，而且打开.class看到的都是无法识别的二进制代码。好在《深入Java虚拟机》这本书详细讲解了字节码，真是雪中送炭。边看边试，发现并没有想像中的那么难以理解。&lt;/p&gt;
&lt;p&gt;.class文件中的内容，可以分为两部分，一是结构描述，二是代码指令。这其实跟我们写的java文件是非常相似的，只不过它为了性能考虑，生成了二进制文件。下面以HelloWorld来举例说明。&lt;/p&gt;
&lt;p&gt;首先我们定义一个最简单的test/HelloWorld.java：&lt;/p&gt;
&lt;p&gt;package test;&lt;/p&gt;
&lt;p&gt;public class HelloWorld {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;
&lt;p&gt;System.out.println(&amp;#8220;Hello, World!&amp;ldquo;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;span id=&quot;more-70&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;编译后，生成一个545字节的HelloWorld.class文件。我们可以使用以下代码，读取其内容并打印出来：&lt;/p&gt;
&lt;p&gt;import java.io.FileInputStream;&lt;/p&gt;
&lt;p&gt;import org.apache.commons.io.HexDump;&lt;/p&gt;
&lt;p&gt;import org.apache.commons.io.IOUtils;&lt;/p&gt;
&lt;p&gt;public class ClassReader {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) throws Exception {&lt;/p&gt;
&lt;p&gt;String file = &amp;#8220;E:/WORKSPACE/TestJava/bin/test/HelloWorld.class&amp;rdquo;;&lt;/p&gt;
&lt;p&gt;FileInputStream input = new FileInputStream(file);&lt;/p&gt;
&lt;p&gt;byte[] bytes = IOUtils.toByteArray(input);&lt;/p&gt;
&lt;p&gt;HexDump.dump(bytes, 0, System.out, 0);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;其中HexDump是commons-io提供的一个类，非常实用。该程序将向控制台上打印出以下内容：&lt;/p&gt;
&lt;p&gt;00000000 CA FE BA BE 00 00 00 32 00 22 07 00 02 01 00 0F &amp;hellip;&amp;hellip;.2.&amp;ldquo;&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;00000010 74 65 73 74 2F 48 65 6C 6C 6F 57 6F 72 6C 64 07 test/HelloWorld.&lt;/p&gt;
&lt;p&gt;00000020 00 04 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F &amp;hellip;..java/lang/O&lt;/p&gt;
&lt;p&gt;00000030 62 6A 65 63 74 01 00 06 3C 69 6E 69 74 3E 01 00 bject&amp;hellip;&lt;init&gt;..&lt;/p&gt;
&lt;p&gt;00000040 03 28 29 56 01 00 04 43 6F 64 65 0A 00 03 00 09 .()V&amp;hellip;Code&amp;hellip;..&lt;/p&gt;
&lt;p&gt;00000050 0C 00 05 00 06 01 00 0F 4C 69 6E 65 4E 75 6D 62 &amp;hellip;&amp;hellip;..LineNumb&lt;/p&gt;
&lt;p&gt;00000060 65 72 54 61 62 6C 65 01 00 12 4C 6F 63 61 6C 56 erTable&amp;hellip;LocalV&lt;/p&gt;
&lt;p&gt;00000070 61 72 69 61 62 6C 65 54 61 62 6C 65 01 00 04 74 ariableTable&amp;hellip;t&lt;/p&gt;
&lt;p&gt;00000080 68 69 73 01 00 11 4C 74 65 73 74 2F 48 65 6C 6C his&amp;hellip;Ltest/Hell&lt;/p&gt;
&lt;p&gt;00000090 6F 57 6F 72 6C 64 3B 01 00 04 6D 61 69 6E 01 00 oWorld;&amp;hellip;main..&lt;/p&gt;
&lt;p&gt;000000A0 16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 .([Ljava/lang/St&lt;/p&gt;
&lt;p&gt;000000B0 72 69 6E 67 3B 29 56 09 00 11 00 13 07 00 12 01 ring;)V&amp;hellip;&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;000000C0 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 53 79 73 74 ..java/lang/Syst&lt;/p&gt;
&lt;p&gt;000000D0 65 6D 0C 00 14 00 15 01 00 03 6F 75 74 01 00 15 em&amp;hellip;&amp;hellip;..out&amp;hellip;&lt;/p&gt;
&lt;p&gt;000000E0 4C 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 53 74 Ljava/io/PrintSt&lt;/p&gt;
&lt;p&gt;000000F0 72 65 61 6D 3B 08 00 17 01 00 0D 48 65 6C 6C 6F ream;&amp;hellip;&amp;hellip;Hello&lt;/p&gt;
&lt;p&gt;00000100 2C 20 57 6F 72 6C 64 21 0A 00 19 00 1B 07 00 1A , World!&amp;hellip;&amp;hellip;..&lt;/p&gt;
&lt;p&gt;00000110 01 00 13 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 &amp;hellip;java/io/Print&lt;/p&gt;
&lt;p&gt;00000120 53 74 72 65 61 6D 0C 00 1C 00 1D 01 00 07 70 72 Stream&amp;hellip;&amp;hellip;..pr&lt;/p&gt;
&lt;p&gt;00000130 69 6E 74 6C 6E 01 00 15 28 4C 6A 61 76 61 2F 6C intln&amp;hellip;(Ljava/l&lt;/p&gt;
&lt;p&gt;00000140 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 01 00 04 ang/String;)V&amp;hellip;&lt;/p&gt;
&lt;p&gt;00000150 61 72 67 73 01 00 13 5B 4C 6A 61 76 61 2F 6C 61 args&amp;hellip;[Ljava/la&lt;/p&gt;
&lt;p&gt;00000160 6E 67 2F 53 74 72 69 6E 67 3B 01 00 0A 53 6F 75 ng/String;&amp;hellip;Sou&lt;/p&gt;
&lt;p&gt;00000170 72 63 65 46 69 6C 65 01 00 0F 48 65 6C 6C 6F 57 rceFile&amp;hellip;HelloW&lt;/p&gt;
&lt;p&gt;00000180 6F 72 6C 64 2E 6A 61 76 61 00 21 00 01 00 03 00 orld.java.!&amp;hellip;..&lt;/p&gt;
&lt;p&gt;00000190 00 00 00 00 02 00 01 00 05 00 06 00 01 00 07 00 &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;000001A0 00 00 2F 00 01 00 01 00 00 00 05 2A B7 00 08 B1 ../&amp;hellip;&amp;hellip;..*&amp;hellip;.&lt;/p&gt;
&lt;p&gt;000001B0 00 00 00 02 00 0A 00 00 00 06 00 01 00 00 00 03 &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;000001C0 00 0B 00 00 00 0C 00 01 00 00 00 05 00 0C 00 0D &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;000001D0 00 00 00 09 00 0E 00 0F 00 01 00 07 00 00 00 37 &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;7&lt;/p&gt;
&lt;p&gt;000001E0 00 02 00 01 00 00 00 09 B2 00 10 12 16 B6 00 18 &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;000001F0 B1 00 00 00 02 00 0A 00 00 00 0A 00 02 00 00 00 &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;00000200 05 00 08 00 06 00 0B 00 00 00 0C 00 01 00 00 00 &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;00000210 09 00 1E 00 1F 00 00 00 01 00 20 00 00 00 02 00 &amp;hellip;&amp;hellip;&amp;hellip;. &amp;hellip;..&lt;/p&gt;
&lt;p&gt;00000220 21                                              !&lt;/p&gt;
&lt;p&gt;上面这些内容，分可为三列&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/70-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/70-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每一列有点像行号，它表示当前行的内容是从原字节流中哪一位开始。所以第一行是00000000，表示从头开始。第一行打印了16个字节的内容，所以第二行是00000010。&lt;/p&gt;
&lt;p&gt;第二列是字节的16进制值，其取值范围从00-FF，每行16个字节。&lt;/p&gt;
&lt;p&gt;第三列是每个字节对应的ASCII码形式，所以数字字母等，可以正确显示出来。超出ASCII码范围的，就用“点”表示了。&lt;/p&gt;
&lt;p&gt;看到这一堆数字，是不是很头晕？不用怕，只要知道如何解读，其实不难。它包含了HelloWorld.java中包含的全部信息（如类名，方法名等），以及编译器自己加入的一些内容（如初始化函数，调试信息如行号等）。只不过它使用了利于机器阅读的格式，只要知道了格式定义，就很容易翻译成人读的格式。&lt;/p&gt;
&lt;p&gt;下表就是.class文件的格式定义。我们只需要从第一个字节读起，一遍下来，整个.class文件的内容就解析完了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取四个字节magic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CA FE BA BE&lt;/strong&gt;00 00 00 32 00 22 07 00 02 01 00 0F&lt;/p&gt;
&lt;p&gt;用于快速判断一个文件是不是java class文件的“魔数”：0xCAFEBABE （它是一个咖啡名称）。如果一个文件不是以它开头，说明绝对不是字节码文件。如果是，还需要再进一步判断后面的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取两个字节minor_version&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CA FE BA BE &lt;strong&gt;00 00&lt;/strong&gt;00 32 00 22 07 00 02 01 00 0F&lt;/p&gt;
&lt;p&gt;表示子版本号，这里是0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取两个字节major_version&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CA FE BA BE 00 00 &lt;strong&gt;00 32&lt;/strong&gt;00 22 07 00 02 01 00 0F &amp;hellip;&amp;hellip;.2.&amp;ldquo;&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;表示主版本号，32表示50，即jdk1.6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取两个字节constant_pool_count&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CA FE BA BE 00 00 00 32 &lt;strong&gt;00 22&lt;/strong&gt;07 00 02 01 00 0F&lt;/p&gt;
&lt;p&gt;0022表示34，说明一共定义了33个常量（索引为0的那个未使用）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着就是33个常量定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个常量的第一个字节是一个标签（tag)，表示一种类型的常量，每个类型都有自己的格式，长度不定。在jdk1.2中，一共有11种不同类型的常量，现在应该增加了不少新的常量：&lt;/p&gt;
&lt;p&gt;常量名                                              标识&lt;/p&gt;
&lt;p&gt;CONSTANT_Utf8                                1&lt;/p&gt;
&lt;p&gt;CONSTANT_Integer                           3&lt;/p&gt;
&lt;p&gt;CONSTANT_Float                              4&lt;/p&gt;
&lt;p&gt;CONSTANT_Long                              5&lt;/p&gt;
&lt;p&gt;CONSTANT_Double                           6&lt;/p&gt;
&lt;p&gt;CONSTANT_Class                             7&lt;/p&gt;
&lt;p&gt;CONSTANT_String                             8&lt;/p&gt;
&lt;p&gt;CONSTANT_Fieldref                          9&lt;/p&gt;
&lt;p&gt;CONSTANT_Methodref                     10&lt;/p&gt;
&lt;p&gt;CONSTANT_InterfaceMethodref       11&lt;/p&gt;
&lt;p&gt;CONSTANT_NameAndType              12&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们要读取33个常量，分别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取常量（索引为1）的第一个字节tag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CA FE BA BE 00 00 00 32 00 22 &lt;strong&gt;07&lt;/strong&gt;00 02 01 00 0F&lt;/p&gt;
&lt;p&gt;07表示Class_info，其格式定义为：&lt;/p&gt;
&lt;p&gt;1字节 tag&lt;/p&gt;
&lt;p&gt;2字节 对应的常量池索引&lt;/p&gt;
&lt;p&gt;所以它一共有3个字节，我们还需要再读2个字节：&lt;/p&gt;
&lt;p&gt;CA FE BA BE 00 00 00 32 00 22 07 &lt;strong&gt;00 02&lt;/strong&gt;01 00 0F&lt;/p&gt;
&lt;p&gt;0002即2，表示这个class对应的常量索引为2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取下一个常量（索引为2）的第一个字节tag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CA FE BA BE 00 00 00 32 00 22 07 00 02 &lt;strong&gt;01&lt;/strong&gt;00 0F&lt;/p&gt;
&lt;p&gt;01表示一个UTF8字符串，它的格式定义为：&lt;/p&gt;
&lt;p&gt;1字节 tag&lt;/p&gt;
&lt;p&gt;2字节 length&lt;/p&gt;
&lt;p&gt;n字节 与length长度相等&lt;/p&gt;
&lt;p&gt;往下读2个字节00 0F ，表示长度为15，然后再从下一行读取15个字节：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;74 65 73 74 2F 48 65 6C 6C 6F 57 6F 72 6C 64&lt;/strong&gt;07&lt;/p&gt;
&lt;p&gt;这个字符串的内容是“test/HelloWorld”，其长度为15。&lt;/p&gt;
&lt;p&gt;一直读到第33个常量。&lt;/p&gt;
&lt;p&gt;继续读2个字节access_flags&lt;/p&gt;
&lt;p&gt;读2个字节this_class&lt;/p&gt;
&lt;p&gt;读2个字节super_class&lt;/p&gt;
&lt;p&gt;读2个字节interfaces_count&lt;/p&gt;
&lt;p&gt;读2个字节interfaces&lt;/p&gt;
&lt;p&gt;读2个字节access_flags&lt;/p&gt;
&lt;p&gt;待续&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Netty初探</title>
                <link>http://freewind.in/posts/67-try-netty</link>
                <pubDate>Tue, 13 Sep 2011 01:16:06 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">67</guid>
                <description><![CDATA[&lt;p&gt;本来打算这几天好好研究Netty的源代码的，真做起来发现还是缺少充足的动力。最开始还算认真的看了其buffer包，但是到了后来，就变成看javadoc了，知道有哪些类、类中有哪些方法就知足了。毕竟有500多个java文件，看起来真够累的。&lt;/p&gt;
&lt;p&gt;好在基本理解了nio 之后，看netty也不是很难。Netty跟Mina结构上相当的相似，据说性能略优、在细节上更完善一些，但是我的直观感觉就是，Netty的文档和例子相当不错，让人很理解起来容易一些（以前学Mina时，费不了少工夫）。&lt;/p&gt;
&lt;p&gt;这里简单的总结一下，技术含量不高（因为没有深入下去）。上一个日志中讲到，NIO有四大主要概念：Channel, Selector, SelectionKey, Buffer。Netty中同样也少不了这些，并且出于性能和设计上的考虑，对它们进行了扩充。比如netty的buffer包，重新定义了Buffer，提供了各种各样的实现，比jdk中自带的Buffer更加高效与好用。举例来说，jdk中的buffer在读完数据写之前，必须调用一个flip()方法，否则数据出错但不报错，这很容易引起bug。而Netty的Buffer中增加了一个write index，将读写分开，解决了这个问题。另外，jdk的buffer是固定的，而netty还提供了一个可变长的buffer，方便操作。&lt;/p&gt;
&lt;p&gt;而Channel在Netty中也重新设计，提供了很多种Channel，照顾到不同程序的需要。而Selector和SelectionKey，还是使用jdk自己的。&lt;/p&gt;
&lt;p&gt;重要的地方，是Netty定义了很多事件，如connected, messageReceived, messageSent等等。我们可以继承一个Handler，来实现对应的操作，它们将在对应事件发生的时候，被自动调用。这就是“事件驱动”。&lt;/p&gt;
&lt;p&gt;为了简化操作，我们还可以使用Encoder和Decoder将传送于网络间的二进制数据与我们操作的pojo进行互转，这样在程序中无须直接操作底层数据。&lt;/p&gt;
&lt;p&gt;Netty提供了不少协议的实现，如http等，让Netty有了初步的处理http请求的能力。其http的encoder和decoder，在底层处理http请求的交互数据，将其变为了request, cookie, response等对象。因此现在有很多web框架尝试将Netty作为自己内嵌的http服务器，以达到更佳的性能与方便的操作。不过据我观察，Netty提供的支持还比较简单（如request, response等类中，方法很少），如果真要使用，还需要对它进行扩展。&lt;/p&gt;
&lt;p&gt;Netty使用一个Boss线程来处理新连接，而将数据读取和处理等，分给若干个Worker线程。它在内部其实还是使用了“轮询”，去调用selector.select()得到可用事件，最终转变为对Hander中相关回调方法的调用。这一点我以前在用Mina的时候不太明白，因为我一直觉得这是一件很神奇的事情，怎么会用最简单的轮询呢？原来还是自己想多了，真的是轮询，现在总算是放下心来。&lt;/p&gt;
&lt;p&gt;这两天的收获如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Nio没有想像中那么深奥难懂&lt;/li&gt;
&lt;li&gt;Netty使用nio，其原理与nio基本相似，并不难懂。可看见对nio的扩展与优化。&lt;/li&gt;
&lt;li&gt;Netty使用轮询来得到nio的可用事件&lt;/li&gt;
&lt;li&gt;Netty支持http，但比较简单。如果希望使用它作为http server，需要自己扩展。&lt;/li&gt;
&lt;/ol&gt;
]]></description>
            </item>
        
            <item>
                <title>Java nio 初体验</title>
                <link>http://freewind.in/posts/66-try-java-nio</link>
                <pubDate>Tue, 13 Sep 2011 01:15:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">66</guid>
                <description><![CDATA[&lt;p&gt;Java的nio是jdk5推出的东西，距现在已经五六年了。我虽然曾经使用过Mina（一个使用事件驱动的nio框架）做过一些项目，但实际上对nio的了解还是很模糊，只是知道它的特点是“非阻塞”。
&lt;br  /&gt;&lt;p&gt;近期打算研究一下Netty（它跟Mina很像，是同一个作者的作品），所以先研究下Nio。网上的中文资料相当少，大多讲得不清不楚，给的示例代码更是看得人头晕。好在群友“羊八井”推荐了我一本好书：《Java network programming 3rn edition》，它的第12章就是专讲nio的。这本书写得不错，详细而清晰，把重点都讲到了。我花了三四个小时，把这一章读完，基本上对nio有了一个比较感性上的认识。
&lt;br  /&gt;&lt;p&gt;nio是new IO，它的特点是“非阻塞”。相对于之前的阻塞IO，最大的好处是提高了性能。只要抓住两点：“非阻塞”与“性能”，nio就好理解了。
&lt;br  /&gt;&lt;p&gt;以前使用Java进行socket编程时，等待客户端连接的accept()和读取数据的read()方法，都是“阻塞”的。“阻塞”的意思就是说，这两个函数都是非常固执的，一旦调用，所在线程就会卡在那里，直到取到了数据，或者超时，或者出错。意味着一个线程一次只能做一件事情。如果客户端连接只有一个，这种方式倒十分简便，但一旦有多个连接，服务器就必须用多个线程分别处理。当连接比较多（比如上千时），就会有大量的时间浪费在线程间的切换上，性能比较差。对于像web server这样的程序来说，是难以接受的。
&lt;br  /&gt;&lt;p&gt;而nio是非阻塞的，它的accept()和read()方法，调用后马上返回，线程不会卡住。这样我们就可以在一个线程中，处理多个连接（当然也可以使用更多的线程，更充分地利用cpu）。那么，我们如何知道有连接来了，或者拿到数据了呢？答案是轮询，判断返回值，办法虽笨，但是有用。
&lt;br  /&gt;&lt;p&gt;nio还是“事件驱动”的，这与“非阻塞”正好搭配。我们可以给每个连接注册想要监听的事件，如accept, connect, read, write，然后就去做别的事。如果没事可做，就轮询，调用selectKeys()方法检查当前发生的事件。当我们监听的事件发生了（比如监听了read事件，并且有数据可读时），即可得到对应的SelectKey对象。我们可以从该对象身上拿到对应的连接，做想做的事情，比如读数据写数据，注册新的监听事件等。
&lt;br  /&gt;&lt;p&gt;该“性能”了。nio为了提高数据交换的性能，提供了一些buffer类，用于缓存读取的数据及输出的数据。这些buffer长度固定，并且用一些属性如position, limit, mark等标示当前可用的数据，以及一些方法clear(), flip(), rewind(), mark(), reset(), compact()等，改变这些属性。这里有些复杂，一定要理解清楚，才不会用错。但理解起来也不难，因为它搞这么复杂就是为了复用数据，为了复用肯定要有一些方法来记录哪些数据被使用了，哪些未被使用。这样在read和write时，才能正确拿到可用的数据。nio中，所有需要交换数据的地方，都在用buffer，所以相关操作一定要弄明白，不然寸步难行。
&lt;br  /&gt;&lt;p&gt;最后就是nio中几个重要的概念：Channel, Selector, SelectionKey, Buffer。Channel就像是门，Selector是看门的，SelectionKey是事件记录，而Buffer是送货的推车。
&lt;br  /&gt;&lt;p&gt;整个流程是这样的：首先我们在墙上装几个门（Channel），然后请一个看门人(Selector)过来，告诉他要看哪几个门（注册），还要记录下哪些情况。然后我就去干自己的事了，过一会儿过来看看，对看门人说：把你的记录本给我看看。如果是空的，就还给他，接着干自己的事。如果有记录(SelectionKey)，就一一查看：A门有人送货，B门有人提货，C门有客上门。这时可能会用到推车(Buffer)来装货卸货。处理完这一批事件后，我把这些记录撕掉(key.remove())，还给看门人，告诉他还要记录哪些新情况（重新注册）。然后我再去做其它事，过一会儿再回来看看。。。
&lt;br  /&gt;&lt;p&gt;从这里可以看出，nio还是比较底层的，属于基础设施。因为它虽然可以告诉我们发生了哪些事件，但是不能给每个事件设置回调函数，必须手动轮询。所以就有了如Mina、Netty这样的基于nio的框架。它们最大的作用，就是抽象出多个事件，让我们设置对应的回调函数。之前我还需要过一会儿过来问问看门人，而现在，我只需要在一开始给看门人交待好“发生了什么事情，你就去做什么事”，然后就可以什么也不用管了。
&lt;br  /&gt;&lt;p&gt;Nio的重点差不多就这样了，剩下的就是要熟悉那些api的使用。原理相比以前的阻塞io要复杂了一点，但是api却复杂不少。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Js UI库 modernizr</title>
                <link>http://freewind.in/posts/65-js-ui-modernizr</link>
                <pubDate>Tue, 13 Sep 2011 01:13:33 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">65</guid>
                <description><![CDATA[&lt;p&gt;网址：&lt;a href=&quot;http://www.modernizr.com/&quot;&gt;http://www.modernizr.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现这个库，源于看到了这个网站：&lt;a href=&quot;http://www.heroku.com/&quot;&gt;http://www.heroku.com/&lt;/a&gt;，感觉它的UI比较酷。特别是Pricing页面：&lt;a href=&quot;http://www.heroku.com/pricing&quot;&gt;http://www.heroku.com/pricing&lt;/a&gt;，上下拖动中间的两个滑片时，感觉很有趣。查看它的源代码时，发现了modernizr。&lt;/p&gt;
&lt;p&gt;暂时没有时间看，先记下来，有空时研究一下。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 9. 窗口操作（转载）</title>
                <link>http://freewind.in/posts/64-vim-9-window-operations</link>
                <pubDate>Tue, 13 Sep 2011 01:05:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">64</guid>
                <description><![CDATA[&lt;p&gt;打开一个新窗口&lt;/p&gt;
&lt;p&gt;最简单的打开新窗口的方法是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:split
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它把一个窗口分成两个，光标留在上面的那个窗口中。 &lt;span id=&quot;more-64&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-w+方向键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来在窗口间切换&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-ww 或 Ctrl-w Ctrl-w
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;切换到下一个窗口;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-wj 和 Ctrl-wk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分别切换到下一个窗口和上一个窗口。&lt;/p&gt;
&lt;p&gt;要关闭窗口，用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:q 或 ZZ 或 Ctrl-wc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找开一个新窗口并在其中打开一个文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:split 文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以给split命令分配一个初始命令，也就是说执行完split接着要做的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:split +命令 文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:split +/printf three.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令会把当前窗口分成两个然后在上面的窗口中查找printf这个字符串。&lt;/p&gt;
&lt;p&gt;控制窗口大小&lt;/p&gt;
&lt;p&gt;如果给split命令指定一个参数，则表示新找开窗口的高度&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:3split alpha.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开一个高度为3的窗口并在其中打开alpha.c&lt;/p&gt;
&lt;p&gt;:new命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:new
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令用起来就跟split差不多，只有一点不同：new命令会在新窗口中新建一个文件，而split只是在新窗口中打开原窗口中的内容。&lt;/p&gt;
&lt;p&gt;分割并查看(Split and View)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:sview
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令新建一个窗口并且其中的内容是只读的。&lt;/p&gt;
&lt;p&gt;改变窗口大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;行数Ctrl-w+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把当前窗口高度增加&quot;行数&quot;行(如不指定行数，默认为1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;行数Ctrl-w-
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把当前窗口高度减少&quot;行数&quot;行(如不指定行数，默认为1)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ctrl-w=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让所有窗口一样高&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;行数Ctrl-w_
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把当前窗口的高度设为&quot;行数&amp;rdquo;，如不指定则把它最大化。&lt;/p&gt;
&lt;p&gt;缓冲&lt;/p&gt;
&lt;p&gt;Vim用缓冲来代表一个文件。当你在编缉一个文件时，只是在编缉它的缓冲。当你完成编辑保存时，Vim把缓冲中的内容保存进文件。当然，事情并不是这么简单。在Vim中设置的标记之类的也保存在缓冲中。你可以同时拥有多个缓冲，当你编辑多个文件时就是这样。当你想要一个Vim窗口，并且想编辑多个文件时，把这个窗口最大化是不管用的，因为这不是一个窗口，其它的窗口还是能看得见的。此时你可以把不编辑的缓冲隐藏(hide)，用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:hide
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个缓冲有三种可能的状态:&lt;/p&gt;
&lt;p&gt;活动:显示在屏幕上的窗口&lt;/p&gt;
&lt;p&gt;隐藏:没有显示在屏幕上的在编辑的缓冲&lt;/p&gt;
&lt;p&gt;不活动:缓冲没有在编辑，但是保存着它的信息&lt;/p&gt;
&lt;p&gt;第三种状态需要多解释一下，当你编辑另一个文件时，当前文件的内容就没有用了。Vim就关掉它。但是它的一些其它信息可能还有用。（这一部分比较混乱，原文说得也不是很清楚，不懂也无所谓）&lt;/p&gt;
&lt;p&gt;要查看缓冲的列表，用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:buffers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命令。输出的第一列是缓冲编号，第二列是状态，第三列是与缓冲对应的文件。&lt;/p&gt;
&lt;p&gt;状态共且以下几种:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 不活动的缓冲
   h 隐藏的缓冲
   % 当前缓冲
   # 其它缓冲
   + 文件被编辑而未保存
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选择一个缓冲&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:buffer 缓冲编号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你不知道缓冲的编号，可以用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:buffer 文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的命令分割窗品并编辑指定的缓冲&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:sbuffer 缓冲编号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:sbuffer 文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有很多关于缓冲的命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:bnext 去下一个缓冲
:count bnext 执行count次去下一个缓冲
:count sbnext 先分割窗口，然后执行:count bnext
:count bprevious 去上一个缓冲。如果指定了count,则执行count次
:count sbprevious 先分割窗口，然后执行:count bprevious
:count bNext 同:count bprevious
:count sbNext 同:count sbprevious
:blast 去最后一个缓冲
:sblast 先分割窗口再执行:blast
:brewind 去第一个窗口
:sbrewind 先分割窗口再执行:brewind
:bmodified count 去第count个编辑过的缓冲
:sbmodified count 等于:split加:bmodified
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;缓冲选项&lt;/p&gt;
&lt;p&gt;通常当所有编辑一个文件的窗口都关掉后，这个窗口的缓冲就变成&quot;不活动&amp;rdquo;,如果不想这样，可以设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:set hidden
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让它变成隐藏而不是不活动。&lt;/p&gt;
&lt;p&gt;通常分割/缓冲相关的命令会分割当前窗口，但是也可以让Vim在已经有窗口打开所指定的缓冲时，切换到那个窗口而不是新建一个:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:set switchbuf=useopen
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 8. java开发插件Vim JDE</title>
                <link>http://freewind.in/posts/63-vim-8-vim-jde-for-java-dev</link>
                <pubDate>Tue, 13 Sep 2011 01:04:55 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">63</guid>
                <description><![CDATA[&lt;p&gt;这是个中国人开发的插件，不错：）
&lt;br  /&gt;&lt;p&gt;重点介绍它，因为它让vim具备了IDE的一些功能：项目管理、代码提示等。特别是代码提示，我一直都担心vim不能像eclipse那样可以进行代码提示，但是今天一试，看起来还不错。上图：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;/user_images/63-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/63-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;还没用熟，先写这么多。
&lt;br  /&gt;&lt;p&gt;主页：&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=1213&quot;&gt;http://www.vim.org/scripts/script.php?script_id=1213&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;中文文档：&lt;a href=&quot;http://media.cqic.com.cn/vjde-tut/index.htm&quot;&gt;http://media.cqic.com.cn/vjde-tut/index.htm&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 7. 英文拼写检查插件Engspchk</title>
                <link>http://freewind.in/posts/60-vim-7-check-spelling-engspchk</link>
                <pubDate>Tue, 13 Sep 2011 00:22:57 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">60</guid>
                <description><![CDATA[&lt;p&gt;像我这样英语马马虎虎的，写出来的英文注释中经常会有一些拼写错误，使用这个&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=195&quot;&gt;Engspchk&lt;/a&gt;可以帮助我们检查。
&lt;br  /&gt;&lt;p&gt;上图：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;/user_images/60-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/60-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;使用起来很简单，只需要输入\ec这三个字符，就会自动对当前的文件进行检查，把不认识的词用多种颜色标示出来。
&lt;br  /&gt;&lt;p&gt;还有其它的命令，暂不介绍。
&lt;br  /&gt;&lt;p&gt;主页：&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=195&quot;&gt;http://www.vim.org/scripts/script.php?script_id=195&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 6. 插件taglist.vim，显示源代码大纲</title>
                <link>http://freewind.in/posts/57-vim-6-taglist-plugin-to-show-outline</link>
                <pubDate>Tue, 13 Sep 2011 00:07:49 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">57</guid>
                <description><![CDATA[&lt;p&gt;所谓大纲，就是把一个源代码文件（比如java,c,c++,c#,php等等）中的类名、函数名、字段名等等提取出来显示，可以让我们快速对整个文件的结构有一个概览。
&lt;br  /&gt;&lt;p&gt;vim本身没有提供这个功能，但是通过一些爱好者写的插件程序，就可以做到。比如这个好评如潮下载量惊人的插件taglist.vim。
&lt;br  /&gt;&lt;p&gt;先来个图看看，使用前：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;/user_images/57-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/57-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;使用后：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;/user_images/57-3.jpg&quot;&gt;&lt;img src=&quot;/user_images/57-3.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;看起来还不错吧：）
&lt;br  /&gt;&lt;p&gt;taglist依赖于另一个工具叫：ctags，必须先安装它才能正常作用。ctags是一个命令行工具，它可以把几十种不同编程语言的源文件中的大纲信息提取出来，生成一个索引文件。taglist实际上是把它与vim结合在了一起。
&lt;br  /&gt;&lt;p&gt;安装教程：
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/unbutun/archive/2009/03/10/3976894.aspx&quot;&gt;http://blog.csdn.net/unbutun/archive/2009/03/10/3976894.aspx&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;&lt;a href=&quot;http://cid-8eca0345e6c4ea28.spaces.live.com/Blog/cns!8ECA0345E6C4EA28!113.entry&quot;&gt;http://cid-8eca0345e6c4ea28.spaces.live.com/Blog/cns!8ECA0345E6C4EA28!113.entry&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;taglist主页：&lt;a href=&quot;http://vim-taglist.sourceforge.net/&quot;&gt;http://vim-taglist.sourceforge.net/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;ctags主页：&lt;a href=&quot;http://ctags.sourceforge.net/&quot;&gt;http://ctags.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 5. 使用启动配置文件</title>
                <link>http://freewind.in/posts/50-vim-5-myvimrc</link>
                <pubDate>Tue, 13 Sep 2011 00:05:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">50</guid>
                <description><![CDATA[&lt;p&gt;我们可以把需要的配置写在vim的配置文件中，这样，当vim启动时，它就会自动变成我们设置好的样子，不需要我们再次设置。怎么做呢？&lt;/p&gt;
&lt;p&gt;在vim的安装目录下，有一个文件叫&lt;code&gt;_vimrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它没有后缀，是一个文本文件，有一些我目前还不怎么懂也不需要去懂的内容。它就是vim默认的启动文件。&lt;/p&gt;
&lt;p&gt;在它的同级目录下，我新建了一个文件叫：&lt;code&gt;myvimrc.vim&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;专门放我的配置，然后在_vimrc中加入一行代码指向它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source $VIMRUNTIME/../myvimrc.vim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的myvimrc.vim文件的内容，现在是这样子的：&lt;/p&gt;
&lt;p&gt;&quot; 不要菜单&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set go=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&quot; 使用evening配色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;colo evening
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&quot; 显示行号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set nu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&quot; 使用Megatops ProCoder字体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set guifont=Megatops_ProCoder_1.0:h10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&quot; 下面是一个插件Taglist的快捷键，按F8就可以快速打开和关闭tag列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;F8&amp;gt; :TlistToggle&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 2. 更换配色</title>
                <link>http://freewind.in/posts/48-vim-2-change-themes</link>
                <pubDate>Tue, 13 Sep 2011 00:03:10 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">48</guid>
                <description><![CDATA[&lt;p&gt;gvim默认使用的是一种灰色的配色方案，这也是它看起来其貌不扬的原因。见下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实它背景应该是白色的，只是我为了保护眼睛，调成了绿豆色。&lt;span id=&quot;more-48&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再看看很多人推荐的，也是我现在使用的evening配色。使用命令&lt;/p&gt;
&lt;p&gt;:colo evening&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-3.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-3.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再看看其它的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-5.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-5.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-7.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-7.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-9.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-9.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-11.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-11.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/48-13.jpg&quot;&gt;&lt;img src=&quot;/user_images/48-13.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多的就不试了&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 4. 查看当前的设置</title>
                <link>http://freewind.in/posts/49-vim-4-view-current-settings</link>
                <pubDate>Tue, 13 Sep 2011 00:03:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">49</guid>
                <description><![CDATA[&lt;p&gt;我们可以使用set命令来配置我们的vim，也可以使用它来查看。&lt;/p&gt;
&lt;p&gt;设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set go=xxxx
set guifont=xxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要想查看，则只输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set go
set guifont
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不要后面的等号&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>vim 1. 更换字体</title>
                <link>http://freewind.in/posts/33-vim-1-set-fonts</link>
                <pubDate>Mon, 12 Sep 2011 23:57:47 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">33</guid>
                <description><![CDATA[&lt;p&gt;在windows下，gvim使用的是一种叫Fixedsys的等宽字体，就是记事本默认使用的那种。其实看起来也还好，除了有一些关键字会被“加粗”，看起来就别扭了。如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/33-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/33-1.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意那些&quot;private/public/void/return&amp;rdquo;，被加粗了，虽然看起来还能将就，看是总觉得有点不舒服，五大三粗，太胖了。&lt;span id=&quot;more-33&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;经过搜索资料，发现在linux等操作系统上，默认使用的字体是细的，“加粗”后看起来正好，但是在windows上，fixedsys这种字体本身就是笔划比较粗的，再加粗后就肿了。怎么办？&lt;/p&gt;
&lt;p&gt;我开始试着改gvim的配置，但是对于现在的我来说实在太复杂了，而且这也好像不是推荐的方式。最后发现，真有不少字体是专门为编程而设计的，这些字体，字母的宽度相等，看起来清晰，容易区分。只要我换一种细字体，不就可以了吗？&lt;/p&gt;
&lt;p&gt;找到了几篇文章，专门讲编程字体：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Megatops ProCoder 1.0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://superding.spaces.live.com/blog/cns!89E842A8485366C7!1059.entry&quot;&gt;http://superding.spaces.live.com/blog/cns!89E842A8485366C7!1059.entry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这款字体是我最后选定的，好像是国内的一个朋友设计的，笔划细腻，形态优美。有图有真相：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/33-3.jpg&quot;&gt;&lt;img src=&quot;/user_images/33-3.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里要特别感谢一下作者。可惜其博客上提供的下载地址用不了，最后是在这里下载到的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/source/670116&quot;&gt;http://download.csdn.net/source/670116&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要注册才行。&lt;/p&gt;
&lt;p&gt;安装方式：&lt;/p&gt;
&lt;p&gt;a. 下载后将其中的字体文件放入windows/font目录下&lt;/p&gt;
&lt;p&gt;b. 在vim上输入命令 :set guifont=Megatops_ProCoder_1.0:h10&lt;/p&gt;
&lt;p&gt;其中Megatops_ProCoder_1.0是字体名，h10是大小：10号&lt;/p&gt;
&lt;p&gt;c. 可以将该命令写入到vim的配置文件中，启动后自动使用该字体&lt;/p&gt;
&lt;p&gt;2.  适合编程的十种字体&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://3seconds.cn/2010/01/20/10-programming-fonts.html&quot;&gt;http://3seconds.cn/2010/01/20/10-programming-fonts.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直奔第一名：免费的Inconsolata&lt;/p&gt;
&lt;p&gt;主页：&lt;a href=&quot;http://www.levien.com/type/myfonts/inconsolata.html&quot;&gt;http://www.levien.com/type/myfonts/inconsolata.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击其中的&quot;OpenType file &amp;#8220;链接下载字体文件，放入windows/font&lt;/p&gt;
&lt;p&gt;看看效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/33-5.jpg&quot;&gt;&lt;img src=&quot;/user_images/33-5.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;字体很好看，圆润型的，我记得那些搞rails的基本上都用的是这种字体。只是不知道为什么，在我这里看起来有点虚，不舒服，不然我就选它了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;适合编程的22种字体&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.2maomao.com/blog/best-programmer-fonts/&quot;&gt;http://www.2maomao.com/blog/best-programmer-fonts/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没试，放在这里备用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;还有不少人推荐Yahei+Consolas&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;见&lt;a href=&quot;http://www.cnblogs.com/webflash/archive/2009/07/05/1517291.html&quot;&gt;http://www.cnblogs.com/webflash/archive/2009/07/05/1517291.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我现在对Megatops ProCoder还是比较满意的，先用一段时间再说。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>VIM 0 – 给你专业程序员的感觉</title>
                <link>http://freewind.in/posts/21-vim-0-for-professional-programmers</link>
                <pubDate>Mon, 12 Sep 2011 23:49:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">21</guid>
                <description><![CDATA[&lt;p&gt;从这两天开始，正式学习vim的使用。在windows下，因为cmd的窗口不支持动态改变高宽，所以vim提供了一个叫gvim的程序，可以随时改变高宽，很方便。我使用和提到的vim都是指的这个gvim。两者其它的功能，都是一样的。&lt;/p&gt;
&lt;p&gt;入门没有想像中的难，就是快捷键相当的多，需要很多练习才能熟练使用。正是这些快捷键，以及简朴的界面，以及隐藏于其中无穷的功能，让我突然有了一种“专业”程序员的感觉：写程序，就是应该这样！界面简单，功能齐全，多用键盘，少用鼠标，手随心动，眼花缭乱。&lt;/p&gt;
&lt;p&gt;先附图一张，看看刚安装上的原始gvim是什么样的（那是相当的简陋，让人想卸载）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/21-1.jpg&quot;&gt;&lt;img src=&quot;/user_images/21-0.jpg&quot; alt=&quot;http_imgload&quot; title=&quot;http_imgload&quot; /&gt;&lt;span id=&quot;more-21&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不要不要急，vim提供了无数的插件，可以增加其功能，美化其界面。现在看看我这两天的研究成果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/user_images/21-3.jpg&quot;&gt;&lt;img src=&quot;/user_images/21-3.jpg&quot; alt=&quot;image&quot; title=&quot;image&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是不是有点感觉了？&lt;/p&gt;
&lt;p&gt;为了记录平时的点点滴滴，每当有新的收获时，都记录在这里，以备不时之需。现在记性真是越来越差了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>liquidform：让你的query string也可以重构</title>
                <link>http://freewind.in/posts/20-liquidform-let-your-query-string-refactorable</link>
                <pubDate>Mon, 12 Sep 2011 23:47:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">20</guid>
                <description><![CDATA[&lt;p&gt;今天在google code上看到了一个有趣的项目：liquidform。&lt;/p&gt;
&lt;p&gt;它是为了解决这个问题：&lt;/p&gt;
&lt;p&gt;我们在写sql的时候，不可避免的要调用一些pojo的字段名，这些字段名的背后，都对应着数据表中的一些字段。有时候，我们会修改pojo中的某些字段，在IDE的强大重构功能下，所有调用这个字段（或者它的getter)的代码都会被自动修改，除了，在sql中用到的名字。这样，bug就出来了，我们只能一个个去找，一个个去改。有没有办法让这些sql也能自动更改呢？&lt;/p&gt;
&lt;p&gt;看看liquidform是怎么做的。&lt;/p&gt;
&lt;p&gt;原代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   @Entity
   public class Person {
   private String firstName;
   private String surname;
   public String getFirstName() { return firstName; }
   public String getSurname() { return surname; }
   // setters omitted
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;List people = em.createQuery( &amp;#8220;SELECT FROM Person p WHERE p.surname LIKE &apos;Smith%&apos;&amp;ldquo;) .getResultList();&lt;/p&gt;
&lt;p&gt;变为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Person p = LiquidForm.use(Person.class, &quot;p&quot;);
   List people = em.createQuery(
   select(p).from(Person.class).as(p).where(like(p.getSurname(), &quot;Smith%&quot;)).toString())
   .getResultList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;魔术就在，通过LiquidForm#use方法，给pojo包上了一层。当使用那一连串函数模拟sql语句的时候，表面上调用的是pojo的函数，实际上在内部记录了其它的信息。这样，我们既可以利用到IDE的重构功能，又能保证得到正确的sql。&lt;/p&gt;
&lt;p&gt;先不论它的实用性到底有多少，这个创意，的确很不错。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>好用的HTML解析器 jsoup</title>
                <link>http://freewind.in/posts/19-easy-to-use-html-parser-jsoup</link>
                <pubDate>Mon, 12 Sep 2011 23:42:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">19</guid>
                <description><![CDATA[&lt;p&gt;曾经用过HTML Parser这个东西来解析html文档，感觉就是看起来强大，用起来超繁琐，还用了一堆如visitor模式，真是继承了java的“优良”传统，让人心里堵。所以遇到需要解析修改html的任务，都觉得是一件挺艰巨的任务。
&lt;br  /&gt;&lt;p&gt;其网址如下： &lt;a href=&quot;http://htmlparser.sourceforge.net/&quot;&gt;http://htmlparser.sourceforge.net/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt; 如果不分语言，对html处理最好的库应该是jquery这个javascript库。其强憾的选择器和超级好用的api，让操作html成了一件享受的事情。我一直在想，如果在java中能像它一样去处理html，那多好。
&lt;br  /&gt;&lt;p&gt; 昨天不经意发现了一个叫jsoup的库，让人惊喜。它模仿了jquery，使用了极其相似的api与使用方法。我使用它来解析和处理html文档，感觉真是太棒了。以前使用HTML Parser觉得无从下手，得写几十行上百行代码才能做的事情，现在三五行就搞定了。这样的东西，才是我们应该学习和使用的。
&lt;br  /&gt;&lt;p&gt;地址如下：&lt;a href=&quot;http://jsoup.org/&quot;&gt;http://jsoup.org/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;很高兴看到现在的javaer们终于开始转变思想，积极学习和吸引其它语言中好的思想与用法，让javaer们的生活变得简单一些。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在java中使用闭包 – lambdaj</title>
                <link>http://freewind.in/posts/18-use-lambdaj-to-use-lambda-in-java</link>
                <pubDate>Mon, 12 Sep 2011 23:41:04 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">18</guid>
                <description><![CDATA[&lt;p&gt;在闭包如此流行的时代，java却迟迟不能支持闭包，不能不说是一件让人失望郁闷的事情。Java7也不支持，Java8也许吧，但不知道那是多久之后的事情（或者只支持lambda?）
&lt;br  /&gt;&lt;p&gt;终于出现了一个叫lambdaj的项目，它充分使用了java的静态导入等功能，模拟出来了一个闭包系统。先看一行代码：
&lt;br  /&gt;&lt;p&gt;List&lt;Integer&gt; biggerThan3 = filter(greaterThan(3), asList(1, 2, 3, 4, 5));&lt;/p&gt;
&lt;p&gt;这是从一个列表中，找到所有大于3的数字。这种写法，是不是挺新奇的？
&lt;br  /&gt;&lt;p&gt;地址：&lt;a href=&quot;http://code.google.com/p/lambdaj/&quot;&gt;http://code.google.com/p/lambdaj/&lt;/a&gt;
&lt;br  /&gt;&lt;p&gt;仔细看了一下lambdaj，想把它的用法弄熟，运用到自己的项目里。细读之下，发现这个东西还是不太好用。只有小部分的代码看起来很清晰且符合习惯，大多数复杂的用法都还是比较别扭和怪异。毕竟java本身语法上的限制，导致lambdaj只能通过一些扭曲的方式来模拟，效果就像是把一件花肚兜套在了java大叔笔挺的西装外面。风格的不相配会让代码写起来异常别扭。
&lt;br  /&gt;&lt;p&gt;如果真的喜欢这些，不妨直接转向scala，用起来感觉会爽得多。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>另一个增强类的工具 aspectj</title>
                <link>http://freewind.in/posts/17-another-tool-to-enhance-class-aspectj</link>
                <pubDate>Mon, 12 Sep 2011 23:38:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">17</guid>
                <description><![CDATA[&lt;p&gt;AspectJ可以说是一个很成熟的技术，成熟表现在：
&lt;br  /&gt;&lt;p&gt;1. 它在2005年就开始了
&lt;br  /&gt;&lt;p&gt;2. 它的eclipse插件做得非常好用，达到了java编辑器的水准
&lt;br  /&gt;&lt;p&gt;然而不得不承认的是，好像很少见到有人使用它。总觉得它是一项很神秘的技术，功能强大，能做很多事情，但是到底能做什么，有什么危险性，却又不清楚。想用到自己的项目中，却又听说它使用了自己的编译器，不知怎么结合使用。中文资料又少得可怜，好像除了书店里那一两本书，很难在网上找到什么有用的资料。而它自己的英文文档写得又臭又长，非常难懂。我昨天尝试使用，以失败告终，那个文档实在太难读了。
&lt;br  /&gt;&lt;p&gt;不过通过对一两个例子的理解，我觉得aspectj这个东西，到真是一个很强大的工具。它可以静态的对java语言进行各种增强，比如增加字段、增加函数、改变函数功能等等。把java与aspectj结合起来，我们可以极大的增强java的灵活性。比如roo这个框架，就是建立在aspectj的基础上的，实现了“充血模型”和很多其它强大的功能。
&lt;br  /&gt;&lt;p&gt;可惜的是，这个东西给人的感觉太严肃太学院了，文档也太难懂，不然的话，现在的发展一定会好很多。
&lt;br  /&gt;&lt;p&gt;希望有机会时好好研究一下这个东西，毕竟java本身的发展太慢，我们必须借助一些其它的工具来提高开发效率。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>动态改变类：Javassist</title>
                <link>http://freewind.in/posts/16-use-javassist-to-modify-class-dynamic</link>
                <pubDate>Mon, 12 Sep 2011 23:37:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">16</guid>
                <description><![CDATA[&lt;p&gt;这个是从playframework里看到的，作者使用了这个Javassist的库，对代码进行了动态增加，实现了很多非常便捷的功能。&lt;/p&gt;
&lt;p&gt;这个javassist，可以让我们修改一个java类的字节码。我们知道这样的工具不少，但是它的优点，是可以让我们用文本写一段java代码，然后就插到已有的字节码里去了。&lt;/p&gt;
&lt;p&gt;比如说，已经有一个类叫Hello，定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Hello() {
    public String hi() {return &quot;hi&quot;;}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以得到这个类编译后的字节码，然后使用javassist给它增加一个函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CtClass ctClass = getBytecodeOf(&quot;Hello&quot;);
   String bye = &quot;public static String bye() { return \&quot;bye\&quot; }&quot;;
   ctClass.addMethod(CtMethod.make(bye, ctClass));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，这个Hello类实际上就有了一个bye()的函数了。&lt;/p&gt;
&lt;p&gt;play使用它，成功地实现了&quot;充血模型&amp;rdquo;，使我们不需要dao。基本思路是：&lt;/p&gt;
&lt;p&gt;定义一个基类，叫Model，里面定义了一些函数如find(), save(), delete()，但是为空，它们的作用就像接口一样，只是为了让我们在程序中可以调用这些函数。我们定义的model都继承于它。当这些model导入时，使用javassist对这些类进行增强，把之前为空的代码都换成事先定义好的代码。这样，我们即可以调用它们，又实现了真正所需的功能，这个做法真的是非常方便。&lt;/p&gt;
&lt;p&gt;这只是其中的一个例子。可以说play的基础就是javassist，它的很多魔术般的功能都来自于它。一旦理解之后，我们也可以自己实现一些方便好用的功能。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Fedora结局篇 windows中安装Fedora虚拟机</title>
                <link>http://freewind.in/posts/14-install-virtual-box-for-fedora-on-windows</link>
                <pubDate>Mon, 12 Sep 2011 23:32:58 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">14</guid>
                <description><![CDATA[&lt;p&gt;经过这几天的试用，对Fedora有了一个比较直观的了解。与windows相比，两者各有优势与不足。
&lt;br  /&gt;&lt;p&gt;Windows的强项在于各种各样好用的日常软件：输入法、浏览器、英汉词典、QQ、讯雷，等等，windows这边完胜。不足之处在于命令行模式，提供的功能太弱，想自己做一些复杂的事情很难。
&lt;br  /&gt;&lt;p&gt;Fedora15的Gnome3图形界面表现还不错，但在日常软件上，明显薄弱。前面提到的那些软件，在Fedora上要么没有，要么功能简单不好用，我弄了几天找不到顺手的，后来还是在Linux中安装一个windows虚拟机，里面再装上这些软件。这个虚拟机，平时基本上要占用15%左右的cpu，比较耗资源。而且不太稳定，出现多次无法关机或者文件损坏的情况。
&lt;br  /&gt;&lt;p&gt;Fedora的强项在于命令行模式，功能太强大了，对于编程工作很有帮助。
&lt;br  /&gt;&lt;p&gt;所以最终我放弃了在Fedora中安装windows虚拟机的做法，反过来在windows中安装一个Fedora的虚拟机，这样就可以取两家之长处。Fedora安装好以后，修改启动文件，只以命令行模式启动，这样只占用不到2%的cpu，非常省资源（如果开图形界面的话，大约是30%靠上）。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>Fedora上的输入法、浏览器</title>
                <link>http://freewind.in/posts/13-fedora-input-methods-and-browsers</link>
                <pubDate>Mon, 12 Sep 2011 23:32:32 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">13</guid>
                <description><![CDATA[&lt;p&gt;经过这几天的使用，对Fedora系统非常喜欢。看来Linux果然适合我们的程序员的口味：爱折腾。
&lt;br  /&gt;&lt;p&gt;比较遗憾的是，linux在日常使用的软件上，与windows相比还有很大差距。就拿人们最常用到的两个程序“输入法”和“浏览器”来说。在windows平台上，有着无数种输入法，不光个人，几个大公司也都推出了非常好用的输入法。但是在linux上，，搜来搜去就那么三四种。不但功能相当简陋，还非常不稳定。最后矮子里面挑高个，用的是ibus+极点词库，勉强能用，但是问题多多：比如词的顺序不能调整，不能同时用五笔和拼音，有时候启动不了，反应有点迟顿，几乎没有提供任何自定义的选项。想想windows，羡慕嫉妒恨。
&lt;br  /&gt;&lt;p&gt;再就是浏览器。跟输入法一样的情况，各种各样的浏览器，个人的，公司的，选择无数。我最喜欢使用的是“世界之窗chrome版”，速度快，功能好用，十分顺手。而在linux下，只能使用原版的firefox和chrome，再自己去找各种插件。插件虽多，但是与世界之窗相比，质量上远远不如。比如鼠标手势，浏览历史，以及后台自定义设置，都差太远了。太多质量不够好的选择，还不如好的没有选择。
&lt;br  /&gt;&lt;p&gt;我想之所有是这个原因，大概是因为：人们使用linux一般都是为了工作，比如编程、维护软件，甚至经常在命令行下，对于日常软件的要求比较低。二是linux下的图形界面有多种，比如gnome, kde，而且每次升级都变化很大，所以开发出一个稳定的程序出来，难度也比较大。
&lt;br  /&gt;&lt;p&gt;最后是我可怜的中指。原来在linux系统下，人们爱使用鼠标中键，不知道是不是国外的鼠标跟国内不一样。有这么多的地方要用中键，连复制、鼠标手势都得用中键！一天下来，右手中指快抽筋了。
&lt;br  /&gt;&lt;p&gt;linux中最爽的一点，就是包管理系统。需要什么软件，只需要yum install softname就可以了，相当省时省力。不像windows里，搜索下载安装，太麻烦了。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之总结 远超期望</title>
                <link>http://freewind.in/posts/12-fedora-more-than-expected</link>
                <pubDate>Mon, 12 Sep 2011 23:32:08 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">12</guid>
                <description><![CDATA[&lt;p&gt;经过两天的折腾，终于把Fedora基本上弄好了。这次体验远超期望，真是相见恨晚。
&lt;br  /&gt;&lt;p&gt;现在我使用的模式是：以Fedora为主打，进行日常工作，同时运行一个虚拟机，运行windows。Fedora中主要是与编程相关的东西，比如Java/Scala，上网等；而Windows则是为了QQ/迅雷/网银等。
&lt;br  /&gt;&lt;p&gt;Fedora使用的Gnome3的桌面环境，非常好用。当把鼠标移动左上角时，桌面上的所有窗口都缩小并排列起来，可以非常方便的找到需要的那个，这可比windows下任务栏上一大堆小图标好认多了。同时，在左边还会弹出一个竖列的快捷图标，有点像苹果系统下方的那行图标，我们可以把常用的程序加上去，方便选择。而在右侧，是多个桌面的缩略图，可以把各程序分到不同的桌面。有了这些功能的帮助，尽管我打开了很多窗口，依然不会迷失。之前使用windowsxp的时候，感觉两个显示器都不够用，而今天只用一个显示器就觉得足够了。
&lt;br  /&gt;&lt;p&gt;再说虚拟机。安装一个VirtualBox，再装个windows，也非常方便。我给它分了500M内存，感觉启动和运行也很快，没有占多少资源。把它运行起来后，放到一个单独的虚拟桌面，即不会影响当前的操作，又方便切换。在里面先安装一个叫“云端”的软件，可以非常方便地添加多种软件，比如QQ、迅雷、旺旺等。需要聊天或者下载东西的时候，就到windows中，平时就在工作桌面。VirtualBox还可以设置共享目录，我可以把下载的东西直接移动到Fedora的下载目录中，交换数据特别方便。
&lt;br  /&gt;&lt;p&gt;另外，在Fedora中，也可以直接访问之前的windows分区，同时也可以与虚拟机中的windows交互。虽然现在同时运行着两个操作系统，感觉却是一体的，可以充分利用各自的优势。
&lt;br  /&gt;&lt;p&gt;在装虚拟机之前，我曾试过使用一个叫wine的程序来运行windows程序，但是不太理想，很多软件如QQ/迅雷等，都无法运行，问题很多，功能有限。安装了虚拟机之后，所有问题都不是问题。
&lt;br  /&gt;&lt;p&gt;另外还有一个小插曲：我将另一台windows主机通过usb网卡连到路由器上，提示要装一个什么驱动。在网上找了几个，都认不出来。但当我把Fedora连上去，马上就认出了并安装好了驱动，可以上网了，让我太意外了。
&lt;br  /&gt;&lt;p&gt;希望各位想尝试Linux但又不敢行动的朋友（特别是程序员），不要再犹豫啦。整个过程，只有安装显卡驱动那一块有点麻烦，其它都不是很难。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之五 wine以及windows程序</title>
                <link>http://freewind.in/posts/10-fedora-5-wine-and-windows-programs</link>
                <pubDate>Mon, 12 Sep 2011 23:31:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">10</guid>
                <description><![CDATA[&lt;p&gt;在Fedora中，使用QQ是一件相当麻烦的事情。腾讯在09年出了一个满是bug的linux版QQ之后，就再也不管了。我费尽力气把它安装成功之后，再也不想运行它，宁愿使用webqq或air版的QQ。&lt;/p&gt;
&lt;p&gt;现在我想常试一下，使用wine能否在linux下正常使用QQ2010或2011。经过一整天的试验，结论是无法在linux上运行QQ（天杀的TX，逼着我们用webqq）。&lt;/p&gt;
&lt;p&gt;意外发现是，很多windows程序还是可以正常运行，比如一些小游戏zuma，以及植物大战僵尸（就是太卡了）&lt;/p&gt;
&lt;p&gt;一、安装wine&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install wine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;共下载15M左右的程序&lt;/p&gt;
&lt;p&gt;二、一个辅助程序winestricks&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget http://www.kegel.com/wine/winetricks
$ chmod +x winetricks
$ ./winetricks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它会提示安装一个gecko的引擎，安装成功后，会出现一个窗口，可以让我们选择一些选项，如安装一些windows下的组件和库等。&lt;/p&gt;
&lt;p&gt;三、wine乱码&lt;/p&gt;
&lt;p&gt;如果程序上有中文，会出现乱码，变成一个个的小方块，可惜我弄了一天也没办法解决。&lt;/p&gt;
&lt;p&gt;四、运行.exe程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wine zuma.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果缺少库，它会在窗口上提示，我们只需要使用winestricks下载相应的库即可。正常情况，那些exe程序会运行，比如祖玛这个游戏。&lt;/p&gt;
&lt;p&gt;五、QQ安装不上，迅雷没试，但是从网上的文章来看，问题也是很多。所以我觉得，最好还是安装一个虚拟机，用来解决这些问题。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之六 虚拟机</title>
                <link>http://freewind.in/posts/11-fedora-6-virtual-box</link>
                <pubDate>Mon, 12 Sep 2011 23:31:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">11</guid>
                <description><![CDATA[&lt;p&gt;在Fedora中安装虚拟机，主要是为了运行一些windows程序，如QQ、迅雷、网银、office等等。这里使用免费开源的VirtualBox&lt;/p&gt;
&lt;p&gt;一、下载virtualbox&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ wget http://download.virtualbox.org/virtualbox/4.1.2/VirtualBox-4.1-4.1.2_73507_fedora15-1.i686.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二、安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sugo rpm -i VirtualBox-4.1-4.1.2_73507_fedora15-1.i686.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、新建一个虚拟机，安装windows&lt;/p&gt;
&lt;p&gt;四、安装云端软件，直接在它里面安装各种常用软件，非常方便。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之四 字体</title>
                <link>http://freewind.in/posts/9-fedora-4-fonts</link>
                <pubDate>Mon, 12 Sep 2011 23:30:35 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">9</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;一、安装chrome&lt;/strong&gt;
&lt;br  /&gt;&lt;p&gt;默认自带的浏览器是firefox，但是我比较喜欢使用chrome。
&lt;br  /&gt;&lt;p&gt;http://www.google.com/chrome，选择32位rpm，下载保存并安装。成功后将在“互联网”菜单中看到。
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;二、安装微软字体&lt;/strong&gt;
&lt;br  /&gt;&lt;p&gt;firefox和chrome下看中文，字发虚，很难受。安装微软的中文字体：
&lt;br  /&gt;&lt;p&gt;　　　　$ wget http://www.my-guides.net/en/images/stories/fedora12/msttcore-fonts-2.0-3.noarch.rpm&lt;/p&gt;
&lt;p&gt;　　　　$ su -c &apos;rpm -ivh msttcore-fonts-2.0-3.noarch.rpm&apos;
&lt;br  /&gt;&lt;p&gt;&lt;strong&gt;三、安装文泉驿开源字体&lt;/strong&gt;
&lt;br  /&gt;&lt;p&gt;Fedora还提供了文泉驿开源字体，使用以下命令安装
&lt;br  /&gt;&lt;p&gt;　　　　# yum install wqy-bitmap-fonts wqy-unibit-fonts wqy-zenhei-fonts
&lt;br  /&gt;&lt;p&gt;然后在chrome等程序中，设置字体。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之三 安装显卡驱动</title>
                <link>http://freewind.in/posts/8-fedora-3-install-video-driver</link>
                <pubDate>Mon, 12 Sep 2011 23:30:14 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">8</guid>
                <description><![CDATA[&lt;p&gt;到目前为止，我们还是在使用默认的驱动程序。在我的24寸的显示器上，它只能使用中间大约19寸的面积，周围全是黑边。而且字也很大个，反应也慢，必须升级驱动程序。&lt;/p&gt;
&lt;p&gt;在Fedora上安装显卡驱动是一件很麻烦且很有技术含量的东西，在安装过程中一定要十分小心，不然可能连桌面都进不了了。真怀念windows下的安装过程，那简直太方便了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、查看显卡类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$ lspci | grep VGA&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;05:00.0 VGA compatible controller: nVidia Corporation G86 [GeForce 8500 GT] (rev a1)&lt;span id=&quot;more-8&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、去官网找驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://www.nvidia.cn/Download/index.aspx?lang=cn&lt;/p&gt;
&lt;p&gt;根据我的型号找到了一个驱动：&lt;/p&gt;
&lt;p&gt;$ wget http://cn.download.nvidia.com/XFree86/Linux-x86/280.13/NVIDIA-Linux-x86-280.13.run&lt;/p&gt;
&lt;p&gt;它其实是一个脚本程序，有30多M。注意不要用firefox直接打开（firefox会卡死）&lt;/p&gt;
&lt;p&gt;下载后，保存在一个没有中文的路径下，因为一会儿要在文本模式下使用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、下载kernel源代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kernel的源代码将在安装驱动时用到，需要先下载下来。&lt;/p&gt;
&lt;p&gt;首先查看当前的kernel版本号：&lt;/p&gt;
&lt;p&gt;$ uname -a&lt;/p&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;p&gt;Linux freewind 2.6.40.3-0.fc15.i686 #1 SMP Tue Aug 16 04:24:09 UTC 2011 i686 i686 i386 GNU/Linux&lt;/p&gt;
&lt;p&gt;可以看出，linux内核是2.6.40.3-0.fc15.i686&lt;/p&gt;
&lt;p&gt;$ sudo yum install kernel-devel&lt;/p&gt;
&lt;p&gt;注意看它找到的源代码的版本号是否与当前系统相同，如果相同可以直接安装。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、编辑grub文件，禁用当前的驱动&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;vim /boot/grub/grub.conf&lt;/h1&gt;
&lt;p&gt;打开后可能看到多个不同版本的linux配置（因为刚才yum update的缘故），我们找到与当前版本号相同的那个（2.6.40），再找到rhgh quiet后，添加rdblacklist=nouveau&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、编辑blacklist.conf&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;vim /etc/modprobe.d/blacklist.conf&lt;/h1&gt;
&lt;p&gt;在最后增加：blacklist nouveau&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、运行命令：&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;setsebool -P allow_execstack on&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;七、安装缺少的库&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;sudo yum install binutils gcc&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;八、重启，进入grub页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时按e将进入修改模式，找到版本号为2.6.40的那个，再按e，直到出现可以修改内容的界面。然后找到quiet，在后面输入3（前后要有空格）。后退，按b启动（将进入文本模式），使用管理员帐号登录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;九、安装驱动&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;cd /home/freewind/Downloads/&lt;/h1&gt;
&lt;h1&gt;chmod +x ./NVIDIA-Linux-x86-280.13.run&lt;/h1&gt;
&lt;h1&gt;./NVIDIA-Linux-x86-280.13.run -k $(uname -r) -kernel-source-path=/usr/src/kernels/2.6.40.3-0.fc15.i686&lt;/h1&gt;
&lt;p&gt;将会出现一个安装画面，按提示选择，顺利的话很快可以安装完成。此处需要强调的是，如果你下载的驱动文件放在了一个中文目录下，那就悲剧了，因为显示为方块，没法输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十、重启&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装成功后将会重启，进入桌面后，整个界面焕然一些。24寸的屏幕全被占满了，界面更漂亮，操作更简便，非常爽快。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之二 基本设置</title>
                <link>http://freewind.in/posts/7-fedora-2-basic-settings</link>
                <pubDate>Mon, 12 Sep 2011 23:29:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">7</guid>
                <description><![CDATA[&lt;p&gt;&lt;strong&gt;一、将当前用户加入到sudo列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前用户非管理员用户，安装软件时经常要su，十分不便。可先将它加入到sudo列表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# visudo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root ALL=(ALL) ALL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在下面增加一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;freewind ALL=(ALL) ALL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存退出，如果有错会提示。 &lt;span id=&quot;more-7&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、安装常用的基本程序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install wget
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三、添加国内的源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开 http://mirrors.163.com/.help/fedora.html， 照提示操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /etc/yum.repos.d
# wget http://mirrors.163.com/.help/fedora-163.repo
# wget http://mirrors.163.com/.help/fedora-updates-163.repo
# yum makecache
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;四、下载加速&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# yum -y install yum-fastestmirror
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# yum install yum-presto
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;五、更新系统&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# yum update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示有200多M需要下载，此时要多等一会儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、在右键中增加&quot;在终端中打开&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# yum install nautilus-open-terminal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;七、增加gnome调整工具&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＃yum install gnome-tweak-tool
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;八、安装flash&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入http://get.adobe.com/cn/flashplayer/，选择要安装的版本。我选择的是.rpm，下载后5M多，保存在~/Downloads目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo yum install flash-plugin-10.3.183.7-release.i386.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完后，重启firefox。如果没生效的话，重启下系统。&lt;/p&gt;
&lt;p&gt;到目前为止，基本的设置完成。但是此时的界面并不好看，因为驱动程序还没装好，没法使用最新的gnome3。下一篇记录如何安装显卡驱动&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>折腾Fedora之一 安装</title>
                <link>http://freewind.in/posts/6-fedora-1-install</link>
                <pubDate>Mon, 12 Sep 2011 23:28:52 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">6</guid>
                <description><![CDATA[&lt;p&gt;昨天安装Fedora时，图新鲜装了64位版本（因为cpu是64位的，想着跟64位的系统更搭一些），结果发现有不少程序不能运行，比如Flash等，以及一些通过wine运行的windows程序，带来了很多麻烦。所以决定还是换成32位系统，毕竟它更加成熟可靠，更适合日常使用。如果是装在大内存(4G以上）的服务器上，可以考虑64位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、版本的选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fedora的官网是http://fedoraproject.org/en/get-fedora，当前的最新稳定版本是Fedora15。作为国内用户，推荐使用http://mirrors.163.com来下载镜像，速度要快很多。&lt;/p&gt;
&lt;p&gt;下载地址：http://mirrors.163.com/fedora/releases/15/Live/i686/Fedora-15-i686-Live-Desktop.iso ，大小为500多M.&lt;/p&gt;
&lt;p&gt;（注意你还可以找到DVD版的安装镜像（大约3G多），但是不要下载，因为里面缺少了一个重要文件，如果使用USB来安装的话，反而会全部从网络下载安装文件，速度奇慢。）&lt;span id=&quot;more-6&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、准备U盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;准备一个U盘，1G以上，把里面的东西备份出来。我本来打算刻成光盘，但是刻录机出了问题，连刻坏几张，还是直接用U盘吧，更加方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、下载unetbootin&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://unetbootin.sourceforge.net/&lt;/p&gt;
&lt;p&gt;该软件提供了windows/linux/mac三个版本，非常易用。启动后，选择刚才下载的镜像文件，插上U盘，点击OK按钮，它会将镜像中的文件解压缩到U盘中，并配置好启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、重启，设置以U盘启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重启电脑，进行bios设置，将第一启动设为U盘。启动成功后将会出现一个菜单，选择第二项（大意是运行Fedora 15 live），进入Fedora live模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、Linux live下安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux发行版通常都提供了神奇的Live模式，即不用安装，就可以正常运行Linux。上网、安装和运行程序，都没有问题。这可比windows xp先进多了。我们现在就可以试试操作，比如左上角的菜单里，可以找到Firefox，用它来上上网。还可以找到一个“安装到硬盘”的菜单项，点击后将开始安装。在安装的过程中，将提示我们进行一些配置，如选择语言、键盘类型、时区，选择硬盘分区，设置密码等。此时如果遇到什么不明白的，还可以上网搜索。&lt;/p&gt;
&lt;p&gt;一切顺利的话，大约十分钟后就能安装成功，重启即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、更改语言区域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，安装的是英文。进入桌面后，点击“Application-&gt;System Tools-&gt;System Settings&amp;rdquo;，在打开的面板中的第一行找到“语言区域设置”，点击后将出现一个列表，找到Chinese一项并点击它。然后注销，重新登录，菜单就会变成中文的了。&lt;/p&gt;
&lt;p&gt;这时会提示，是否把一些常用目录改为中文，如“Download”将改为“下载”，“Music&quot;改为“音乐”。最好的做法是“Keep old names&amp;rdquo;，不然你在文本模式下操作时，中文都变成了一个个黑方块，让人欲哭无泪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、安装中文输入法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统已经默认安装了一个拼音输入法。但我习惯使用五笔，所以第一件事就是安装一个五笔输入法，不然这篇日志都没法写。。点击“应用程序-&gt;系统工具-&gt;添加删除程序“，在打开的对话框中输入wubi，等一会儿后，将会出现几条结果。我选择“Jidian&quot;开头的那个，它使用的是极点五笔的词库。安装后，在点上角的“小键盘”图标上点右键，选择“重新启动”，然后再点右键，选择“首选项”进行配置。在第二个tab里，给“custom active methods&quot;勾上，在列表中找到“极点五笔”并点击右边的&quot;添加“按钮。同时可以删除一些无用的输入法，并将五笔向上移到首位。&lt;/p&gt;
&lt;p&gt;至此，基本的安装过程结束。&lt;/p&gt;
]]></description>
            </item>
        
            <item>
                <title>在Fedora下激动</title>
                <link>http://freewind.in/posts/71-excited-on-fedora</link>
                <pubDate>Mon, 12 Sep 2011 11:18:00 CST</pubDate>
                <dc:creator><![CDATA[Freewind]]></dc:creator>
                <category><![CDATA[未分类]]></category>
                <guid isPermaLink="false">71</guid>
                <description><![CDATA[&lt;p&gt;终于，我linux了！&lt;/p&gt;
&lt;p&gt;现在我正在Fedora 15的系统下，用着webqq，写下这篇日志，以记录我激动的心情。经过昨今两天的辛苦折腾，总算把Linux搞得基本能用了，万里长征迈出了坚实的第一步。&lt;/p&gt;
&lt;p&gt;记得在大二时，我就装过一个叫红旗的linux，不过只坚持了一天就回到了windows。转眼已过十年，现在我终于鼓足勇气，抛开windows，投入到Linux的怀抱，因为这才是程序员的乐园。在我那scala群里，原来早已有大批群友在Linux下工作多年，实在惭愧。&lt;/p&gt;
&lt;p&gt;这两天，我试用了三个版本的Linux，分别是Centos,Ubuntu,Fedora。Centos求稳，界面实在太旧太难看，特别是中文字体，歪歪扭扭丑陋无比，我又不会调整。然后是使用人数广泛，受到很多好评的ubuntu，它以华丽的界面和丰富的软件仓库闻名。我因为不会装驱动，没法使用它最新的unity界面，只能使用传统界面，其颜色偏暗，窗口的关闭按钮在左上角，让我十分不习惯。考虑到我习惯使用centos系统的服务器，所以最新选择了Fedora这个与centos同出于redhat的Linux。同样因为显卡驱动问题，无法使用gnome3的华丽界面，但是传统界面的配色十分清爽，我也很喜欢。&lt;/p&gt;
&lt;p&gt;另外，Fedora这个词，总让我想起Fedor（菲多），这个号称60亿最强男的俄国格斗猛男。想当年星爷在日本宣传《功夫》时，曾有一日本猥琐肥男挑衅他，气焰无比嚣张。但没多久，就在一场比赛中，1分钟就被菲多KO，眼泪都快出来了。让人无比解气。&lt;/p&gt;
&lt;p&gt;Fedora装好后，首先得解决这几大问题：&lt;span id=&quot;more-71&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;输入法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在windows里我最爱的极点五笔，在linux下用不了。经过搜索，发现了一个海峰五笔，基本能用，只是没有极点用得顺手，只能先将就着了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VPN&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;作为一个程序员，VPN是必备之物，不然google用不了，国外网站去不了。之前在windows下，只需要下载一个客户端，输入帐号密码即可，但是在linux下，只能自己摸索。好在现在ubuntu和fedora都直接内置了vpn客户端，只需要把配置选对即可（参见：http://superuser.com/questions/329308/how-to-configure-vpn-in-ubuntu/329321）。看来外国人也很懂中国，连vpn都内置了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;QQ&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;QQ是个大问题。腾讯在09年推出一个满是bug、经常卡住、功能简陋的linux版QQ之后，就再也不管了。现在在Linux上用QQ只有三种方法：1. 使用这个linux qq，2.使用浏览器访问webqq 3. 装个虚拟机装windows，再上QQ。这三种方法都难以让人满意。没办法，有得即有失，只能这样忍了。&lt;/p&gt;
&lt;p&gt;后来发现webqq有一个增强版，是用adobe air做的一个跨平台的简单客户端，把webqq包在里面。运行时，它就最大化，代替了原有的桌面，而里面是各样各样的QQ功能，比如QQ，QQ空间，QQ游戏，QQ输入法，以及腾讯自己和第三方的小应用程序。我现在就在它提供的QQ空间里写日志呢。这个增强版简直就是一个网络操作系统，虽然是一个浏览器，但是看起来和普通桌面几乎没有任何区别。不能不佩服QQ的能力和野心，尽管又是抄袭之作，但是质量却相当好，而且看起来前途非常光明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最后是安装显卡驱动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认的驱动程序功能有限，只能使用传统的桌面，并且在我的24寸的显示器上，只能显示出19寸的画面。可是升级驱动程序是一个相当麻烦而且危险的事情（相对于新手来说），我按着教程一步步，中间出现几次问题，差点重装系统，好在最终一一解决。当安装成功重新进入系统后，我被漂亮的桌面震惊了：不但占满了24寸的屏幕，而且功能操作、界面和颜色都变得很酷，远远超出windows xp的水平，这难得真是我印象中的Linux吗？可惜我现在还不会截图，不然真想截几张放上来。&lt;/p&gt;
&lt;p&gt;Linux经过这些年的发展，界面、操作与以前相比，真是有了巨大的进步，完全可以媲美windows。但是相对于国内的普通用户来说，使用Linux来取代windows还是不太可能的事情，因为人们日常使用的各种软件，基本上都没有提供linux版本。单单一个QQ，就能阻止多少人的脚步；还有播放器，输入法，音乐软件，办公软件，还有游戏。。。另外，在安装过程中，经常需要使用命令行去配置或者安装软件，普通用户更难以掌握。最终剩下来的，就是像我们这样的程序员了。&lt;/p&gt;
&lt;p&gt;为什么程序员会喜欢Linux? 因为它提供了无数功能强大灵活好用的命令工具，各种编程语言和工具对Linux的支持都非常好，人们部署服务器，通常也会选择Linux。使用Linux，娱乐性不如windows，但是编程时要方便很多。虽然我们在生活中还离不开windows，但是至少在工作上，Linux可以成为我们的好伙伴。&lt;/p&gt;
]]></description>
            </item>
        
    </channel>
</rss>