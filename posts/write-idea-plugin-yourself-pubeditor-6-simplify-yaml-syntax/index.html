<!DOCTYPE html>
<html>
<head>
    <title>自己动手写IDEA plugin – PubEditor (6) 实现简化的yaml语法规则</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<link rel="alternate" type="application/rss+xml" title="Freewind @ Thoughtworks ~ Feed" href="/feed.xml" />

<link href="/assets/rainbow/themes/github.css" rel="stylesheet" type="text/css">
<link rel='stylesheet' href='/assets/css/main.css' type='text/css' media='all' />

<script src="/assets/rainbow/js/rainbow.js"></script>
<script src="/assets/rainbow/js/language/generic.js"></script>
<script src="/assets/rainbow/js/language/python.js"></script>
<script src="/assets/rainbow/js/language/java.js"></script>
<script src="/assets/rainbow/js/language/javascript.js"></script>
<script src="/assets/rainbow/js/language/html.js"></script>
<script src="/assets/rainbow/js/language/css.js"></script>
<script src="/assets/rainbow/js/language/scala.js"></script>
<script src="/assets/rainbow/js/language/shell.js"></script>

</head>
<body>

<h1>
    (2014-04-22) 自己动手写IDEA plugin – PubEditor (6) 实现简化的yaml语法规则
</h1>

<div>
    <a href="http://findti.com/?r=0379029af20eda86" target="_blank">广告：从今天开始用云梯翻墙</a>
</div>


<hr/>

<div>
    <p>YAML是一种看起来很易读、格式简单的语法格式，但实际上，它的<a href="www.yaml.org/spec/1.2/spec.html">语言规范</a>相当复杂，甚至连读一遍文档都是非常痛苦的事情。同时在IDEA上也没有找到可用的YAML插件，这让我很头痛，看起来一个很简单的任务突然变得复杂到无法实现。</p>
<h2>简化的文法</h2>
<p>经过短暂的纠结，我决定按照pubspec.yaml上给出的例子，实现一个简化的YAML语法规则，只支持以下几种格式：</p>
<h3>注释</h3>
<p>如</p>
<pre><code># this is comment
</code></pre>
<h3>单行key value</h3>
<p>如</p>
<pre><code>key: value
</code></pre>
<h3>嵌套key value, 如</h3>
<pre><code>key:
  key1: value1
  key2:
    key3: value3
    key4: value4
</code></pre>
<h3>多行文本，如</h3>
<pre><code>key: &gt;
  this is
  multiline
  string
</code></pre>
<p>对于其它格式的内容，直接当作不识别的文本处理，这样简化后，词法规则的规模小了很多。</p>
<h2>缩进处理</h2>
<p>但是马上又遇到另一个头疼的问题：YAML的文法实际上并不完全是“上下文无关”的，因为它的很多词法成分实际上跟它前面的缩进数量是相关的。而我使用的词法生成器工具JFlex只支持“上下文无关”文法，必须对缩进进行一些额外的处理才行。</p>
<p>好在看到了一篇文章，讲如何在JFlex中处理缩进，对于我要实现的简化的缩进来说，还是可行的: <a href="http://matt.might.net/articles/standalone-lexers-with-lex/">http://matt.might.net/articles/standalone-lexers-with-lex/</a></p>
<h2>JFlex规则</h2>
<p>经过两天的努力和反复的尝试，终于实现了以下规则：</p>
<pre><code>package com.thoughtworks.pli.pub_editor.parser;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;
import java.util.*;

%%

%class _PubSpecLexer
%implements FlexLexer
%unicode
%type IElementType
%function advance
//%debug
%{
IndentationStack indentationStack = new IndentationStack();
public int currentIndentation() { return indentationStack.current(); }
public List&lt;Integer&gt; allIndentations() { return indentationStack.all(); }
%}

Comment = "#" .*
LineSeparator = \r\n | \r | \n
Indentation = {WhiteSpace}+
WhiteSpace = [\ ]
NonWhiteSpace = [^\ ]
BlankChar = [\ \t\f]
NonBlankChar = [^\ \r\n\t\f]
ParentKey = {NonBlankChar}+ ":" {BlankChar}* {LineSeparator}
InlineKey = {NonBlankChar}+ ":" {BlankChar}+
InlineValue = .+
MultiLineStringKey = {NonBlankChar}+ ":" {BlankChar}* "&gt;" {LineSeparator}

%state $newLine
%state $value
%state $multiLineString
%state $multiLineStringAfterIndentation
%state $inlineValue
%state $multiChildren

%%
&lt;YYINITIAL&gt; {
    {Indentation}    { indentationStack.push(yytext().length()); return PubTokenTypes.Indentation(); }
    {Comment}        { return PubTokenTypes.Comment(); }
    {ParentKey}      { yybegin(YYINITIAL);return PubTokenTypes.ParentKey(); }
    {InlineKey}      { yybegin($inlineValue); return PubTokenTypes.InlineKey(); }
    {MultiLineStringKey} { yybegin($multiLineString); return PubTokenTypes.MultiLineStringKey(); }
    {LineSeparator}  { return PubTokenTypes.LineSeparator(); }
}
&lt;$inlineValue&gt; {
    {InlineValue}    { yybegin(YYINITIAL); return PubTokenTypes.InlineValue(); }
}
&lt;$multiLineString&gt; {
    {Indentation}    {
                         int currentIndent = yytext().length();
                         if(currentIndent &gt;= indentationStack.current()) {
                         yybegin($multiLineStringAfterIndentation);
                             return PubTokenTypes.Indentation();
                         } else {
                             yypushback(currentIndent);
                             yybegin(YYINITIAL);
                         }
                     }
    {NonWhiteSpace}+ { yypushback(yytext().length()); yybegin(YYINITIAL); }
    &lt;$multiLineStringAfterIndentation&gt; {
        {NonBlankChar}+ {  return PubTokenTypes.OneLineOfMultiLineString(); }
        {LineSeparator} {  yybegin($multiLineString); return PubTokenTypes.LineSeparator(); }
    }
}
.                    { return PubTokenTypes.BadCharacter(); }
</code></pre>
<p>可以看到对于这小小的文法，居然需要这么多定义和代码。除去文法相关的定义，有不少代码是关于处理缩进的。不过由于上面的代码比较直白，所以就不多解释，如果看起来有不明白的地方，最好再看一遍JFlex的文档：<a href="http://jflex.de/manual.html">http://jflex.de/manual.html</a></p>
<h2>测试</h2>
<p>最后上一个测试：</p>
<pre><code>String input = "#!!!!!\n" +
        "#????\n" +
        "abc: \"sss\"\n" +
        "xxx:\n" +
        "  aaa: 111\n" +
        "  bbb: 222\n" +
        "yyy: &gt;\n" +
        "  1111111111111\n" +
        "    2222222222222\n" +
        "  3333333333333\n" +
        "zzz: ZZZ\n" +
        "  ccc: This line actually is invalid\n" +
        "???";
PubSpecLexer lexer = new PubSpecLexer();
lexer.start(input);
while (true) {
    IElementType tokenType = lexer.getTokenType();
    if (tokenType == null) {
        System.out.println("--- end ---");
        return;
    }

    System.out.println(tokenType + "(" + lexer.getTokenText() + ")");
    lexer.advance();
}
</code></pre>
<p>运行结果如下：</p>
<pre><code>Comment(#!!!!!)
LineSeparator(
)
Comment(#????)
LineSeparator(
)
InlineKey(abc: )
InlineValue("sss")
LineSeparator(
)
ParentKey(xxx:
)
Indentation(  )
InlineKey(aaa: )
InlineValue(111)
LineSeparator(
)
Indentation(  )
InlineKey(bbb: )
InlineValue(222)
LineSeparator(
)
MultiLineStartFlag(yyy: &gt;
)
Indentation(  )
OneLineOfMultiLineString(1111111111111)
LineSeparator(
)
Indentation(    )
OneLineOfMultiLineString(2222222222222)
LineSeparator(
)
Indentation(  )
OneLineOfMultiLineString(3333333333333)
LineSeparator(
)
InlineKey(zzz: )
InlineValue(ZZZ)
LineSeparator(
)
Indentation(  )
InlineKey(ccc: )
InlineValue(This line actually is invalid)
LineSeparator(
)
BadCharacter(?)
BadCharacter(?)
BadCharacter(?)
--- end ---
</code></pre>
<h2>源代码</h2>
<p>代码在<a href="http://github.com/freewind/PubEditor">http://github.com/freewind/PubEditor</a>，标签为<code>6_other_basic_rules</code></p>

</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'freewind'; // required: replace example with your forum shortname
    var disqus_identifier = '2595';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</body>
<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-54316895-1");
        pageTracker._trackPageview();
    } catch(err) {}
</script>

</html>
