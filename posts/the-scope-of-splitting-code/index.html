<!DOCTYPE html>
<html>
<head>
    <title>分解的粒度</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<link rel="alternate" type="application/rss+xml" title="Freewind @ Thoughtworks &raquo; Feed" href="/feed.xml" />
<link rel='stylesheet' href='/css/main.css' type='text/css' media='all' />

</head>
<body>

<h1>
    分解的粒度
</h1>
<div>
    <a href="http://findti.com/?r=0379029af20eda86" target="_blank">广告：从今天开始用云梯翻墙</a>
</div>

<div>
    <hr />
<p>这篇日志真不好写，已经重写了两遍，每次都是写到一大半时，发现自己对于问题本质的理解不对，于是删了重写，内容也完全不同。希望这次能把它写完。</p>
<p>日志的起因是我们项目里需要写一个测试工具，我写的代码受到了同事的质疑，他认为我的方案要写太多的类，而且宁愿用<code>if...else</code>来做。</p>
<p>简单的说，这个测试工具，需要对不同Module的不同检查点进行检查。可以假设我们有下面一张表：</p>
<pre><code> ||---------------||---------------||---------------||------------------||
 || Module Name   ||  Dir Checker  ||  DB Checker   || Storage Checker  ||
 ||---------------||---------------||---------------||------------------||
 ||    ModuleA    ||       Y       ||     OK        ||    /aaa.xml      ||
 ||---------------||---------------||---------------||------------------||
 ||    ModuleB    ||       Y       ||     OK        ||    /bbb.xml      ||
 ||---------------||---------------||---------------||------------------||
 ||    ModuleC    ||       N       ||   FAILED      ||    /ccc.xml      ||
 ||---------------||---------------||---------------||------------------||


我们的测试工具，需要读取这样的一个表，根据其内容对相应的Module和检查点进行检查。

## 我的方案

我的方案是将每个Module的每个检查点，都作为一个独立的类。这样当以后有新的Module或检查点出现时，可以不用修改已有任何代码，只需要创建新类。

对于上表中的ModuleA，定义了三个类:

class ModuleADirChecker {
     void check(String shouldInOrNot);
}
class ModuleADbChecker {
     void check(String expectedStatus);
}
class ModuleAStorageChecker {
     void check(String remotePath);
}


对于ModuleB和C，也将会各有三个类，这样就会有9个类。

如何将每个类与module/checkpoint匹配起来呢？最简单的方式是通过一堆`if...else...`来判断：

public void getChecker(String module, String checkPoint) {
    if(module.equals("ModuleA")) {
         if(checkPoint.equals("Dir Checker")) {
              return new ModuleADirChecker();
         } else if(checkPoint.equals("DB Checker")) {
              return new ModuleADbChecker();
         } else if(checkPoint.equals("Storage Checker")) {
              return new ModuleAStorageChecker();
         }
    } else if(module.equals("ModuleB")) {
         ...
    } else if(module.equals("ModuleC")) {
         ...
    }
}


我想到用注解，可以会让代码更加独立一些，于是写了一个`CheckerAnno`注解，这么用：

@CheckerAnno(module="ModuleA", checkPoint="Dir Checker")
class ModuleADirChecker {
     void check(String shouldInOrNot);
}


每个checker上，都放一个`CheckerAnno`，指示它匹配的是哪个module和checkPoint。在程序运行时，将会扫描代码，根据`CheckerAnno`中的数据，自动把各checker与excel表中的单元格匹配起来，生成实例，传入数据进行检查。这样我们就不需要写上面那个长长的`getChcker`方法了，并且以后添加新的Module或者Column时，也不需要修改**任何**已有代码。

## 同事的方案

同事觉得我的方案不好，因为他觉得我的类太多了。而且他发现，某些检查点虽然要检查多个Module，但它们的逻辑非常相似。比如`Dir Checker`仅仅需要不同的Module提供一个不同的值，实际的检查逻辑是一样的。

他给出的方案是：每个检查点一个类，在类里通过`if...else`来针对不同的Module做不同的检查。比如对于`DirChecker`，他是这么做的：

class DirChecker {
    public void check(String moduleName, String shouldInOrNot) {
        File dir = getDir(moduleName);
        checkDir(dir, shouldInOrNot);
    }
    private File getDir(String moduleName) {
        if(moduleName.equal("ModuleA") {
            return localTempDirOfModuleA();
        } else if(moduleName.equals("ModuleB")) {
            return localTempDirOfModuleB();
        } else if(moduleName.equals("ModuleC")) {
            return localTempDirOfModuleC();
        } else {
            throw new IllegaArgumentException("Unknown module:" + moduleName);
        }
    }
}


对于其它的每一个检查点，也都需要定义一些这样的类，每个类中通过`if...else`来决定哪个Module进行哪种检查。

我觉得他这种方式的关键，不在于是否使用了`if...else`，因为他也可以使用注解来实现，跟我那种一样：

@CheckPoint("Dir Checker")
class DirChecker {
    @CheckModule("ModuleA")
    public void check1(String shouldInOrNot) {
         ...
    }
    @CheckModule("ModuleB")
    public void check2(String shouldInOrNot) {
         ...
    }
    @CheckModule("ModuleC")
    public void check3(String shouldInOrNot) {
         ...
    }
}


然后可使用相同的方式扫描注解，将每个check方法与相应的module和checkpoint匹配起来。虽然每当增加一个新Module时，他需要修改已有的类，添加一个新的方法并加上相应的注解，但由于这样的方法相当于一个入口，不会修改已有的逻辑，所以也是可以接受的。

## 第三种方案

可以很自然的想到第三种方式：以行为类。即为每个Module定义一个类，里面提供多个方法分别对应每个检查点。如果用注解的话，大约是这样的：

@CheckerModule("ModuleA")
class ModuleA {
    @CheckPoint("Dir Checker")
    public void check1(String shouldInOrNot) {}
    @CheckPoint("Db Checker")
    public void check2(String expectedStatus) {}
    @CheckPoint("Storage Checker")
    public void check3(String remotePath) {}
}
</code></pre>
<h2>问题的本质</h2>
<p>所以问题的关键就在于粒度：对于这个例子，哪种粒度更好？行？列？还是单元格？</p>
<p>如果说这三种方案都是差不多的，随便选一个就行，那就省事了，看自己的喜好即可。否则的话，我应该以什么为考虑的重点，来决定采用哪一种粒度呢？</p>
<hr />
<p>有同学说看不懂我在问什么。</p>
<p>的确我也感觉不知道自己在问什么，因为这个问题产生于真实的项目，很多影响我思考的因素也许在本文外，但我还没有意识到。从一个复杂项目中，把一个问题以最简方式完整的剥离出来，本身就是一件很难的事吧。如果真的能把所有有关联的因素抽出来了，所有没有关联的因素都留下了，也许答案自然就出来了，不需要再问了。</p>
<p>看来这个问题只能等我自己解决了。</p>

</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'freewind'; // required: replace example with your forum shortname
    var disqus_identifier = '2257';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</body>
<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-54316895-1");
        pageTracker._trackPageview();
    } catch(err) {}
</script>

</html>
