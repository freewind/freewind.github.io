<!DOCTYPE html>
<html>
<head>
    <title>type A=B不等于import {A=&gt;B}</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<link rel='stylesheet' href='/css/main.css' type='text/css' media='all' />

</head>
<body>

<h1>
    type A=B不等于import {A=&gt;B}
</h1>

<div>
    <hr />
<p>今天被一个问题折磨了很久，最后才想明白。</p>
<p>在检查代码的时候，发现不少类为了使用mutable的map，都进行了这样的导入:</p>
<pre><code>import scala.collection.mutable.{ Map =&gt; MMap }
</code></pre>
<p>然后这样使用：</p>
<pre><code>val map = MMap[String,String]
</code></pre>
<p>于是想，何不把它放到一个package object中，这样就不需要到处导入了。于是：</p>
<pre><code>package org
package object scalaeye {
    type MMap[K,V] = scala.collection.mutable.Map[K,V]
}
</code></pre>
<p>然后去掉了其它类中的import {Map=>MMap}的导入声明。结果发现编译时，所有使用了MMap的类，都报错：找不到type MMap。</p>
<p><span id="more-183"></span>
<br  /><p>MMap明明已经定义了，为什么找不到呢？简化问题为：</p>
<pre><code>class Test {
    type MMap[K,V] = scala.collection.mutable.{Map=&gt;MMap}
    val data = MMap[String,String]()
}
</code></pre>
<p>还是报找不到MMap，可是明明就在前面定义了！</p>
<p>调试了好久，突然想起之前问过这个问题，答案也差不多想起来了。</p>
<pre><code>type MMap[K,V] = scala.collection.mutable.Map[K,V]

import scala.collection.mutable.{ Map =&gt; MMap }
</code></pre>
<p>这两者右边的Map是不一样的。第一个是trait Map，第二个是object Map。第一个像是一个接口，并没有apply()函数可让我们调用，所以MMap()出错。而第二个，实际上还是object Map，我们可以调用它的()函数</p>
<p>下面是唐古拉山的回贴：</p>
<pre><code>import scala.collection.mutable.{ Map =&gt; MMap }
-&gt; Map trait及其伴生对象都可见了
</code></pre>
<p>如:</p>
<pre><code>classOf[MMap[_,_]]
MMap()
</code></pre>
<p>scala 知道什么时候是trait，什么时候object
<br  />看看Predef里对immuable.Map的导入</p>
<pre><code>...
type Map[A, +B] = collection.immutable.Map[A, B] //类型别名
val Map = collection.immutable.Map //引用对象
...
</code></pre>

</div>
</body>
</html>
